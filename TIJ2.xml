<?xml version="1.0" encoding="UTF-8"?>
<article version="5.0" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xl="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook" xml:lang="en">
  <info>
    <title>Thinking in Java, 2nd Edition</title>
  </info>
  <para>Thinking</para>
  <para>in</para>
  <para>Java</para>
  <para>Second Edition</para>
  <para>Bruce Eckel</para>
  <para>President, MindView, Inc. </para>
  <informaltable frame="none">
    <tgroup cols="2">
      <colspec colname="c1" colwidth="44*"/>
      <colspec colname="c2" colwidth="56*"/>
      <tbody>
        <row>
          <entry><para/></entry>
        </row>
        <row>
          <entry><para/></entry>
          <entry><para><inlinemediaobject><imageobject role="html">
                  <imagedata contentdepth="113" contentwidth="215" fileref="./TIJ2_files/image001.jpg" format="JPG" scalefit="1"/>
                </imageobject>
<imageobject role="fo">
                  <imagedata contentdepth="100%" fileref="./TIJ2_files/image001.jpg" format="JPG" scalefit="1" width="100%"/>
                </imageobject>
</inlinemediaobject></para></entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>
   <para>Comments from readers:</para>
  <para><emphasis role="italic">Much</emphasis> better than any other Java book I�ve seen. Make that �by an order of magnitude�... very complete, with excellent right-to-the-point examples and intelligent, not dumbed-down, explanations ... In contrast to many other Java books I found it to be unusually mature, consistent, intellectually honest, well-written and precise. IMHO, an ideal book for studying Java. <emphasis role="bold">Anatoly Vorobey, Technion University, Haifa, Israel</emphasis></para>
  <para>One of the absolutely best programming tutorials I�ve seen for any language. <emphasis role="bold">Joakim Ziegler, FIX sysop</emphasis></para>
  <para>Thank you for your wonderful, wonderful book on Java. <emphasis role="bold">Dr. Gavin Pillay, Registrar, King Edward VIII Hospital, South Africa</emphasis></para>
  <para>Thank you again for your awesome book. I was really floundering (being a non-C programmer), but your book has brought me up to speed as fast as I could read it. It�s really cool to be able to understand the underlying principles and concepts from the start, rather than having to try to build that conceptual model through trial and error. Hopefully I will be able to attend your seminar in the not-too-distant future. <emphasis role="bold">Randall R. Hawley, Automation Technician, Eli Lilly &amp; Co.</emphasis></para>
  <para>The best computer book writing I have seen. <emphasis role="bold">Tom Holland</emphasis></para>
  <para>This is one of the best books I�ve read about a programming language� The best book ever written on Java. <emphasis role="bold">Ravindra Pai, Oracle Corporation, SUNOS product line</emphasis></para>
  <para>This is the best book on Java that I have ever found! You have done a great job. Your depth is amazing. I will be purchasing the book when it is published. I have been learning Java since October 96. I have read a few books, and consider yours a �MUST READ.� These past few months we have been focused on a product written entirely in Java. Your book has helped solidify topics I was shaky on and has expanded my knowledge base. I have even used some of your explanations as information in interviewing contractors to help our team. I have found how much Java knowledge they have by asking them about things I have learned from reading your book (e.g., the difference between arrays and Vectors). Your book is great! <emphasis role="bold">Steve Wilkinson, Senior Staff Specialist, MCI Telecommunications</emphasis></para>
  <para>Great book. Best book on Java I have seen so far. <emphasis role="bold">Jeff Sinclair, Software Engineer, Kestral Computing</emphasis></para>
  <para>Thank you for <emphasis role="italic">Thinking in Java</emphasis>. It�s time someone went beyond mere language description to a thoughtful, penetrating analytic tutorial that doesn�t kowtow to The Manufacturers. I�ve read almost all the others�only yours and Patrick Winston�s have found a place in my heart. I�m already recommending it to customers. Thanks again. <emphasis role="bold">Richard Brooks, Java Consultant, Sun Professional Services, Dallas</emphasis></para>
  <para>Other books cover the WHAT of Java (describing the syntax and the libraries) or the HOW of Java (practical programming examples). <emphasis role="italic">Thinking in Java</emphasis> is the only book I know that explains the WHY of Java; why it was designed the way it was, why it works the way it does, why it sometimes doesn�t work, why it�s better than C++, why it�s not. Although it also does a good job of teaching the what and how of the language, <emphasis role="italic">Thinking in Java</emphasis> is definitely the thinking person�s choice in a Java book. <emphasis role="bold">Robert S. Stephenson</emphasis></para>
  <para>Thanks for writing a great book. The more I read it the better I like it. My students like it, too. <emphasis role="bold">Chuck Iverson</emphasis></para>
  <para>I just want to commend you for your work on <emphasis role="italic">Thinking in Java</emphasis>. It is people like you that dignify the future of the Internet and I just want to thank you for your effort. It is very much appreciated. <emphasis role="bold">Patrick Barrell, Network Officer Mamco, QAF Mfg. Inc.</emphasis></para>
  <para>Most of the Java books out there are fine for a start, and most just have beginning stuff and a lot of the same examples. Yours is by far the best advanced thinking book I�ve seen. Please publish it soon! ... I also bought <emphasis role="italic">Thinking in C++</emphasis> just because I was so impressed with <emphasis role="italic">Thinking in Java</emphasis>. <emphasis role="bold">George Laframboise, LightWorx Technology Consulting, Inc.</emphasis></para>
  <para>I wrote to you earlier about my favorable impressions regarding your <emphasis role="italic">Thinking in C++</emphasis> (a book that stands prominently on my shelf here at work). And today I�ve been able to delve into Java with your e-book in my virtual hand, and I must say (in my best Chevy Chase from <emphasis role="italic">Modern Problems</emphasis>) �I like it!� Very informative and explanatory, without reading like a dry textbook. You cover the most important yet the least covered concepts of Java development: the whys. <emphasis role="bold">Sean Brady</emphasis></para>
  <para>Your examples are clear and easy to understand. You took care of many important details of Java that can�t be found easily in the weak Java documentation. And you don�t waste the reader�s time with the basic facts a programmer already knows. <emphasis role="bold">Kai Engert, Innovative Software, Germany</emphasis></para>
  <para>I�m a great fan of your <emphasis role="italic">Thinking in C++</emphasis> and have recommended it to associates. As I go through the electronic version of your Java book, I�m finding that you�ve retained the same high level of writing. Thank you! <emphasis role="bold">Peter R. Neuwald</emphasis></para>
  <para>VERY well-written Java book...I think you�ve done a GREAT job on it. As the leader of a Chicago-area Java special interest group, I�ve favorably mentioned your book and Web site several times at our recent meetings. I would like to use <emphasis role="italic">Thinking in Java</emphasis> as the basis for a part of each monthly SIG meeting, in which we review and discuss each chapter in succession. <emphasis role="bold">Mark Ertes</emphasis></para>
  <para>I really appreciate your work and your book is good. I recommend it here to our users and Ph.D. students. <emphasis role="bold">Hugues Leroy // Irisa-Inria Rennes France, Head of Scientific Computing and Industrial Tranfert</emphasis></para>
  <para>OK, I�ve only read about 40 pages of <emphasis role="italic">Thinking in Java</emphasis>, but I�ve already found it to be the most clearly written and presented programming book I�ve come across...and I�m a writer, myself, so I am probably a little critical. I have <emphasis role="italic">Thinking in C++</emphasis> on order and can�t wait to crack it�I�m fairly new to programming and am hitting learning curves head-on everywhere. So this is just a quick note to say thanks for your excellent work. I had begun to burn a little low on enthusiasm from slogging through the mucky, murky prose of most computer books�even ones that came with glowing recommendations. I feel a whole lot better now. <emphasis role="bold">Glenn Becker, Educational Theatre Association</emphasis></para>
  <para>Thank you for making your wonderful book available. I have found it immensely useful in finally understanding what I experienced as confusing in Java and C++. Reading your book has been very satisfying. <emphasis role="bold">Felix Bizaoui, Twin Oaks Industries, Louisa, Va.</emphasis></para>
  <para>I must congratulate you on an excellent book. I decided to have a look at <emphasis role="italic">Thinking in Java</emphasis> based on my experience with <emphasis role="italic">Thinking in C++</emphasis>, and I was not disappointed. <emphasis role="bold">Jaco van der Merwe, Software Specialist, DataFusion Systems Ltd, Stellenbosch, South Africa</emphasis></para>
  <para>This has to be one of the best Java books I�ve seen. <emphasis role="bold">E.F. Pritchard, Senior Software Engineer, Cambridge Animation Systems Ltd., United Kingdom</emphasis></para>
  <para>Your book makes all the other Java books I�ve read or flipped through seem doubly useless and insulting. <emphasis role="bold">Brett g Porter, Senior Programmer, Art &amp; Logic</emphasis></para>
  <para>I have been reading your book for a week or two and compared to the books I have read earlier on Java, your book seems to have given me a great start. I have recommended this book to a lot of my friends and they have rated it excellent. Please accept my congratulations for coming out with an excellent book. <emphasis role="bold">Rama Krishna Bhupathi, Software Engineer, TCSI Corporation, San Jose</emphasis></para>
  <para>Just wanted to say what a �brilliant� piece of work your book is. I�ve been using it as a major reference for in-house Java work. I find that the table of contents is just right for quickly locating the section that is required. It�s also nice to see a book that is not just a rehash of the API nor treats the programmer like a dummy. <emphasis role="bold">Grant Sayer, Java Components Group Leader, Ceedata Systems Pty Ltd, Australia</emphasis></para>
  <para>Wow! A readable, in-depth Java book. There are a lot of poor (and admittedly a couple of good) Java books out there, but from what I�ve seen yours is definitely one of the best. <emphasis role="bold">John Root, Web Developer, Department of Social Security, London</emphasis></para>
  <para>I�ve *just* started <emphasis role="italic">Thinking in Java</emphasis>. I expect it to be very good because I really liked <emphasis role="italic">Thinking in C++</emphasis> (which I read as an experienced C++ programmer, trying to stay ahead of the curve). I�m somewhat less experienced in Java, but expect to be very satisfied. You are a wonderful author. <emphasis role="bold">Kevin K. Lewis, Technologist, ObjectSpace, Inc.</emphasis></para>
  <para>I think it�s a great book. I learned all I know about Java from this book. Thank you for making it available for free over the Internet. If you wouldn�t have I�d know nothing about Java at all. But the best thing is that your book isn�t a commercial brochure for Java. It also shows the bad sides of Java. YOU have done a great job here. <emphasis role="bold">Frederik Fix, Belgium</emphasis></para>
  <para>I have been hooked to your books all the time. A couple of years ago, when I wanted to start with C++, it was <emphasis role="italic">C++ Inside &amp; Out</emphasis> which took me around the fascinating world of C++. It helped me in getting better opportunities in life. Now, in pursuit of more knowledge and when I wanted to learn Java, I bumped into <emphasis role="italic">Thinking in Java</emphasis>�no doubts in my mind as to whether I need some other book. Just fantastic. It is more like rediscovering myself as I get along with the book. It is just a month since I started with Java, and heartfelt thanks to you, I am understanding it better now. <emphasis role="bold">Anand Kumar S., Software Engineer, Computervision, India</emphasis></para>
  <para>Your book stands out as an excellent general introduction. <emphasis role="bold">Peter Robinson, University of Cambridge Computer Laboratory</emphasis></para>
  <para>It�s by far the best material I have come across to help me learn Java and I just want you to know how lucky I feel to have found it. THANKS! <emphasis role="bold">Chuck Peterson, Product Leader, Internet Product Line, IVIS International</emphasis></para>
  <para>The book is great. It�s the third book on Java I�ve started and I�m about two-thirds of the way through it now. I plan to finish this one. I found out about it because it is used in some internal classes at Lucent Technologies and a friend told me the book was on the Net. Good work. <emphasis role="bold">Jerry Nowlin, MTS, Lucent Technologies</emphasis></para>
  <para>Of the six or so Java books I�ve accumulated to date, your <emphasis role="italic">Thinking in Java</emphasis> is by far the best and clearest. <emphasis role="bold">Michael Van Waas, Ph.D., President, TMR Associates</emphasis></para>
  <para>I just want to say thanks for <emphasis role="italic">Thinking in Java</emphasis>. What a wonderful book you�ve made here! Not to mention downloadable for free! As a student I find your books invaluable (I have a copy of <emphasis role="italic">C++ Inside Out</emphasis>, another great book about C++), because they not only teach me the how-to, but also the whys, which are of course very important in building a strong foundation in languages such as C++ or Java. I have quite a lot of friends here who love programming just as I do, and I�ve told them about your books. They think it�s great! Thanks again! By the way, I�m Indonesian and I live in Java. <emphasis role="bold">Ray Frederick Djajadinata, Student at Trisakti University, Jakarta</emphasis></para>
  <para>The mere fact that you have made this work free over the Net puts me into shock. I thought I�d let you know how much I appreciate and respect what you�re doing. <emphasis role="bold">Shane LeBouthillier, Computer Engineering student, University of Alberta, Canada</emphasis></para>
  <para>I have to tell you how much I look forward to reading your monthly column. As a newbie to the world of object oriented programming, I appreciate the time and thoughtfulness that you give to even the most elementary topic. I have downloaded your book, but you can bet that I will purchase the hard copy when it is published. Thanks for all of your help. <emphasis role="bold">Dan Cashmer, B. C. Ziegler &amp; Co.</emphasis></para>
  <para>Just want to congratulate you on a job well done. First I stumbled upon the PDF version of <emphasis role="italic">Thinking in Java</emphasis>. Even before I finished reading it, I ran to the store and found <emphasis role="italic">Thinking in C++</emphasis>. Now, I have been in the computer business for over eight years, as a consultant, software engineer, teacher/trainer, and recently as self-employed, so I�d like to think that I have seen enough (not �have seen it all,� mind you, but enough). However, these books cause my girlfriend to call me a �geek.� Not that I have anything against the concept�it is just that I thought this phase was well beyond me. But I find myself truly enjoying both books, like no other computer book I have touched or bought so far. Excellent writing style, very nice introduction of every new topic, and lots of wisdom in the books. Well done. <emphasis role="bold">Simon Goland, simonsez@smartt.com, Simon Says Consulting, Inc.</emphasis></para>
  <para>I must say that your <emphasis role="italic">Thinking in Java</emphasis> is great! That is exactly the kind of documentation I was looking for. Especially the sections about good and poor software design using Java. <emphasis role="bold">Dirk Duehr, Lexikon Verlag, Bertelsmann AG, Germany</emphasis></para>
  <para>Thank you for writing two great books (<emphasis role="italic">Thinking in C++</emphasis>, <emphasis role="italic">Thinking in Java</emphasis>). You have helped me immensely in my progression to object oriented programming. <emphasis role="bold">Donald Lawson, DCL Enterprises</emphasis></para>
  <para>Thank you for taking the time to write a really helpful book on Java. If teaching makes you understand something, by now you must be pretty pleased with yourself. <emphasis role="bold">Dominic Turner, GEAC Support</emphasis></para>
  <para>It�s the best Java book I have ever read�and I read some. <emphasis role="bold">Jean-Yves MENGANT, Chief Software Architect NAT-SYSTEM, Paris, France</emphasis></para>
  <para><emphasis role="italic">Thinking in Java</emphasis> gives the best coverage and explanation. Very easy to read, and I mean the code fragments as well. <emphasis role="bold">Ron Chan, Ph.D., Expert Choice, Inc., Pittsburgh PA</emphasis></para>
  <para>Your book is great. I have read lots of programming books and your book still adds insights to programming in my mind. <emphasis role="bold">Ningjian Wang, Information System Engineer, The Vanguard Group</emphasis></para>
  <para><emphasis role="italic">Thinking in Java</emphasis> is an excellent and readable book. I recommend it to all my students. <emphasis role="bold">Dr. Paul Gorman, Department of Computer Science, University of Otago, Dunedin, New Zealand</emphasis></para>
  <para>You make it possible for the proverbial free lunch to exist, not just a soup kitchen type of lunch but a gourmet delight for those who appreciate good software and books about it. <emphasis role="bold">Jose Suriol, Scylax Corporation</emphasis></para>
  <para>Thanks for the opportunity of watching this book grow into a masterpiece! IT IS THE BEST book on the subject that I�ve read or browsed. <emphasis role="bold">Jeff Lapchinsky, Programmer, Net Results Technologies</emphasis></para>
  <para>Your book is concise, accessible and a joy to read. <emphasis role="bold">Keith Ritchie, Java Research &amp; Development Team, KL Group Inc.</emphasis></para>
  <para>It truly is the best book I�ve read on Java! <emphasis role="bold">Daniel Eng</emphasis></para>
  <para>The best book I have seen on Java! <emphasis role="bold">Rich Hoffarth, Senior Architect, West Group</emphasis></para>
  <para>Thank you for a wonderful book. I�m having a lot of fun going through the chapters. <emphasis role="bold">Fred Trimble, Actium Corporation</emphasis></para>
  <para>You have mastered the art of slowly and successfully making us grasp the details. You make learning VERY easy and satisfying. Thank you for a truly wonderful tutorial. <emphasis role="bold">Rajesh Rau, Software Consultant</emphasis></para>
  <para><emphasis role="italic">Thinking in Java</emphasis> rocks the free world! <emphasis role="bold">Miko O�Sullivan, President, Idocs Inc.</emphasis></para>
  <para><emphasis role="bold"><emphasis role="italic"> </emphasis></emphasis> <emphasis role="bold">About <emphasis role="italic">Thinking in C++</emphasis>:</emphasis></para>
  <para><emphasis role="bold">Best Book! Winner of the   1995 Software Development Magazine Jolt Award!</emphasis></para>
  <para>�This book is a tremendous achievement. You owe it to yourself to have a copy on your shelf. The chapter on iostreams is the most comprehensive and understandable treatment of that subject I�ve seen to date.�</para>
  <para><emphasis role="bold">Al Stevens   Contributing Editor, <emphasis role="italic">Doctor Dobbs Journal</emphasis></emphasis></para>
  <para>�Eckel�s book is the only one to so clearly explain how to rethink program construction for object orientation. That the book is also an excellent tutorial on the ins and outs of C++ is an added bonus.�</para>
  <para><emphasis role="bold">Andrew Binstock  Editor, <emphasis role="italic">Unix Review</emphasis></emphasis></para>
  <para>�Bruce continues to amaze me with his insight into C++, and <emphasis role="italic">Thinking in C++</emphasis> is his best collection of ideas yet. If you want clear answers to difficult questions about C++, buy this outstanding book.�</para>
  <para><emphasis role="bold">Gary Entsminger  Author, <emphasis role="italic">The Tao of Objects</emphasis></emphasis></para>
  <para>�<emphasis role="italic">Thinking in C++</emphasis> patiently and methodically explores the issues of when and how to use inlines, references, operator overloading, inheritance, and dynamic objects, as well as advanced topics such as the proper use of templates, exceptions and multiple inheritance. The entire effort is woven in a fabric that includes Eckel�s own philosophy of object and program design. A must for every C++ developer�s bookshelf, <emphasis role="italic">Thinking in C++</emphasis> is the one C++ book you must have if you�re doing serious development with C++.�</para>
  <para><emphasis role="bold">Richard Hale Shaw  Contributing Editor, PC Magazine</emphasis></para>
  <para>Thinking</para>
  <para>in</para>
  <para>Java</para>
  <para>Second Edition</para>
  <para>Bruce Eckel</para>
  <para>President, MindView, Inc.</para>
  <para> </para>
  <para> </para>
  <para> </para>
  <para><inlinemediaobject><imageobject role="html">
        <imagedata align="left" contentdepth="66" contentwidth="72" fileref="./TIJ2_files/image002.png" format="PNG" scalefit="1"/>
      </imageobject>
<imageobject role="fo">
        <imagedata align="left" contentdepth="100%" fileref="./TIJ2_files/image002.png" format="PNG" scalefit="1" width="100%"/>
      </imageobject>
</inlinemediaobject>Prentice Hall</para>
  <para> Upper Saddle River, New Jersey 07458</para>
  <para> www.phptr.com</para>
   <para>Library of Congress Cataloging-in-Publication Data</para>
  <para>Eckel, Bruce.</para>
  <para>� Thinking in Java / Bruce Eckel.--2nd ed.</para>
  <para>���� p.�� cm.</para>
  <para>� ISBN 0-13-027363-5</para>
  <para>� 1. Java (Computer program language) I. Title.</para>
  <para>�QA76.73.J38E25 2000</para>
  <para>�005.13&apos;3--dc21��������������������� 00-037522</para>
  <para>���������������������������������������� CIP</para>
  <para><emphasis role="italic">Editorial/Production Supervision: </emphasis>Nicholas Radhuber</para>
  <para><emphasis role="italic">Acquisitions Editor: </emphasis>Paul Petralia</para>
  <para><emphasis role="italic">Manufacturing Manager: </emphasis>Maura Goldstaub</para>
  <para><emphasis role="italic">Marketing Manager: </emphasis>Bryan Gambrel</para>
  <para><emphasis role="italic">Cover Design: </emphasis>Daniel Will-Harris </para>
  <para><emphasis role="italic">Interior Design: </emphasis>Daniel Will-Harris, www.will-harris.com</para>
  <para>� 2000 by Bruce Eckel, President, MindView, Inc. </para>
  <para> Published by Prentice Hall PTR</para>
  <para> Prentice-Hall, Inc.</para>
  <para> Upper Saddle River, NJ 07458</para>
  <para>The information in this book is distributed on an �as is� basis, without warranty. While every precaution has been taken in the preparation of this book, neither the author nor the publisher shall have any liability to any person or entitle with respect to any liability, loss or damage caused or alleged to be caused directly or indirectly by instructions contained in this book or by the computer software or hardware products described herein.</para>
  <para>All rights reserved. No part of this book may be reproduced, in any form or by any means, without permission in writing from the publisher.</para>
  <para>Prentice-Hall books are widely used by corporations and government agencies for training, marketing, and resale. The publisher offers discounts on this book when ordered in bulk quantities. For more information, contact the Corporate Sales Department at 800-382-3419, fax: 201-236-7141, email: <emphasis role="italic"><link xl:href="mailto:corpsales@prenhall.com">corpsales@prenhall.com</link></emphasis> or write: Corporate Sales Department, Prentice Hall PTR, One Lake Street, Upper Saddle River, New Jersey 07458. </para>
  <para>Java is a registered trademark of Sun Microsystems, Inc. Windows 95 and Windows NT are trademarks of Microsoft Corporation. All other product names and company names mentioned herein are the property of their respective owners.</para>
  <para>Printed in the United States of AmericaISBN 0-13-027363-5</para>
  <para> 10 9 8 7 6 5 4 3 2 1</para>
  <para><inlinemediaobject><imageobject role="html">
        <imagedata align="left" contentdepth="56" contentwidth="61" fileref="./TIJ2_files/image003.png" format="PNG" scalefit="1"/>
      </imageobject>
<imageobject role="fo">
        <imagedata align="left" contentdepth="100%" fileref="./TIJ2_files/image003.png" format="PNG" scalefit="1" width="100%"/>
      </imageobject>
</inlinemediaobject>Prentice-Hall International (UK) Limited, <emphasis role="italic">London</emphasis></para>
  <para>Prentice-Hall of Australia Pty. Limited, <emphasis role="italic">Sydney</emphasis></para>
  <para>Prentice-Hall Canada, Inc., <emphasis role="italic">Toronto</emphasis></para>
  <para>Prentice-Hall Hispanoamericana, S.A., <emphasis role="italic">Mexico</emphasis></para>
  <para>Prentice-Hall of India Private Limited, <emphasis role="italic">New Delhi</emphasis></para>
  <para>Prentice-Hall of Japan, Inc., <emphasis role="italic">Tokyo</emphasis></para>
  <para>Pearson Education Asia Ltd., <emphasis role="italic">Singapore</emphasis></para>
  <para>Editora Prentice-Hall do Brasil, Ltda., <emphasis role="italic">Rio de Janeiro</emphasis><emphasis role="italic"> </emphasis></para>
  <informaltable frame="none">
    <tgroup cols="2">
      <colspec colname="c1" colwidth="8"/>
      <colspec colname="c2" colwidth="100*"/>
      <tbody>
        <row>
          <entry><para/></entry>
        </row>
        <row>
          <entry><para/></entry>
          <entry><para><inlinemediaobject><imageobject role="html">
                  <imagedata contentdepth="383" contentwidth="690" fileref="./TIJ2_files/image004.png" format="PNG" scalefit="1"/>
                </imageobject>
<imageobject role="fo">
                  <imagedata contentdepth="100%" fileref="./TIJ2_files/image004.png" format="PNG" scalefit="1" width="100%"/>
                </imageobject>
</inlinemediaobject></para></entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>
   <informaltable frame="none">
    <tgroup cols="2">
      <colspec colname="c1" colwidth="5"/>
      <colspec colname="c2" colwidth="100*"/>
      <tbody>
        <row>
          <entry><para/></entry>
        </row>
        <row>
          <entry><para/></entry>
          <entry><para><inlinemediaobject><imageobject role="html">
                  <imagedata contentdepth="453" contentwidth="717" fileref="./TIJ2_files/image005.png" format="PNG" scalefit="1"/>
                </imageobject>
<imageobject role="fo">
                  <imagedata contentdepth="100%" fileref="./TIJ2_files/image005.png" format="PNG" scalefit="1" width="100%"/>
                </imageobject>
</inlinemediaobject></para></entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>
   <para><emphasis role="italic"> </emphasis>  </para>
  <para> </para>
  <para>Dedication</para>
  <para>To the person who, even now,</para>
  <para> is creating the next great computer language</para>
   <para><anchor xreflabel="" xml:id="_Ref403700469"/><anchor xreflabel="" xml:id="TOCOverview"/>Overview</para>
  <para>Preface���������������������������������� �������������������������������������������������� 1</para>
  <para>Introduction���������������������������������������������������������������������������� 9</para>
  <para>1: Introduction� to Objects�� ������������������������������������������������ 29</para>
  <para>2: Everything is an Object��� ����������������������������������������������� 101</para>
  <para>3: Controlling Program Flow���������������������������������������������������� ���� 133</para>
  <para>4: Initialization� &amp; Cleanup�� ����������������������������������������������� 191</para>
  <para>5: Hiding the Implementation������������������������������������������� 243</para>
  <para>6: Reusing Classes��������������������������������������������������������������� 271</para>
  <para>7: Polymorphism������������������������������������������������������������������ 311</para>
  <para>8: Interfaces &amp; Inner Classes���������������������������������������������������� ���� 349</para>
  <para>9: Holding� Your Objects����� ���������������������������������������������� 407</para>
  <para>10: Error Handling� with Exceptions��������������������������������� 531</para>
  <para>11: The Java� I/O System����� ���������������������������������������������� 573</para>
  <para>12: Run-time Type Identification��������������������������������������� 659</para>
  <para>13: Creating Windows� &amp; Applets�������������������������������������� 689</para>
  <para>14: Multiple Threads����������������������������������������������������������� 825</para>
  <para>15: Distributed Computing�� ���������������������������������������������� 903</para>
  <para>A: Passing &amp; Returning Objects��������������������������������������� 1015</para>
  <para>B: The Java Native Interface (JNI)���������������������������������� 1067</para>
  <para>C: Java Programming Guidelines������������������������������������� 1079</para>
  <para>D: Resources��������������������������������������������������������������������� 1093</para>
  <para>Index����������������������������������������������������������������������������������� 1101</para>
  <para> </para>
  <para><anchor xreflabel="" xml:id="AAAIndex"/>What�s Inside</para>
   <para>Preface�������������������������������� 1</para>
  <para>Preface to the 2<superscript>nd</superscript> edition.. 4</para>
  <para>Java 2........................................... 6</para>
  <para>The CD ROM...................... 7</para>
  <para>Introduction����������������������� 9</para>
  <para>Prerequisites...................... 9</para>
  <para>Learning Java................... 10</para>
  <para>Goals.................................. 11</para>
  <para>Online documentation..... 12</para>
  <para>Chapters............................ 13</para>
  <para>Exercises........................... 19</para>
  <para>Multimedia CD ROM....... 19</para>
  <para>Source code...................... 20</para>
  <para>Coding standards..................... 22</para>
  <para>Java versions................... 22</para>
  <para>Seminars and ......................... 23</para>
  <para> mentoring</para>
  <para>Errors................................ 23</para>
  <para>Note on the cover design24</para>
  <para>Acknowledgements......... 25</para>
  <para>Internet contributors............... 28</para>
  <para>1: Introduction� ������������������������� 29</para>
  <para> to Objects</para>
  <para>The progress </para>
  <para>of abstraction................... 30</para>
  <para>An object has </para>
  <para>an interface...................... 32</para>
  <para>The hidden </para>
  <para>implementation................ 35</para>
  <para>Reusing the </para>
  <para>implementation................ 37</para>
  <para>Inheritance: reusing </para>
  <para>the interface..................... 38</para>
  <para>Is-a vs. is-like-a relationships42</para>
  <para>Interchangeable objects� with polymorphism�������� 44</para>
  <para>Abstract base classes </para>
  <para>and interfaces........................... 48</para>
  <para>Object landscapes and lifetimes����� 49</para>
  <para>Collections and iterators......... 51</para>
  <para>The singly rooted hierarchy.... 53</para>
  <para>Collection libraries and </para>
  <para>support for easy collection use54</para>
  <para>The housekeeping dilemma: </para>
  <para>who should clean up?.............. 55</para>
  <para>Exception handling: </para>
  <para>dealing with errors........... 57</para>
  <para>Multithreading................. 58</para>
  <para>Persistence....................... 60</para>
  <para>Java and the Internet..... 60</para>
  <para>What is the Web?..................... 60</para>
  <para>Client-side programming........ 63</para>
  <para>Server-side programming....... 70</para>
  <para>A separate arena: </para>
  <para>applications............................... 71</para>
  <para>Analysis and design......... 71</para>
  <para>Phase 0: Make a plan............... 74</para>
  <para>Phase 1: What are we making?75</para>
  <para>Phase 2: How will we build it?79</para>
  <para>Phase 3: Build the core............ 83</para>
  <para>Phase 4: Iterate the use cases. 84</para>
  <para>Phase 5: Evolution................... 85</para>
  <para>Plans pay off............................. 87</para>
  <para>Extreme programming... 88</para>
  <para>Write tests first........................ 88</para>
  <para>Pair programming................... 90</para>
  <para>Why Java succeeds.......... 91</para>
  <para>Systems are easier� to </para>
  <para>express and understand.......... 91</para>
  <para>Maximal leverage </para>
  <para>with libraries............................ 92</para>
  <para>Error handling.......................... 92</para>
  <para>Programming in the large....... 92</para>
  <para>Strategies for transition.. 93</para>
  <para>Guidelines................................. 93</para>
  <para>Management obstacles............ 95</para>
  <para>Java vs. C++?.................. 97</para>
  <para>Summary......................... 98</para>
  <para>2: Everything is ������������������������� 101</para>
  <para> an Object</para>
  <para>You manipulate objects� </para>
  <para>with references............... 101</para>
  <para>You must create� </para>
  <para>all the objects.................. 103</para>
  <para>Where storage lives............... 103</para>
  <para>Special case: primitive types105</para>
  <para>Arrays in Java......................... 107</para>
  <para>You never need to� </para>
  <para>destroy an object............ 107</para>
  <para>Scoping.................................... 108</para>
  <para>Scope of objects....................... 109</para>
  <para>Creating new� data </para>
  <para>types: class...................... 110</para>
  <para>Fields and methods................ 110</para>
  <para>Methods, arguments,� </para>
  <para>and return values........... 112</para>
  <para>The argument list................... 114</para>
  <para>Building a </para>
  <para>Java program.................. 115</para>
  <para>Name visibility........................ 115</para>
  <para>Using other components........ 116</para>
  <para>The <emphasis role="bold">static</emphasis> keyword................. 117</para>
  <para>Your first Java program. 119</para>
  <para>Compiling and running......... 121</para>
  <para>Comments and embedded documentation����������� 122</para>
  <para>Comment documentation...... 123</para>
  <para>Syntax....................................... 124</para>
  <para>Embedded HTML................... 125</para>
  <para><emphasis role="bold">@see</emphasis>: referring to </para>
  <para>other classes............................ 125</para>
  <para>Class documentation tags...... 126</para>
  <para>Variable documentation tags127</para>
  <para>Method documentation tags.. 127</para>
  <para>Documentation example....... 128</para>
  <para>Coding style.................... 129</para>
  <para>Summary........................ 130</para>
  <para>Exercises......................... 130</para>
  <para>3: Controlling ����������������� 133</para>
  <para> Program Flow</para>
  <para>Using Java operators..... 133</para>
  <para>Precedence.............................. 134</para>
  <para>Assignment.............................. 134</para>
  <para>Mathematical operators......... 137</para>
  <para>Auto increment </para>
  <para>and decrement........................ 139</para>
  <para>Relational operators............... 141</para>
  <para>Logical operators.................... 143</para>
  <para>Bitwise operators.................... 146</para>
  <para>Shift operators........................ 147</para>
  <para>Ternary if-else operator......... 151</para>
  <para>The comma operator.............. 152</para>
  <para><emphasis role="bold">String</emphasis> operator +................... 153</para>
  <para>Common pitfalls </para>
  <para>when using operators............. 153</para>
  <para>Casting operators.................... 154</para>
  <para>Java has no �sizeof�............... 158</para>
  <para>Precedence revisited............. 158</para>
  <para>A compendium of operators.. 159</para>
  <para>Execution control........... 170</para>
  <para>true and false.......................... 170</para>
  <para>if-else........................................ 171</para>
  <para>Iteration................................... 172</para>
  <para>do-while................................... 173</para>
  <para>for............................................. 173</para>
  <para>break and continue................ 175</para>
  <para>switch....................................... 183</para>
  <para>Summary........................ 187</para>
  <para>Exercises........................ 188</para>
  <para>4: Initialization� ������������������������ 191</para>
  <para> &amp; Cleanup</para>
  <para>Guaranteed initialization� with the constructor����� 191</para>
  <para>Method overloading...... 194</para>
  <para>Distinguishing </para>
  <para>overloaded methods............... 196</para>
  <para>Overloading with primitives. 197</para>
  <para>Overloading on </para>
  <para>return values.......................... 202</para>
  <para>Default constructors.............. 202</para>
  <para>The <emphasis role="bold">this </emphasis>keyword................... 203</para>
  <para>Cleanup: finalization </para>
  <para>and� garbage collection. 207</para>
  <para>What is <emphasis role="bold">finalize( )</emphasis> for?......... 208</para>
  <para>You must perform cleanup... 209</para>
  <para>The death condition............... 214</para>
  <para>How a garbage </para>
  <para>collector works........................ 215</para>
  <para>Member initialization..... 219</para>
  <para>Specifying initialization........ 221</para>
  <para>Constructor initialization...... 223</para>
  <para>Array initialization.......... 231</para>
  <para>Multidimensional arrays....... 236</para>
  <para>Summary........................ 239</para>
  <para>Exercises........................ 240</para>
  <para>5: Hiding the Implementation������������������������������������������� 243</para>
  <para><emphasis role="bold">package</emphasis>: </para>
  <para>the library unit............... 244</para>
  <para>Creating unique </para>
  <para>package names....................... 247</para>
  <para>A custom tool library.............. 251</para>
  <para>Using imports to </para>
  <para>change behavior..................... 252</para>
  <para>Package caveat........................ 254</para>
  <para>Java access specifiers.... 255</para>
  <para>�Friendly�................................ 255</para>
  <para><emphasis role="bold">public</emphasis>: interface access......... 256</para>
  <para><emphasis role="bold">private</emphasis>: </para>
  <para>you can�t touch that!.............. 258</para>
  <para><emphasis role="bold">protected</emphasis>: �sort of friendly�. 260</para>
  <para>Interface and implementation�������� 261</para>
  <para>Class access................... 263</para>
  <para>Summary........................ 267</para>
  <para>Exercises........................ 268</para>
  <para>6: Reusing Classes���������� 271</para>
  <para>Composition syntax........ 271</para>
  <para>Inheritance syntax......... 275</para>
  <para>Initializing the base class..... 278</para>
  <para>Combining composition� </para>
  <para>and inheritance.............. 281</para>
  <para>Guaranteeing </para>
  <para>proper cleanup....................... 283</para>
  <para>Name hiding........................... 286</para>
  <para>Choosing composition� </para>
  <para>vs. inheritance............... 288</para>
  <para>protected........................ 290</para>
  <para>Incremental </para>
  <para>development................... 291</para>
  <para>Upcasting........................ 291</para>
  <para>Why �upcasting�?................... 293</para>
  <para>The <emphasis role="bold">final</emphasis> keyword......... 294</para>
  <para>Final data................................ 294</para>
  <para>Final methods......................... 299</para>
  <para>Final classes............................ 301</para>
  <para>Final caution.......................... 302</para>
  <para>Initialization and� </para>
  <para>class loading.................. 304</para>
  <para>Initialization </para>
  <para>with inheritance..................... 304</para>
  <para>Summary....................... 306</para>
  <para>Exercises........................ 307</para>
  <para>7: Polymorphism������������ 311</para>
  <para>Upcasting revisited......... 311</para>
  <para>Forgetting the object type...... 313</para>
  <para>The twist.......................... 315</para>
  <para>Method-call binding.............. 315</para>
  <para>Producing the right behavior316</para>
  <para>Extensibility........................... 320</para>
  <para>Overriding vs. </para>
  <para>overloading.................... 324</para>
  <para>Abstract classes� </para>
  <para>and methods.................. 325</para>
  <para>Constructors and polymorphism����� 330</para>
  <para>Order of constructor calls..... 330</para>
  <para>Inheritance and <emphasis role="bold">finalize( )</emphasis>.. 333</para>
  <para>Behavior of polymorphic </para>
  <para>methods� inside constructors337</para>
  <para>Designing with </para>
  <para>inheritance..................... 339</para>
  <para>Pure inheritance </para>
  <para>vs. extension............................ 341</para>
  <para>Downcasting and run-time� </para>
  <para>type identification.................. 343</para>
  <para>Summary....................... 346</para>
  <para>Exercises........................ 346</para>
  <para>8: Interfaces &amp; ������������������ 349</para>
  <para> Inner Classes</para>
  <para>Interfaces....................... 349</para>
  <para>�Multiple inheritance� </para>
  <para>in Java..................................... 354</para>
  <para>Extending an interface� </para>
  <para>with inheritance..................... 358</para>
  <para>Grouping constants................ 359</para>
  <para>Initializing fields </para>
  <para>in interfaces............................ 361</para>
  <para>Nesting interfaces.................. 362</para>
  <para>Inner classes.................. 365</para>
  <para>Inner classes and upcasting. 368</para>
  <para>Inner classes� in </para>
  <para>methods and scopes............... 370</para>
  <para>Anonymous inner classes...... 373</para>
  <para>The link to the outer class.... 376</para>
  <para><emphasis role="bold">static</emphasis> inner classes................ 379</para>
  <para>Referring to the </para>
  <para>outer class object.................... 381</para>
  <para>Reaching outward from </para>
  <para>a multiply-nested class......... 383</para>
  <para>Inheriting from inner classes384</para>
  <para>Can inner classes </para>
  <para>be overridden?....................... 385</para>
  <para>Inner class identifiers........... 387</para>
  <para>Why inner classes?................ 388</para>
  <para>Inner classes &amp; </para>
  <para>control frameworks................ 394</para>
  <para>Summary....................... 402</para>
  <para>Exercises........................ 403</para>
  <para>9: Holding� ������������������ 407</para>
  <para> Your Objects</para>
  <para>Arrays............................. 407</para>
  <para>Arrays are first-class objects. 409</para>
  <para>Returning an array................. 413</para>
  <para>The <emphasis role="bold">Arrays</emphasis> class.................... 415</para>
  <para>Filling an array...................... 428</para>
  <para>Copying an array..................... 429</para>
  <para>Comparing arrays................... 431</para>
  <para>Array element comparisons... 431</para>
  <para>Sorting an array...................... 435</para>
  <para>Searching a sorted array........ 437</para>
  <para>Array summary........................ 439</para>
  <para>Introduction to </para>
  <para>containers...................... 439</para>
  <para>Printing containers................ 441</para>
  <para>Filling containers................... 443</para>
  <para>Container disadvantage:� unknown type���� 450</para>
  <para>Sometimes it works anyway... 452</para>
  <para>Making a type-conscious <emphasis role="bold">ArrayList</emphasis>����������� 454</para>
  <para>Iterators......................... 456</para>
  <para>Container taxonomy..... 460</para>
  <para><emphasis role="bold">Collection</emphasis></para>
  <para>functionality................... 463</para>
  <para><emphasis role="bold">List</emphasis> functionality........... 467</para>
  <para>Making a stack </para>
  <para>from a <emphasis role="bold">LinkedList</emphasis>................. 471</para>
  <para>Making a queue </para>
  <para>from a <emphasis role="bold">LinkedList</emphasis>................. 472</para>
  <para><emphasis role="bold">Set</emphasis> functionality............ 473</para>
  <para><emphasis role="bold">SortedSet</emphasis>................................ 476</para>
  <para><emphasis role="bold">Map</emphasis> functionality.......... 476</para>
  <para><emphasis role="bold">SortedMap</emphasis>............................. 482</para>
  <para>Hashing and hash codes....... 482</para>
  <para>Overriding <emphasis role="bold">hashCode( )</emphasis>...... 492</para>
  <para>Holding references........ 495</para>
  <para>The <emphasis role="bold">WeakHashMap</emphasis>............. 498</para>
  <para>Iterators revisited.......... 500</para>
  <para>Choosing an </para>
  <para>implementation.............. 501</para>
  <para>Choosing between <emphasis role="bold">List</emphasis>s........ 502</para>
  <para>Choosing between <emphasis role="bold">Set</emphasis>s.......... 506</para>
  <para>Choosing between <emphasis role="bold">Map</emphasis>s....... 508</para>
  <para>Sorting and </para>
  <para>searching <emphasis role="bold">List</emphasis>s............... 511</para>
  <para>Utilities............................ 512</para>
  <para>Making a <emphasis role="bold">Collection</emphasis></para>
  <para>or <emphasis role="bold">Map</emphasis> unmodifiable............ 513</para>
  <para>Synchronizing a </para>
  <para><emphasis role="bold">Collection</emphasis> or <emphasis role="bold">Map</emphasis>................. 514</para>
  <para>Unsupported </para>
  <para>operations....................... 516</para>
  <para>Java 1.0/1.1 containers... 519</para>
  <para>Vector &amp; Enumeration............ 519</para>
  <para>Hashtable................................ 521</para>
  <para>Stack......................................... 521</para>
  <para>BitSet........................................ 522</para>
  <para>Summary........................ 524</para>
  <para>Exercises........................ 525</para>
  <para>10: Error Handling� �������������� 531</para>
  <para> with Exceptions</para>
  <para>Basic exceptions............. 532</para>
  <para>Exception arguments............. 533</para>
  <para>Catching an exception... 534</para>
  <para>The <emphasis role="bold">try</emphasis> block.......................... 535</para>
  <para>Exception handlers................ 535</para>
  <para>Creating your own exceptions��������� 537</para>
  <para>The exception </para>
  <para>specification................... 542</para>
  <para>Catching any exception.......... 543</para>
  <para>Rethrowing an exception...... 545</para>
  <para>Standard Java </para>
  <para>exceptions...................... 549</para>
  <para>The special case of <emphasis role="bold">RuntimeException</emphasis>���� 550</para>
  <para>Performing cleanup� </para>
  <para>with finally...................... 552</para>
  <para>What�s <emphasis role="bold">finally</emphasis> for?................. 554</para>
  <para>Pitfall: the lost exception...... 557</para>
  <para>Exception restrictions.... 558</para>
  <para>Constructors................... 562</para>
  <para>Exception matching...... 566</para>
  <para>Exception guidelines............. 568</para>
  <para>Summary....................... 568</para>
  <para>Exercises........................ 569</para>
  <para>11: The Java� ��������������������� 573</para>
  <para> I/O System</para>
  <para>The <emphasis role="bold">File</emphasis> class................ 574</para>
  <para>A directory lister..................... 574</para>
  <para>Checking for and </para>
  <para>creating directories............... 578</para>
  <para>Input and output............ 581</para>
  <para>Types of <emphasis role="bold">InputStream</emphasis>........... 581</para>
  <para>Types of <emphasis role="bold">OutputStream</emphasis>........ 583</para>
  <para>Adding attributes� </para>
  <para>and useful interfaces..... 585</para>
  <para>Reading from an <emphasis role="bold">InputStream� </emphasis>with<emphasis role="bold"> FilterInputStream</emphasis>����� 586</para>
  <para>Writing to an <emphasis role="bold">OutputStream<emphasis role="italic">� </emphasis></emphasis></para>
  <para>with<emphasis role="bold"> FilterOutputStream</emphasis>.... 587</para>
  <para><emphasis role="bold">Reader</emphasis>s &amp; <emphasis role="bold">Writer</emphasis>s.... 589</para>
  <para>Sources and sinks of data..... 590</para>
  <para>Modifying stream behavior... 591</para>
  <para>Unchanged Classes................. 592</para>
  <para>Off by itself:� RandomAccessFile���� 593</para>
  <para>Typical uses of </para>
  <para>I/O streams................... 594</para>
  <para>Input streams.......................... 597</para>
  <para>Output streams....................... 599</para>
  <para>A bug?...................................... 601</para>
  <para>Piped streams......................... 602</para>
  <para>Standard I/O................. 602</para>
  <para>Reading from standard input603</para>
  <para>Changing <emphasis role="bold">System.out</emphasis></para>
  <para>to a <emphasis role="bold">PrintWriter</emphasis>.................... 604</para>
  <para>Redirecting standard I/O...... 604</para>
  <para>Compression.................. 606</para>
  <para>Simple compression </para>
  <para>with GZIP................................ 607</para>
  <para>Multifile storage with Zip.... 608</para>
  <para>Java ARchives (JARs)............. 611</para>
  <para>Object serialization......... 613</para>
  <para>Finding the class.................... 618</para>
  <para>Controlling serialization....... 619</para>
  <para>Using persistence................... 630</para>
  <para>Tokenizing input............ 639</para>
  <para><emphasis role="bold">StreamTokenizer</emphasis>................. 639</para>
  <para><emphasis role="bold">StringTokenizer</emphasis>................... 642</para>
  <para>Checking capitalization style645</para>
  <para>Summary........................ 655</para>
  <para>Exercises........................ 656</para>
  <para>12: Run-time Type Identification��������������������������������������� 659</para>
  <para>The need for RTTI......... 659</para>
  <para>The <emphasis role="bold">Class</emphasis> object..................... 662</para>
  <para>Checking before a cast........... 665</para>
  <para>RTTI syntax................... 674</para>
  <para>Reflection: run-time� </para>
  <para>class information........... 677</para>
  <para>A class method extractor....... 679</para>
  <para>Summary....................... 685</para>
  <para>Exercises........................ 686</para>
  <para>13: Creating Windows� ����������������������� 689</para>
  <para> &amp; Applets</para>
  <para>The basic applet............. 692</para>
  <para>Applet restrictions................. 692</para>
  <para>Applet advantages.................. 693</para>
  <para>Application frameworks........ 694</para>
  <para>Running applets inside </para>
  <para>a Web browser........................ 695</para>
  <para>Using <emphasis role="italic">Appletviewer</emphasis>................. 698</para>
  <para>Testing applets....................... 698</para>
  <para>Running applets from </para>
  <para>the command line......... 700</para>
  <para>A display framework.............. 702</para>
  <para>Using the Windows Explorer705</para>
  <para>Making a button............ 706</para>
  <para>Capturing an event........ 707</para>
  <para>Text areas........................ 711</para>
  <para>Controlling layout........... 712</para>
  <para>BorderLayout........................... 713</para>
  <para>FlowLayout.............................. 714</para>
  <para>GridLayout............................... 715</para>
  <para>GridBagLayout........................ 716</para>
  <para>Absolute positioning.............. 716</para>
  <para>BoxLayout................................ 717</para>
  <para>The best approach?................ 721</para>
  <para>The Swing event model. 722</para>
  <para>Event and listener types........ 723</para>
  <para>Tracking multiple events..... 730</para>
  <para>A catalog of Swing components������ 734</para>
  <para>Buttons..................................... 734</para>
  <para>Icons......................................... 738</para>
  <para>Tool tips.................................. 740</para>
  <para>Text fields............................... 740</para>
  <para>Borders.................................... 743</para>
  <para>JScrollPanes............................ 744</para>
  <para>A mini-editor.......................... 747</para>
  <para>Check boxes............................ 748</para>
  <para>Radio buttons......................... 750</para>
  <para>Combo boxes </para>
  <para>(drop-down lists).................... 751</para>
  <para>List boxes................................ 753</para>
  <para>Tabbed panes......................... 755</para>
  <para>Message boxes........................ 756</para>
  <para>Menus...................................... 758</para>
  <para>Pop-up menus......................... 766</para>
  <para>Drawing................................... 768</para>
  <para>Dialog Boxes............................ 771</para>
  <para>File dialogs............................. 776</para>
  <para>HTML on </para>
  <para>Swing components.................. 779</para>
  <para>Sliders and progress bars..... 780</para>
  <para>Trees........................................ 781</para>
  <para>Tables...................................... 784</para>
  <para>Selecting Look &amp; Feel............ 787</para>
  <para>The clipboard......................... 790</para>
  <para>Packaging an applet </para>
  <para>into a JAR file................ 793</para>
  <para>Programming </para>
  <para>techniques..................... 794</para>
  <para>Binding events dynamically.. 794</para>
  <para>Separating business </para>
  <para>logic� from UI logic................. 796</para>
  <para>A canonical form..................... 799</para>
  <para>Visual programming� </para>
  <para>and Beans...................... 800</para>
  <para>What is a Bean?...................... 801</para>
  <para>Extracting <emphasis role="bold">BeanInfo</emphasis>� </para>
  <para>with the <emphasis role="bold">Introspector</emphasis>.......... 804</para>
  <para>A more sophisticated Bean.... 811</para>
  <para>Packaging a Bean................... 816</para>
  <para>More complex Bean support. 818</para>
  <para>More to Beans......................... 819</para>
  <para>Summary........................ 819</para>
  <para>Exercises........................ 820</para>
  <para>14: Multiple Threads����� 825</para>
  <para>Responsive </para>
  <para>user interfaces............... 826</para>
  <para>Inheriting from <emphasis role="bold">Thread</emphasis>....... 828</para>
  <para>Threading for a </para>
  <para>responsive interface.............. 831</para>
  <para>Combining the thread� </para>
  <para>with the main class................ 834</para>
  <para>Making many threads............ 836</para>
  <para>Daemon threads..................... 840</para>
  <para>Sharing </para>
  <para>limited resources........... 842</para>
  <para>Improperly accessing </para>
  <para>resources................................. 842</para>
  <para>How Java shares resources... 848</para>
  <para>JavaBeans revisited............... 854</para>
  <para>Blocking.......................... 859</para>
  <para>Becoming blocked................. 860</para>
  <para>Deadlock................................. 872</para>
  <para>Priorities......................... 877</para>
  <para>Reading and </para>
  <para>setting priorities.................... 878</para>
  <para>Thread groups........................ 882</para>
  <para><emphasis role="bold">Runnable</emphasis> revisited...... 891</para>
  <para>Too many threads................... 894</para>
  <para>Summary....................... 899</para>
  <para>Exercises........................ 901</para>
  <para>15: Distributed ��������������������� 903</para>
  <para> Computing</para>
  <para>Network programming. 904</para>
  <para>Identifying a machine........... 905</para>
  <para>Sockets..................................... 909</para>
  <para>Serving multiple clients........ 917</para>
  <para>Datagrams............................... 923</para>
  <para>Using URLs from </para>
  <para>within an applet..................... 923</para>
  <para>More to networking................ 926</para>
  <para>Java Database </para>
  <para>Connectivity (JDBC)...... 927</para>
  <para>Getting the example to work. 931</para>
  <para>A GUI version </para>
  <para>of the lookup program........... 935</para>
  <para>Why the JDBC API� </para>
  <para>seems so complex................... 938</para>
  <para>A more sophisticated </para>
  <para>example................................... 939</para>
  <para>Servlets.......................... 948</para>
  <para>The basic servlet.................... 949</para>
  <para>Servlets and multithreading954</para>
  <para>Handling sessions </para>
  <para>with servlets............................ 955</para>
  <para>Running the </para>
  <para>servlet examples.................... 960</para>
  <para>Java Server Pages......... 960</para>
  <para>Implicit objects....................... 962</para>
  <para>JSP directives......................... 963</para>
  <para>JSP scripting elements.......... 964</para>
  <para>Extracting fields and values. 966</para>
  <para>JSP page </para>
  <para>attributes and scope.............. 968</para>
  <para>Manipulating </para>
  <para>sessions in JSP........................ 969</para>
  <para>Creating and </para>
  <para>modifying cookies................... 971</para>
  <para>JSP summary........................... 972</para>
  <para>RMI (Remote Method Invocation)� 973</para>
  <para>Remote interfaces.................. 973</para>
  <para>Implementing the </para>
  <para>remote interface..................... 974</para>
  <para>Creating stubs and skeletons978</para>
  <para>Using the remote object......... 979</para>
  <para>CORBA........................... 980</para>
  <para>CORBA fundamentals............ 981</para>
  <para>An example............................. 983</para>
  <para>Java Applets and CORBA...... 989</para>
  <para>CORBA vs. RMI....................... 989</para>
  <para>Enterprise JavaBeans... 990</para>
  <para>JavaBeans vs. EJBs................. 991</para>
  <para>The EJB specification............ 992</para>
  <para>EJB components..................... 993</para>
  <para>The pieces of an </para>
  <para>EJB component....................... 994</para>
  <para>EJB operation......................... 995</para>
  <para>Types of EJBs.......................... 996</para>
  <para>Developing an EJB................. 998</para>
  <para>EJB summary........................ 1003</para>
  <para>Jini: distributed </para>
  <para>services......................... 1004</para>
  <para>Jini in context...................... 1004</para>
  <para>What is Jini?......................... 1005</para>
  <para>How Jini works..................... 1006</para>
  <para>The discovery process.......... 1006</para>
  <para>The join process................... 1007</para>
  <para>The lookup process.............. 1007</para>
  <para>Separation of interface </para>
  <para>and implementation........... 1008</para>
  <para>Abstracting </para>
  <para>distributed systems.............. 1010</para>
  <para>Summary...................... 1010</para>
  <para>Exercises....................... 1010</para>
  <para>A: Passing &amp; �������� 1015</para>
  <para> Returning Objects</para>
  <para>Passing </para>
  <para>references around........ 1016</para>
  <para>Aliasing.................................. 1016</para>
  <para>Making local copies...... 1019</para>
  <para>Pass by value........................ 1020</para>
  <para>Cloning objects..................... 1020</para>
  <para>Adding cloneability </para>
  <para>to a class................................ 1022</para>
  <para>Successful cloning................ 1024</para>
  <para>The effect of </para>
  <para><emphasis role="bold">Object.clone( )</emphasis>.................... 1027</para>
  <para>Cloning a composed object.. 1029</para>
  <para>A deep copy </para>
  <para>with <emphasis role="bold">ArrayList</emphasis>..................... 1032</para>
  <para>Deep copy via serialization. 1034</para>
  <para>Adding cloneability� </para>
  <para>further down a hierarchy.... 1036</para>
  <para>Why this strange design?.... 1037</para>
  <para>Controlling </para>
  <para>cloneability.................... 1038</para>
  <para>The copy constructor............ 1044</para>
  <para>Read-only classes........ 1049</para>
  <para>Creating read-only classes... 1051</para>
  <para>The drawback </para>
  <para>to immutability..................... 1052</para>
  <para>Immutable <emphasis role="bold">String</emphasis>s.............. 1054</para>
  <para>The <emphasis role="bold">String</emphasis> and� </para>
  <para><emphasis role="bold">StringBuffer </emphasis>classes........... 1058</para>
  <para><emphasis role="bold">String</emphasis>s are special............... 1062</para>
  <para>Summary...................... 1062</para>
  <para>Exercises...................... 1064</para>
  <para>B: The Java Native ������������� 1067</para>
  <para> Interface (JNI)</para>
  <para>Calling a </para>
  <para>native method.............. 1068</para>
  <para>The header file </para>
  <para>generator: javah.................... 1069</para>
  <para>Name mangling and </para>
  <para>function signatures.............. 1070</para>
  <para>Implementing your DLL...... 1070</para>
  <para>Accessing JNI functions:� </para>
  <para>the <emphasis role="bold">JNIEnv</emphasis> argument1071</para>
  <para>Accessing Java Strings......... 1073</para>
  <para>Passing and </para>
  <para>using Java objects........ 1073</para>
  <para>JNI and </para>
  <para>Java exceptions............ 1076</para>
  <para>JNI and threading....... 1077</para>
  <para>Using a preexisting </para>
  <para>code base...................... 1077</para>
  <para>Additional </para>
  <para>information................... 1078</para>
  <para>C: Java Programming Guidelines������������������������������������� 1079</para>
  <para>Design........................... 1079</para>
  <para>Implementation........... 1086</para>
  <para>D: Resources���������������� 1093</para>
  <para>Software........................ 1093</para>
  <para>Books............................ 1093</para>
  <para>Analysis &amp; design................. 1095</para>
  <para>Python.................................... 1097</para>
  <para>My own list of books............ 1098</para>
  <para>Index������������������������������ 1101</para>
    <section>
    <title><anchor xreflabel="" xml:id="_Toc481064446"/><anchor xreflabel="" xml:id="_Toc477690719"/><anchor xreflabel="" xml:id="preface"/>Preface</title>
    <para>I suggested to my brother Todd, who is making the leap from hardware into programming, that the next big revolution will be in genetic engineering.</para>
    <para>We�ll have microbes designed to make food, fuel, and plastic; they�ll clean up pollution and in general allow us to master the manipulation of the physical world for a fraction of what it costs now. I claimed that it would make the computer revolution look small in comparison. </para>
    <para>Then I realized I was making a mistake common to science fiction writers: getting lost in the technology (which is of course easy to do in science fiction). An experienced writer knows that the story is never about the things; it�s about the people. Genetics will have a very large impact on our lives, but I�m not so sure it will dwarf the computer revolution (which enables the genetic revolution)�or at least the information revolution. Information is about talking to each other: yes, cars and shoes and especially genetic cures are important, but in the end those are just trappings. What truly matters is how we relate to the world. And so much of that is about communication.</para>
    <para>This book is a case in point. A majority of folks thought I was very bold or a little crazy to put the entire thing up on the Web. �Why would anyone buy it?� they asked. If I had been of a more conservative nature I wouldn�t have done it, but I really didn�t want to write another computer book in the same old way. I didn�t know what would happen but it turned out to be the smartest thing I�ve ever done with a book.</para>
    <para>For one thing, people started sending in corrections. This has been an amazing process, because folks have looked into every nook and cranny and caught both technical and grammatical errors, and I�ve been able to eliminate bugs of all sorts that I know would have otherwise slipped through. People have been simply terrific about this, very often saying �Now, I don�t mean this in a critical way�� and then giving me a collection of errors I�m sure I never would have found. I feel like this has been a kind of group process and it has really made the book into something special.</para>
    <para>But then I started hearing �OK, fine, it�s nice you�ve put up an electronic version, but I want a printed and bound copy from a real publisher.� I tried very hard to make it easy for everyone to print it out in a nice looking format but that didn�t stem the demand for the published book. Most people don�t want to read the entire book on screen, and hauling around a sheaf of papers, no matter how nicely printed, didn�t appeal to them either. (Plus, I think it�s not so cheap in terms of laser printer toner.) It seems that the computer revolution won�t put publishers out of business, after all. However, one student suggested this may become a model for future publishing: books will be published on the Web first, and only if sufficient interest warrants it will the book be put on paper. Currently, the great majority of all books are financial failures, and perhaps this new approach could make the publishing industry more profitable.</para>
    <para>This book became an enlightening experience for me in another way. I originally approached Java as �just another programming language,� which in many senses it is. But as time passed and I studied it more deeply, I began to see that the fundamental intention of this language is different from all the other languages I have seen.</para>
    <para>Programming is about managing complexity: the complexity of the problem you want to solve, laid upon the complexity of the machine in which it is solved. Because of this complexity, most of our programming projects fail. And yet, of all the programming languages of which I am aware, none of them have gone all-out and decided that their main design goal would be to conquer the complexity of developing and maintaining programs<anchor xreflabel="[1]" xml:id="_ftnref1"/>[1]. Of course, many language design decisions were made with complexity in mind, but at some point there were always some other issues that were considered essential to be added into the mix. Inevitably, those other issues are what cause programmers to eventually �hit the wall� with that language. For example, C++ had to be backwards-compatible with C (to allow easy migration for C programmers), as well as efficient. Those are both very useful goals and account for much of the success of C++, but they also expose extra complexity that prevents some projects from being finished (certainly, you can blame programmers and management, but if a language can help by catching your mistakes, why shouldn�t it?). As another example, Visual Basic (VB) was tied to BASIC, which wasn�t really designed to be an extensible language, so all the extensions piled upon VB have produced some truly horrible and unmaintainable syntax. Perl is backwards-compatible with Awk, Sed, Grep, and other Unix tools it was meant to replace, and as a result is often accused of producing �write-only code� (that is, after a few months you can�t read it). On the other hand, C++, VB, Perl, and other languages like Smalltalk had some of their design efforts focused on the issue of complexity and as a result are remarkably successful in solving certain types of problems.</para>
    <para>What has impressed me most as I have come to understand Java is what seems like an unflinching goal of reducing complexity <emphasis role="italic">for the programmer</emphasis>. As if to say �we don�t care about anything except reducing the time and difficulty of producing robust code.� In the early days, this goal has resulted in code that doesn�t run very fast (although there have been many promises made about how quickly Java will someday run) but it has indeed produced amazing reductions in development time; half or less of the time that it takes to create an equivalent C++ program. This result alone can save incredible amounts of time and money, but Java doesn�t stop there. It goes on to wrap all the complex tasks that have become important, such as multithreading and network programming, in language features or libraries that can at times make those tasks trivial. And finally, it tackles some really big complexity problems: cross-platform programs, dynamic code changes, and even security, each of which can fit on your complexity spectrum anywhere from �impediment� to �show-stopper.� So despite the performance problems we�ve seen, the promise of Java is tremendous: it can make us significantly more productive programmers.</para>
    <para>One of the places I see the greatest impact for this is on the Web. Network programming has always been hard, and Java makes it easy (and the Java language designers are working on making it even easier). Network programming is how we talk to each other more effectively and cheaper than we ever have with telephones (email alone has revolutionized many businesses). As we talk to each other more, amazing things begin to happen, possibly more amazing even than the promise of genetic engineering.</para>
    <para>In all ways�creating the programs, working in teams to create the programs, building user interfaces so the programs can communicate with the user, running the programs on different types of machines, and easily writing programs that communicate across the Internet�Java increases the communication bandwidth <emphasis role="italic">between people</emphasis>. I think that perhaps the results of the communication revolution will not be seen from the effects of moving large quantities of bits around; we shall see the true revolution because we will all be able to talk to each other more easily: one-on-one, but also in groups and, as a planet. I&apos;ve heard it suggested that the next revolution is the formation of a kind of global mind that results from enough people and enough interconnectedness. Java may or may not be the tool that foments that revolution, but at least the possibility has made me feel like I&apos;m doing something meaningful by attempting to teach the language.</para>
    <section>
      <title><anchor xreflabel="Preface to the 2nd
edition" xml:id="_Toc481064447"/>Preface to the 2<superscript>nd</superscript> edition</title>
      <para>People have made many, many wonderful comments about the first edition of this book, which has naturally been very pleasant for me. However, every now and then someone will have complaints, and for some reason one complaint that comes up periodically is �the book is too big.� In my mind it is faint damnation indeed if �too many pages� is your only complaint. (One is reminded of the Emperor of Austria�s complaint about Mozart�s work: �Too many notes!� Not that I am in any way trying to compare myself to Mozart.) In addition, I can only assume that such a complaint comes from someone who is yet to be acquainted with the vastness of the Java language itself, and has not seen the rest of the books on the subject�for example, my favorite reference is Cay Horstmann &amp; Gary Cornell�s <emphasis role="italic">Core Java</emphasis> (Prentice-Hall), which grew so big it had to be broken into two volumes. Despite this, one of the things I have attempted to do in this edition is trim out the portions that have become obsolete, or at least nonessential. I feel comfortable doing this because the original material remains on the Web site and the CD ROM that accompanies this book, in the form of the freely-downloadable first edition of the book (at <emphasis role="italic">www.BruceEckel.com</emphasis>). If you want the old stuff, it�s still there, and this is a wonderful relief for an author. For example, you may notice that the original last chapter, �Projects,� is no longer here; two of the projects have been integrated into other chapters, and the rest were no longer appropriate. Also, the �Design Pattens� chapter became too big and has been moved into a book of its own (also downloadable at the Web site). So, by all rights the book should be thinner.</para>
      <para>But alas, it is not to be.</para>
      <para>The biggest issue is the continuing development of the Java language itself, and in particular the expanding APIs that promise to provide standard interfaces for just about everything you�d like to do (and I won�t be surprised to see the �JToaster� API eventually appear). Covering all these APIs is obviously beyond the scope of this book and is a task relegated to other authors, but some issues cannot be ignored. The biggest of these include server-side Java (primarily Servlets &amp; Java Server pages, or <emphasis role="italic">JSP</emphasis>s), which is truly an excellent solution to the World Wide Web problem, wherein we�ve discovered that the various Web browser platforms are just not consistent enough to support client-side programming. In addition, there is the whole problem of easily creating applications to interact with databases, transactions, security, and the like, which is involved with Enterprise Java Beans (EJBs). These topics are wrapped into the chapter formerly called �Network Programming� and now called �Distributed Computing,� a subject that is becoming essential to everyone. You�ll also find this chapter has been expanded to include an overview of Jini (pronounced �genie,� and it isn�t an acronym, just a name), which is a cutting-edge technology that allows us to change the way we think about interconnected applications. And of course the book has been changed to use the Swing GUI library throughout. Again, if you want the old Java 1.0/1.1 stuff you can get it from the freely-downloadable book at <emphasis role="italic">www.BruceEckel.com</emphasis> (it is also included on this edition�s new CD ROM, bound into the book; more on that a little later).</para>
      <para>Aside from additional small language features added in Java 2 and corrections made throughout the book, the other major change is in the collections chapter (9), which now focuses on the Java 2 collections used throughout the book. I�ve also improved that chapter to more deeply go into some of the important issues of collections, in particular how a hash function works (so that you can know how to properly create one). There have been other movements and changes, including a rewrite of Chapter 1, and removal of some appendices and other material that I consider no longer necessary for the printed book, but those are the bulk of them. In general, I�ve tried to go over everything, remove from the 2<superscript>nd</superscript> edition what is no longer necessary (but which still exists in the electronic first edition), include changes, and improve everything I could. As the language continues to change�albeit not quite at the same breakneck pace as before�there will no doubt be further editions of this book.</para>
      <para>For those of you who still can�t stand the size of the book, I do apologize. Believe it or not, I have worked hard to keep it small. Despite the bulk, I feel like there may be enough alternatives to satisfy you. For one thing, the book is available electronically (from the Web site, and also on the CD ROM that accompanies this book), so if you carry your laptop you can carry the book on that with no extra weight. If you�re really into slimming down, there are actually Palm Pilot versions of the book floating around. (One person told me he would read the book in bed on his Palm with the backlighting on to keep from annoying his wife. I can only hope that it helps send him to slumberland.) If you need it on paper, I know of people who print a chapter at a time and carry it in their briefcase to read on the train.</para>
      <section>
        <title><anchor xreflabel="Java 2" xml:id="_Toc481064448"/>Java 2</title>
        <para>At this writing, the release of Sun�s <emphasis role="italic">Java Development Kit </emphasis>(JDK) 1.3 is imminent, and the proposed changes for JDK 1.4 have been publicized. Although these version numbers are still in the �ones,� the standard way to refer to any version of the language that is JDK 1.2 or greater is to call it �Java 2.� This indicates the very significant changes between �old Java��which had many warts that I complained about in the first edition of this book�and this more modern and improved version of the language, which has far fewer warts and many additions and nice designs.</para>
        <para>This book is written for Java 2. I have the great luxury of getting rid of all the old stuff and writing to only the new, improved language because the old information still exists in the electronic 1<superscript>st</superscript> edition on the Web and on the CD ROM (which is where you can go if you�re stuck using a pre-Java-2 version of the language). Also, because anyone can freely download the JDK from java.sun.com, it means that by writing to Java 2 I�m not imposing a financial hardship on someone by forcing them to upgrade.</para>
        <para>There is a bit of a catch, however. JDK 1.3 has some improvements that I�d really like to use, but the version of Java that is currently being released for Linux is JDK 1.2.2. Linux (see www.Linux.org) is a very important development in conjunction with Java, because it is fast becoming the most important server platform out there�fast, reliable, robust, secure, well-maintained, and free, a true revolution in the history of computing (I don�t think we�ve ever seen all of those features in any tool before). And Java has found a very important niche in server-side programming in the form of <emphasis role="italic">Servlets</emphasis>, a technology that is a huge improvement over the traditional CGI programming (this is covered in the �Distributed Programming� chapter).</para>
        <para>So although I would like to only use the very newest features, it�s critical that everything compiles under Linux, and so when you unpack the source code and compile it under that OS (with the latest JDK) you�ll discover that everything will compile. However, you will find that I�ve put notes about features in JDK 1.3 here and there.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="The CD ROM" xml:id="_Toc481064449"/>The CD ROM</title>
      <para>Another bonus with this edition is the CD ROM that is packaged in the back of the book. I�ve resisted putting CD ROMs in the back of my books in the past because I felt the extra charge for a few Kbytes of source code on this enormous CD was not justified, preferring instead to allow people to download such things from my Web site. However, you�ll soon see that this CD ROM is different.</para>
      <para>The CD does contain the source code from the book, but it also contains the book in its entirety, in several electronic formats. My favorite of these is the HTML format, because it is fast and fully indexed�you just click on an entry in the index or table of contents and you�re immediately at that portion of the book.</para>
      <para>The bulk of the 300+ Megabytes of the CD, however, is a full multimedia course called <emphasis role="italic">Thinking in C: Foundations for C++ &amp; Java. </emphasis>I originally commissioned Chuck Allison to create this seminar-on-CD ROM as a stand-alone product, but decided to include it with the second editions of both <emphasis role="italic">Thinking in C++</emphasis> and <emphasis role="italic">Thinking in Java</emphasis> because of the consistent experience of having people come to seminars without an adequate background in C. The thinking apparently goes �I�m a smart programmer and I don�t <emphasis role="italic">want</emphasis> to learn C, but rather C++ or Java, so I�ll just skip C and go directly to C++/Java.� After arriving at the seminar, it slowly dawns on folks that the prerequisite of understanding C syntax is there for a very good reason. By including the CD ROM with the book, we can ensure that everyone attends a seminar with adequate preparation.</para>
      <para>The CD also allows the book to appeal to a wider audience. Even though Chapter 3 (Controlling program flow) does cover the fundamentals of the parts of Java that come from C, the CD is a gentler introduction, and assumes even less about the student�s programming background than does the book. It is my hope that by including the CD more people will be able to be brought into the fold of Java programming.</para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064450"/><anchor xreflabel="Introduction" xml:id="_Toc477690720"/>Introduction</title>
    <para>Like any human language, Java provides a way to express concepts. If successful, this medium of expression will be significantly easier and more flexible than the alternatives as problems grow larger and more complex.</para>
    <para>You can�t look at Java as just a collection of features�some of the features make no sense in isolation. You can use the sum of the parts only if you are thinking about <emphasis role="italic">design</emphasis>, not simply coding. And to understand Java in this way, you must understand the problems with it and with programming in general. This book discusses programming problems, why they are problems, and the approach Java has taken to solve them. Thus, the set of features I explain in each chapter are based on the way I see a particular type of problem being solved with the language. In this way I hope to move you, a little at a time, to the point where the Java mindset becomes your native tongue.</para>
    <para>Throughout, I�ll be taking the attitude that you want to build a model in your head that allows you to develop a deep understanding of the language; if you encounter a puzzle you�ll be able to feed it to your model and deduce the answer.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064451"/><anchor xreflabel="" xml:id="_Toc375545177"/><anchor xreflabel="Prerequisites" xml:id="_Toc312373769"/>Prerequisites</title>
      <para>This book assumes that you have some programming familiarity: you understand that a program is a collection of statements, the idea of a subroutine/function/macro, control statements such as �if� and looping constructs such as �while,� etc. However, you might have learned this in many places, such as programming with a macro language or working with a tool like Perl. As long as you�ve programmed to the point where you feel comfortable with the basic ideas of programming, you�ll be able to work through this book. Of course, the book will be <emphasis role="italic">easier</emphasis> for the C programmers and more so for the C++ programmers, but don�t count yourself out if you�re not experienced with those languages (but come willing to work hard; also, the multimedia CD that accompanies this book will bring you up to speed on the basic C syntax necessary to learn Java). I�ll be introducing the concepts of object-oriented programming (OOP) and Java�s basic control mechanisms, so you�ll be exposed to those, and the first exercises will involve the basic control-flow statements.</para>
      <para>Although references will often be made to C and C++ language features, these are not intended to be insider comments, but instead to help all programmers put Java in perspective with those languages, from which, after all, Java is descended. I will attempt to make these references simple and to explain anything that I think a non- C/C++ programmer would not be familiar with.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064452"/><anchor xreflabel="" xml:id="_Toc375545178"/><anchor xreflabel="Learning " xml:id="_Toc312373770"/>Learning Java</title>
      <para>At about the same time that my first book <emphasis role="italic">Using C++</emphasis> (Osborne/McGraw-Hill, 1989) came out, I began teaching that language. Teaching programming languages has become my profession; I�ve seen nodding heads, blank faces, and puzzled expressions in audiences all over the world since 1989. As I began giving in-house training with smaller groups of people, I discovered something during the exercises. Even those people who were smiling and nodding were confused about many issues. I found out, by chairing the C++ track at the Software Development Conference for a number of years (and later the Java track), that I and other speakers tended to give the typical audience too many topics too fast. So eventually, through both variety in the audience level and the way that I presented the material, I would end up losing some portion of the audience. Maybe it�s asking too much, but because I am one of those people resistant to traditional lecturing (and for most people, I believe, such resistance results from boredom), I wanted to try to keep everyone up to speed.</para>
      <para>For a time, I was creating a number of different presentations in fairly short order. Thus, I ended up learning by experiment and iteration (a technique that also works well in Java program design). Eventually I developed a course using everything I had learned from my teaching experience�one that I would be happy giving for a long time. It tackles the learning problem in discrete, easy-to-digest steps, and in a hands-on seminar (the ideal learning situation) there are exercises following each of the short lessons. I now give this course in public Java seminars, which you can find out about at <emphasis role="italic">www.BruceEckel.com</emphasis>. (The introductory seminar is also available as a CD ROM. Information is available at the same Web site.)</para>
      <para>The feedback that I get from each seminar helps me change and refocus the material until I think it works well as a teaching medium. But this book isn�t just seminar notes�I tried to pack as much information as I could within these pages, and structured it to draw you through onto the next subject. More than anything, the book is designed to serve the solitary reader who is struggling with a new programming language.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064453"/><anchor xreflabel="" xml:id="_Toc375545179"/><anchor xreflabel="Goals" xml:id="_Toc312373771"/>Goals</title>
      <para>Like my previous book <emphasis role="italic">Thinking in C++</emphasis>, this book has come to be structured around the process of teaching the language. In particular, my motivation is to create something that provides me with a way to teach the language in my own seminars. When I think of a chapter in the book, I think in terms of what makes a good lesson during a seminar. My goal is to get bite-sized pieces that can be taught in a reasonable amount of time, followed by exercises that are feasible to accomplish in a classroom situation.</para>
      <para>My goals in this book are to:</para>
      <para>1.          Present the material one simple step at a time so that you can easily digest each concept before moving on.</para>
      <para>2.          Use examples that are as simple and short as possible. This sometimes prevents me from tackling �real world� problems, but I�ve found that beginners are usually happier when they can understand every detail of an example rather than being impressed by the scope of the problem it solves. Also, there�s a severe limit to the amount of code that can be absorbed in a classroom situation. For this I will no doubt receive criticism for using �toy examples,� but I�m willing to accept that in favor of producing something pedagogically useful.</para>
      <para>3.          Carefully sequence the presentation of features so that you aren�t seeing something that you haven�t been exposed to. Of course, this isn�t always possible; in those situations, a brief introductory description is given.</para>
      <para>4.          Give you what I think is important for you to understand about the language, rather than everything I know. I believe there is an information importance hierarchy, and that there are some facts that 95 percent of programmers will never need to know and that just confuse people and adds to their perception of the complexity of the language. To take an example from C, if you memorize the operator precedence table (I never did), you can write clever code. But if you need to think about it, it will also confuse the reader/maintainer of that code. So forget about precedence, and use parentheses when things aren�t clear. </para>
      <para>5.          Keep each section focused enough so that the lecture time�and the time between exercise periods�is small. Not only does this keep the audience�s minds more active and involved during a hands-on seminar, but it gives the reader a greater sense of accomplishment.</para>
      <para>6.          Provide you with a solid foundation so that you can understand the issues well enough to move on to more difficult coursework and books.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545180"/><anchor xreflabel="" xml:id="_Toc312373772"/><anchor xreflabel="Online documentation" xml:id="_Toc481064454"/>Online documentation</title>
      <para>The Java language and libraries from Sun Microsystems (a free download) come with documentation in electronic form, readable using a Web browser, and virtually every third party implementation of Java has this or an equivalent documentation system. Almost all the books published on Java have duplicated this documentation. So you either already have it or you can download it, and unless necessary, this book will not repeat that documentation because it�s usually much faster if you find the class descriptions with your Web browser than if you look them up in a book (and the on-line documentation is probably more up-to-date). This book will provide extra descriptions of the classes only when it�s necessary to supplement the documentation so you can understand a particular example.</para>
    </section>
    <section>
      <title><anchor xreflabel="Chapters" xml:id="_Toc481064455"/>Chapters</title>
      <para>This book was designed with one thing in mind: the way people learn the Java language. Seminar audience feedback helped me understand the difficult parts that needed illumination. In the areas where I got ambitious and included too many features all at once, I came to know�through the process of presenting the material�that if you include a lot of new features, you need to explain them all, and this easily compounds the student�s confusion. As a result, I�ve taken a great deal of trouble to introduce the features as few at a time as possible.</para>
      <para>The goal, then, is for each chapter to teach a single feature, or a small group of associated features, without relying on additional features. That way you can digest each piece in the context of your current knowledge before moving on.</para>
      <para>Here is a brief description of the chapters contained in the book, which correspond to lectures and exercise periods in my hands-on seminars.</para>
      <para><anchor xreflabel="Chapter
1:����� Introduction to Objects" xml:id="OLE_LINK10"/>Chapter 1:����� Introduction to Objects</para>
      <para>This chapter is an overview of what object-oriented programming is all about, including the answer to the basic question �What�s an object?�, interface vs. implementation, abstraction and encapsulation, messages and functions, inheritance and composition, and the all-important polymorphism. You�ll also get an overview of issues of object creation such as constructors, where the objects live, where to put them once they�re created, and the magical garbage collector that cleans up the objects that are no longer needed. Other issues will be introduced, including error handling with exceptions, multithreading for responsive user interfaces, and networking and the Internet. You�ll learn what makes Java special, why it�s been so successful, and about object-oriented analysis and design. </para>
      <para>Chapter 2:����� Everything is an Object</para>
      <para>This chapter moves you to the point where you can write your first Java program, so it must give an overview of the essentials, including the concept of a <emphasis role="italic">reference</emphasis> to an object; how to create an object; an introduction to primitive types and arrays; scoping and the way objects are destroyed by the garbage collector; how everything in Java is a new data type (class) and how to create your own classes; functions, arguments, and return values; name visibility and using components from other libraries; the <emphasis role="bold">static</emphasis> keyword; and comments and embedded documentation.</para>
      <para>Chapter 3:����� Controlling Program Flow</para>
      <para>This chapter begins with all of the operators that come to Java from C and C++. In addition, you�ll discover common operator pitfalls, casting, promotion, and precedence. This is followed by the basic control-flow and selection operations that you get with virtually any programming language: choice with if-else; looping with for and while; quitting a loop with break and continue as well as Java�s labeled break and labeled continue (which account for the �missing goto� in Java); and selection using switch. Although much of this material has common threads with C and C++ code, there are some differences. In addition, all the examples will be full Java examples so you�ll get more comfortable with what Java looks like. </para>
      <para>Chapter 4:����� Initialization &amp; Cleanup</para>
      <para>This chapter begins by introducing the constructor, which guarantees proper initialization. The definition of the constructor leads into the concept of function overloading (since you might want several constructors). This is followed by a discussion of the process of cleanup, which is not always as simple as it seems. Normally, you just drop an object when you�re done with it and the garbage collector eventually comes along and releases the memory. This portion explores the garbage collector and some of its idiosyncrasies. The chapter concludes with a closer look at how things are initialized: automatic member initialization, specifying member initialization, the order of initialization, <emphasis role="bold">static</emphasis> initialization and array initialization. </para>
      <para>Chapter 5:����� Hiding the Implementation</para>
      <para>This chapter covers the way that code is packaged together, and why some parts of a library are exposed while other parts are hidden. It begins by looking at the <emphasis role="bold">package</emphasis> and <emphasis role="bold">import</emphasis> keywords, which perform file-level packaging and allow you to build libraries of classes. It then examines subject of directory paths and file names. The remainder of the chapter looks at the <emphasis role="bold">public</emphasis>, <emphasis role="bold">private,</emphasis> and <emphasis role="bold">protected</emphasis> keywords, the concept of �friendly� access, and what the different levels of access control mean when used in various contexts. </para>
      <para>Chapter 6:����� Reusing Classes </para>
      <para>The concept of inheritance is standard in virtually all OOP languages. It�s a way to take an existing class and add to its functionality (as well as change it, the subject of Chapter 7). Inheritance is often a way to reuse code by leaving the �base class� the same, and just patching things here and there to produce what you want. However, inheritance isn�t the only way to make new classes from existing ones. You can also embed an object inside your new class with <emphasis role="italic">composition</emphasis>. In this chapter you�ll learn about these two ways to reuse code in Java, and how to apply them. </para>
      <para>Chapter 7:����� Polymorphism</para>
      <para>On your own, you might take nine months to discover and understand polymorphism, a cornerstone of OOP. Through small, simple examples you�ll see how to create a family of types with inheritance and manipulate objects in that family through their common base class. Java�s polymorphism allows you to treat all objects in this family generically, which means the bulk of your code doesn�t rely on specific type information. This makes your programs extensible, so building programs and code maintenance is easier and cheaper.</para>
      <para>Chapter 8:����� Interfaces &amp; Inner Classes</para>
      <para>Java provides a third way to set up a reuse relationship, through the <emphasis role="italic">interface</emphasis>, which is a pure abstraction of the interface of an object. The <emphasis role="bold">interface </emphasis>is more than just an abstract class taken to the extreme, since it allows you to perform a variation on C++�s �multiple inheritance,� by creating a class that can be upcast to more than one base type.<anchor xreflabel="" xml:id="Intro"/></para>
      <para>At first, inner classes look like a simple code hiding mechanism: you place classes inside other classes. You�ll learn, however, that the inner class does more than that�it knows about and can communicate with the surrounding class�and that the kind of code you can write with inner classes is more elegant and clear, although it is a new concept to most and takes some time to become comfortable with design using inner classes.</para>
      <para>Chapter 9:����� Holding your Objects </para>
      <para>It�s a fairly simple program that has only a fixed quantity of objects with known lifetimes. In general, your programs will always be creating new objects at a variety of times that will be known only while the program is running. In addition, you won�t know until run-time the quantity or even the exact type of the objects you need. To solve the general programming problem, you need to create any number of objects, anytime, anywhere. This chapter explores in depth the container library that Java 2 supplies to hold objects while you�re working with them: the simple arrays and more sophisticated containers (data structures) such as <emphasis role="bold">ArrayList </emphasis>and <emphasis role="bold">HashMap</emphasis>.</para>
      <para>Chapter 10:��� Error Handling with Exceptions</para>
      <para>The basic philosophy of Java is that badly-formed code will not be run. As much as possible, the compiler catches problems, but sometimes the problems�either programmer error or a natural error condition that occurs as part of the normal execution of the program�can be detected and dealt with only at run-time. Java has <emphasis role="italic">exception handling</emphasis> to deal with any problems that arise while the program is running. This chapter examines how the keywords <emphasis role="bold">try</emphasis>, <emphasis role="bold">catch</emphasis>, <emphasis role="bold">throw</emphasis>, <emphasis role="bold">throws</emphasis>, and <emphasis role="bold">finally</emphasis> work in Java; when you should throw exceptions and what to do when you catch them. In addition, you�ll see Java�s standard exceptions, how to create your own, what happens with exceptions in constructors, and how exception handlers are located. </para>
      <para>Chapter 11:��� The Java I/O System </para>
      <para>Theoretically, you can divide any program into three parts: input, process, and output. This implies that I/O (input/output) is an important part of the equation. In this chapter you�ll learn about the different classes that Java provides for reading and writing files, blocks of memory, and the console. The distinction between �old� I/O and �new� Java I/O will be shown. In addition, this chapter examines the process of taking an object, �streaming� it (so that it can be placed on disk or sent across a network) and reconstructing it, which is handled for you with Java�s <emphasis role="italic">object serialization</emphasis>. Also, Java�s compression libraries, which are used in the Java ARchive file format (JAR), are examined.</para>
      <para><anchor xreflabel="Chapter
12:��� Run-Time Type Identification" xml:id="OLE_LINK9"/>Chapter 12:��� Run-Time Type Identification</para>
      <para>Java run-time type identification (RTTI) lets you find the exact type of an object when you have a reference to only the base type. Normally, you�ll want to intentionally ignore the exact type of an object and let Java�s dynamic binding mechanism (polymorphism) implement the correct behavior for that type. But occasionally it is very helpful to know the exact type of an object for which you have only a base reference. Often this information allows you to perform a special-case operation more efficiently. This chapter explains what RTTI is for, how to use it, and how to get rid of it when it doesn�t belong there. In addition, this chapter introduces the Java <emphasis role="italic">reflection</emphasis> mechanism.</para>
      <para>Chapter 13:��� Creating Windows and Applets</para>
      <para>Java comes with the �Swing� GUI library, which is a set of classes that handle windowing in a portable fashion. These windowed programs can either be applets or stand-alone applications. This chapter is an introduction to Swing and the creation of World Wide Web applets. The important �JavaBeans� technology is introduced. This is fundamental for the creation of Rapid-Application Development (RAD) program-building tools.</para>
      <para>Chapter 14:��� Multiple Threads </para>
      <para>Java provides a built-in facility to support multiple concurrent subtasks, called <emphasis role="italic">threads</emphasis>, running within a single program. (Unless you have multiple processors on your machine, this is only the <emphasis role="italic">appearance</emphasis> of multiple subtasks.) Although these can be used anywhere, threads are most apparent when trying to create a responsive user interface so, for example, a user isn�t prevented from pressing a button or entering data while some processing is going on. This chapter looks at the syntax and semantics of multithreading in Java. </para>
      <para>Chapter 15:��� Distributed Computing </para>
      <para>All the Java features and libraries seem to really come together when you start writing programs to work across networks. This chapter explores communication across networks and the Internet, and the classes that Java provides to make this easier. It introduces the very important concepts of <emphasis role="italic">Servlets </emphasis>and <emphasis role="italic">JSPs</emphasis> (for server-side programming), along<emphasis role="italic"> with </emphasis><emphasis role="italic">Java DataBase Connectivity</emphasis> (JDBC), and <emphasis role="italic">Remote Method Invocation</emphasis> (RMI). Finally, there�s an introduction to the new technologies of <emphasis role="italic">JINI</emphasis>, <emphasis role="italic">JavaSpaces</emphasis>, and <emphasis role="italic">Enterprise JavaBeans</emphasis> (EJBs).</para>
      <para>Appendix A:�� Passing &amp; Returning Objects</para>
      <para>Since the only way you talk to objects in Java is through references, the concepts of passing an object into a function and returning an object from a function have some interesting consequences. This appendix explains what you need to know to manage objects when you�re moving in and out of functions, and also shows the <emphasis role="bold">String</emphasis> class, which uses a different approach to the problem.</para>
      <para>Appendix B:�� The Java Native Interface (JNI)</para>
      <para>A totally portable Java program has serious drawbacks: speed and the inability to access platform-specific services. When you know the platform that you�re running on, it�s possible to dramatically speed up certain operations by making them <emphasis role="italic">native methods</emphasis>, which are functions that are written in another programming language (currently, only C/C++ is supported). This appendix gives you enough of an introduction to this feature that you should be able to create simple examples that interface with non-Java code.</para>
      <para>Appendix C:�� Java Programming Guidelines</para>
      <para>This appendix contains suggestions to help guide you while performing low-level program design and writing code.</para>
      <para>Appendix D:� Recommended Reading</para>
      <para>A list of some of the Java books I�ve found particularly useful.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064456"/><anchor xreflabel="" xml:id="_Toc375545181"/><anchor xreflabel="Exercises" xml:id="_Toc312373773"/>Exercises</title>
      <para>I�ve discovered that simple exercises are exceptionally useful to complete a student�s understanding during a seminar, so you�ll find a set at the end of each chapter.</para>
      <para>Most exercises are designed to be easy enough that they can be finished in a reasonable amount of time in a classroom situation while the instructor observes, making sure that all the students are absorbing the material. Some exercises are more advanced to prevent boredom for experienced students. The majority are designed to be solved in a short time and test and polish your knowledge. Some are more challenging, but none present major challenges. (Presumably, you�ll find those on your own�or more likely they�ll find you).</para>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from www.BruceEckel.com.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545182"/><anchor xreflabel="" xml:id="_Toc312373774"/><anchor xreflabel="" xml:id="_Ref310733137"/><anchor xreflabel="Multimedia CD
ROM" xml:id="_Toc481064457"/>Multimedia CD ROM</title>
      <para>There are two multimedia CDs associated with this book. The first is bound into the book itself: <emphasis role="italic">Thinking in C</emphasis>, described at the end of the preface, which prepares you for the book by bringing you up to speed on the necessary C syntax you need to be able to understand Java.</para>
      <para>A second<emphasis role="italic"/>Multimedia CD ROM is available, which is based on the contents of the book. This CD ROM is a separate product and contains the <emphasis role="bold">entire</emphasis> contents of the week-long �Hands-On Java� training seminar. This is more than 15 hours of lectures that I have recorded, synchronized with hundreds of slides of information. Because the seminar is based on this book, it is an ideal accompaniment.</para>
      <para>The CD ROM contains all the lectures (with the important exception of personalized attention!) from the five-day full-immersion training seminars. We believe that it sets a new standard for quality.</para>
      <para>The Hands-On Java CD ROM is available only by ordering directly from the Web site <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
    </section>
    <section>
      <title><anchor xreflabel="Source code" xml:id="_Toc481064458"/>Source code</title>
      <para>All the source code for this book is available as copyrighted freeware, distributed as a single package, by visiting the Web site <emphasis role="italic">www.BruceEckel.com</emphasis>. To make sure that you get the most current version, this is the official site for distribution of the code and the electronic version of the book. You can find mirrored versions of the electronic book and the code on other sites (some of these sites are found at <emphasis role="italic">www.BruceEckel.com</emphasis>), but you should check the official site to ensure that the mirrored version is actually the most recent edition. You may distribute the code in classroom and other educational situations.</para>
      <para>The primary goal of the copyright is to ensure that the source of the code is properly cited, and to prevent you from republishing the code in print media without permission. (As long as the source is cited, using examples from the book in most media is generally not a problem.)</para>
      <para>In each source code file you will find a reference to the following copyright notice:</para>
      <para>//:! :CopyRight.txt</para>
      <para>Copyright �2000 Bruce Eckel </para>
      <para>Source code file from the 2nd edition of the book</para>
      <para>&quot;Thinking in Java.&quot; All rights reserved EXCEPT as</para>
      <para>allowed by the following statements: </para>
      <para>You can freely use this file</para>
      <para>for your own work (personal or commercial),</para>
      <para>including modifications and distribution in</para>
      <para>executable form only. Permission is granted to use</para>
      <para>this file in classroom situations, including its</para>
      <para>use in presentation materials, as long as the book</para>
      <para>&quot;Thinking in Java&quot; is cited as the source. </para>
      <para>Except in classroom situations, you cannot copy</para>
      <para>and distribute this code; instead, the sole</para>
      <para>distribution point is http://www.BruceEckel.com </para>
      <para>(and official mirror sites) where it is</para>
      <para>freely available. You cannot remove this</para>
      <para>copyright and notice. You cannot distribute</para>
      <para>modified versions of the source code in this</para>
      <para>package. You cannot use this file in printed</para>
      <para>media without the express permission of the</para>
      <para>author. Bruce Eckel makes no representation about</para>
      <para>the suitability of this software for any purpose.</para>
      <para>It is provided &quot;as is&quot; without express or implied</para>
      <para>warranty of any kind, including any implied</para>
      <para>warranty of merchantability, fitness for a</para>
      <para>particular purpose or non-infringement. The entire</para>
      <para>risk as to the quality and performance of the</para>
      <para>software is with you. Bruce Eckel and the</para>
      <para>publisher shall not be liable for any damages</para>
      <para>suffered by you or any third party as a result of</para>
      <para>using or distributing software. In no event will</para>
      <para>Bruce Eckel or the publisher be liable for any</para>
      <para>lost revenue, profit, or data, or for direct,</para>
      <para>indirect, special, consequential, incidental, or</para>
      <para>punitive damages, however caused and regardless of</para>
      <para>the theory of liability, arising out of the use of</para>
      <para>or inability to use software, even if Bruce Eckel</para>
      <para>and the publisher have been advised of the</para>
      <para>possibility of such damages. Should the software</para>
      <para>prove defective, you assume the cost of all</para>
      <para>necessary servicing, repair, or correction. If you</para>
      <para>think you&apos;ve found an error, please submit the</para>
      <para>correction using the form you will find at</para>
      <para>www.BruceEckel.com. (Please use the same</para>
      <para>form for non-code errors found in the book.)</para>
      <para>///:~</para>
      <para> </para>
      <para>You may use the code in your projects and in the classroom (including your presentation materials) as long as the copyright notice that appears in each source file is retained.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064459"/><anchor xreflabel="" xml:id="_Toc375545183"/><anchor xreflabel="Coding standards" xml:id="_Toc312373775"/>Coding standards</title>
        <para>In the text of this book, identifiers (function, variable, and class names) are set in <emphasis role="bold">bold</emphasis>. Most keywords are also set in bold, except for those keywords that are used so much that the bolding can become tedious, such as �class.�</para>
        <para>I use a particular coding style for the examples in this book. This style follows the style that Sun itself uses in virtually all of the code you will find at its site (see <emphasis role="italic">java.sun.com/docs/codeconv/index.html</emphasis>), and seems to be supported by most Java development environments. If you�ve read my other works, you�ll also notice that Sun�s coding style coincides with mine�this pleases me, although I had nothing to do with it. The subject of formatting style is good for hours of hot debate, so I�ll just say I�m not trying to dictate correct style via my examples; I have my own motivation for using the style that I do. Because Java is a free-form programming language, you can continue to use whatever style you�re comfortable with.</para>
        <para>The programs in this book are files that are included by the word processor in the text, directly from compiled files. Thus, the code files printed in the book should all work without compiler errors. The errors that <emphasis role="italic">should</emphasis> cause compile-time error messages are commented out with the comment <emphasis role="bold">//! </emphasis>so they can be easily discovered and tested using automatic means. Errors discovered and reported to the author will appear first in the distributed source code and later in updates of the book (which will also appear on the Web site <emphasis role="italic">www.BruceEckel.com</emphasis>).</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545184"/><anchor xreflabel="" xml:id="_Toc312373778"/><anchor xreflabel="Java versions" xml:id="_Toc481064460"/>Java versions</title>
      <para>I generally rely on the Sun implementation of Java as a reference when determining whether behavior is correct.</para>
      <para>Over time, Sun has released three major versions of Java: 1.0, 1.1 and 2 (which is called version 2 even though the releases of the JDK from Sun continue to use the numbering scheme of 1.2, 1.3, 1.4, etc.). Version 2 seems to finally bring Java into the prime time, in particular where user interface tools are concerned. This book focuses on and is tested with Java 2, although I do sometimes make concessions to earlier features of Java 2 so that the code will compile under Linux (via the Linux JDK that was available at this writing).</para>
      <para>If you need to learn about earlier releases of the language that are not covered in this edition, the first edition of the book is freely downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis> and is also contained on the CD that is bound in with this book.</para>
      <para>One thing you�ll notice is that, when I do need to mention earlier versions of the language, I don�t use the sub-revision numbers. In this book I will refer to Java 1.0, Java 1.1, and Java 2 only, to guard against typographical errors produced by further sub-revisioning of these products.</para>
    </section>
    <section>
      <title><anchor xreflabel="Seminars and mentoring" xml:id="_Toc481064461"/>Seminars and mentoring</title>
      <para>My company provides five-day, hands-on, public and in-house training seminars based on the material in this book. Selected material from each chapter represents a lesson, which is followed by a monitored exercise period so each student receives personal attention. The audio lectures and slides for the introductory seminar are also captured on CD ROM to provide at least some of the experience of the seminar without the travel and expense. For more information, go to <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>My company also provides consulting, mentoring and walkthrough services to help guide your project through its development cycle�especially your company�s first Java project. </para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064462"/><anchor xreflabel="" xml:id="_Toc375545185"/><anchor xreflabel="Errors" xml:id="_Toc312373779"/>Errors</title>
      <para>No matter how many tricks a writer uses to detect errors, some always creep in and these often leap off the page for a fresh reader. </para>
      <para>There is an error submission form linked from the beginning of each chapter in the HTML version of this book (and on the CD ROM bound into the back of this book, and downloadable from <emphasis role="italic">www.BruceEckel.com</emphasis>) and also on the Web site itself, on the page for this book.<emphasis role="italic"/>If you discover anything you believe to be an error, please use this form to submit the error along with your suggested correction. If necessary, include the original source file and note any suggested modifications. Your help is appreciated.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545186"/><anchor xreflabel="" xml:id="_Toc312373780"/><anchor xreflabel="" xml:id="_Toc481064463"/><anchor xreflabel="" xml:id="Acknowledgements"/>Note on the cover design</title>
      <para>The cover of <emphasis role="italic">Thinking in Java</emphasis> is inspired by the American Arts &amp; Crafts Movement, which began near the turn of the century and reached its zenith between 1900 and 1920. It began in England as a reaction to both the machine production of the Industrial Revolution and the highly ornamental style of the Victorian era. Arts &amp; Crafts emphasized spare design, the forms of nature as seen in the art nouveau movement, hand-crafting, and the importance of the individual craftsperson, and yet it did not eschew the use of modern tools. There are many echoes with the situation we have today: the turn of the century, the evolution from the raw beginnings of the computer revolution to something more refined and meaningful to individual persons, and the emphasis on software craftsmanship rather than just manufacturing code. </para>
      <para>I see Java in this same way: as an attempt to elevate the programmer away from an operating-system mechanic and toward being a �software craftsman.�</para>
      <para>Both the author and the book/cover designer (who have been friends since childhood) find inspiration in this movement, and both own furniture, lamps, and other pieces that are either original or inspired by this period. </para>
      <para>The other theme in this cover suggests a collection box that a naturalist might use to display the insect specimens that he or she has preserved. These insects are objects, which are placed within the box objects. The box objects are themselves placed within the �cover object,� which illustrates the fundamental concept of aggregation in object-oriented programming. Of course, a programmer cannot help but make the association with �bugs,� and here the bugs have been captured and presumably killed in a specimen jar, and finally confined within a small display box, as if to imply Java�s ability to find, display, and subdue bugs (which is truly one of its most powerful attributes).</para>
    </section>
    <section>
      <title><anchor xreflabel="Acknowledgements" xml:id="_Toc481064464"/>Acknowledgements</title>
      <para>First, thanks to associates who have worked with me to give seminars, provide consulting, and develop teaching projects: Andrea Provaglio, Dave Bartlett (who also contributed significantly to Chapter 15), Bill Venners, and Larry O�Brien. I appreciate your patience as I continue to try to develop the best model for independent folks like us to work together. Thanks to Rolf Andr� Klaedtke (Switzerland); Martin Vlcek, Martin Byer, Vlada &amp; Pavel Lahoda, Martin the Bear, and Hanka (Prague); and Marco Cantu (Italy) for hosting me on my first self-organized European seminar tour.</para>
      <para>Thanks to the Doyle Street Cohousing Community for putting up with me for the two years that it took me to write the first edition of this book (and for putting up with me at all). Thanks very much to Kevin and Sonda Donovan for subletting their great place in gorgeous Crested Butte, Colorado for the summer while I worked on the first edition of the book. Also thanks to the friendly residents of Crested Butte and the Rocky Mountain Biological Laboratory who make me feel so welcome.</para>
      <para>Thanks to Claudette Moore at Moore Literary Agency for her tremendous patience and perseverance in getting me exactly what I wanted.</para>
      <para>My first two books were published with Jeff Pepper as editor at Osborne/McGraw-Hill. Jeff appeared at the right place and the right time at Prentice-Hall and has cleared the path and made all the right things happen to make this a very pleasant publishing experience. Thanks, Jeff�it means a lot to me.</para>
      <para>I�m especially indebted to Gen Kiyooka and his company Digigami, who graciously provided my Web server for the first several years of my presence on the Web. This was an invaluable learning aid.</para>
      <para>Thanks to Cay Horstmann (co-author of <emphasis role="italic">Core Java</emphasis>, Prentice-Hall, 2000<emphasis role="italic">)</emphasis>, D�Arcy Smith (Symantec), and Paul Tyma (co-author of <emphasis role="italic">Java Primer Plus</emphasis>, The Waite Group, 1996), for helping me clarify concepts in the language.</para>
      <para>Thanks to people who have spoken in my Java track at the Software Development Conference, and students in my seminars, who ask the questions I need to hear in order to make the material more clear.</para>
      <para>Special thanks to Larry and Tina O�Brien, who helped turn my seminar into the original <emphasis role="italic">Hands-On Java </emphasis>CD ROM. (You can find out more at <emphasis role="italic">www.BruceEckel.com</emphasis>.)</para>
      <para>Lots of people sent in corrections and I am indebted to them all, but particular thanks go to (for the first edition): Kevin Raulerson (found tons of great bugs), Bob Resendes (simply incredible), John Pinto, Joe Dante, Joe Sharp (all three were fabulous), David Combs (many grammar and clarification corrections), Dr. Robert Stephenson, John Cook, Franklin Chen, Zev Griner, David Karr, Leander A. Stroschein, Steve Clark, Charles A. Lee, Austin Maher, Dennis P. Roth, Roque Oliveira, Douglas Dunn, Dejan Ristic, Neil Galarneau, David B. Malkovsky, Steve Wilkinson, and a host of others. Prof. Ir. Marc Meurrens put in a great deal of effort to publicize and make the electronic version of the first edition of the book available in Europe.</para>
      <para>There have been a spate of smart technical people in my life who have become friends and have also been both influential and unusual in that they do yoga and practice other forms of spiritual enhancement, which I find quite inspirational and instructional. They are Kraig Brockschmidt, Gen Kiyooka, and Andrea Provaglio, (who helps in the understanding of Java and programming in general in Italy, and now in the United States as an associate of the MindView team).</para>
      <para>It�s not that much of a surprise to me that understanding Delphi helped me understand Java, since there are many concepts and language design decisions in common. My Delphi friends provided assistance by helping me gain insight into that marvelous programming environment. They are Marco Cantu (another Italian�perhaps being steeped in Latin gives one aptitude for programming languages?), Neil Rubenking (who used to do the yoga/vegetarian/Zen thing until he discovered computers), and of course Zack Urlocker, a long-time pal whom I�ve traveled the world with.</para>
      <para>My friend Richard Hale Shaw�s insights and support have been very helpful (and Kim�s, too). Richard and I spent many months giving seminars together and trying to work out the perfect learning experience for the attendees. Thanks also to KoAnn Vikoren, Eric Faurot, Marco Pardi, and the rest of the cast and crew at MFI. Thanks especially to Tara Arrowood, who re-inspired me about the possibilities of conferences.</para>
      <para>The book design, cover design, and cover photo were created by my friend Daniel Will-Harris, noted author and designer (<emphasis role="italic">www.Will-Harris.com</emphasis>), who used to play with rub-on letters in junior high school while he awaited the invention of computers and desktop publishing, and complained of me mumbling over my algebra problems. However, I produced the camera-ready pages myself, so the typesetting errors are mine. Microsoft<superscript>�</superscript> Word 97 for Windows was used to write the book and to create camera-ready pages in Adobe Acrobat; the book was created directly from the Acrobat PDF files. (As a tribute to the electronic age, I happened to be overseas both times the final version of the book was produced�the first edition was sent from Capetown, South Africa and the second edition was posted from Prague). The body typeface is <emphasis role="italic">Georgia </emphasis>and the headlines are in <emphasis role="italic">Verdana</emphasis>. The cover typeface is <emphasis role="italic">ITC Rennie Mackintosh.</emphasis></para>
      <para>Thanks to the vendors who created the compilers: Borland, the Blackdown group (for Linux), and of course, Sun.</para>
      <para>A special thanks to all my teachers and all my students (who are my teachers as well). The most fun writing teacher was Gabrielle Rico (author of <emphasis role="italic">Writing the Natural Way</emphasis>, Putnam, 1983). I�ll always treasure the terrific week at Esalen.</para>
      <para>The supporting cast of friends includes, but is not limited to: Andrew Binstock, Steve Sinofsky, JD Hildebrandt, Tom Keffer, Brian McElhinney, Brinkley Barr, Bill Gates at <emphasis role="italic">Midnight Engineering Magazine</emphasis>, Larry Constantine and Lucy Lockwood, Greg Perry, Dan Putterman, Christi Westphal, Gene Wang, Dave Mayer, David Intersimone, Andrea Rosenfield, Claire Sawyers, more Italians (Laura Fallai, Corrado, Ilsa, and Cristina Giustozzi), Chris and Laura Strand, the Almquists, Brad Jerbic, Marilyn Cvitanic, the Mabrys, the Haflingers, the Pollocks, Peter Vinci, the Robbins Families, the Moelter Families (and the McMillans), Michael Wilk, Dave Stoner, Laurie Adams, the Cranstons, Larry Fogg, Mike and Karen Sequeira, Gary Entsminger and Allison Brody, Kevin Donovan and Sonda Eastlack, Chester and Shannon Andersen, Joe Lordi, Dave and Brenda Bartlett, David Lee, the Rentschlers, the Sudeks, Dick, Patty, and Lee Eckel, Lynn and Todd, and their families. And of course, Mom and Dad.</para>
      <section>
        <title><anchor xreflabel="Internet contributors" xml:id="_Toc481064465"/>Internet contributors<anchor xreflabel="" xml:id="InternetContributors"/></title>
        <para>Thanks to those who helped me rewrite the examples to use the Swing library, and for other assistance: Jon Shvarts, Thomas Kirsch, Rahim Adatia, Rajesh Jain, Ravi Manthena, Banu Rajamani, Jens Brandt, Nitin Shivaram, Malcolm Davis, and everyone who expressed support. This really helped me jump-start the project.</para>
       </section>
    </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064466"/><anchor xreflabel="" xml:id="_Toc477690721"/><anchor xreflabel="1: Introduction 
to Objects" xml:id="_Toc375545187"/>1: Introduction   to Objects</title>
    <para>The genesis of the computer revolution was in a machine. The genesis of our programming languages thus tends to look like that machine.</para>
    <para>But computers are not so much machines as they are mind amplification tools (�bicycles for the mind,� as Steve Jobs is fond of saying) and a different kind of expressive medium. As a result, the tools are beginning to look less like machines and more like parts of our minds, and also like other forms of expression such as writing, painting, sculpture, animation, and filmmaking. Object-oriented programming (OOP) is part of this movement toward using the computer as an expressive medium.</para>
    <para>This chapter will introduce you to the basic concepts of OOP, including an overview of development methods. This chapter, and this book, assume that you have had experience in a procedural programming language, although not necessarily C. If you think you need more preparation in programming and the syntax of C before tackling this book, you should work through the <emphasis role="italic">Thinking in C: Foundations for C++ and Java</emphasis> training CD ROM, bound in with this book and also available at <emphasis role="italic">www.BruceEckel.com</emphasis>. </para>
    <para>This chapter is background and supplementary material. Many people do not feel comfortable wading into object-oriented programming without understanding the big picture first. Thus, there are many concepts that are introduced here to give you a solid overview of OOP. However, many other people don�t get the big picture concepts until they�ve seen some of the mechanics first; these people may become bogged down and lost without some code to get their hands on. If you�re part of this latter group and are eager to get to the specifics of the language, feel free to jump past this chapter�skipping it at this point will not prevent you from writing programs or learning the language. However, you will want to come back here eventually to fill in your knowledge so you can understand why objects are important and how to design with them.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064467"/><anchor xreflabel="" xml:id="_Toc472654682"/><anchor xreflabel="" xml:id="_Toc408018385"/><anchor xreflabel="The progress
of abstraction" xml:id="_Toc375545188"/>The progress of abstraction</title>
      <para><anchor xreflabel="" xml:id="mark"/>All programming languages provide abstractions. It can be argued that the complexity of the problems you�re able to solve is directly related to the kind and quality of abstraction. By �kind� I mean, �What is it that you are abstracting?� Assembly language is a small abstraction of the underlying machine. Many so-called �imperative� languages that followed (such as Fortran, BASIC, and C) were abstractions of assembly language. These languages are big improvements over assembly language, but their primary abstraction still requires you to think in terms of the structure of the computer rather than the structure of the problem you are trying to solve. The programmer must establish the association between the machine model (in the �solution space,� which is the place where you�re modeling that problem, such as a computer) and the model of the problem that is actually being solved (in the �problem space,� which is the place where the problem exists). The effort required to perform this mapping, and the fact that it is extrinsic to the programming language, produces programs that are difficult to write and expensive to maintain, and as a side effect created the entire �programming methods� industry.</para>
      <para>The alternative to modeling the machine is to model the problem you�re trying to solve. Early languages such as LISP and APL chose particular views of the world (�All problems are ultimately lists� or �All problems are algorithmic,� respectively). PROLOG casts all problems into chains of decisions. Languages have been created for constraint-based programming and for programming exclusively by manipulating graphical symbols. (The latter proved to be too restrictive.) Each of these approaches is a good solution to the particular class of problem they�re designed to solve, but when you step outside of that domain they become awkward. </para>
      <para>The object-oriented approach goes a step further by providing tools for the programmer to represent elements in the problem space. This representation is general enough that the programmer is not constrained to any particular type of problem. We refer to the elements in the problem space and their representations in the solution space as �objects.� (Of course, you will also need other objects that don�t have problem-space analogs.) The idea is that the program is allowed to adapt itself to the lingo of the problem by adding new types of objects, so when you read the code describing the solution, you�re reading words that also express the problem. This is a more flexible and powerful language abstraction than what we�ve had before. Thus, OOP allows you to describe the problem in terms of the problem, rather than in terms of the computer where the solution will run. There�s still a connection back to the computer, though. Each object looks quite a bit like a little computer; it has a state, and it has operations that you can ask it to perform. However, this doesn�t seem like such a bad analogy to objects in the real world�they all have characteristics and behaviors. </para>
      <para>Some language designers have decided that object-oriented programming by itself is not adequate to easily solve all programming problems, and advocate the combination of various approaches into <emphasis role="italic">multiparadigm</emphasis> programming languages.<anchor xreflabel="[2]" xml:id="_ftnref2"/>[2]</para>
      <para>Alan Kay summarized five basic characteristics of Smalltalk, the first successful object-oriented language and one of the languages upon which Java is based. These characteristics represent a pure approach to object-oriented programming:</para>
      <para><emphasis role="bold">Everything is an object.</emphasis> Think of an object as a fancy variable; it stores data, but you can �make requests� to that object, asking it to perform operations on itself. In theory, you can take any conceptual component in the problem you�re trying to solve (dogs, buildings, services, etc.) and represent it as an object in your program.</para>
      <para>7.          <emphasis role="bold">A </emphasis><emphasis role="bold">program</emphasis><emphasis role="bold"> is a bunch of objects telling each other what to do by sending messages</emphasis>. To make a request of an object, you �send a message� to that object. More concretely, you can think of a message as a request to call a function that belongs to a particular object.</para>
      <para>8.          <emphasis role="bold">Each </emphasis><emphasis role="bold">object</emphasis><emphasis role="bold"> has its own memory made up of other objects</emphasis>. Put another way, you create a new kind of object by making a package containing existing objects. Thus, you can build complexity in a program while hiding it behind the simplicity of objects.</para>
      <para>9.          <emphasis role="bold">Every </emphasis><emphasis role="bold">object</emphasis><emphasis role="bold"> has a type</emphasis>. Using the parlance, each object is an <emphasis role="italic">instance</emphasis> of a <emphasis role="italic">class</emphasis>, in which �class� is synonymous with �type.� The most important distinguishing characteristic of a class is �What messages can you send to it?�</para>
      <para>10.      <emphasis role="bold">All </emphasis><emphasis role="bold">objects</emphasis><emphasis role="bold"> of a particular type can receive the same messages</emphasis>. This is actually a loaded statement, as you will see later. Because an object of type �circle� is also an object of type �shape,� a circle is guaranteed to accept shape messages. This means you can write code that talks to shapes and automatically handle anything that fits the description of a shape. This <emphasis role="italic">substitutability</emphasis> is one of the most powerful concepts in OOP.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064468"/><anchor xreflabel="" xml:id="_Toc472654683"/><anchor xreflabel="" xml:id="_Toc408018386"/><anchor xreflabel="An object has
an interface" xml:id="_Toc375545189"/>An object has an interface</title>
      <para>Aristotle was probably the first to begin a careful study of the concept of <emphasis role="italic">type;</emphasis> he spoke of �the class of fishes and the class of birds.� The idea that all objects, while being unique, are also part of a class of objects that have characteristics and behaviors in common was used directly in the first object-oriented language, Simula-67, with its fundamental keyword <emphasis role="bold">class</emphasis> that introduces a new type into a program.</para>
      <para>Simula, as its name implies, was created for developing simulations such as the classic �bank teller problem.� In this, you have a bunch of tellers, customers, accounts, transactions, and units of money�a lot of �objects.� Objects that are identical except for their state during a program�s execution are grouped together into �classes of objects� and that�s where the keyword <emphasis role="bold">class</emphasis> came from. Creating abstract data types (classes) is a fundamental concept in object-oriented programming. Abstract data types work almost exactly like built-in types: You can create variables of a type (called <emphasis role="italic">objects </emphasis>or <emphasis role="italic">instances</emphasis> in object-oriented parlance) and manipulate those variables (called <emphasis role="italic">sending messages</emphasis> or <emphasis role="italic">requests;</emphasis> you send a message and the object figures out what to do with it). The members (elements) of each class share some commonality: every account has a balance, every teller can accept a deposit, etc. At the same time, each member has its own state, each account has a different balance, each teller has a name. Thus, the tellers, customers, accounts, transactions, etc., can each be represented with a unique entity in the computer program. This entity is the object, and each object belongs to a particular class that defines its characteristics and behaviors.</para>
      <para>So, although what we really do in object-oriented programming is create new data types, virtually all object-oriented programming languages use the �class� keyword. When you see the word �type� think �class� and vice versa<anchor xreflabel="[3]" xml:id="_ftnref3"/>[3].</para>
      <para>Since a class describes a set of objects that have identical characteristics (data elements) and behaviors (functionality), a class is really a data type because a floating point number, for example, also has a set of characteristics and behaviors. The difference is that a programmer defines a class to fit a problem rather than being forced to use an existing data type that was designed to represent a unit of storage in a machine. You extend the programming language by adding new data types specific to your needs. The programming system welcomes the new classes and gives them all the care and type-checking that it gives to built-in types.</para>
      <para>The object-oriented approach is not limited to building simulations. Whether or not you agree that any program is a simulation of the system you�re designing, the use of OOP techniques can easily reduce a large set of problems to a simple solution.</para>
      <para>Once a class is established, you can make as many objects of that class as you like, and then manipulate those objects as if they are the elements that exist in the problem you are trying to solve. Indeed, one of the challenges of object-oriented programming is to create a one-to-one mapping between the elements in the problem space and objects in the solution space.</para>
      <para>But how do you get an object to do useful work for you? There must be a way to make a request of the object so that it will do something, such as complete a transaction, draw something on the screen, or turn on a switch. And each object can satisfy only certain requests. The requests you can make of an object are defined by its <emphasis role="italic">interface,</emphasis> and the type is what determines the interface. A simple example might be a representation of a light bulb: </para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="164" contentwidth="314" fileref="./TIJ2_files/image006.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image006.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>Light lt = new Light();</para>
      <para>lt.on();</para>
      <para> </para>
      <para>The interface establishes <emphasis role="italic">what</emphasis> requests you can make for a particular object. However, there must be code somewhere to satisfy that request. This, along with the hidden data, comprises the <emphasis role="italic">implementation</emphasis>. From a procedural programming standpoint, it�s not that complicated. A type has a function associated with each possible request, and when you make a particular request to an object, that function is called. This process is usually summarized by saying that you �send a message� (make a request) to an object, and the object figures out what to do with that message (it executes code).</para>
      <para>Here, the name of the type/class is <emphasis role="bold">Light</emphasis>, the name of this particular <emphasis role="bold">Light </emphasis>object is <emphasis role="bold">lt</emphasis>,<emphasis role="bold"/>and the requests that you can make of a <emphasis role="bold">Light</emphasis> object are to turn it on, turn it off, make it brighter, or make it dimmer. You create a <emphasis role="bold">Light </emphasis>object by defining a �reference� (<emphasis role="bold">lt</emphasis>) for that object and calling <emphasis role="bold">new</emphasis> to request a new object of that type. To send a message to the object, you state the name of the object and connect it to the message request with a period (dot). From the standpoint of the user of a predefined class, that�s pretty much all there is to programming with objects.</para>
      <para>The diagram shown above follows the format of the <emphasis role="italic">Unified Modeling Language</emphasis> (UML). Each class is represented by a box, with the type name in the top portion of the box, any data members that you care to describe in the middle portion of the box, and the <emphasis role="italic">member functions</emphasis> (the functions that belong to this object, which receive any messages you send to that object) in the bottom portion of the box. Often, only the name of the class and the public member functions are shown in UML design diagrams, and so the middle portion is not shown. If you�re interested only in the class name, then the bottom portion doesn�t need to be shown, either.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064469"/><anchor xreflabel="" xml:id="_Toc472654684"/><anchor xreflabel="" xml:id="_Toc408018387"/><anchor xreflabel="The hidden
implementation" xml:id="_Toc375545190"/>The hidden implementation</title>
      <para>It is helpful to break up the playing field into <emphasis role="italic">class creators</emphasis> (those who create new data types) and <emphasis role="italic">client programmers</emphasis><anchor xreflabel="[4]" xml:id="_ftnref4"/>[4] (the class consumers who use the data types in their applications). The goal of the client programmer is to collect a toolbox full of classes to use for rapid application development. The goal of the class creator is to build a class that exposes only what�s necessary to the client programmer and keeps everything else hidden. Why? Because if it�s hidden, the client programmer can�t use it, which means that the class creator can change the hidden portion at will without worrying about the impact to anyone else. The hidden portion usually represents the tender insides of an object that could easily be corrupted by a careless or uninformed client programmer, so hiding the implementation reduces program bugs. The concept of implementation hiding cannot be overemphasized.</para>
      <para>In any relationship it�s important to have boundaries that are respected by all parties involved. When you create a library, you establish a relationship with the client<emphasis role="italic"/>programmer, who is also a programmer, but one who is putting together an application by using your library, possibly to build a bigger library.</para>
      <para>If all the members of a class are available to everyone, then the client programmer can do anything with that class and there�s no way to enforce rules. Even though you might really prefer that the client programmer not directly manipulate some of the members of your class, without access control there�s no way to prevent it. Everything�s naked to the world.</para>
      <para>So the first reason for access control is to keep client programmers� hands off portions they shouldn�t touch�parts that are necessary for the internal machinations of the data type but not part of the interface that users need in order to solve their particular problems. This is actually a service to users because they can easily see what�s important to them and what they can ignore.</para>
      <para>The second reason for access control is to allow the library designer to change the internal workings of the class without worrying about how it will affect the client programmer. For example, you might implement a particular class in a simple fashion to ease development, and then later discover that you need to rewrite it in order to make it run faster. If the interface and implementation are clearly separated and protected, you can accomplish this easily.</para>
      <para>Java uses three explicit keywords to set the boundaries in a class: <emphasis role="bold">public</emphasis>, <emphasis role="bold">private</emphasis>, and <emphasis role="bold">protected</emphasis>. Their use and meaning are quite straightforward. These <emphasis role="italic">access specifiers</emphasis>determine who can use the definitions that follow. <emphasis role="bold">public</emphasis>means the following definitions are available to everyone. The <emphasis role="bold">private</emphasis>keyword, on the other hand, means that no one can access those definitions except you, the creator of the type, inside member functions of that type. <emphasis role="bold">private</emphasis> is a brick wall between you and the client programmer. If someone tries to access a <emphasis role="bold">private</emphasis> member, they�ll get a compile-time error. <emphasis role="bold">protected</emphasis> acts like <emphasis role="bold">private</emphasis>, with the exception that an inheriting class has access to <emphasis role="bold">protected</emphasis> members, but not <emphasis role="bold">private</emphasis> members. Inheritance will be introduced shortly.</para>
      <para>Java also has a �default� access, which comes into play if you don�t use one of the aforementioned specifiers. This is sometimes called �friendly� access because classes can access the friendly members of other classes in the same package, but outside of the package those same friendly members appear to be <emphasis role="bold">private</emphasis>.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064470"/><anchor xreflabel="" xml:id="_Toc472654685"/><anchor xreflabel="" xml:id="_Toc408018388"/><anchor xreflabel="Reusing the
implementation" xml:id="_Toc375545191"/>Reusing the implementation</title>
      <para>Once a class has been created and tested, it should (ideally) represent a useful unit of code. It turns out that this reusability is not nearly so easy to achieve as many would hope; it takes experience and insight to produce a good design. But once you have such a design, it begs to be reused. Code reuse is one of the greatest advantages that object-oriented programming languages provide.</para>
      <para>The simplest way to reuse a class is to just use an object of that class directly, but you can also place an object of that class inside a new class. We call this �creating a member object.� Your new class can be made up of any number and type of other objects, in any combination that you need to achieve the functionality desired in your new class. Because you are composing a new class from existing classes, this concept is called <emphasis role="italic">composition</emphasis> (or more generally, <emphasis role="italic">aggregation</emphasis>). Composition is often referred to as a �has-a� relationship, as in �a car has an engine.�</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="69" contentwidth="284" fileref="./TIJ2_files/image007.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image007.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>(The above UML diagram indicates composition with the filled diamond, which states there is one car. I will typically use a simpler form: just a line, without the diamond, to indicate an association.<anchor xreflabel="[5]" xml:id="_ftnref5"/>[5])</para>
      <para>Composition comes with a great deal of flexibility. The member objects of your new class are usually private, making them inaccessible to the client programmers who are using the class. This allows you to change those members without disturbing existing client code. You can also change the member objects at run-time, to dynamically change the behavior of your program. Inheritance, which is described next, does not have this flexibility since the compiler must place compile-time restrictions on classes created with inheritance.</para>
      <para>Because inheritance is so important in object-oriented programming it is often highly emphasized, and the new programmer can get the idea that inheritance should be used everywhere. This can result in awkward and overly complicated designs. Instead, you should first look to composition when creating new classes, since it is simpler and more flexible. If you take this approach, your designs will be cleaner. Once you�ve had some experience, it will be reasonably obvious when you need inheritance.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064471"/><anchor xreflabel="" xml:id="_Toc472654686"/><anchor xreflabel="" xml:id="_Toc408018389"/><anchor xreflabel="Inheritance:
reusing the interface" xml:id="_Toc375545192"/>Inheritance:  reusing the interface</title>
      <para>By itself, the idea of an object is a convenient tool. It allows you to package data and functionality together by <emphasis role="italic">concept</emphasis>, so you can represent an appropriate problem-space idea rather than being forced to use the idioms of the underlying machine. These concepts are expressed as fundamental units in the programming language by using the <emphasis role="bold">class</emphasis> keyword.</para>
      <para>It seems a pity, however, to go to all the trouble to create a class and then be forced to create a brand new one that might have similar functionality. It�s nicer if we can take the existing class, clone it, and then make additions and modifications to the clone. This is effectively what you get with <emphasis role="italic">inheritance</emphasis>, with the exception that if the original class (called the <emphasis role="italic">base</emphasis> or <emphasis role="italic">super</emphasis> or <emphasis role="italic">parent</emphasis> class) is changed, the modified �clone� (called the <emphasis role="italic">derived </emphasis>or <emphasis role="italic">inherited</emphasis> or <emphasis role="italic">sub</emphasis> or <emphasis role="italic">child</emphasis><emphasis role="bold"/>class) also reflects those changes.</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="149" contentwidth="125" fileref="./TIJ2_files/image008.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image008.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>(The arrow in the above UML diagram points from the derived class to the base class. As you will see, there can be more than one derived class.)</para>
      <para>A type does more than describe the constraints on a set of objects; it also has a relationship with other types. Two types can have characteristics and behaviors in common, but one type may contain more characteristics than another and may also handle more messages (or handle them differently). Inheritance expresses this similarity between types using the concept of base types and derived types. A base type contains all of the characteristics and behaviors that are shared among the types derived from it. You create a base type to represent the core of your ideas about some objects in your system. From the base type, you derive other types to express the different ways that this core can be realized.</para>
      <para>For example, a trash-recycling machine sorts pieces of trash. The base type is �trash,� and each piece of trash has a weight, a value, and so on, and can be shredded, melted, or decomposed. From this, more specific types of trash are derived that may have additional characteristics (a bottle has a color) or behaviors (an aluminum can may be crushed, a steel can is magnetic). In addition, some behaviors may be different (the value of paper depends on its type and condition). Using inheritance, you can build a type hierarchy that expresses the problem you�re trying to solve in terms of its types.</para>
      <para>A second example is the classic �shape� example, perhaps used in a computer-aided design system or game simulation. The base type is �shape,� and each shape has a size, a color, a position, and so on. Each shape can be drawn, erased, moved, colored, etc. From this, specific types of shapes are derived (inherited): circle, square, triangle, and so on, each of which may have additional characteristics and behaviors. Certain shapes can be flipped, for example. Some behaviors may be different, such as when you want to calculate the area of a shape. The type hierarchy embodies both the similarities and differences between the shapes.</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="261" contentwidth="338" fileref="./TIJ2_files/image009.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image009.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>Casting the solution in the same terms as the problem is tremendously beneficial because you don�t need a lot of intermediate models to get from a description of the problem to a description of the solution. With objects, the type hierarchy is the primary model, so you go directly from the description of the system in the real world to the description of the system in code. Indeed, one of the difficulties people have with object-oriented design is that it�s too simple to get from the beginning to the end. A mind trained to look for complex solutions is often stumped by this simplicity at first.</para>
      <para>When you inherit from an existing type, you create a new type. This new type contains not only all the members of the existing type (although the <emphasis role="bold">private</emphasis> ones are hidden away and inaccessible), but more important, it duplicates the interface of the base class. That is, all the messages you can send to objects of the base class you can also send to objects of the derived class. Since we know the type of a class by the messages we can send to it, this means that the derived class <emphasis role="italic">is the same type as the base class</emphasis>. In the previous example, �a circle is a shape.� This type equivalence via inheritance is one of the fundamental gateways in understanding the meaning of object-oriented programming.</para>
      <para>Since both the base class and derived class have the same interface, there must be some implementation to go along with that interface. That is, there must be some code to execute when an object receives a particular message. If you simply inherit a class and don�t do anything else, the methods from the base-class interface come right along into the derived class. That means objects of the derived class have not only the same type, they also have the same behavior, which isn�t particularly interesting.</para>
      <para>You have two ways to differentiate your new derived class from the original base class. The first is quite straightforward: You simply add brand new functions to the derived class. These new functions are not part of the base class interface. This means that the base class simply didn�t do as much as you wanted it to, so you added more functions. This simple and primitive use for inheritance is, at times, the perfect solution to your problem. However, you should look closely for the possibility that your base class might also need these additional functions. This process of discovery and iteration of your design happens regularly in object-oriented programming.</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="296" contentwidth="364" fileref="./TIJ2_files/image010.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image010.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>Although inheritance may sometimes imply (especially in Java, where the keyword that indicates inheritance is <emphasis role="bold">extends</emphasis>)<emphasis role="bold"/>that you are going to add new functions to the interface, that�s not necessarily true. The second and more important way to differentiate your new class is to <emphasis role="italic">change</emphasis> the behavior of an existing base-class function. This is referred to as <emphasis role="italic">overriding</emphasis> that function.</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="296" contentwidth="350" fileref="./TIJ2_files/image011.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image011.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>To override a function, you simply create a new definition for the function in the derived class. You�re saying, �I�m using the same interface function here, but I want it to do something different for my new type.�</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064472"/><anchor xreflabel="" xml:id="_Toc472654687"/><anchor xreflabel="" xml:id="_Toc408018391"/><anchor xreflabel="Is-a vs.
is-like-a relationships" xml:id="_Toc375545194"/>Is-a vs. is-like-a relationships</title>
        <para>There�s a certain debate that can occur about inheritance: Should inheritance override <emphasis role="italic">only</emphasis> base-class functions (and not add new member functions that aren�t in the base class)? This would mean that the derived type is <emphasis role="italic">exactly</emphasis> the same type as the base class since it has exactly the same interface. As a result, you can exactly substitute an object of the derived class for an object of the base class. This can be thought of as <emphasis role="italic">pure substitution</emphasis>, and it�s often referred to as the <emphasis role="italic">substitution principle</emphasis>. In a sense, this is the ideal way to treat inheritance. We often refer to the relationship between the base class and derived classes in this case as an <emphasis role="italic">is-a</emphasis> relationship, because you can say �a circle <emphasis role="italic">is a</emphasis> shape.� A test for inheritance is to determine whether you can state the is-a relationship about the classes and have it make sense.</para>
        <para>There are times when you must add new interface elements to a derived type, thus extending the interface and creating a new type. The new type can still be substituted for the base type, but the substitution isn�t perfect because your new functions are not accessible from the base type. This can be described as an <emphasis role="italic">is-like-a</emphasis><anchor xreflabel="[6]" xml:id="_ftnref6"/>[6] relationship; the new type has the interface of the old type but it also contains other functions, so you can�t really say it�s exactly the same. For example, consider an air conditioner. Suppose your house is wired with all the controls for cooling; that is, it has an interface that allows you to control cooling. Imagine that the air conditioner breaks down and you replace it with a heat pump, which can both heat and cool. The heat pump <emphasis role="italic">is-like-an</emphasis> air conditioner, but it can do more. Because the control system of your house is designed only to control cooling, it is restricted to communication with the cooling part of the new object. The interface of the new object has been extended, and the existing system doesn�t know about anything except the original interface.</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="220" contentwidth="417" fileref="./TIJ2_files/image012.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image012.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>Of course, once you see this design it becomes clear that the base class �cooling system� is not general enough, and should be renamed to �temperature control system� so that it can also include heating�at which point the substitution principle will work. However, the diagram above is an example of what can happen in design and in the real world. </para>
        <para>When you see the substitution principle it�s easy to feel like this approach (pure substitution) is the only way to do things, and in fact it <emphasis role="italic">is</emphasis> nice if your design works out that way. But you�ll find that there are times when it�s equally clear that you must add new functions to the interface of a derived class. With inspection both cases should be reasonably obvious.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064473"/><anchor xreflabel="" xml:id="_Toc472654688"/><anchor xreflabel="" xml:id="_Toc408018392"/><anchor xreflabel="Interchangeable
objects 
with polymorphism" xml:id="_Toc375545195"/>Interchangeable objects   with polymorphism</title>
      <para>When dealing with type hierarchies, you often want to treat an object not as the specific type that it is, but instead as its base type. This allows you to write code that doesn�t depend on specific types. In the shape example, functions manipulate generic shapes without respect to whether they�re circles, squares, triangles, or some shape that hasn�t even been defined yet. All shapes can be drawn, erased, and moved, so these functions simply send a message to a shape object; they don�t worry about how the object copes with the message.</para>
      <para>Such code is unaffected by the addition of new types, and adding new types is the most common way to extend an object-oriented program to handle new situations. For example, you can derive a new subtype of shape called pentagon<emphasis role="italic"/>without modifying the functions that deal only with generic shapes. This ability to extend a program easily by deriving new subtypes is important because it greatly improves designs while reducing the cost of software maintenance.</para>
      <para>There�s a problem, however, with attempting to treat derived-type objects as their generic base types (circles as shapes, bicycles as vehicles, cormorants as birds, etc.). If a function is going to tell a generic shape to draw itself, or a generic vehicle to steer, or a generic bird to move, the compiler cannot know at compile-time precisely what piece of code will be executed. That�s the whole point�when the message is sent, the programmer doesn�t <emphasis role="italic">want</emphasis> to know what piece of code will be executed; the draw function can be applied equally to a circle, a square, or a triangle, and the object will execute the proper code depending on its specific type. If you don�t have to know what piece of code will be executed, then when you add a new subtype, the code it executes can be different without requiring changes to the function call. Therefore, the compiler cannot know precisely what piece of code is executed, so what does it do? For example, in the following diagram the <emphasis role="bold">BirdController</emphasis> object just works with generic <emphasis role="bold">Bird</emphasis> objects, and does not know what exact type they are. This is convenient from <emphasis role="bold">BirdController</emphasis>�s perspective because it doesn�t have to write special code to determine the exact type of <emphasis role="bold">Bird</emphasis> it�s working with, or that <emphasis role="bold">Bird</emphasis>�s behavior. So how does it happen that, when <emphasis role="bold">move( )</emphasis> is called while ignoring the specific type of <emphasis role="bold">Bird</emphasis>, the right behavior will occur (a <emphasis role="bold">Goose </emphasis>runs, flies, or swims, and a <emphasis role="bold">Penguin</emphasis> runs or swims)?</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="199" contentwidth="443" fileref="./TIJ2_files/image013.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image013.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>The answer is the primary twist in object-oriented programming: the compiler cannot make a function call in the traditional sense. The function call generated by a non-OOP compiler causes what is called <emphasis role="italic">early binding</emphasis>, a term you may not have heard before because you�ve never thought about it any other way. It means the compiler generates a call to a specific function name, and the linker resolves this call to the absolute address of the code to be executed. In OOP, the program cannot determine the address of the code until run-time, so some other scheme is necessary when a message is sent to a generic object.</para>
      <para>To solve the problem, object-oriented languages use the concept of <emphasis role="italic">late binding</emphasis>. When you send a message to an object, the code being called isn�t determined until run-time. The compiler does ensure that the function exists and performs type checking on the arguments and return value (a language in which this isn�t true is called <emphasis role="italic">weakly typed</emphasis>), but it doesn�t know the exact code to execute.</para>
      <para>To perform late binding, Java uses a special bit of code in lieu of the absolute call. This code calculates the address of the function body, using information stored in the object (this process is covered in great detail in Chapter 7). Thus, each object can behave differently according to the contents of that special bit of code. When you send a message to an object, the object actually does figure out what to do with that message.</para>
      <para>In some languages (C++, in particular) you must explicitly state that you want a function to have the flexibility of late-binding properties. In these languages, by default, member functions are <emphasis role="italic">not</emphasis> dynamically bound. This caused problems, so in Java dynamic binding is the default and you don�t need to remember to add any extra keywords in order to get polymorphism.</para>
      <para>Consider the shape example. The family of classes (all based on the same uniform interface) was diagrammed earlier in this chapter. To demonstrate polymorphism, we want to write a single piece of code that ignores the specific details of type and talks only to the base class. That code is <emphasis role="italic">decoupled</emphasis> from type-specific information, and thus is simpler to write and easier to understand. And, if a new type�a <emphasis role="bold">Hexagon</emphasis>, for example�is added through inheritance, the code you write will work just as well for the new type of <emphasis role="bold">Shape</emphasis> as it did on the existing types. Thus, the program is <emphasis role="italic">extensible</emphasis>.</para>
      <para>If you write a method in Java (as you will soon learn how to do):</para>
      <para>void doStuff(Shape s) {</para>
      <para>� s.erase();</para>
      <para>� // ...</para>
      <para>� s.draw();</para>
      <para>}</para>
      <para> </para>
      <para>This function speaks to any <emphasis role="bold">Shape</emphasis>, so it is independent of the specific type of object that it�s drawing and erasing. If in some other part of the program we use the <emphasis role="bold">doStuff( )</emphasis> function:</para>
      <para>Circle c = new Circle();</para>
      <para>Triangle t = new Triangle();</para>
      <para>Line l = new Line();</para>
      <para>doStuff(c);</para>
      <para>doStuff(t);</para>
      <para>doStuff(l);</para>
      <para> </para>
      <para>The calls to <emphasis role="bold">doStuff( ) </emphasis>automatically work correctly, regardless of the exact type of the object. </para>
      <para>This is actually a pretty amazing trick. Consider the line:</para>
      <para>doStuff(c);</para>
      <para> </para>
      <para>What�s happening here is that a <emphasis role="bold">Circle</emphasis> is being passed into a function that�s expecting a <emphasis role="bold">Shape</emphasis>. Since a <emphasis role="bold">Circle</emphasis><emphasis role="italic">is</emphasis> a <emphasis role="bold">Shape</emphasis> it can be treated as one by <emphasis role="bold">doStuff( )</emphasis>. That is, any message that <emphasis role="bold">doStuff( )</emphasis> can send to a <emphasis role="bold">Shape</emphasis>, a <emphasis role="bold">Circle</emphasis> can accept. So it is a completely safe and logical thing to do.</para>
      <para>We call this process of treating a derived type as though it were its base type <emphasis role="italic">upcasting</emphasis>. The name <emphasis role="italic">cast </emphasis>is used in the sense of casting into a mold and the <emphasis role="italic">up</emphasis> comes from the way the inheritance diagram is typically arranged, with the base type at the top and the derived classes fanning out downward. Thus, casting to a base type is moving up the inheritance diagram: �upcasting.�</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="179" contentwidth="362" fileref="./TIJ2_files/image014.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image014.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>An object-oriented program contains some upcasting somewhere, because that�s how you decouple yourself from knowing about the exact type you�re working with. Look at the code in <emphasis role="bold">doStuff( )</emphasis>:</para>
      <para>� s.erase();</para>
      <para>� // ...</para>
      <para>� s.draw();</para>
      <para> </para>
      <para>Notice that it doesn�t say �If you�re a <emphasis role="bold">Circle</emphasis>, do this, if you�re a <emphasis role="bold">Square</emphasis>, do that, etc.� If you write that kind of code, which checks for all the possible types that a <emphasis role="bold">Shape</emphasis> can actually be, it�s messy and you need to change it every time you add a new kind of <emphasis role="bold">Shape</emphasis>. Here, you just say �You�re a shape, I know you can <emphasis role="bold">erase( ) </emphasis>and <emphasis role="bold">draw( ) </emphasis>yourself, do it, and take care of the details correctly.� </para>
      <para>What�s impressive about the code in <emphasis role="bold">doStuff( )</emphasis> is that, somehow, the right thing happens. Calling <emphasis role="bold">draw( )</emphasis> for <emphasis role="bold">Circle</emphasis> causes different code to be executed than when calling <emphasis role="bold">draw( ) </emphasis>for a <emphasis role="bold">Square</emphasis> or a <emphasis role="bold">Line</emphasis>, but when the <emphasis role="bold">draw( )</emphasis> message is sent to an anonymous <emphasis role="bold">Shape</emphasis>, the correct behavior occurs based on the actual type of the <emphasis role="bold">Shape</emphasis>. This is amazing because, as mentioned earlier, when the Java compiler is compiling the code for <emphasis role="bold">doStuff( )</emphasis>, it cannot know exactly what types it is dealing with. So ordinarily, you�d expect it to end up calling the version of <emphasis role="bold">erase( )</emphasis> and <emphasis role="bold">draw( ) </emphasis>for the base class <emphasis role="bold">Shape</emphasis>, and not for the specific <emphasis role="bold">Circle</emphasis>, <emphasis role="bold">Square</emphasis>, or <emphasis role="bold">Line</emphasis>. And yet the right thing happens because of polymorphism. The compiler and run-time system handle the details; all you need to know is that it happens, and more important how to design with it. When you send a message to an object, the object will do the right thing, even when upcasting is involved.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064474"/><anchor xreflabel="" xml:id="_Toc473421287"/><anchor xreflabel="Abstract base class" xml:id="_Toc375545197"/>Abstract base classes and interfaces</title>
        <para>Often in a design, you want the base class to present <emphasis role="italic">only</emphasis> an interface for its derived classes. That is, you don�t want anyone to actually create an object of the base class, only to upcast to it so that its interface can be used. This is accomplished by making that class <emphasis role="italic">abstract </emphasis>using the <emphasis role="bold">abstract</emphasis> keyword. If anyone tries to make an object of an <emphasis role="bold">abstract</emphasis> class, the compiler prevents them. This is a tool to enforce a particular design.</para>
        <para>You can also use the <emphasis role="bold">abstract</emphasis> keyword to describe a method that hasn�t been implemented yet�as a stub indicating �here is an interface function for all types inherited from this class, but at this point I don�t have any implementation for it.� An <emphasis role="bold">abstract </emphasis>method may be created only inside an <emphasis role="bold">abstract </emphasis>class. When the class is inherited, that method must be implemented, or the inheriting class becomes <emphasis role="bold">abstract</emphasis> as well. Creating an <emphasis role="bold">abstract</emphasis> method allows you to put a method in an interface without being forced to provide a possibly meaningless body of code for that method.</para>
        <para>The <emphasis role="bold">interface</emphasis> keyword takes the concept of an <emphasis role="bold">abstract</emphasis> class one step further by preventing any function definitions at all. The <emphasis role="bold">interface</emphasis> is a very handy and commonly used tool, as it provides the perfect separation of interface and implementation. In addition, you can combine many interfaces together, if you wish, whereas inheriting from multiple regular classes or abstract classes is not possible.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc312373795"/><anchor xreflabel="" xml:id="_Toc408018408"/><anchor xreflabel="" xml:id="_Toc408018395"/><anchor xreflabel="" xml:id="_Toc375545198"/><anchor xreflabel="Object landscapes and lifetimes" xml:id="_Toc481064475"/>Object landscapes and lifetimes</title>
      <para>Technically, OOP is just about abstract data typing, inheritance, and polymorphism, but other issues can be at least as important. The remainder of this section will cover these issues.</para>
      <para>One of the most important factors is the way objects are created and destroyed. Where is the data for an object and how is the lifetime of the object controlled? There are different philosophies at work here. C++ takes the approach that control of efficiency is the most important issue, so it gives the programmer a choice. For maximum run-time speed, the storage and lifetime can be determined while the program is being written, by placing the objects on the stack (these are sometimes called <emphasis role="italic">automatic</emphasis> or <emphasis role="italic">scoped</emphasis> variables) or in the static storage area. This places a priority on the speed of storage allocation and release, and control of these can be very valuable in some situations. However, you sacrifice flexibility because you must know the exact quantity, lifetime, and type of objects while you&apos;re writing the program. If you are trying to solve a more general problem such as computer-aided design, warehouse management, or air-traffic control, this is too restrictive.</para>
      <para>The second approach is to create objects dynamically in a pool of memory called the heap. In this approach, you don&apos;t know until run-time how many objects you need, what their lifetime is, or what their exact type is. Those are determined at the spur of the moment while the program is running. If you need a new object, you simply make it on the heap at the point that you need it. Because the storage is managed dynamically, at run-time, the amount of time required to allocate storage on the heap is significantly longer than the time to create storage on the stack. (Creating storage on the stack is often a single assembly instruction to move the stack pointer down, and another to move it back up.) The dynamic approach makes the generally logical assumption that objects tend to be complicated, so the extra overhead of finding storage and releasing that storage will not have an important impact on the creation of an object. In addition, the greater flexibility is essential to solve the general programming problem.</para>
      <para>Java uses the second approach, exclusively<anchor xreflabel="[7]" xml:id="_ftnref7"/>[7]. Every time you want to create an object, you use the <emphasis role="bold">new</emphasis> keyword to build a dynamic instance of that object.</para>
      <para>There&apos;s another issue, however, and that&apos;s the lifetime of an object. With languages that allow objects to be created on the stack, the compiler determines how long the object lasts and can automatically destroy it. However, if you create it on the heap the compiler has no knowledge of its lifetime. In a language like C++, you must determine programmatically when to destroy the object, which can lead to memory leaks if you don�t do it correctly (and this is a common problem in C++ programs). Java provides a feature called a garbage collector that automatically discovers when an object is no longer in use and destroys it. A garbage collector is much more convenient because it reduces the number of issues that you must track and the code you must write. More important, the garbage collector provides a much higher level of insurance against the insidious problem of memory leaks (which has brought many a C++ project to its knees).</para>
      <para>The rest of this section looks at additional factors concerning object lifetimes and landscapes.</para>
      <section>
        <title><anchor xreflabel="Collections and iterators" xml:id="_Toc481064476"/>Collections and iterators</title>
        <para>If you don�t know how many objects you�re going to need to solve a particular problem, or how long they will last, you also don�t know how to store those objects. How can you know how much space to create for those objects? You can�t, since that information isn�t known until run-time.</para>
        <para>The solution to most problems in object-oriented design seems flippant: you create another type of object. The new type of object that solves this particular problem holds references to other objects. Of course, you can do the same thing with an array, which is available in most languages. But there�s more. This new object, generally called a <emphasis role="italic">container</emphasis> (also called a <emphasis role="italic">collection</emphasis>, but the Java library uses that term in a different sense so this book will use �container�), will expand itself whenever necessary to accommodate everything you place inside it. So you don�t need to know how many objects you�re going to hold in a container. Just create a container object and let it take care of the details.</para>
        <para>Fortunately, a good OOP language comes with a set of containers as part of the package. In C++, it�s part of the Standard C++ Library and is sometimes called the Standard Template Library (STL). Object Pascal has containers in its Visual Component Library (VCL). Smalltalk has a very complete set of containers. Java also has containers in its standard library. In some libraries, a generic container is considered good enough for all needs, and in others (Java, for example) the library has different types of containers for different needs: a vector (called an <emphasis role="bold">ArrayList </emphasis>in Java) for consistent access to all elements, and a linked list for consistent insertion at all elements, for example, so you can choose the particular type that fits your needs. Container libraries may also include sets, queues, hash tables, trees, stacks, etc.</para>
        <para>All containers have some way to put things in and get things out; there are usually functions to add elements to a container, and others to fetch those elements back out. But fetching elements can be more problematic, because a single-selection function is restrictive. What if you want to manipulate or compare a set of elements in the container instead of just one?</para>
        <para>The solution is an iterator, which is an object whose job is to select the elements within a container and present them to the user of the iterator. As a class, it also provides a level of abstraction. This abstraction can be used to separate the details of the container from the code that�s accessing that container. The container, via the iterator, is abstracted to be simply a sequence. The iterator allows you to traverse that sequence without worrying about the underlying structure�that is, whether it�s an <emphasis role="bold">ArrayList</emphasis>, a <emphasis role="bold">LinkedList</emphasis>, a <emphasis role="bold">Stack</emphasis>, or something else. This gives you the flexibility to easily change the underlying data structure without disturbing the code in your program. Java began (in version 1.0 and 1.1) with a standard iterator, called <emphasis role="bold">Enumeration</emphasis>, for all of its container classes. Java 2 has added a much more complete container library that contains an iterator called <emphasis role="bold">Iterator</emphasis> that does more than the older <emphasis role="bold">Enumeration</emphasis>.</para>
        <para>From a design standpoint, all you really want is a sequence that can be manipulated to solve your problem. If a single type of sequence satisfied all of your needs, there�d be no reason to have different kinds. There are two reasons that you need a choice of containers. First, containers provide different types of interfaces and external behavior. A stack has a different interface and behavior than that of a queue, which is different from that of a set or a list. One of these might provide a more flexible solution to your problem than the other. Second, different containers have different efficiencies for certain operations. The best example is an <emphasis role="bold">ArrayList</emphasis> and a <emphasis role="bold">LinkedList</emphasis>. Both are simple sequences that can have identical interfaces and external behaviors. But certain operations can have radically different costs. Randomly accessing elements in an <emphasis role="bold">ArrayList</emphasis> is a constant-time operation; it takes the same amount of time regardless of the element you select. However, in a <emphasis role="bold">LinkedList</emphasis> it is expensive to move through the list to randomly select an element, and it takes longer to find an element that is further down the list. On the other hand, if you want to insert an element in the middle of a sequence, it�s much cheaper in a <emphasis role="bold">LinkedList </emphasis>than in an <emphasis role="bold">ArrayList</emphasis>. These and other operations have different efficiencies depending on the underlying structure of the sequence. In the design phase, you might start with a <emphasis role="bold">LinkedList</emphasis> and, when tuning for performance, change to an <emphasis role="bold">ArrayList</emphasis>. Because of the abstraction via iterators, you can change from one to the other with minimal impact on your code.</para>
        <para>In the end, remember that a container is only a storage cabinet to put objects in. If that cabinet solves all of your needs, it doesn�t really matter how it is implemented (a basic concept with most types of objects). If you�re working in a programming environment that has built-in overhead due to other factors, then the cost difference between an <emphasis role="bold">ArrayList</emphasis> and a <emphasis role="bold">LinkedList</emphasis> might not matter. You might need only one type of sequence. You can even imagine the �perfect� container abstraction, which can automatically change its underlying implementation according to the way it is used.</para>
      </section>
      <section>
        <title><anchor xreflabel="The singly rooted hierarchy" xml:id="_Toc481064477"/>The singly rooted hierarchy</title>
        <para>One of the issues in OOP that has become especially prominent since the introduction of C++ is whether all classes should ultimately be inherited from a single base class. In Java (as with virtually all other OOP languages) the answer is �yes� and the name of this ultimate base class is simply <emphasis role="bold">Object</emphasis>. It turns out that the benefits of the singly rooted hierarchy are many.</para>
        <para>All objects in a singly rooted hierarchy have an interface in common, so they are all ultimately the same type. The alternative (provided by C++) is that you don�t know that everything is the same fundamental type. From a backward-compatibility standpoint this fits the model of C better and can be thought of as less restrictive, but when you want to do full-on object-oriented programming you must then build your own hierarchy to provide the same convenience that�s built into other OOP languages. And in any new class library you acquire, some other incompatible interface will be used. It requires effort (and possibly multiple inheritance) to work the new interface into your design. Is the extra �flexibility� of C++ worth it? If you need it�if you have a large investment in C�it�s quite valuable. If you�re starting from scratch, other alternatives such as Java can often be more productive.</para>
        <para>All objects in a singly rooted hierarchy (such as Java provides) can be guaranteed to have certain functionality. You know you can perform certain basic operations on every object in your system. A singly rooted hierarchy, along with creating all objects on the heap, greatly simplifies argument passing (one of the more complex topics in C++).</para>
        <para>A singly rooted hierarchy makes it much easier to implement a garbage collector (which is conveniently built into Java). The necessary support can be installed in the base class, and the garbage collector can thus send the appropriate messages to every object in the system. Without a singly rooted hierarchy and a system to manipulate an object via a reference, it is difficult to implement a garbage collector.</para>
        <para>Since run-time type information is guaranteed to be in all objects, you�ll never end up with an object whose type you cannot determine. This is especially important with system level operations, such as exception handling, and to allow greater flexibility in programming.</para>
      </section>
      <section>
        <title><anchor xreflabel="Collection libraries and support
for easy collection use" xml:id="_Toc481064478"/>Collection libraries and support for easy collection use</title>
        <para>Because a container is a tool that you�ll use frequently, it makes sense to have a library of containers that are built in a reusable fashion, so you can take one off the shelf and plug it into your program. Java provides such a library, which should satisfy most needs.</para>
        <section>
          <title>Downcasting vs. templates/generics</title>
          <para>To make these containers reusable, they hold the one universal type in Java that was previously mentioned: <emphasis role="bold">Object</emphasis>. The singly rooted hierarchy means that everything is an <emphasis role="bold">Object</emphasis>, so a container that holds <emphasis role="bold">Object</emphasis>s can hold anything. This makes containers easy to reuse.</para>
          <para>To use such a container, you simply add object references to it, and later ask for them back. But, since the container holds only <emphasis role="bold">Object</emphasis>s, when you add your object reference into the container it is upcast to <emphasis role="bold">Object</emphasis>, thus losing its identity. When you fetch it back, you get an <emphasis role="bold">Object</emphasis> reference, and not a reference to the type that you put in. So how do you turn it back into something that has the useful interface of the object that you put into the container?</para>
          <para>Here, the cast is used again, but this time you�re not casting up the inheritance hierarchy to a more general type, you cast down the hierarchy to a more specific type. This manner of casting is called downcasting. With upcasting, you know, for example, that a <emphasis role="bold">Circle</emphasis> is a type of <emphasis role="bold">Shape</emphasis> so it�s safe to upcast, but you don�t know that an <emphasis role="bold">Object</emphasis> is necessarily a <emphasis role="bold">Circle</emphasis> or a <emphasis role="bold">Shape</emphasis> so it�s hardly safe to downcast unless you know that�s what you�re dealing with.</para>
          <para>It�s not completely dangerous, however, because if you downcast to the wrong thing you�ll get a run-time error called an <emphasis role="italic">exception,</emphasis> which will be described shortly. When you fetch object references from a container, though, you must have some way to remember exactly what they are so you can perform a proper downcast.</para>
          <para>Downcasting and the run-time checks require extra time for the running program, and extra effort from the programmer. Wouldn�t it make sense to somehow create the container so that it knows the types that it holds, eliminating the need for the downcast and a possible mistake? The solution is parameterized types, which are classes that the compiler can automatically customize to work with particular types. For example, with a parameterized container, the compiler could customize that container so that it would accept only Shapes and fetch only Shapes.</para>
          <para>Parameterized types are an important part of C++, partly because C++ has no singly rooted hierarchy. In C++, the keyword that implements parameterized types is �template.� Java currently has no parameterized types since it is possible for it to get by�however awkwardly�using the singly rooted hierarchy. However, a current proposal for parameterized types uses a syntax that is strikingly similar to C++ templates.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="The housekeeping dilemma: who
should clean up?" xml:id="_Toc481064479"/>The housekeeping dilemma: who should clean up?</title>
        <para>Each object requires resources in order to exist, most notably memory. When an object is no longer needed it must be cleaned up so that these resources are released for reuse. In simple programming situations the question of how an object is cleaned up doesn�t seem too challenging: you create the object, use it for as long as it�s needed, and then it should be destroyed. It�s not hard, however, to encounter situations in which the situation is more complex.</para>
        <para>Suppose, for example, you are designing a system to manage air traffic for an airport. (The same model might also work for managing crates in a warehouse, or a video rental system, or a kennel for boarding pets.) At first it seems simple: make a container to hold airplanes, then create a new airplane and place it in the container for each airplane that enters the air-traffic-control zone. For cleanup, simply delete the appropriate airplane object when a plane leaves the zone.</para>
        <para>But perhaps you have some other system to record data about the planes; perhaps data that doesn�t require such immediate attention as the main controller function. Maybe it�s a record of the flight plans of all the small planes that leave the airport. So you have a second container of small planes, and whenever you create a plane object you also put it in this second container if it�s a small plane. Then some background process performs operations on the objects in this container during idle moments.</para>
        <para>Now the problem is more difficult: how can you possibly know when to destroy the objects? When you�re done with the object, some other part of the system might not be. This same problem can arise in a number of other situations, and in programming systems (such as C++) in which you must explicitly delete an object when you�re done with it this can become quite complex.</para>
        <para>With Java, the garbage collector is designed to take care of the problem of releasing the memory (although this doesn�t include other aspects of cleaning up an object). The garbage collector �knows� when an object is no longer in use, and it then automatically releases the memory for that object. This (combined with the fact that all objects are inherited from the single root class <emphasis role="bold">Object</emphasis> and that you can create objects only one way, on the heap) makes the process of programming in Java much simpler than programming in C++. You have far fewer decisions to make and hurdles to overcome.</para>
        <section>
          <title>Garbage collectors vs. efficiency and flexibility</title>
          <para>If all this is such a good idea, why didn�t they do the same thing in C++? Well of course there�s a price you pay for all this programming convenience, and that price is run-time overhead. As mentioned before, in C++ you can create objects on the stack, and in this case they�re automatically cleaned up (but you don�t have the flexibility of creating as many as you want at run-time). Creating objects on the stack is the most efficient way to allocate storage for objects and to free that storage. Creating objects on the heap can be much more expensive. Always inheriting from a base class and making all function calls polymorphic also exacts a small toll. But the garbage collector is a particular problem because you never quite know when it�s going to start up or how long it will take. This means that there�s an inconsistency in the rate of execution of a Java program, so you can�t use it in certain situations, such as when the rate of execution of a program is uniformly critical. (These are generally called real time programs, although not all real time programming problems are this stringent.)</para>
          <para>The designers of the C++ language, trying to woo C programmers (and most successfully, at that), did not want to add any features to the language that would impact the speed or the use of C++ in any situation where programmers might otherwise choose C. This goal was realized, but at the price of greater complexity when programming in C++. Java is simpler than C++, but the trade-off is in efficiency and sometimes applicability. For a significant portion of programming problems, however, Java is the superior choice.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Exception handling: dealing with
errors" xml:id="_Toc481064480"/>Exception handling: dealing with errors</title>
      <para>Ever since the beginning of programming languages, error handling has been one of the most difficult issues. Because it�s so hard to design a good error handling scheme, many languages simply ignore the issue, passing the problem on to library designers who come up with halfway measures that can work in many situations but can easily be circumvented, generally by just ignoring them. A major problem with most error handling schemes is that they rely on programmer vigilance in following an agreed-upon convention that is not enforced by the language. If the programmer is not vigilant�often the case if they are in a hurry�these schemes can easily be forgotten.</para>
      <para>Exception handling wires error handling directly into the programming language and sometimes even the operating system. An exception is an object that is �thrown� from the site of the error and can be �caught� by an appropriate exception handler designed to handle that particular type of error. It�s as if exception handling is a different, parallel path of execution that can be taken when things go wrong. And because it uses a separate execution path, it doesn�t need to interfere with your normally executing code. This makes that code simpler to write since you aren�t constantly forced to check for errors. In addition, a thrown exception is unlike an error value that�s returned from a function or a flag that�s set by a function in order to indicate an error condition�these can be ignored. An exception cannot be ignored, so it�s guaranteed to be dealt with at some point. Finally, exceptions provide a way to reliably recover from a bad situation. Instead of just exiting you are often able to set things right and restore the execution of a program, which produces much more robust programs.</para>
      <para>Java�s exception handling stands out among programming languages, because in Java, exception handling was wired in from the beginning and you�re forced to use it. If you don�t write your code to properly handle exceptions, you�ll get a compile-time error message. This guaranteed consistency makes error handling much easier.</para>
      <para>It�s worth noting that exception handling isn�t an object-oriented feature, although in object-oriented languages the exception is normally represented with an object. Exception handling existed before object-oriented languages.</para>
    </section>
    <section>
      <title><anchor xreflabel="Multithreading" xml:id="_Toc481064481"/>Multithreading</title>
      <para>A fundamental concept in computer programming is the idea of handling more than one task at a time. Many programming problems require that the program be able to stop what it�s doing, deal with some other problem, and then return to the main process. The solution has been approached in many ways. Initially, programmers with low-level knowledge of the machine wrote interrupt service routines and the suspension of the main process was initiated through a hardware interrupt. Although this worked well, it was difficult and nonportable, so it made moving a program to a new type of machine slow and expensive. </para>
      <para>Sometimes interrupts are necessary for handling time-critical tasks, but there�s a large class of problems in which you�re simply trying to partition the problem into separately running pieces so that the whole program can be more responsive. Within a program, these separately running pieces are called threads, and the general concept is called <emphasis role="italic">multithreading.</emphasis> A common example of multithreading is the user interface. By using threads, a user can press a button and get a quick response rather than being forced to wait until the program finishes its current task.</para>
      <para>Ordinarily, threads are just a way to allocate the time of a single processor. But if the operating system supports multiple processors, each thread can be assigned to a different processor and they can truly run in parallel. One of the convenient features of multithreading at the language level is that the programmer doesn�t need to worry about whether there are many processors or just one. The program is logically divided into threads and if the machine has more than one processor then the program runs faster, without any special adjustments.</para>
      <para>All this makes threading sound pretty simple. There is a catch: shared resources. If you have more than one thread running that�s expecting to access the same resource you have a problem. For example, two processes can�t simultaneously send information to a printer. To solve the problem, resources that can be shared, such as the printer, must be locked while they are being used. So a thread locks a resource, completes its task, and then releases the lock so that someone else can use the resource.</para>
      <para>Java�s threading is built into the language, which makes a complicated subject much simpler. The threading is supported on an object level, so one thread of execution is represented by one object. Java also provides limited resource locking. It can lock the memory of any object (which is, after all, one kind of shared resource) so that only one thread can use it at a time. This is accomplished with the <emphasis role="bold">synchronized</emphasis> keyword. Other types of resources must be locked explicitly by the programmer, typically by creating an object to represent the lock that all threads must check before accessing that resource.</para>
    </section>
    <section>
      <title><anchor xreflabel="Persistence" xml:id="_Toc481064482"/>Persistence</title>
      <para>When you create an object, it exists for as long as you need it, but under no circumstances does it exist when the program terminates. While this makes sense at first, there are situations in which it would be incredibly useful if an object could exist and hold its information even while the program wasn�t running. Then the next time you started the program, the object would be there and it would have the same information it had the previous time the program was running. Of course, you can get a similar effect by writing the information to a file or to a database, but in the spirit of making everything an object it would be quite convenient to be able to declare an object persistent and have all the details taken care of for you.</para>
      <para>Java provides support for �lightweight persistence,� which means that you can easily store objects on disk and later retrieve them. The reason it�s �lightweight� is that you�re still forced to make explicit calls to do the storage and retrieval. In addition, JavaSpaces (described in Chapter 15) provide for a kind of persistent storage of objects. In some future release more complete support for persistence might appear.</para>
    </section>
    <section>
      <title><anchor xreflabel="Java and the Internet" xml:id="_Toc481064483"/>Java and the Internet</title>
      <para>If Java is, in fact, yet another computer programming language, you may question why it is so important and why it is being promoted as a revolutionary step in computer programming. The answer isn�t immediately obvious if you�re coming from a traditional programming perspective. Although Java is very useful for solving traditional stand-alone programming problems, it is also important because it will solve programming problems on the World Wide Web.</para>
      <section>
        <title><anchor xreflabel="What is the Web?" xml:id="_Toc481064484"/>What is the Web?</title>
        <para>The Web can seem a bit of a mystery at first, with all this talk of �surfing,� �presence,� and �home pages.� There has even been a growing reaction against �Internet-mania,� questioning the economic value and outcome of such a sweeping movement. It�s helpful to step back and see what it really is, but to do this you must understand client/server systems, another aspect of computing that�s full of confusing issues.</para>
        <section>
          <title>Client/Server computing</title>
          <para>The primary idea of a client/server system is that you have a central repository of information�some kind of data, often in a database�that you want to distribute on demand to some set of people or machines. A key to the client/server concept is that the repository of information is centrally located so that it can be changed and so that those changes will propagate out to the information consumers. Taken together, the information repository, the software that distributes the information, and the machine(s) where the information and software reside is called the server. The software that resides on the remote machine, communicates with the server, fetches the information, processes it, and then displays it on the remote machine is called the <emphasis role="italic">client.</emphasis></para>
          <para>The basic concept of client/server computing, then, is not so complicated. The problems arise because you have a single server trying to serve many clients at once. Generally, a database management system is involved so the designer �balances� the layout of data into tables for optimal use. In addition, systems often allow a client to insert new information into a server. This means you must ensure that one client�s new data doesn�t walk over another client�s new data, or that data isn�t lost in the process of adding it to the database. (This is called transaction processing.) As client software changes, it must be built, debugged, and installed on the client machines, which turns out to be more complicated and expensive than you might think. It�s especially problematic to support multiple types of computers and operating systems. Finally, there�s the all-important performance issue: you might have hundreds of clients making requests of your server at any one time, and so any small delay is crucial. To minimize latency, programmers work hard to offload processing tasks, often to the client machine, but sometimes to other machines at the server site, using so-called <emphasis role="italic">middleware.</emphasis> (Middleware is also used to improve maintainability.)</para>
          <para>The simple idea of distributing information to people has so many layers of complexity in implementing it that the whole problem can seem hopelessly enigmatic. And yet it�s crucial: client/server computing accounts for roughly half of all programming activities. It�s responsible for everything from taking orders and credit-card transactions to the distribution of any kind of data�stock market, scientific, government, you name it. What we�ve come up with in the past is individual solutions to individual problems, inventing a new solution each time. These were hard to create and hard to use, and the user had to learn a new interface for each one. The entire client/server problem needs to be solved in a big way.</para>
        </section>
        <section>
          <title>The Web as a giant server</title>
          <para>The Web is actually one giant client/server system. It�s a bit worse than that, since you have all the servers and clients coexisting on a single network at once. You don�t need to know that, since all you care about is connecting to and interacting with one server at a time (even though you might be hopping around the world in your search for the correct server).</para>
          <para>Initially it was a simple one-way process. You made a request of a server and it handed you a file, which your machine�s browser software (i.e., the client) would interpret by formatting onto your local machine. But in short order people began wanting to do more than just deliver pages from a server. They wanted full client/server capability so that the client could feed information back to the server, for example, to do database lookups on the server, to add new information to the server, or to place an order (which required more security than the original systems offered). These are the changes we�ve been seeing in the development of the Web.</para>
          <para>The Web browser was a big step forward: the concept that one piece of information could be displayed on any type of computer without change. However, browsers were still rather primitive and rapidly bogged down by the demands placed on them. They weren�t particularly interactive, and tended to clog up both the server and the Internet because any time you needed to do something that required programming you had to send information back to the server to be processed. It could take many seconds or minutes to find out you had misspelled something in your request. Since the browser was just a viewer it couldn�t perform even the simplest computing tasks. (On the other hand, it was safe, since it couldn�t execute any programs on your local machine that might contain bugs or viruses.)</para>
          <para>To solve this problem, different approaches have been taken. To begin with, graphics standards have been enhanced to allow better animation and video within browsers. The remainder of the problem can be solved only by incorporating the ability to run programs on the client end, under the browser. This is called client-side programming.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Client-side programming" xml:id="_Toc481064485"/>Client-side programming</title>
        <para>The Web�s initial server-browser design provided for interactive content, but the interactivity was completely provided by the server. The server produced static pages for the client browser, which would simply interpret and display them. Basic HTML contains simple mechanisms for data gathering: text-entry boxes, check boxes, radio boxes, lists and drop-down lists, as well as a button that can only be programmed to reset the data on the form or �submit� the data on the form back to the server. This submission passes through the Common Gateway Interface (CGI) provided on all Web servers. The text within the submission tells CGI what to do with it. The most common action is to run a program located on the server in a directory that�s typically called �cgi-bin.� (If you watch the address window at the top of your browser when you push a button on a Web page, you can sometimes see �cgi-bin� within all the gobbledygook there.) These programs can be written in most languages. Perl is a common choice because it is designed for text manipulation and is interpreted, so it can be installed on any server regardless of processor or operating system.</para>
        <para>Many powerful Web sites today are built strictly on CGI, and you can in fact do nearly anything with it. However, Web sites built on CGI programs can rapidly become overly complicated to maintain, and there is also the problem of response time. The response of a CGI program depends on how much data must be sent, as well as the load on both the server and the Internet. (On top of this, starting a CGI program tends to be slow.) The initial designers of the Web did not foresee how rapidly this bandwidth would be exhausted for the kinds of applications people developed. For example, any sort of dynamic graphing is nearly impossible to perform with consistency because a GIF file must be created and moved from the server to the client for each version of the graph. And you�ve no doubt had direct experience with something as simple as validating the data on an input form. You press the submit button on a page; the data is shipped back to the server; the server starts a CGI program that discovers an error, formats an HTML page informing you of the error, and then sends the page back to you; you must then back up a page and try again. Not only is this slow, it�s inelegant.</para>
        <para>The solution is client-side programming. Most machines that run Web browsers are powerful engines capable of doing vast work, and with the original static HTML approach they are sitting there, just idly waiting for the server to dish up the next page. Client-side programming means that the Web browser is harnessed to do whatever work it can, and the result for the user is a much speedier and more interactive experience at your Web site.</para>
        <para>The problem with discussions of client-side programming is that they aren�t very different from discussions of programming in general. The parameters are almost the same, but the platform is different: a Web browser is like a limited operating system. In the end, you must still program, and this accounts for the dizzying array of problems and solutions produced by client-side programming. The rest of this section provides an overview of the issues and approaches in client-side programming.</para>
        <section>
          <title>Plug-ins</title>
          <para>One of the most significant steps forward in client-side programming is the development of the plug-in. This is a way for a programmer to add new functionality to the browser by downloading a piece of code that plugs itself into the appropriate spot in the browser. It tells the browser �from now on you can perform this new activity.� (You need to download the plug-in only once.) Some fast and powerful behavior is added to browsers via plug-ins, but writing a plug-in is not a trivial task, and isn�t something you�d want to do as part of the process of building a particular site. The value of the plug-in for client-side programming is that it allows an expert programmer to develop a new language and add that language to a browser without the permission of the browser manufacturer. Thus, plug-ins provide a �back door� that allows the creation of new client-side programming languages (although not all languages are implemented as plug-ins).</para>
        </section>
        <section>
          <title>Scripting languages</title>
          <para>Plug-ins resulted in an explosion of scripting languages. With a scripting language you embed the source code for your client-side program directly into the HTML page, and the plug-in that interprets that language is automatically activated while the HTML page is being displayed. Scripting languages tend to be reasonably easy to understand and, because they are simply text that is part of an HTML page, they load very quickly as part of the single server hit required to procure that page. The trade-off is that your code is exposed for everyone to see (and steal). Generally, however, you aren�t doing amazingly sophisticated things with scripting languages so this is not too much of a hardship.</para>
          <para>This points out that the scripting languages used inside Web browsers are really intended to solve specific types of problems, primarily the creation of richer and more interactive graphical user interfaces (GUIs). However, a scripting language might solve 80 percent of the problems encountered in client-side programming. Your problems might very well fit completely within that 80 percent, and since scripting languages can allow easier and faster development, you should probably consider a scripting language before looking at a more involved solution such as Java or ActiveX programming.</para>
          <para>The most commonly discussed browser scripting languages are JavaScript (which has nothing to do with Java; it�s named that way just to grab some of Java�s marketing momentum), VBScript (which looks like Visual Basic), and Tcl/Tk, which comes from the popular cross-platform GUI-building language. There are others out there, and no doubt more in development.</para>
          <para>JavaScript is probably the most commonly supported. It comes built into both Netscape Navigator and the Microsoft Internet Explorer (IE). In addition, there are probably more JavaScript books available than there are for the other browser languages, and some tools automatically create pages using JavaScript. However, if you�re already fluent in Visual Basic or Tcl/Tk, you�ll be more productive using those scripting languages rather than learning a new one. (You�ll have your hands full dealing with the Web issues already.) </para>
        </section>
        <section>
          <title>Java</title>
          <para>If a scripting language can solve 80 percent of the client-side programming problems, what about the other 20 percent�the �really hard stuff?� The most popular solution today is Java. Not only is it a powerful programming language built to be secure, cross-platform, and international, but Java is being continually extended to provide language features and libraries that elegantly handle problems that are difficult in traditional programming languages, such as multithreading, database access, network programming, and distributed computing. Java allows client-side programming via the <emphasis role="italic">applet</emphasis>.</para>
          <para>An applet is a mini-program that will run only under a Web browser. The applet is downloaded automatically as part of a Web page (just as, for example, a graphic is automatically downloaded). When the applet is activated it executes a program. This is part of its beauty�it provides you with a way to automatically distribute the client software from the server at the time the user needs the client software, and no sooner. The user gets the latest version of the client software without fail and without difficult reinstallation. Because of the way Java is designed, the programmer needs to create only a single program, and that program automatically works with all computers that have browsers with built-in Java interpreters. (This safely includes the vast majority of machines.) Since Java is a full-fledged programming language, you can do as much work as possible on the client before and after making requests of the server. For example, you won�t need to send a request form across the Internet to discover that you�ve gotten a date or some other parameter wrong, and your client computer can quickly do the work of plotting data instead of waiting for the server to make a plot and ship a graphic image back to you. Not only do you get the immediate win of speed and responsiveness, but the general network traffic and load on servers can be reduced, preventing the entire Internet from slowing down.</para>
          <para>One advantage a Java applet has over a scripted program is that it�s in compiled form, so the source code isn�t available to the client. On the other hand, a Java applet can be decompiled without too much trouble, but hiding your code is often not an important issue. Two other factors can be important. As you will see later in this book, a compiled Java applet can comprise many modules and take multiple server �hits� (accesses) to download. (In Java 1.1 and higher this is minimized by Java archives, called JAR files, that allow all the required modules to be packaged together and compressed for a single download.) A scripted program will just be integrated into the Web page as part of its text (and will generally be smaller and reduce server hits). This could be important to the responsiveness of your Web site. Another factor is the all-important learning curve. Regardless of what you�ve heard, Java is not a trivial language to learn. If you�re a Visual Basic programmer, moving to VBScript will be your fastest solution, and since it will probably solve most typical client/server problems you might be hard pressed to justify learning Java. If you�re experienced with a scripting language you will certainly benefit from looking at JavaScript or VBScript before committing to Java, since they might fit your needs handily and you�ll be more productive sooner.</para>
        </section>
        <section>
          <title>ActiveX</title>
          <para>To some degree, the competitor to Java is Microsoft�s ActiveX, although it takes a completely different approach. ActiveX was originally a Windows-only solution, although it is now being developed via an independent consortium to become cross-platform. Effectively, ActiveX says �if your program connects to its environment just so, it can be dropped into a Web page and run under a browser that supports ActiveX.� (IE directly supports ActiveX and Netscape does so using a plug-in.) Thus, ActiveX does not constrain you to a particular language. If, for example, you�re already an experienced Windows programmer using a language such as C++, Visual Basic, or Borland�s Delphi, you can create ActiveX components with almost no changes to your programming knowledge. ActiveX also provides a path for the use of legacy code in your Web pages.</para>
        </section>
        <section>
          <title>Security</title>
          <para>Automatically downloading and running programs across the Internet can sound like a virus-builder�s dream. ActiveX especially brings up the thorny issue of security in client-side programming. If you click on a Web site, you might automatically download any number of things along with the HTML page: GIF files, script code, compiled Java code, and ActiveX components. Some of these are benign; GIF files can�t do any harm, and scripting languages are generally limited in what they can do. Java was also designed to run its applets within a �sandbox� of safety, which prevents it from writing to disk or accessing memory outside the sandbox. </para>
          <para>ActiveX is at the opposite end of the spectrum. Programming with ActiveX is like programming Windows�you can do anything you want. So if you click on a page that downloads an ActiveX component, that component might cause damage to the files on your disk. Of course, programs that you load onto your computer that are not restricted to running inside a Web browser can do the same thing. Viruses downloaded from Bulletin-Board Systems (BBSs) have long been a problem, but the speed of the Internet amplifies the difficulty.</para>
          <para>The solution seems to be �digital signatures,� whereby code is verified to show who the author is. This is based on the idea that a virus works because its creator can be anonymous, so if you remove the anonymity individuals will be forced to be responsible for their actions. This seems like a good plan because it allows programs to be much more functional, and I suspect it will eliminate malicious mischief. If, however, a program has an unintentional destructive bug it will still cause problems.</para>
          <para>The Java approach is to prevent these problems from occurring, via the sandbox. The Java interpreter that lives on your local Web browser examines the applet for any untoward instructions as the applet is being loaded. In particular, the applet cannot write files to disk or erase files (one of the mainstays of viruses). Applets are generally considered to be safe, and since this is essential for reliable client/server systems, any bugs in the Java language that allow viruses are rapidly repaired. (It�s worth noting that the browser software actually enforces these security restrictions, and some browsers allow you to select different security levels to provide varying degrees of access to your system.)</para>
          <para>You might be skeptical of this rather draconian restriction against writing files to your local disk. For example, you may want to build a local database or save data for later use offline. The initial vision seemed to be that eventually everyone would get online to do anything important, but that was soon seen to be impractical (although low-cost �Internet appliances� might someday satisfy the needs of a significant segment of users). The solution is the �signed applet� that uses public-key encryption to verify that an applet does indeed come from where it claims it does. A signed applet can still trash your disk, but the theory is that since you can now hold the applet creator accountable they won�t do vicious things. Java provides a framework for digital signatures so that you will eventually be able to allow an applet to step outside the sandbox if necessary.</para>
          <para>Digital signatures have missed an important issue, which is the speed that people move around on the Internet. If you download a buggy program and it does something untoward, how long will it be before you discover the damage? It could be days or even weeks. By then, how will you track down the program that�s done it? And what good will it do you at that point?</para>
        </section>
        <section>
          <title>Internet vs. intranet</title>
          <para>The Web is the most general solution to the client/server problem, so it makes sense that you can use the same technology to solve a subset of the problem, in particular the classic client/server problem <emphasis role="italic">within</emphasis> a company. With traditional client/server approaches you have the problem of multiple types of client computers, as well as the difficulty of installing new client software, both of which are handily solved with Web browsers and client-side programming. When Web technology is used for an information network that is restricted to a particular company, it is referred to as an intranet. Intranets provide much greater security than the Internet, since you can physically control access to the servers within your company. In terms of training, it seems that once people understand the general concept of a browser it�s much easier for them to deal with differences in the way pages and applets look, so the learning curve for new kinds of systems seems to be reduced.</para>
          <para>The security problem brings us to one of the divisions that seems to be automatically forming in the world of client-side programming. If your program is running on the Internet, you don�t know what platform it will be working under, and you want to be extra careful that you don�t disseminate buggy code. You need something cross-platform and secure, like a scripting language or Java. </para>
          <para>If you�re running on an intranet, you might have a different set of constraints. It�s not uncommon that your machines could all be Intel/Windows platforms. On an intranet, you�re responsible for the quality of your own code and can repair bugs when they�re discovered. In addition, you might already have a body of legacy code that you�ve been using in a more traditional client/server approach, whereby you must physically install client programs every time you do an upgrade. The time wasted in installing upgrades is the most compelling reason to move to browsers, because upgrades are invisible and automatic. If you are involved in such an intranet, the most sensible approach to take is the shortest path that allows you to use your existing code base, rather than trying to recode your programs in a new language.</para>
          <para>When faced with this bewildering array of solutions to the client-side programming problem, the best plan of attack is a cost-benefit analysis. Consider the constraints of your problem and what would be the shortest path to your solution. Since client-side programming is still programming, it�s always a good idea to take the fastest development approach for your particular situation. This is an aggressive stance to prepare for inevitable encounters with the problems of program development.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Server-side programming" xml:id="_Toc481064486"/>Server-side programming</title>
        <para>This whole discussion has ignored the issue of server-side programming. What happens when you make a request of a server? Most of the time the request is simply �send me this file.� Your browser then interprets the file in some appropriate fashion: as an HTML page, a graphic image, a Java applet, a script program, etc. A more complicated request to a server generally involves a database transaction. A common scenario involves a request for a complex database search, which the server then formats into an HTML page and sends to you as the result. (Of course, if the client has more intelligence via Java or a scripting language, the raw data can be sent and formatted at the client end, which will be faster and less load on the server.) Or you might want to register your name in a database when you join a group or place an order, which will involve changes to that database. These database requests must be processed via some code on the server side, which is generally referred to as server-side programming. Traditionally, server-side programming has been performed using Perl and CGI scripts, but more sophisticated systems have been appearing. These include Java-based Web servers that allow you to perform all your server-side programming in Java by writing what are called servlets. Servlets and their offspring, JSPs, are two of the most compelling reasons that companies who develop Web sites are moving to Java, especially because they eliminate the problems of dealing with differently abled browsers. </para>
      </section>
      <section>
        <title><anchor xreflabel="A separate arena: applications" xml:id="_Toc481064487"/>A separate arena: applications</title>
        <para>Much of the brouhaha over Java has been over applets. Java is actually a general-purpose programming language that can solve any type of problem�at least in theory. And as pointed out previously, there might be more effective ways to solve most client/server problems. When you move out of the applet arena (and simultaneously release the restrictions, such as the one against writing to disk) you enter the world of general-purpose applications that run standalone, without a Web browser, just like any ordinary program does. Here, Java�s strength is not only in its portability, but also its programmability. As you�ll see throughout this book, Java has many features that allow you to create robust programs in a shorter period than with previous programming languages.</para>
        <para>Be aware that this is a mixed blessing. You pay for the improvements through slower execution speed (although there is significant work going on in this area�JDK 1.3, in particular, introduces the so-called �hotspot� performance improvements). Like any language, Java has built-in limitations that might make it inappropriate to solve certain types of programming problems. Java is a rapidly evolving language, however, and as each new release comes out it becomes more and more attractive for solving larger sets of problems.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064488"/><anchor xreflabel="Analysis
and design" xml:id="_Toc472654691"/>Analysis and design</title>
      <para>The object-oriented paradigm is a new and different way of thinking about programming. Many folks have trouble at first knowing how to approach an OOP project. Once you know that everything is supposed to be an object, and as you learn to think more in an object-oriented style, you can begin to create �good� designs that take advantage of all the benefits that OOP has to offer.</para>
      <para>A <emphasis role="italic">method</emphasis> (often called a <emphasis role="italic">methodology</emphasis>)<emphasis role="italic"/>is a set of processes and heuristics used to break down the complexity of a programming problem. Many OOP methods have been formulated since the dawn of object-oriented programming. This section will give you a feel for what you�re trying to accomplish when using a method.</para>
      <para>Especially in OOP, methodology is a field of many experiments, so it is important to understand what problem the method is trying to solve before you consider adopting one. This is particularly true with Java, in which the programming language is intended to reduce the complexity (compared to C) involved in expressing a program. This may in fact alleviate the need for ever-more-complex methodologies. Instead, simple methodologies may suffice in Java for a much larger class of problems than you could handle using simple methodologies with procedural languages.</para>
      <para>It�s also important to realize that the term �methodology� is often too grand and promises too much. Whatever you do now when you design and write a program is a method. It may be your own method, and you may not be conscious of doing it, but it is a process you go through as you create. If it is an effective process, it may need only a small tune-up to work with Java. If you are not satisfied with your productivity and the way your programs turn out, you may want to consider adopting a formal method, or choosing pieces from among the many formal methods.</para>
      <para>While you�re going through the development process, the most important issue is this: Don�t get lost. It�s easy to do. Most of the analysis and design methods are intended to solve the largest of problems. Remember that most projects don�t fit into that category, so you can usually have successful analysis and design with a relatively small subset of what a method recommends<anchor xreflabel="[8]" xml:id="_ftnref8"/>[8]. But some sort of process, no matter how limited, will generally get you on your way in a much better fashion than simply beginning to code.</para>
      <para>It�s also easy to get stuck, to fall into �analysis paralysis,� where you feel like you can�t move forward because you haven�t nailed down every little detail at the current stage. Remember, no matter how much analysis you do, there are some things about a system that won�t reveal themselves until design time, and more things that won�t reveal themselves until you�re coding, or not even until a program is up and running. Because of this, it�s crucial to move fairly quickly through analysis and design, and to implement a test of the proposed system.</para>
      <para>This point is worth emphasizing. Because of the history we�ve had with procedural languages, it is commendable that a team will want to proceed carefully and understand every minute detail before moving to design and implementation. Certainly, when creating a DBMS, it pays to understand a customer�s needs thoroughly. But a DBMS is in a class of problems that is very well-posed and well-understood; in many such programs, the database structure <emphasis role="italic">is</emphasis> the problem to be tackled. The class of programming problem discussed in this chapter is of the �wild-card� (my term) variety, in which the solution isn�t simply re-forming a well-known solution, but instead involves one or more �wild-card factors��elements for which there is no well-understood previous solution, and for which research is necessary<anchor xreflabel="[9]" xml:id="_ftnref9"/>[9]. Attempting to thoroughly analyze a wild-card problem before moving into design and implementation results in analysis paralysis because you don�t have enough information to solve this kind of problem during the analysis phase. Solving such a problem requires iteration through the whole cycle, and that requires risk-taking behavior (which makes sense, because you�re trying to do something new and the potential rewards are higher). It may seem like the risk is compounded by �rushing� into a preliminary implementation, but it can instead reduce the risk in a wild-card project because you�re finding out early whether a particular approach to the problem is viable. Product development is risk management.</para>
      <para>It�s often proposed that you �build one to throw away.� With OOP, you may still throw <emphasis role="italic">part</emphasis> of it away, but because code is encapsulated into classes, during the first pass you will inevitably produce some useful class designs and develop some worthwhile ideas about the system design that do not need to be thrown away. Thus, the first rapid pass at a problem not only produces critical information for the next analysis, design, and implementation pass, it also creates a code foundation.</para>
      <para>That said, if you�re looking at a methodology that contains tremendous detail and suggests many steps and documents, it�s still difficult to know when to stop. Keep in mind what you�re trying to discover:</para>
      <para>What are the objects? (How do you partition your project into its component parts?)</para>
      <para>11.      What are their interfaces? (What messages do you need to send to each object?)</para>
      <para>If you come up with nothing more than the objects and their interfaces, then you can write a program. For various reasons you might need more descriptions and documents than this, but you can�t get away with any less.</para>
      <para>The process can be undertaken in five phases, and a Phase 0 that is just the initial commitment to using some kind of structure.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064489"/><anchor xreflabel="" xml:id="_Toc472654692"/><anchor xreflabel="Phase 0: Make a plan" xml:id="_Toc408018410"/>Phase 0: Make a plan</title>
        <para>You must first decide what steps you�re going to have in your process. It sounds simple (in fact, <emphasis role="italic">all</emphasis> of this sounds simple), and yet people often don�t make this decision before they start coding. If your plan is �let�s jump in and start coding,� fine. (Sometimes that�s appropriate when you have a well-understood problem.) At least agree that this is the plan.</para>
        <para>You might also decide at this phase that some additional process structure is necessary, but not the whole nine yards. Understandably, some programmers like to work in �vacation mode,� in which no structure is imposed on the process of developing their work; �It will be done when it�s done.� This can be appealing for a while, but I�ve found that having a few milestones along the way helps to focus and galvanize your efforts around those milestones instead of being stuck with the single goal of �finish the project.� In addition, it divides the project into more bite-sized pieces and makes it seem less threatening (plus the milestones offer more opportunities for celebration).</para>
        <para>When I began to study story structure (so that I will someday write a novel) I was initially resistant to the idea of structure, feeling that I wrote best when I simply let it flow onto the page. But I later realized that when I write about computers the structure is clear enough to me that I don�t have to think about it very much. But I still structure my work, albeit only semi-consciously in my head. Even if you think that your plan is to just start coding, you still somehow go through the subsequent phases while asking and answering certain questions.</para>
        <section>
          <title><anchor xreflabel="The mission statement" xml:id="_Toc408018411"/>The mission statement</title>
          <para>Any system you build, no matter how complicated, has a fundamental purpose; the business that it�s in, the basic need that it satisfies. If you can look past the user interface, the hardware- or system-specific details, the coding algorithms and the efficiency problems, you will eventually find the core of its being�simple and straightforward. Like the so-called <emphasis role="italic">high concept</emphasis> from a Hollywood movie, you can describe it in one or two sentences. This pure description is the starting point.</para>
          <para>The high concept is quite important because it sets the tone for your project; it�s a mission statement. You won�t necessarily get it right the first time (you may be in a later phase of the project before it becomes completely clear), but keep trying until it feels right. For example, in an air-traffic control system you may start out with a high concept focused on the system that you�re building: �The tower program keeps track of the aircraft.� But consider what happens when you shrink the system to a very small airfield; perhaps there�s only a human controller, or none at all. A more useful model won�t concern the solution you�re creating as much as it describes the problem: �Aircraft arrive, unload, service and reload, then depart.�</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064490"/><anchor xreflabel="Phase
1: What are we making?" xml:id="_Toc472654693"/>Phase 1: What are we making?</title>
        <para>In the previous generation of program design (called <emphasis role="italic">procedural design</emphasis>), this is called �creating the <emphasis role="italic">requirements analysis</emphasis> and <emphasis role="italic">system specification</emphasis>.� These, of course, were places to get lost; intimidatingly named documents that could become big projects in their own right. Their intention was good, however. The requirements analysis says �Make a list of the guidelines we will use to know when the job is done and the customer is satisfied.� The system specification says �Here�s a description of <emphasis role="italic">what</emphasis> the program will do (not <emphasis role="italic">how</emphasis>) to satisfy the requirements.� The requirements analysis is really a contract between you and the customer (even if the customer works within your company, or is some other object or system). The system specification is a top-level exploration into the problem and in some sense a discovery of whether it can be done and how long it will take. Since both of these will require consensus among people (and because they will usually change over time), I think it�s best to keep them as bare as possible�ideally, to lists and basic diagrams�to save time. You might have other constraints that require you to expand them into bigger documents, but by keeping the initial document small and concise, it can be created in a few sessions of group brainstorming with a leader who dynamically creates the description. This not only solicits input from everyone, it also fosters initial buy-in and agreement by everyone on the team. Perhaps most importantly, it can kick off a project with a lot of enthusiasm.</para>
        <para>It�s necessary to stay focused on the heart of what you�re trying to accomplish in this phase: determine what the system is supposed to do. The most valuable tool for this is a collection of what are called �use cases.� Use cases identify key features in the system that will reveal some of the fundamental classes you�ll be using. These are essentially descriptive answers to questions like<anchor xreflabel="[10]" xml:id="_ftnref10"/>[10]:</para>
        <para>�Who will use this system?� </para>
        <para>�What can those actors do with the system?�� </para>
        <para>�How does <emphasis role="italic">this</emphasis> actor do <emphasis role="italic">that</emphasis> with this system?�</para>
        <para>�How else might this work if someone else were doing this, or if the same actor had a different objective?� (to reveal variations)</para>
        <para>            �What problems might happen while doing this with the system?� (to reveal exceptions)</para>
        <para>If you are designing an auto-teller, for example, the use case for a particular aspect of the functionality of the system is able to describe what the auto-teller does in every possible situation. Each of these �situations� is referred to as a <emphasis role="italic">scenario</emphasis>, and a use case can be considered a collection of scenarios. You can think of a scenario as a question that starts with: �What does the system do if�?� For example, �What does the auto-teller do if a customer has just deposited a check within the last 24 hours, and there�s not enough in the account without the check having cleared to provide a desired withdrawal?� </para>
        <para>Use case diagrams are intentionally simple to prevent you from getting bogged down in system implementation details prematurely:</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="254" contentwidth="467" fileref="./TIJ2_files/image015.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image015.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>Each stick person represents an �actor,� which is typically a human or some other kind of free agent. (These can even be other computer systems, as is the case with �ATM.�) The box represents the boundary of your system. The ellipses represent the use cases, which are descriptions of valuable work that can be performed with the system. The lines between the actors and the use cases represent the interactions.</para>
        <para>It doesn�t matter how the system is actually implemented, as long as it looks like this to the user.</para>
        <para>A use case does not need to be terribly complex, even if the underlying system is complex. It is only intended to show the system as it appears to the user. For example:</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="115" contentwidth="284" fileref="./TIJ2_files/image016.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image016.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>The use cases produce the requirements specifications by determining all the interactions that the user may have with the system. You try to discover a full set of use cases for your system, and once you�ve done that you have the core of what the system is supposed to do. The nice thing about focusing on use cases is that they always bring you back to the essentials and keep you from drifting off into issues that aren�t critical for getting the job done. That is, if you have a full set of use cases, you can describe your system and move onto the next phase. You probably won�t get it all figured out perfectly on the first try, but that�s OK. Everything will reveal itself in time, and if you demand a perfect system specification at this point you�ll get stuck.</para>
        <para>If you do get stuck, you can kick-start this phase by using a rough approximation tool: describe the system in a few paragraphs and then look for nouns and verbs. The nouns can suggest actors, context of the use case (e.g., �lobby�), or artifacts manipulated in the use case. Verbs can suggest interactions between actors and use cases, and specify steps within the use case. You�ll also discover that nouns and verbs produce objects and messages during the design phase (and note that use cases describe interactions between subsystems, so the �noun and verb� technique can be used only as a brainstorming tool as it does not generate use cases)<emphasis role="bold"/><anchor xreflabel="[11]" xml:id="_ftnref11"/>[11].</para>
        <para>The boundary between a use case and an actor can point out the existence of a user interface, but it does not define such a user interface. For a process of defining and creating user interfaces, see <emphasis role="italic">Software for Use</emphasis> by Larry Constantine and Lucy Lockwood, (Addison-Wesley Longman, 1999) or go to <emphasis role="italic">www.ForUse.com</emphasis>.</para>
        <para>Although it�s a black art, at this point some kind of basic scheduling is important. You now have an overview of what you�re building, so you�ll probably be able to get some idea of how long it will take. A lot of factors come into play here. If you estimate a long schedule then the company might decide not to build it (and thus use their resources on something more reasonable�that�s a <emphasis role="italic">good</emphasis> thing). Or a manager might have already decided how long the project should take and will try to influence your estimate. But it�s best to have an honest schedule from the beginning and deal with the tough decisions early. There have been a lot of attempts to come up with accurate scheduling techniques (much like techniques to predict the stock market), but probably the best approach is to rely on your experience and intuition. Get a gut feeling for how long it will really take, then double that and add 10 percent. Your gut feeling is probably correct; you <emphasis role="italic">can</emphasis> get something working in that time. The �doubling� will turn that into something decent, and the 10 percent will deal with the final polishing and details<anchor xreflabel="[12]" xml:id="_ftnref12"/>[12]. However you want to explain it, and regardless of the moans and manipulations that happen when you reveal such a schedule, it just seems to work out that way.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064491"/><anchor xreflabel="" xml:id="_Toc472654694"/><anchor xreflabel="Phase 2: How will we build it?" xml:id="_Toc408018412"/>Phase 2: How will we build it?</title>
        <para>In this phase you must come up with a design that describes what the classes look like and how they will interact. An excellent technique in determining classes and interactions is the <emphasis role="italic">Class-Responsibility-Collaboration</emphasis> (CRC) card. Part of the value of this tool is that it�s so low-tech: you start out with a set of blank 3 x 5 cards, and you write on them. Each card represents a single class, and on the card you write:</para>
        <para>The name of the class. It�s important that this name capture the essence of what the class does, so that it makes sense at a glance.</para>
        <para>12.      The �responsibilities� of the class: what it should do. This can typically be summarized by just stating the names of the member functions (since those names should be descriptive in a good design), but it does not preclude other notes. If you need to seed the process, look at the problem from a lazy programmer�s standpoint: What objects would you like to magically appear to solve your problem?</para>
        <para>13.      The �collaborations� of the class: what other classes does it interact with? �Interact� is an intentionally broad term; it could mean aggregation or simply that some other object exists that will perform services for an object of the class. Collaborations should also consider the audience for this class. For example, if you create a class <emphasis role="bold">Firecracker</emphasis>, who is going to observe it, a <emphasis role="bold">Chemist</emphasis> or a <emphasis role="bold">Spectator</emphasis>? The former will want to know what chemicals go into the construction, and the latter will respond to the colors and shapes released when it explodes.</para>
        <para>You may feel like the cards should be bigger because of all the information you�d like to get on them, but they are intentionally small, not only to keep your classes small but also to keep you from getting into too much detail too early. If you can�t fit all you need to know about a class on a small card, the class is too complex (either you�re getting too detailed, or you should create more than one class). The ideal class should be understood at a glance. The idea of CRC cards is to assist you in coming up with a first cut of the design so that you can get the big picture and then refine your design.</para>
        <para>One of the great benefits of CRC cards is in communication. It�s best done real time, in a group, without computers. Each person takes responsibility for several classes (which at first have no names or other information). You run a live simulation by solving one scenario at a time, deciding which messages are sent to the various objects to satisfy each scenario. As you go through this process, you discover the classes that you need along with their responsibilities and collaborations, and you fill out the cards as you do this. When you�ve moved through all the use cases, you should have a fairly complete first cut of your design.</para>
        <para>Before I began using CRC cards, the most successful consulting experiences I had when coming up with an initial design involved standing in front of a team�who hadn�t built an OOP project before�and drawing objects on a whiteboard. We talked about how the objects should communicate with each other, and erased some of them and replaced them with other objects. Effectively, I was managing all the �CRC cards� on the whiteboard. The team (who knew what the project was supposed to do) actually created the design; they �owned� the design rather than having it given to them. All I was doing was guiding the process by asking the right questions, trying out the assumptions, and taking the feedback from the team to modify those assumptions. The true beauty of the process was that the team learned how to do object-oriented design not by reviewing abstract examples, but by working on the one design that was most interesting to them at that moment: theirs.</para>
        <para>Once you�ve come up with a set of CRC cards, you may want to create a more formal description of your design using UML<anchor xreflabel="[13]" xml:id="_ftnref13"/>[13]. You don�t need to use UML, but it can be helpful, especially if you want to put up a diagram on the wall for everyone to ponder, which is a good idea. An alternative to UML is a textual description of the objects and their interfaces, or, depending on your programming language, the code itself<anchor xreflabel="[14]" xml:id="_ftnref14"/>[14].</para>
        <para>UML also provides an additional diagramming notation for describing the dynamic model of your system. This is helpful in situations in which the state transitions of a system or subsystem are dominant enough that they need their own diagrams (such as in a control system). You may also need to describe the data structures, for systems or subsystems in which data is a dominant factor (such as a database).</para>
        <para>You�ll know you�re done with Phase 2 when you have described the objects and their interfaces. Well, most of them�there are usually a few that slip through the cracks and don�t make themselves known until Phase 3. But that�s OK. All you are concerned with is that you eventually discover all of your objects. It�s nice to discover them early in the process, but OOP provides enough structure so that it�s not so bad if you discover them later. In fact, the design of an object tends to happen in five stages, throughout the process of program development.</para>
        <section>
          <title><anchor xreflabel="" xml:id="_Toc408018413"/><anchor xreflabel="Five
stages of object design" xml:id="_Toc312373799"/>Five stages of object design</title>
          <para>The design life of an object is not limited to the time when you�re writing the program. Instead, the design of an object appears over a sequence of stages. It�s helpful to have this perspective because you stop expecting perfection right away; instead, you realize that the understanding of what an object does and what it should look like happens over time. This view also applies to the design of various types of programs; the pattern for a particular type of program emerges through struggling again and again with that problem (This is chronicled in the book <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis>). Objects, too, have their patterns that emerge through understanding, use, and reuse.</para>
          <para><emphasis role="bold">1. Object discovery.</emphasis>This stage occurs during the initial analysis of a program. Objects may be discovered by looking for external factors and boundaries, duplication of elements in the system, and the smallest conceptual units. Some objects are obvious if you already have a set of class libraries. Commonality between classes suggesting base classes and inheritance may appear right away, or later in the design process.</para>
          <para><emphasis role="bold">2. Object assembly.</emphasis>As you�re building an object you�ll discover the need for new members that didn�t appear during discovery. The internal needs of the object may require other classes to support it.</para>
          <para><emphasis role="bold">3. System construction.</emphasis>Once again, more requirements for an object may appear at this later stage. As you learn, you evolve your objects. The need for communication and interconnection with other objects in the system may change the needs of your classes or require new classes. For example, you may discover the need for facilitator or helper classes, such as a linked list, that contain little or no state information and simply help other classes function.</para>
          <para><emphasis role="bold">4. System extension.</emphasis>As you add new features to a system you may discover that your previous design doesn�t support easy system extension. With this new information, you can restructure parts of the system, possibly adding new classes or class hierarchies.</para>
          <para><emphasis role="bold">5. Object reuse.</emphasis>This is the real stress test for a class. If someone tries to reuse it in an entirely new situation, they�ll probably discover some shortcomings. As you change a class to adapt to more new programs, the general principles of the class will become clearer, until you have a truly reusable type. However, don�t expect most objects from a system design to be reusable�it is perfectly acceptable for the bulk of your objects to be system-specific. Reusable types tend to be less common, and they must solve more general problems in order to be reusable.</para>
        </section>
        <section>
          <title>Guidelines for object development</title>
          <para>These stages suggest some guidelines when thinking about developing your classes:</para>
          <para>Let a specific problem generate a class, then let the class grow and mature during the solution of other problems.</para>
          <para>14.      Remember, discovering the classes you need (and their interfaces) is the majority of the system design. If you already had those classes, this would be an easy project.</para>
          <para>15.      Don�t force yourself to know everything at the beginning; learn as you go. This will happen anyway.</para>
          <para>16.      Start programming; get something working so you can prove or disprove your design. Don�t fear that you�ll end up with procedural-style spaghetti code�classes partition the problem and help control anarchy and entropy. Bad classes do not break good classes.</para>
          <para>17.      Always keep it simple. Little clean objects with obvious utility are better than big complicated interfaces. When decision points come up, use an Occam�s Razor approach: Consider the choices and select the one that is simplest, because simple classes are almost always best. Start small and simple, and you can expand the class interface when you understand it better. As time goes on, it�s difficult to remove elements from a class.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064492"/><anchor xreflabel="Phase
3: Build " xml:id="_Toc472654695"/>Phase 3: Build the core</title>
        <para>This is the initial conversion from the rough design into a compiling and executing body of code that can be tested, and especially that will prove or disprove your architecture. This is not a one-pass process, but rather the beginning of a series of steps that will iteratively build the system, as you�ll see in Phase 4.</para>
        <para>Your goal is to find the core of your system architecture that needs to be implemented in order to generate a running system, no matter how incomplete that system is in this initial pass. You�re creating a framework that you can build on with further iterations. You�re also performing the first of many system integrations and tests, and giving the stakeholders feedback about what their system will look like and how it is progressing. Ideally, you are also exposing some of the critical risks. You�ll probably also discover changes and improvements that can be made to your original architecture�things you would not have learned without implementing the system.</para>
        <para>Part of building the system is the reality check that you get from testing against your requirements analysis and system specification (in whatever form they exist). Make sure that your tests verify the requirements and use cases. When the core of the system is stable, you�re ready to move on and add more functionality.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc408018414"/><anchor xreflabel="" xml:id="_Toc481064493"/><anchor xreflabel="Phase 4: Iterate the " xml:id="_Toc472654696"/>Phase 4: Iterate the use cases</title>
        <para>Once the core framework is running, each feature set you add is a small project in itself. You add a feature set during an <emphasis role="italic">iteration</emphasis>, a reasonably short period of development.</para>
        <para>How big is an iteration? Ideally, each iteration lasts one to three weeks (this can vary based on the implementation language). At the end of that period, you have an integrated, tested system with more functionality than it had before. But what�s particularly interesting is the basis for the iteration: a single use case. Each use case is a package of related functionality that you build into the system all at once, during one iteration. Not only does this give you a better idea of what the scope of a use case should be, but it also gives more validation to the idea of a use case, since the concept isn�t discarded after analysis and design, but instead it is a fundamental unit of development throughout the software-building process. </para>
        <para>You stop iterating when you achieve target functionality or an external deadline arrives and the customer can be satisfied with the current version. (Remember, software is a subscription business.) Because the process is iterative, you have many opportunities to ship a product rather than a single endpoint; open-source projects work exclusively in an iterative, high-feedback environment, which is precisely what makes them successful.</para>
        <para>An iterative development process is valuable for many reasons. You can reveal and resolve critical risks early, the customers have ample opportunity to change their minds, programmer satisfaction is higher, and the project can be steered with more precision. But an additional important benefit is the feedback to the stakeholders, who can see by the current state of the product exactly where everything lies. This may reduce or eliminate the need for mind-numbing status meetings and increase the confidence and support from the stakeholders.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064494"/><anchor xreflabel="Phase
5: " xml:id="_Toc472654697"/>Phase 5: Evolution</title>
        <para>This is the point in the development cycle that has traditionally been called �maintenance,� a catch-all term that can mean everything from �getting it to work the way it was really supposed to in the first place� to �adding features that the customer forgot to mention� to the more traditional �fixing the bugs that show up� and �adding new features as the need arises.� So many misconceptions have been applied to the term �maintenance� that it has taken on a slightly deceiving quality, partly because it suggests that you�ve actually built a pristine program and all you need to do is change parts, oil it, and keep it from rusting. Perhaps there�s a better term to describe what�s going on.</para>
        <para>I�ll use the term <emphasis role="italic">evolution</emphasis><anchor xreflabel="[15]" xml:id="_ftnref15"/>[15]. That is, �You won�t get it right the first time, so give yourself the latitude to learn and to go back and make changes.� You might need to make a lot of changes as you learn and understand the problem more deeply. The elegance you�ll produce if you evolve until you get it right will pay off, both in the short and the long term. Evolution is where your program goes from good to great, and where those issues that you didn�t really understand in the first pass become clear. It�s also where your classes can evolve from single-project usage to reusable resources.</para>
        <para>What it means to �get it right� isn�t just that the program works according to the requirements and the use cases. It also means that the internal structure of the code makes sense to you, and feels like it fits together well, with no awkward syntax, oversized objects, or ungainly exposed bits of code. In addition, you must have some sense that the program structure will survive the changes that it will inevitably go through during its lifetime, and that those changes can be made easily and cleanly. This is no small feat. You must not only understand what you�re building, but also how the program will evolve (what I call the <emphasis role="italic">vector of change</emphasis>). Fortunately, object-oriented programming languages are particularly adept at supporting this kind of continuing modification�the boundaries created by the objects are what tend to keep the structure from breaking down. They also allow you to make changes�ones that would seem drastic in a procedural program�without causing earthquakes throughout your code. In fact, support for evolution might be the most important benefit of OOP.</para>
        <para>With evolution, you create something that at least approximates what you think you�re building, and then you kick the tires, compare it to your requirements, and see where it falls short. Then you can go back and fix it by redesigning and reimplementing the portions of the program that didn�t work right<anchor xreflabel="[16]" xml:id="_ftnref16"/>[16]. You might actually need to solve the problem, or an aspect of the problem, several times before you hit on the right solution. (A study of <emphasis role="italic">Design Patterns </emphasis>is usually helpful here. You can find information in <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis>.)</para>
        <para>Evolution also occurs when you build a system, see that it matches your requirements, and then discover it wasn�t actually what you wanted. When you see the system in operation, you find that you really wanted to solve a different problem. If you think this kind of evolution is going to happen, then you owe it to yourself to build your first version as quickly as possible so you can find out if it is indeed what you want.</para>
        <para>Perhaps the most important thing to remember is that by default�by definition, really�if you modify a class, its super- and subclasses will still function. You need not fear modification (especially if you have a built-in set of unit tests to verify the correctness of your modifications). Modification won�t necessarily break the program, and any change in the outcome will be limited to subclasses and/or specific collaborators of the class you change.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064495"/><anchor xreflabel="" xml:id="_Toc472654698"/><anchor xreflabel="Plans pay off" xml:id="_Toc408018415"/>Plans pay off</title>
        <para>Of course you wouldn�t build a house without a lot of carefully drawn plans. If you build a deck or a dog house your plans won�t be so elaborate, but you�ll probably still start with some kind of sketches to guide you on your way. Software development has gone to extremes. For a long time, people didn�t have much structure in their development, but then big projects began failing. In reaction, we ended up with methodologies that had an intimidating amount of structure and detail, primarily intended for those big projects. These methodologies were too scary to use�it looked like you�d spend all your time writing documents and no time programming. (This was often the case.) I hope that what I�ve shown you here suggests a middle path�a sliding scale. Use an approach that fits your needs (and your personality). No matter how minimal you choose to make it, <emphasis role="italic">some</emphasis> kind of plan will make a big improvement in your project as opposed to no plan at all. Remember that, by most estimates, over 50 percent of projects fail (some estimates go up to 70 percent!).<anchor xreflabel="" xml:id="_Toc312373783"/></para>
        <para>By following a plan�preferably one that is simple and brief�and coming up with design structure before coding, you�ll discover that things fall together far more easily than if you dive in and start hacking. You�ll also realize a great deal of satisfaction. It�s my experience that coming up with an elegant solution is deeply satisfying at an entirely different level; it feels closer to art than technology. And elegance always pays off; it�s not a frivolous pursuit. Not only does it give you a program that�s easier to build and debug, but it�s also easier to understand and maintain, and that�s where the financial value lies.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc312373787"/><anchor xreflabel="" xml:id="_Toc481064496"/><anchor xreflabel="Extreme programming" xml:id="_Toc472654699"/>Extreme programming</title>
      <para>I have studied analysis and design techniques, on and off, since I was in graduate school. The concept of <emphasis role="italic">Extreme Programming</emphasis> (XP) is the most radical, and delightful, that I�ve seen. You can find it chronicled in <emphasis role="italic">Extreme Programming Explained</emphasis> by Kent Beck (Addison-Wesley, 2000) and on the Web at <emphasis role="italic">www.xprogramming.com</emphasis>.</para>
      <para>XP is both a philosophy about programming work and a set of guidelines to do it. Some of these guidelines are reflected in other recent methodologies, but the two most important and distinct contributions, in my opinion, are �write tests first� and �pair programming.� Although he argues strongly for the whole process, Beck points out that if you adopt only these two practices you�ll greatly improve your productivity and reliability.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064497"/><anchor xreflabel="Write
tests first" xml:id="_Toc472654700"/>Write tests first</title>
        <para>Testing has traditionally been relegated to the last part of a project, after you�ve �gotten everything working, but just to be sure.� It�s implicitly had a low priority, and people who specialize in it have not been given a lot of status and have often even been cordoned off in a basement, away from the �real programmers.� Test teams have responded in kind, going so far as to wear black clothing and cackling with glee whenever they break something (to be honest, I�ve had this feeling myself when breaking compilers).</para>
        <para>XP completely revolutionizes the concept of testing by giving it equal (or even greater) priority than the code. In fact, you write the tests <emphasis role="italic">before</emphasis> you write the code that will be tested, and the tests stay with the code forever. The tests must be executed successfully every time you do an integration of the project (which is often, sometimes more than once a day).</para>
        <para>Writing tests first has two extremely important effects.</para>
        <para>First, it forces a clear definition of the interface of a class. I�ve often suggested that people �imagine the perfect class to solve a particular problem� as a tool when trying to design the system. The XP testing strategy goes further than that�it specifies exactly what the class must look like, to the consumer of that class, and exactly how the class must behave. In no uncertain terms. You can write all the prose, or create all the diagrams you want, describing how a class should behave and what it looks like, but nothing is as real as a set of tests. The former is a wish list, but the tests are a contract that is enforced by the compiler and the running program. It�s hard to imagine a more concrete description of a class than the tests.</para>
        <para>While creating the tests, you are forced to completely think out the class and will often discover needed functionality that might be missed during the thought experiments of UML diagrams, CRC cards, use cases, etc.</para>
        <para>The second important effect of writing the tests first comes from running the tests every time you do a build of your software. This activity gives you the other half of the testing that�s performed by the compiler. If you look at the evolution of programming languages from this perspective, you�ll see that the real improvements in the technology have actually revolved around testing. Assembly language checked only for syntax, but C imposed some semantic restrictions, and these prevented you from making certain types of mistakes. OOP languages impose even more semantic restrictions, which if you think about it are actually forms of testing. �Is this data type being used properly?� and �Is this function being called properly?� are the kinds of tests that are being performed by the compiler or run-time system. We�ve seen the results of having these tests built into the language: people have been able to write more complex systems, and get them to work, with much less time and effort. I�ve puzzled over why this is, but now I realize it�s the tests: you do something wrong, and the safety net of the built-in tests tells you there�s a problem and points you to where it is.</para>
        <para>But the built-in testing afforded by the design of the language can only go so far. At some point, <emphasis role="italic">you</emphasis> must step in and add the rest of the tests that produce a full suite (in cooperation with the compiler and run-time system) that verifies all of your program. And, just like having a compiler watching over your shoulder, wouldn�t you want these tests helping you right from the beginning? That�s why you write them first, and run them automatically with every build of your system. Your tests become an extension of the safety net provided by the language.</para>
        <para>One of the things that I�ve discovered about the use of more and more powerful programming languages is that I am emboldened to try more brazen experiments, because I know that the language will keep me from wasting my time chasing bugs. The XP test scheme does the same thing for your entire project. Because you know your tests will always catch any problems that you introduce (and you regularly add any new tests as you think of them), you can make big changes when you need to without worrying that you�ll throw the whole project into complete disarray. This is incredibly powerful.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064498"/><anchor xreflabel="Pair
programming" xml:id="_Toc472654701"/>Pair programming</title>
        <para>Pair programming goes against the rugged individualism that we�ve been indoctrinated into from the beginning, through school (where we succeed or fail on our own, and working with our neighbors is considered �cheating�), and media, especially Hollywood movies in which the hero is usually fighting against mindless conformity<anchor xreflabel="[17]" xml:id="_ftnref17"/>[17]. Programmers, too, are considered paragons of individuality��cowboy coders� as Larry Constantine likes to say. And yet XP, which is itself battling against conventional thinking, says that code should be written with two people per workstation. And that this should be done in an area with a group of workstations, without the barriers that the facilities-design people are so fond of. In fact, Beck says that the first task of converting to XP is to arrive with screwdrivers and Allen wrenches and take apart everything that gets in the way.<anchor xreflabel="[18]" xml:id="_ftnref18"/>[18] (This will require a manager who can deflect the ire of the facilities department.)</para>
        <para>The value of pair programming is that one person is actually doing the coding while the other is thinking about it. The thinker keeps the big picture in mind�not only the picture of the problem at hand, but the guidelines of XP. If two people are working, it�s less likely that one of them will get away with saying, �I don�t want to write the tests first,� for example. And if the coder gets stuck, they can swap places. If both of them get stuck, their musings may be overheard by someone else in the work area who can contribute. Working in pairs keeps things flowing and on track. Probably more important, it makes programming a lot more social and fun.</para>
        <para>I�ve begun using pair programming during the exercise periods in some of my seminars and it seems to significantly improve everyone�s experience.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064499"/><anchor xreflabel="Why
Java succeeds" xml:id="_Toc472654702"/>Why Java succeeds</title>
      <para>The reason Java has been so successful is that the goal was to solve many of the problems facing developers today. The goal of Java is improved productivity. This productivity comes in many ways, but the language is designed to aid you as much as possible, while hindering you as little as possible with arbitrary rules or any requirement that you use a particular set of features. Java is designed to be practical; Java language design decisions were based on providing the maximum benefits to the programmer.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064500"/><anchor xreflabel="" xml:id="_Toc472654706"/><anchor xreflabel="Systems are easier 
to express and understand" xml:id="_Toc312373791"/>Systems are easier   to express and understand</title>
        <para>Classes designed to fit the problem tend to express it better. This means that when you write the code, you�re describing your solution in the terms of the problem space (�Put the grommet in the bin�) rather than the terms of the computer, which is the solution space (�Set the bit in the chip that means that the relay will close�). You deal with higher-level concepts and can do much more with a single line of code.</para>
        <para>The other benefit of this ease of expression is maintenance, which (if reports can be believed) takes a huge portion of the cost over a program�s lifetime. If a program is easier to understand, then it�s easier to maintain. This can also reduce the cost of creating and maintaining the documentation.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064501"/><anchor xreflabel="" xml:id="_Toc472654707"/><anchor xreflabel="Maximal leverage with libraries" xml:id="_Toc312373792"/>Maximal leverage with libraries</title>
        <para>The fastest way to create a program is to use code that�s already written: a library. A major goal in Java is to make library use easier. This is accomplished by casting libraries into new data types (classes), so that bringing in a library means adding new types to the language. Because the Java compiler takes care of how the library is used�guaranteeing proper initialization and cleanup, and ensuring that functions are called properly�you can focus on what you want the library to do, not how you have to do it. </para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064502"/><anchor xreflabel="" xml:id="_Toc472654709"/><anchor xreflabel="Error handling" xml:id="_Toc312373793"/>Error handling</title>
        <para>Error handling in C is a notorious problem, and one that is often ignored�finger-crossing is usually involved. If you�re building a large, complex program, there�s nothing worse than having an error buried somewhere with no clue as to where it came from. Java <emphasis role="italic">exception handling</emphasis> is a way to guarantee that an error is noticed, and that something happens as a result.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064503"/><anchor xreflabel="" xml:id="_Toc472654710"/><anchor xreflabel="Programming in the large" xml:id="_Toc312373794"/>Programming in the large</title>
        <para>Many traditional languages have built-in limitations to program size and complexity. BASIC, for example, can be great for pulling together quick solutions for certain classes of problems, but if the program gets more than a few pages long, or ventures out of the normal problem domain of that language, it�s like trying to swim through an ever-more viscous fluid. There�s no clear line that tells you when your language is failing you, and even if there were, you�d ignore it. You don�t say, �My BASIC program just got too big; I�ll have to rewrite it in C!� Instead, you try to shoehorn a few more lines in to add that one new feature. So the extra costs come creeping up on you.</para>
        <para>Java is designed to aid <emphasis role="italic">programming in the large</emphasis>�that is, to erase those creeping-complexity boundaries between a small program and a large one. You certainly don�t need to use OOP when you�re writing a �hello world� style utility program, but the features are there when you need them. And the compiler is aggressive about ferreting out bug-producing errors for small and large programs alike.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc312373815"/><anchor xreflabel="" xml:id="_Toc481064504"/><anchor xreflabel="Strategies for
transition" xml:id="_Toc472654711"/>Strategies for transition</title>
      <para>If you buy into OOP, your next question is probably, �How can I get my manager/colleagues/department/peers to start using objects?� Think about how you�one independent programmer�would go about learning to use a new language and a new programming paradigm. You�ve done it before. First comes education and examples; then comes a trial project to give you a feel for the basics without doing anything too confusing. Then comes a �real world� project that actually does something useful. Throughout your first projects you continue your education by reading, asking questions of experts, and trading hints with friends. This is the approach many experienced programmers suggest for the switch to Java. Switching an entire company will of course introduce certain group dynamics, but it will help at each step to remember how one person would do it. </para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064505"/><anchor xreflabel="Guidelines" xml:id="_Toc472654712"/>Guidelines</title>
        <para>Here are some guidelines to consider when making the transition to OOP and Java:</para>
        <section>
          <title>1. Training</title>
          <para>The first step is some form of education. Remember the company�s investment in code, and try not to throw everything into disarray for six to nine months while everyone puzzles over how interfaces work. Pick a small group for indoctrination, preferably one composed of people who are curious, work well together, and can function as their own support network while they�re learning Java.</para>
          <para>An alternative approach that is sometimes suggested is the education of all company levels at once, including overview courses for strategic managers as well as design and programming courses for project builders. This is especially good for smaller companies making fundamental shifts in the way they do things, or at the division level of larger companies. Because the cost is higher, however, some may choose to start with project-level training, do a pilot project (possibly with an outside mentor), and let the project team become the teachers for the rest of the company.</para>
        </section>
        <section>
          <title>2. Low-risk project</title>
          <para>Try a low-risk project first and allow for mistakes. Once you�ve gained some experience, you can either seed other projects from members of this first team or use the team members as an OOP technical support staff. This first project may not work right the first time, so it should not be mission-critical for the company. It should be simple, self-contained, and instructive; this means that it should involve creating classes that will be meaningful to the other programmers in the company when they get their turn to learn Java.</para>
        </section>
        <section>
          <title>3. Model from success</title>
          <para>Seek out examples of good object-oriented design before starting from scratch. There�s a good probability that someone has solved your problem already, and if they haven�t solved it exactly you can probably apply what you�ve learned about abstraction to modify an existing design to fit your needs. This is the general concept of <emphasis role="italic">design patterns, </emphasis>covered in <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
        </section>
        <section>
          <title>4. Use existing class libraries</title>
          <para>The primary economic motivation for switching to OOP is the easy use of existing code in the form of class libraries (in particular, the Standard Java libraries, which are covered throughout this book). The shortest application development cycle will result when you can create and use objects from off-the-shelf libraries. However, some new programmers don�t understand this, are unaware of existing class libraries, or, through fascination with the language, desire to write classes that may already exist. Your success with OOP and Java will be optimized if you make an effort to seek out and reuse other people�s code early in the transition process.</para>
        </section>
        <section>
          <title>5. Don�t rewrite existing code in Java</title>
          <para>It is not usually the best use of your time to take existing, functional code and rewrite it in Java. (If you must turn it into objects, you can interface to the C or C++ code using the Java Native Interface, described in Appendix B.) There are incremental benefits, especially if the code is slated for reuse. But chances are you aren�t going to see the dramatic increases in productivity that you hope for in your first few projects unless that project is a new one. Java and OOP shine best when taking a project from concept to reality.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc312373817"/><anchor xreflabel="" xml:id="_Toc481064506"/><anchor xreflabel="Management
obstacles" xml:id="_Toc472654713"/>Management obstacles</title>
        <para>If you�re a manager, your job is to acquire resources for your team, to overcome barriers to your team�s success, and in general to try to provide the most productive and enjoyable environment so your team is most likely to perform those miracles that are always being asked of you. Moving to Java falls in all three of these categories, and it would be wonderful if it didn�t cost you anything as well. Although moving to Java may be cheaper�depending on your constraints�than the OOP alternatives for a team of C programmers (and probably for programmers in other procedural languages), it isn�t free, and there are obstacles you should be aware of before trying to sell the move to Java within your company and embarking on the move itself.</para>
        <section>
          <title>Startup costs</title>
          <para>The cost of moving to Java is more than just the acquisition of Java compilers (the Sun Java compiler is free, so this is hardly an obstacle). Your medium- and long-term costs will be minimized if you invest in training (and possibly mentoring for your first project) and also if you identify and purchase class libraries that solve your problem rather than trying to build those libraries yourself. These are hard-money costs that must be factored into a realistic proposal. In addition, there are the hidden costs in loss of productivity while learning a new language and possibly a new programming environment. Training and mentoring can certainly minimize these, but team members must overcome their own struggles to understand the new technology. During this process they will make more mistakes (this is a feature, because acknowledged mistakes are the fastest path to learning) and be less productive. Even then, with some types of programming problems, the right classes, and the right development environment, it�s possible to be more productive while you�re learning Java (even considering that you�re making more mistakes and writing fewer lines of code per day) than if you�d stayed with C.</para>
        </section>
        <section>
          <title>Performance issues</title>
          <para>A common question is, �Doesn�t OOP automatically make my programs a lot bigger and slower?� The answer is, �It depends.� The extra safety features in Java have traditionally extracted a performance penalty over a language like C++. Technologies such as �hotspot� and compilation technologies have improved the speed significantly in most cases, and efforts continue toward higher performance.</para>
          <para>When your focus is on rapid prototyping, you can throw together components as fast as possible while ignoring efficiency issues. If you�re using any third-party libraries, these are usually already optimized by their vendors; in any case it�s not an issue while you�re in rapid-development mode. When you have a system that you like, if it�s small and fast enough, then you�re done. If not, you begin tuning with a profiling tool, looking first for speedups that can be done by rewriting small portions of code. If that doesn�t help, you look for modifications that can be made in the underlying implementation so no code that uses a particular class needs to be changed. Only if nothing else solves the problem do you need to change the design. The fact that performance is so critical in that portion of the design is an indicator that it must be part of the primary design criteria. You have the benefit of finding this out early using rapid development.</para>
          <para>If you find a function that is a particular bottleneck, you can rewrite it in C/C++ using Java�s <emphasis role="italic">native methods</emphasis>, the subject of Appendix B.</para>
        </section>
        <section>
          <title>Common design errors</title>
          <para>When starting your team into OOP and Java, programmers will typically go through a series of common design errors. This often happens due to insufficient feedback from experts during the design and implementation of early projects, because no experts have been developed within the company, and because there may be resistance to retaining consultants. It�s easy to feel that you understand OOP too early in the cycle and go off on a bad tangent. Something that�s obvious to someone experienced with the language may be a subject of great internal debate for a novice. Much of this trauma can be skipped by using an experienced outside expert for training and mentoring.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064507"/><anchor xreflabel="" xml:id="_Toc473421309"/><anchor xreflabel="Java vs. C++?" xml:id="_Toc375545210"/>Java vs. C++?</title>
      <para>Java looks a lot like C++, and so naturally it would seem that C++ will be replaced by Java. But I�m starting to question this logic. For one thing, C++ still has some features that Java doesn�t, and although there have been a lot of promises about Java someday being as fast or faster than C++, we�ve seen steady improvements but no dramatic breakthroughs. Also, there seems to be a continuing interest in C++, so I don�t think that language is going away any time soon. (Languages seem to hang around. Speaking at one of my �Intermediate/Advanced Java Seminars,� Allen Holub asserted that the two most commonly used languages are Rexx and COBOL, in that order.)</para>
      <para>I�m beginning to think that the strength of Java lies in a slightly different arena than that of C++. C++ is a language that doesn�t try to fit a mold. Certainly it has been adapted in a number of ways to solve particular problems. Some C++ tools combine libraries, component models, and code-generation tools to solve the problem of developing windowed end-user applications (for Microsoft Windows). And yet, what do the vast majority of Windows developers use? Microsoft�s Visual Basic (VB). This despite the fact that VB produces the kind of code that becomes unmanageable when the program is only a few pages long (and syntax that can be positively mystifying). As successful and popular as VB is, it�s not a very good example of language design. It would be nice to have the ease and power of VB without the resulting unmanageable code. And that�s where I think Java will shine: as the �next VB.� You may or may not shudder to hear this, but think about it: so much of Java is intended to make it easy for the programmer to solve application-level problems like networking and cross-platform UI, and yet it has a language design that allows the creation of very large and flexible bodies of code. Add to this the fact that Java has the most robust type checking and error handling systems I�ve ever seen in a language and you have the makings of a significant leap forward in programming productivity.</para>
      <para>Should you use Java instead of C++ for your project? Other than Web applets, there are two issues to consider. First, if you want to use a lot of existing C++ libraries (and you�ll certainly get a lot of productivity gains there), or if you have an existing C or C++ code base, Java might slow your development down rather than speeding it up. </para>
      <para>If you�re developing all your code primarily from scratch, then the simplicity of Java over C++ will significantly shorten your development time�the anecdotal evidence (stories from C++ teams that I�ve talked to who have switched to Java) suggests a doubling of development speed over C++. If Java performance doesn�t matter or you can somehow compensate for it, sheer time-to-market issues make it difficult to choose C++ over Java.</para>
      <para>The biggest issue is performance. Interpreted Java has been slow, even 20 to 50 times slower than C in the original Java interpreters. This has improved greatly over time, but it will still remain an important number. Computers are about speed; if it wasn�t significantly faster to do something on a computer then you�d do it by hand. (I�ve even heard it suggested that you start with Java, to gain the short development time, then use a tool and support libraries to translate your code to C++, if you need faster execution speed.)</para>
      <para>The key to making Java feasible for most development projects is the appearance of speed improvements like so-called �just-in time� (JIT) compilers, Sun�s own �hotspot� technology, and even native code compilers. Of course, native code compilers will eliminate the touted cross-platform execution of the compiled programs, but they will also bring the speed of the executable closer to that of C and C++. And cross-compiling a program in Java should be a lot easier than doing so in C or C++. (In theory, you just recompile, but that promise has been made before for other languages.) </para>
      <para>You can find comparisons of Java and C++ and observations about Java realities in the appendices of the first edition of this book (Available on this book�s accompanying CD ROM, as well as at <emphasis role="italic">www.BruceEckel.com)</emphasis>.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064508"/><anchor xreflabel="" xml:id="_Toc472654714"/><anchor xreflabel="Summary" xml:id="_Toc312373818"/>Summary</title>
      <para>This chapter attempts to give you a feel for the broad issues of object-oriented programming and Java, including why OOP is different, and why Java in particular is different, concepts of OOP methodologies, and finally the kinds of issues you will encounter when moving your own company to OOP and Java.</para>
      <para>OOP and Java may not be for everyone. It�s important to evaluate your own needs and decide whether Java will optimally satisfy those needs, or if you might be better off with another programming system (including the one you�re currently using). If you know that your needs will be very specialized for the foreseeable future and if you have specific constraints that may not be satisfied by Java, then you owe it to yourself to investigate the alternatives<anchor xreflabel="[19]" xml:id="_ftnref19"/>[19]. Even if you eventually choose Java as your language, you�ll at least understand what the options were and have a clear vision of why you took that direction.</para>
      <para>You know what a procedural program looks like: data definitions and function calls. To find the meaning of such a program you have to work a little, looking through the function calls and low-level concepts to create a model in your mind. This is the reason we need intermediate representations when designing procedural programs�by themselves, these programs tend to be confusing because the terms of expression are oriented more toward the computer than to the problem you�re solving.</para>
      <para>Because Java adds many new concepts on top of what you find in a procedural language, your natural assumption may be that the <emphasis role="bold">main( )</emphasis> in a Java program will be far more complicated than for the equivalent C program. Here, you�ll be pleasantly surprised: A well-written Java program is generally far simpler and much easier to understand than the equivalent C program. What you�ll see are the definitions of the objects that represent concepts in your problem space (rather than the issues of the computer representation) and messages sent to those objects to represent the activities in that space. One of the delights of object-oriented programming is that, with a well-designed program, it�s easy to understand the code by reading it. Usually there�s a lot less code as well, because many of your problems will be solved by reusing existing library code.</para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="OLE_LINK5"/><anchor xreflabel="" xml:id="_Toc481064509"/><anchor xreflabel="" xml:id="_Toc477690722"/><anchor xreflabel="" xml:id="_Toc375545216"/><anchor xreflabel="" xml:id="Chapter_2"/>2: Everything  is an Object</title>
    <para>Although it is based on C++, Java is more of a �pure� object-oriented language.</para>
    <para>Both C++ and Java are hybrid languages, but in Java the designers felt that the hybridization was not as important as it was in C++. A hybrid language allows multiple programming styles; the reason C++ is hybrid is to support backward compatibility with the C language. Because C++ is a superset of the C language, it includes many of that language�s undesirable features, which can make some aspects of C++ overly complicated.</para>
    <para>The Java language assumes that you want to do only object-oriented programming. This means that before you can begin you must shift your mindset into an object-oriented world (unless it�s already there)<emphasis role="italic">.</emphasis> The benefit of this initial effort is the ability to program in a language that is simpler to learn and to use than many other OOP languages. In this chapter we�ll see the basic components of a Java program and we�ll learn that everything in Java is an object, even a Java program.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064510"/><anchor xreflabel="You
manipulate objects 
with references" xml:id="_Toc375545217"/>You manipulate objects   with references</title>
      <para>Each programming language has its own means of manipulating data. Sometimes the programmer must be constantly aware of what type of manipulation is going on. Are you manipulating the object directly, or are you dealing with some kind of indirect representation (a pointer in C or C++) that must be treated with a special syntax?</para>
      <para>All this is simplified in Java. You treat everything as an object, so there is a single consistent syntax that you use everywhere. Although you <emphasis role="italic">treat </emphasis>everything as an object, the identifier you manipulate is actually a �reference� to an object<anchor xreflabel="[20]" xml:id="_ftnref20"/>[20]. You might imagine this scene as a television (the object) with your remote control (the reference). As long as you�re holding this reference, you have a connection to the television, but when someone says �change the channel� or �lower the volume,� what you�re manipulating is the reference, which in turn modifies the object. If you want to move around the room and still control the television, you take the remote/reference with you, not the television.</para>
      <para>Also, the remote control can stand on its own, with no television. That is, just because you have a reference doesn�t mean there�s necessarily an object connected to it. So if you want to hold a word or sentence, you create a <emphasis role="bold">String</emphasis> reference:</para>
      <para>String s;</para>
      <para> </para>
      <para>But here you�ve created <emphasis role="italic">only</emphasis> the reference, not an object. If you decided to send a message to <emphasis role="bold">s</emphasis> at this point, you�ll get an error (at run-time) because <emphasis role="bold">s</emphasis> isn�t actually attached to anything (there�s no television). A safer practice, then, is always to initialize a reference when you create it:</para>
      <para>String s = &quot;asdf&quot;;</para>
      <para> </para>
      <para>However, this uses a special Java feature: strings can be initialized with quoted text. Normally, you must use a more general type of initialization for objects.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064511"/><anchor xreflabel="You
must create 
all the objects" xml:id="_Toc375545218"/>You must create   all the objects</title>
      <para>When you create a reference, you want to connect it with a new object. You do so, in general, with the <emphasis role="bold">new</emphasis> keyword. <emphasis role="bold">new</emphasis> says, �Make me a new one of these objects.� So in the above example, you can say:</para>
      <para>String s = new String(&quot;asdf&quot;);</para>
      <para> </para>
      <para>Not only does this mean �Make me a new <emphasis role="bold">String</emphasis>,� but it also gives information about <emphasis role="italic">how</emphasis> to make the <emphasis role="bold">String</emphasis> by supplying an initial character string.</para>
      <para>Of course, <emphasis role="bold">String</emphasis> is not the only type that exists. Java comes with a plethora of ready-made types. What�s more important is that you can create your own types. In fact, that�s the fundamental activity in Java programming, and it�s what you�ll be learning about in the rest of this book.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064512"/><anchor xreflabel="Where
storage lives" xml:id="_Toc375545219"/>Where storage lives</title>
        <para>It�s useful to visualize some aspects of how things are laid out while the program is running, in particular how memory is arranged. There are six different places to store data:</para>
        <para><emphasis role="bold">Registers</emphasis>. This is the fastest storage because it exists in a place different from that of other storage: inside the processor. However, the number of registers is severely limited, so registers are allocated by the compiler according to its needs. You don�t have direct control, nor do you see any evidence in your programs that registers even exist.</para>
        <para>18.      <emphasis role="bold">The stack</emphasis>. This lives in the general RAM (random-access memory) area, but has direct support from the processor via its <emphasis role="italic">stack pointer</emphasis>. The stack pointer is moved down to create new memory and moved up to release that memory. This is an extremely fast and efficient way to allocate storage, second only to registers. The Java compiler must know, while it is creating the program, the exact size and lifetime of all the data that is stored on the stack, because it must generate the code to move the stack pointer up and down. This constraint places limits on the flexibility of your programs, so while some Java storage exists on the stack�in particular, object references�Java objects themselves are not placed on the stack.</para>
        <para>19.      <emphasis role="bold">The heap</emphasis>. This is a general-purpose pool of memory (also in the RAM area) where all Java objects live. The nice thing about the heap is that, unlike the stack, the compiler doesn�t need to know how much storage it needs to allocate from the heap or how long that storage must stay on the heap. Thus, there�s a great deal of flexibility in using storage on the heap. Whenever you need to create an object, you simply write the code to create it using <emphasis role="bold">new</emphasis>,<emphasis role="bold"/>and the storage is allocated on the heap when that code is executed. Of course there�s a price you pay for this flexibility: it takes more time to allocate heap storage than it does to allocate stack storage (that is, if you even <emphasis role="italic">could</emphasis> create objects on the stack in Java, as you can in C++).</para>
        <para>20.      <emphasis role="bold">Static storage</emphasis>. �Static� is used here in the sense of �in a fixed location� (although it�s also in RAM). Static storage contains data that is available for the entire time a program is running. You can use the <emphasis role="bold">static</emphasis> keyword to specify that a particular element of an object is static, but Java objects themselves are never placed in static storage.</para>
        <para>21.      <emphasis role="bold">Constant storage</emphasis>. Constant values are often placed directly in the program code, which is safe since they can never change. Sometimes constants are cordoned off by themselves so that they can be optionally placed in read‑only memory (ROM).</para>
        <para>22.      <emphasis role="bold">Non-RAM storage</emphasis>. If data lives completely outside a program it can exist while the program is not running, outside the control of the program. The two primary examples of this are <emphasis role="italic">streamed objects,</emphasis> in which objects are turned into streams of bytes, generally to be sent to another machine, and <emphasis role="italic">persistent objects, </emphasis>in which the objects are placed on disk so they will hold their state even when the program is terminated. The trick with these types of storage is turning the objects into something that can exist on the other medium, and yet can be resurrected into a regular RAM-based object when necessary. Java provides support for <emphasis role="italic">lightweight persistence</emphasis>, and future versions of Java might provide more complete solutions for persistence.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064513"/><anchor xreflabel="Special
case: primitive types" xml:id="_Toc375545220"/>Special case: primitive types</title>
        <para>There is a group of types that gets special treatment; you can think of these as �primitive� types that you use quite often in your programming. The reason for the special treatment is that to create an object with <emphasis role="bold">new</emphasis>�especially a small, simple variable�isn�t very efficient because <emphasis role="bold">new</emphasis> places objects on the heap. For these types Java falls back on the approach taken by C and C++. That is, instead of creating the variable using <emphasis role="bold">new</emphasis>, an �automatic� variable is created that <emphasis role="italic">is not a reference</emphasis>. The variable holds the value, and it�s placed on the stack so it�s much more efficient.</para>
        <para>Java determines the size of each primitive type. These sizes don�t change from one machine architecture to another as they do in most languages. This size invariance is one reason Java programs are so portable.</para>
        <informaltable frame="all">
          <tgroup cols="5">
            <colspec colname="c1" colwidth="9*"/>
            <colspec colname="c2" colwidth="6*"/>
            <colspec colname="c3" colwidth="9*"/>
            <colspec colname="c4" colwidth="11*"/>
            <colspec colname="c5" colwidth="10*"/>
            <thead>
              <row>
                <entry valign="top"><para> Primitive type</para></entry>
                <entry valign="top"><para> Size</para></entry>
                <entry valign="top"><para> Minimum</para></entry>
                <entry valign="top"><para> Maximum</para></entry>
                <entry valign="top"><para> Wrapper type</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry valign="top"><para> boolean</para></entry>
                <entry valign="top"><para> �</para></entry>
                <entry valign="top"><para> �</para></entry>
                <entry valign="top"><para> �</para></entry>
                <entry valign="top"><para> Boolean</para></entry>
              </row>
              <row>
                <entry valign="top"><para> char</para></entry>
                <entry valign="top"><para> 16-bit</para></entry>
                <entry valign="top"><para> Unicode 0</para></entry>
                <entry valign="top"><para> Unicode 2<superscript>16</superscript>- 1</para></entry>
                <entry valign="top"><para> Character</para></entry>
              </row>
              <row>
                <entry valign="top"><para> byte </para></entry>
                <entry valign="top"><para> 8-bit</para></entry>
                <entry valign="top"><para> -128</para></entry>
                <entry valign="top"><para> +127</para></entry>
                <entry valign="top"><para> Byte</para></entry>
              </row>
              <row>
                <entry valign="top"><para> short</para></entry>
                <entry valign="top"><para> 16-bit</para></entry>
                <entry valign="top"><para> -2<superscript>15</superscript></para></entry>
                <entry valign="top"><para> +2<superscript>15</superscript>�1</para></entry>
                <entry valign="top"><para> Short</para></entry>
              </row>
              <row>
                <entry valign="top"><para> int</para></entry>
                <entry valign="top"><para> 32-bit</para></entry>
                <entry valign="top"><para> -2<superscript>31</superscript></para></entry>
                <entry valign="top"><para> +2<superscript>31</superscript>�1</para></entry>
                <entry valign="top"><para> Integer</para></entry>
              </row>
              <row>
                <entry valign="top"><para> long</para></entry>
                <entry valign="top"><para> 64-bit</para></entry>
                <entry valign="top"><para> -2<superscript>63</superscript></para></entry>
                <entry valign="top"><para> +2<superscript>63</superscript>�1</para></entry>
                <entry valign="top"><para> Long</para></entry>
              </row>
              <row>
                <entry valign="top"><para> float</para></entry>
                <entry valign="top"><para> 32-bit</para></entry>
                <entry valign="top"><para> IEEE754</para></entry>
                <entry valign="top"><para> IEEE754</para></entry>
                <entry valign="top"><para> Float</para></entry>
              </row>
              <row>
                <entry valign="top"><para> double</para></entry>
                <entry valign="top"><para> 64-bit </para></entry>
                <entry valign="top"><para> IEEE754</para></entry>
                <entry valign="top"><para> IEEE754</para></entry>
                <entry valign="top"><para> Double</para></entry>
              </row>
              <row>
                <entry valign="top"><para> void</para></entry>
                <entry valign="top"><para> �</para></entry>
                <entry valign="top"><para> �</para></entry>
                <entry valign="top"><para> �</para></entry>
                <entry valign="top"><para> Void</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>All numeric types are signed, so don�t go looking for unsigned types.</para>
        <para>The size of the <emphasis role="bold">boolean</emphasis> type is not explicitly defined; it is only specified to be able to take the literal values <emphasis role="bold">true</emphasis> or <emphasis role="bold">false</emphasis>.</para>
        <para>The primitive data types also have �wrapper�<emphasis role="italic"/>classes for them. That means that if you want to make a nonprimitive object on the heap to represent that primitive type, you use the associated wrapper. For example:</para>
        <para>char c = &apos;x&apos;;</para>
        <para>Character C = new Character(c);</para>
        <para> </para>
        <para>Or you could also use:</para>
        <para>Character C = new Character(&apos;x&apos;);</para>
        <para> </para>
        <para>The reasons for doing this will be shown in a later chapter.</para>
        <section>
          <title>High-precision numbers</title>
          <para>Java includes two classes for performing high-precision arithmetic: <emphasis role="bold">BigInteger</emphasis> and <emphasis role="bold">BigDecimal</emphasis>. Although these approximately fit into the same category as the �wrapper� classes, neither one has a primitive analogue.</para>
          <para>Both classes have methods that provide analogues for the operations that you perform on primitive types. That is, you can do anything with a <emphasis role="bold">BigInteger</emphasis> or <emphasis role="bold">BigDecimal </emphasis>that you can with an <emphasis role="bold">int</emphasis> or <emphasis role="bold">float</emphasis>, it�s just that you must use method calls instead of operators. Also, since there�s more involved, the operations will be slower. You�re exchanging speed for accuracy.</para>
          <para><emphasis role="bold">BigInteger</emphasis> supports arbitrary-precision integers. This means that you can accurately represent integral values of any size without losing any information during operations.</para>
          <para><emphasis role="bold">BigDecimal</emphasis> is for arbitrary-precision fixed-point numbers; you can use these for accurate monetary calculations, for example.</para>
          <para>Consult your online documentation for details about the constructors and methods you can call for these two classes.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064514"/><anchor xreflabel="Arrays
in Java" xml:id="_Toc375545221"/>Arrays in Java</title>
        <para>Virtually all programming languages support arrays. Using arrays in C and C++ is perilous because those arrays are only blocks of memory. If a program accesses the array outside of its memory block or uses the memory before initialization (common programming errors) there will be unpredictable results.</para>
        <para>One of the primary goals of Java is safety, so many of the problems that plague programmers in C and C++ are not repeated in Java. A Java array is guaranteed to be initialized and cannot be accessed outside of its range. The range checking comes at the price of having a small amount of memory overhead on each array as well as verifying the index at run-time, but the assumption is that the safety and increased productivity is worth the expense.</para>
        <para>When you create an array of objects, you are really creating an array of references, and each of those references is automatically initialized to a special value with its own keyword: <emphasis role="bold">null</emphasis>. When Java sees <emphasis role="bold">null</emphasis>, it recognizes that the reference in question isn�t pointing to an object.<emphasis role="bold"/>You must assign an object to each reference before you use it, and if you try to use a reference that�s still <emphasis role="bold">null,</emphasis> the problem will be reported at run-time. Thus, typical array errors are prevented in Java.</para>
        <para>You can also create an array of primitives. Again, the compiler guarantees initialization because it zeroes the memory for that array.</para>
        <para>Arrays will be covered in detail in later chapters.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064515"/><anchor xreflabel="You
never need to 
destroy an object" xml:id="_Toc375545222"/>You never need to   destroy an object</title>
      <para>In most programming languages, the concept of the lifetime of a variable occupies a significant portion of the programming effort. How long does the variable last? If you are supposed to destroy it, when should you? Confusion over variable lifetimes can lead to a lot of bugs, and this section shows how Java greatly simplifies the issue by doing all the cleanup work for you.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064516"/><anchor xreflabel="Scoping" xml:id="_Toc375545223"/>Scoping</title>
        <para>Most procedural languages have the concept of <emphasis role="italic">scope</emphasis>. This determines both the visibility and lifetime of the names defined within that scope. In C, C++, and Java, scope is determined by the placement of curly braces <emphasis role="bold">{}</emphasis>. So for example:</para>
        <para>{</para>
        <para>� int x = 12;</para>
        <para>� /* only x available */</para>
        <para>� {</para>
        <para>��� int q = 96;</para>
        <para>��� /* both x &amp; q available */</para>
        <para>� }</para>
        <para>� /* only x available */</para>
        <para>� /* q �out of scope� */</para>
        <para>}</para>
        <para> </para>
        <para>A variable defined within a scope is available only to the end of that scope.</para>
        <para>Indentation makes Java code easier to read. Since Java is a free-form language, the extra spaces, tabs, and carriage returns do not affect the resulting program.</para>
        <para>Note that you <emphasis role="italic">cannot</emphasis> do the following, even though it is legal in C and C++:</para>
        <para>{</para>
        <para>� int x = 12;</para>
        <para>� {</para>
        <para>��� int x = 96; /* illegal */</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>The compiler will announce that the variable <emphasis role="bold">x </emphasis>has already been defined. Thus the C and C++ ability to �hide� a variable in a larger scope is not allowed because the Java designers thought that it led to confusing programs.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064517"/><anchor xreflabel="Scope
of objects" xml:id="_Toc375545224"/>Scope of objects</title>
        <para>Java objects do not have the same lifetimes as primitives. When you create a Java object using <emphasis role="bold">new</emphasis>, it hangs around past the end of the scope. Thus if you use:</para>
        <para>{</para>
        <para>� String s = new String(&quot;a string&quot;);</para>
        <para>} /* end of scope */</para>
        <para> </para>
        <para>the reference <emphasis role="bold">s</emphasis> vanishes at the end of the scope. However, the <emphasis role="bold">String</emphasis> object that <emphasis role="bold">s</emphasis> was pointing to is still occupying memory. In this bit of code, there is no way to access the object because the only reference to it is out of scope. In later chapters you�ll see how the reference to the object can be passed around and duplicated during the course of a program.</para>
        <para>It turns out that because objects created with <emphasis role="bold">new</emphasis> stay around for as long as you want them, a whole slew of C++ programming problems simply vanish in Java. The hardest problems seem to occur in C++ because you don�t get any help from the language in making sure that the objects are available when they�re needed. And more important, in C++ you must make sure that you destroy the objects when you�re done with them.</para>
        <para>That brings up an interesting question. If Java leaves the objects lying around, what keeps them from filling up memory and halting your program? This is exactly the kind of problem that would occur in C++. This is where a bit of magic happens. Java has a <emphasis role="italic">garbage collector</emphasis>, which looks at all the objects that were created with <emphasis role="bold">new</emphasis> and figures out which ones are not being referenced anymore. Then it releases the memory for those objects, so the memory can be used for new objects. This means that you never need to worry about reclaiming memory yourself. You simply create objects, and when you no longer need them they will go away by themselves. This eliminates a certain class of programming problem: the so-called �memory leak,� in which a programmer forgets to release memory.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064518"/><anchor xreflabel="Creating
new 
data types: class" xml:id="_Toc375545225"/>Creating new   data types: class</title>
      <para>If everything is an object, what determines how a particular class of object looks and behaves? Put another way, what establishes the <emphasis role="italic">type</emphasis> of an object? You might expect there to be a keyword called �type,� and that certainly would have made sense. Historically, however, most object-oriented languages have used the keyword <emphasis role="bold">class</emphasis> to mean �I�m about to tell you what a new type of object looks like.� The <emphasis role="bold">class</emphasis> keyword (which is so common that it will not be emboldened throughout this book) is followed by the name of the new type. For example:</para>
      <para>class ATypeName { /* class body goes here */ }</para>
      <para> </para>
      <para>This introduces a new type, so you can now create an object of this type using <emphasis role="bold">new</emphasis>:</para>
      <para>ATypeName a = new ATypeName();</para>
      <para> </para>
      <para>In <emphasis role="bold">ATypeName</emphasis>, the class body consists only of a comment (the stars and slashes and what is inside, which will be discussed later in this chapter), so there is not too much that you can do with it. In fact, you cannot tell it to do much of anything (that is, you cannot send it any interesting messages) until you define some methods for it.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064519"/><anchor xreflabel="Fields
and methods" xml:id="_Toc375545226"/>Fields and methods</title>
        <para>When you define a class (and all you do in Java is define classes, make objects of those classes, and send messages to those objects), you can put two types of elements in your class: data members (sometimes called <emphasis role="italic">fields</emphasis>), and member functions (typically called <emphasis role="italic">methods</emphasis>). A data member is an object of any type that you can communicate with via its reference. It can also be one of the primitive types (which isn�t a reference). If it is a reference to an object, you must initialize that reference to connect it to an actual object (using <emphasis role="bold">new</emphasis>, as seen earlier) in a special function called a <emphasis role="italic">constructor</emphasis> (described fully in Chapter 4). If it is a primitive type you can initialize it directly at the point of definition in the class. (As you�ll see later, references can also be initialized at the point of definition.)</para>
        <para>Each object keeps its own storage for its data members; the data members are not shared among objects. Here is an example of a class with some data members:</para>
        <para>class DataOnly {</para>
        <para>� int i;</para>
        <para>� float f;</para>
        <para>� boolean b;</para>
        <para>}</para>
        <para> </para>
        <para>This class doesn�t <emphasis role="italic">do</emphasis> anything, but you can create an object:</para>
        <para>DataOnly d = new DataOnly();</para>
        <para> </para>
        <para>You can assign values to the data members, but you must first know how to refer to a member of an object. This is accomplished by stating the name of the object reference, followed by a period (dot), followed by the name of the member inside the object:</para>
        <para>objectReference.member</para>
        <para> </para>
        <para>For example:</para>
        <para>d.i = 47;</para>
        <para>d.f = 1.1f;</para>
        <para>d.b = false;</para>
        <para> </para>
        <para>It is also possible that your object might contain other objects that contain data you�d like to modify. For this, you just keep �connecting the dots.� For example:</para>
        <para>myPlane.leftTank.capacity = 100;</para>
        <para> </para>
        <para>The <emphasis role="bold">DataOnly </emphasis>class cannot do much of anything except hold data, because it has no member functions (methods). To understand how those work, you must first understand <emphasis role="italic">arguments</emphasis> and <emphasis role="italic">return values</emphasis>, which will be described shortly.</para>
        <section>
          <title>Default values for primitive members</title>
          <para>When a primitive data type is a member of a class, it is guaranteed to get a default value if you do not initialize it:</para>
          <informaltable frame="all">
            <tgroup cols="2">
              <colspec colname="c1" colwidth="13*"/>
              <colspec colname="c2" colwidth="14*"/>
              <thead>
                <row>
                  <entry valign="top"><para> Primitive type</para></entry>
                  <entry valign="top"><para> Default</para></entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry valign="top"><para> boolean</para></entry>
                  <entry valign="top"><para> false</para></entry>
                </row>
                <row>
                  <entry valign="top"><para> char</para></entry>
                  <entry valign="top"><para> �\u0000� (null)</para></entry>
                </row>
                <row>
                  <entry valign="top"><para> byte</para></entry>
                  <entry valign="top"><para> (byte)0</para></entry>
                </row>
                <row>
                  <entry valign="top"><para> short</para></entry>
                  <entry valign="top"><para> (short)0</para></entry>
                </row>
                <row>
                  <entry valign="top"><para> int</para></entry>
                  <entry valign="top"><para> 0</para></entry>
                </row>
                <row>
                  <entry valign="top"><para> long</para></entry>
                  <entry valign="top"><para> 0L</para></entry>
                </row>
                <row>
                  <entry valign="top"><para> float</para></entry>
                  <entry valign="top"><para> 0.0f</para></entry>
                </row>
                <row>
                  <entry valign="top"><para> double</para></entry>
                  <entry valign="top"><para> 0.0d</para></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>Note carefully that the default values are what Java guarantees when the variable is used <emphasis role="italic">as a member of a class</emphasis>. This ensures that member variables of primitive types will always be initialized (something C++ doesn�t do), reducing a source of bugs. However, this initial value may not be correct or even legal for the program you are writing. It�s best to always explicitly initialize your variables.</para>
          <para>This guarantee doesn�t apply to �local� variables�those that are not fields of a class. Thus, if within a function definition you have:</para>
          <para>int x;</para>
          <para> </para>
          <para>Then <emphasis role="bold">x</emphasis> will get some arbitrary value (as in C and C++); it will not automatically be initialized to zero. You are responsible for assigning an appropriate value before you use <emphasis role="bold">x</emphasis>. If you forget, Java definitely improves on C++: you get a compile-time error telling you the variable might not have been initialized. (Many C++ compilers will warn you about uninitialized variables, but in Java these are errors.)</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064520"/><anchor xreflabel="Methods,
arguments, 
and return values" xml:id="_Toc375545227"/>Methods, arguments,   and return values</title>
      <para>Up until now, the term <emphasis role="italic">function</emphasis> has been used to describe a named subroutine. The term that is more commonly used in Java is <emphasis role="italic">method,</emphasis> as in �a way to do something.� If you want, you can continue thinking in terms of functions. It�s really only a syntactic difference, but from now on �method� will be used in this book rather than �function.�</para>
      <para>Methods in Java determine the messages an object can receive. In this section you will learn how simple it is to define a method.</para>
      <para>The fundamental parts of a method are the name, the arguments, the return type, and the body. Here is the basic form:</para>
      <para>returnType methodName( /* argument list */ ) {</para>
      <para>� /* Method body */</para>
      <para>}</para>
      <para> </para>
      <para>The return type is the type of the value that pops out of the method after you call it. The argument list gives the types and names for the information you want to pass into the method. The method name and argument list together uniquely identify the method. </para>
      <para>Methods in Java can be created only as part of a class. A method can be called only for an object,<anchor xreflabel="[21]" xml:id="_ftnref21"/>[21] and that object must be able to perform that method call. If you try to call the wrong method for an object, you�ll get an error message at compile-time. You call a method for an object by naming the object followed by a period (dot), followed by the name of the method and its argument list, like this: <emphasis role="bold">objectName.methodName(arg1, arg2, arg3)</emphasis>. For example, suppose you have a method <emphasis role="bold">f( )</emphasis> that takes no arguments and returns a value of type <emphasis role="bold">int</emphasis>. Then, if you have an object called <emphasis role="bold">a</emphasis> for which <emphasis role="bold">f( )</emphasis> can be called, you can say this:</para>
      <para>int x = a.f();</para>
      <para> </para>
      <para>The type of the return value must be compatible with the type of <emphasis role="bold">x</emphasis>.</para>
      <para>This act of calling a method is commonly referred to as <emphasis role="italic">sending a message to an object</emphasis>. In the above example, the message is <emphasis role="bold">f( )</emphasis> and the object is <emphasis role="bold">a</emphasis>. Object-oriented programming is often summarized as simply �sending messages to objects.�</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064521"/><anchor xreflabel="The
argument list" xml:id="_Toc375545228"/>The argument list</title>
        <para>The method argument list specifies what information you pass into the method. As you might guess, this information�like everything else in Java�takes the form of objects. So, what you must specify in the argument list are the types of the objects to pass in and the name to use for each one. As in any situation in Java where you seem to be handing objects around, you are actually passing references<anchor xreflabel="[22]" xml:id="_ftnref22"/>[22]. The type of the reference must be correct, however. If the argument is supposed to be a <emphasis role="bold">String</emphasis>, what you pass in must be a string.</para>
        <para>Consider a method that takes a <emphasis role="bold">String</emphasis> as its argument. Here is the definition, which must be placed within a class definition for it to be compiled:</para>
        <para>int storage(String s) {</para>
        <para>� return s.length() * 2;</para>
        <para>}</para>
        <para> </para>
        <para>This method tells you how many bytes are required to hold the information in a particular <emphasis role="bold">String. </emphasis>(Each <emphasis role="bold">char </emphasis>in a <emphasis role="bold">String </emphasis>is 16 bits, or two bytes, long, to support Unicode characters.) The argument is of type <emphasis role="bold">String</emphasis> and is called <emphasis role="bold">s</emphasis>. Once <emphasis role="bold">s</emphasis> is passed into the method, you can treat it just like any other object. (You can send messages to it.) Here, the <emphasis role="bold">length( )</emphasis> method is called, which is one of the methods for <emphasis role="bold">String</emphasis>s; it returns the number of characters in a string.</para>
        <para>You can also see the use of the <emphasis role="bold">return</emphasis> keyword, which does two things. First, it means �leave the method, I�m done.� Second, if the method produces a value, that value is placed right after the <emphasis role="bold">return</emphasis> statement. In this case, the return value is produced by evaluating the expression <emphasis role="bold">s.length( ) * 2</emphasis>.</para>
        <para>You can return any type you want, but if you don�t want to return anything at all, you do so by indicating that the method returns <emphasis role="bold">void</emphasis>. Here are some examples:</para>
        <para>boolean flag() { return true; }</para>
        <para>float naturalLogBase() { return 2.718f; }</para>
        <para>void nothing() { return; }</para>
        <para>void nothing2() {}</para>
        <para> </para>
        <para>When the return type is <emphasis role="bold">void</emphasis>, then the <emphasis role="bold">return</emphasis> keyword is used only to exit the method, and is therefore unnecessary when you reach the end of the method. You can return from a method at any point, but if you�ve given a non-<emphasis role="bold">void </emphasis>return type then the compiler will force you (with error messages) to return the appropriate type of value regardless of where you return.</para>
        <para>At this point, it can look like a program is just a bunch of objects with methods that take other objects as arguments and send messages to those other objects. That is indeed much of what goes on, but in the following chapter you�ll learn how to do the detailed low-level work by making decisions within a method. For this chapter, sending messages will suffice.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064522"/><anchor xreflabel="Building
a Java program" xml:id="_Toc375545229"/>Building a Java program</title>
      <para>There are several other issues you must understand before seeing your first Java program.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064523"/><anchor xreflabel="Name
visibility" xml:id="_Toc375545230"/>Name visibility</title>
        <para>A problem in any programming language is the control of names. If you use a name in one module of the program, and another programmer uses the same name in another module, how do you distinguish one name from another and prevent the two names from �clashing?� In C this is a particular problem because a program is often an unmanageable sea of names. C++ classes (on which Java classes are based) nest functions within classes so they cannot clash with function names nested within other classes. However, C++ still allowed global data and global functions, so clashing was still possible. To solve this problem, C++ introduced <emphasis role="italic">namespaces</emphasis> using additional keywords.</para>
        <para>Java was able to avoid all of this by taking a fresh approach. To produce an unambiguous name for a library, the specifier used is not unlike an Internet domain name. In fact, the Java creators want you to use your Internet domain name in reverse since those are guaranteed to be unique. Since my domain name is <emphasis role="bold">BruceEckel.com</emphasis>, my utility library of foibles would be named <emphasis role="bold">com.bruceeckel.utility.foibles</emphasis>. After your reversed domain name, the dots are intended to represent subdirectories.</para>
        <para>In Java 1.0 and Java 1.1 the domain extensions <emphasis role="bold">com</emphasis>, <emphasis role="bold">edu</emphasis>, <emphasis role="bold">org</emphasis>, <emphasis role="bold">net</emphasis>, etc., were capitalized by convention, so the library would appear: <emphasis role="bold">COM.bruceeckel.utility.foibles</emphasis>. Partway through the development of Java 2, however, it was discovered that this caused problems, and so now the entire package name is lowercase.</para>
        <para>This mechanism means that all of your files automatically live in their own namespaces, and each class within a file must have a unique identifier. So you do not need to learn special language features to solve this problem�the language takes care of it for you.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064524"/><anchor xreflabel="Using
other components" xml:id="_Toc375545231"/>Using other components</title>
        <para>Whenever you want to use a predefined class in your program, the compiler must know how to locate it. Of course, the class might already exist in the same source code file that it�s being called from. In that case, you simply use the class�even if the class doesn�t get defined until later in the file. Java eliminates the �forward referencing� problem so you don�t need to think about it.</para>
        <para>What about a class that exists in some other file? You might think that the compiler should be smart enough to simply go and find it, but there is a problem. Imagine that you want to use a class of a particular name, but more than one definition for that class exists (presumably these are different definitions). Or worse, imagine that you�re writing a program, and as you�re building it you add a new class to your library that conflicts with the name of an existing class.</para>
        <para>To solve this problem, you must eliminate all potential ambiguities. This is accomplished by telling the Java compiler exactly what classes you want using the <emphasis role="bold">import</emphasis> keyword. <emphasis role="bold">import </emphasis>tells the compiler to bring in a <emphasis role="italic">package</emphasis>, which is a library of classes. (In other languages, a library could consist of functions and data as well as classes, but remember that all code in Java must be written inside a class.) </para>
        <para>Most of the time you�ll be using components from the standard Java libraries that come with your compiler. With these, you don�t need to worry about long, reversed domain names; you just say, for example:</para>
        <para>import java.util.ArrayList;</para>
        <para> </para>
        <para>to tell the compiler that you want to use Java�s <emphasis role="bold">ArrayList</emphasis> class. However, <emphasis role="bold">util</emphasis> contains a number of classes and you might want to use several of them without declaring them all explicitly. This is easily accomplished by using �<emphasis role="bold">*</emphasis>� to indicate a wild card:</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>It is more common to import a collection of classes in this manner than to import classes individually.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064525"/><anchor xreflabel="The static
keyword" xml:id="_Toc375545232"/>The <emphasis role="bold">static</emphasis> keyword</title>
        <para>Ordinarily, when you create a class you are describing how objects of that class look and how they will behave. You don�t actually get anything until you create an object of that class with <emphasis role="bold">new</emphasis>, and at that point data storage is created and methods become available.</para>
        <para>But there are two situations in which this approach is not sufficient. One is if you want to have only one piece of storage for a particular piece of data, regardless of how many objects are created, or even if no objects are created. The other is if you need a method that isn�t associated with any particular object of this class. That is, you need a method that you can call even if no objects are created. You can achieve both of these effects with the <emphasis role="bold">static</emphasis> keyword. When you say something is <emphasis role="bold">static</emphasis>, it means that data or method is not tied to any particular object instance of that class. So even if you�ve never created an object of that class you can call a <emphasis role="bold">static</emphasis> method or access a piece of <emphasis role="bold">static</emphasis> data. With ordinary, non-<emphasis role="bold">static</emphasis> data and methods you must create an object and use that object to access the data or method, since non-<emphasis role="bold">static</emphasis> data and methods must know the particular object they are working with. Of course, since <emphasis role="bold">static</emphasis> methods don�t need any objects to be created before they are used, they cannot <emphasis role="italic">directly </emphasis>access non-<emphasis role="bold">static</emphasis> members or methods by simply calling those other members without referring to a named object (since non-<emphasis role="bold">static</emphasis> members and methods must be tied to a particular object).</para>
        <para>Some object-oriented languages use the terms <emphasis role="italic">class data</emphasis> and <emphasis role="italic">class methods</emphasis>, meaning that the data and methods exist only for the class as a whole, and not for any particular objects of the class. Sometimes the Java literature uses these terms too.</para>
        <para>To make a data member or method <emphasis role="bold">static</emphasis>, you simply place the keyword before the definition. For example, the following produces a <emphasis role="bold">static</emphasis> data member and initializes it:</para>
        <para>class StaticTest {</para>
        <para>��� static int i = 47;</para>
        <para>}</para>
        <para> </para>
        <para>Now even if you make two <emphasis role="bold">StaticTest</emphasis> objects, there will still be only one piece of storage for <emphasis role="bold">StaticTest.i.</emphasis> Both objects will share the same <emphasis role="bold">i</emphasis>.<emphasis role="bold"/>Consider:</para>
        <para>StaticTest st1 = new StaticTest();</para>
        <para>StaticTest st2 = new StaticTest();</para>
        <para> </para>
        <para>At this point, both <emphasis role="bold">st1.i</emphasis> and <emphasis role="bold">st2.i</emphasis> have the same value of 47 since they refer to the same piece of memory.</para>
        <para>There are two ways to refer to a <emphasis role="bold">static</emphasis> variable. As indicated above, you can name it via an object, by saying, for example, <emphasis role="bold">st2.i</emphasis>. You can also refer to it directly through its class name, something you cannot do with a non-static member. (This is the preferred way to refer to a <emphasis role="bold">static</emphasis> variable since it emphasizes that variable�s <emphasis role="bold">static</emphasis> nature.)</para>
        <para>StaticTest.i++;</para>
        <para> </para>
        <para>The <emphasis role="bold">++</emphasis> operator increments the variable. At this point, both <emphasis role="bold">st1.i</emphasis> and <emphasis role="bold">st2.i</emphasis> will have the value 48.</para>
        <para>Similar logic applies to static methods. You can refer to a static method either through an object as you can with any method, or with the special additional syntax <emphasis role="bold">ClassName.method( )</emphasis>. You define a static method in a similar way:</para>
        <para>class StaticFun {</para>
        <para>� static void incr() { StaticTest.i++; }</para>
        <para>}</para>
        <para> </para>
        <para>You can see that the <emphasis role="bold">StaticFun</emphasis> method <emphasis role="bold">incr( )</emphasis> increments the <emphasis role="bold">static</emphasis> data <emphasis role="bold">i</emphasis>. You can call <emphasis role="bold">incr( )</emphasis> in the typical way, through an object:</para>
        <para>StaticFun sf = new StaticFun();</para>
        <para>sf.incr();</para>
        <para> </para>
        <para>Or, because <emphasis role="bold">incr( ) </emphasis>is a static method, you can call it directly through its class:</para>
        <para>StaticFun.incr();</para>
        <para> </para>
        <para>While <emphasis role="bold">static</emphasis>, when applied to a data member, definitely changes the way the data is created (one for each class vs. the non-<emphasis role="bold">static </emphasis>one for each object), when applied to a method it�s not so dramatic. An important use of <emphasis role="bold">static</emphasis> for methods is to allow you to call that method without creating an object. This is essential, as we will see, in defining the <emphasis role="bold">main( )</emphasis> method that is the entry point for running an application.</para>
        <para>Like any method, a <emphasis role="bold">static</emphasis> method can create or use named objects of its type, so a <emphasis role="bold">static</emphasis> method is often used as a �shepherd� for a flock of instances of its own type.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064526"/><anchor xreflabel="Your
first Java program" xml:id="_Toc375545233"/>Your first Java program</title>
      <para>Finally, here�s the program.<anchor xreflabel="[23]" xml:id="_ftnref23"/>[23] It starts by printing a string, and then the date, using the <emphasis role="bold">Date </emphasis>class from the Java standard library. Note that an additional style of comment is introduced here: the �<emphasis role="bold">//</emphasis>�, which is a comment until the end of the line:</para>
      <para>// HelloDate.java</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>public class HelloDate {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� System.out.println(&quot;Hello, it&apos;s: &quot;);</para>
      <para>��� System.out.println(new Date());</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>At the beginning of each program file, you must place the <emphasis role="bold">import</emphasis> statement to bring in any extra classes you�ll need for the code in that file. Note that I say �extra;� that�s because there�s a certain library of classes that are automatically brought into every Java file: <emphasis role="bold">java.lang</emphasis>. Start up your Web browser and look at the documentation from Sun. (If you haven�t downloaded it from <emphasis role="italic">java.sun.com</emphasis> or otherwise installed the Java documentation, do so now). If you look at the list of the packages, you�ll see all the different class libraries that come with Java. Select <emphasis role="bold">java.lang</emphasis>. This will bring up a list of all the classes that are part of that library. Since <emphasis role="bold">java.lang</emphasis> is implicitly included in every Java code file, these classes are automatically available. There�s no <emphasis role="bold">Date</emphasis> class listed in <emphasis role="bold">java.lang</emphasis>, which means you must import another library to use that. If you don�t know the library where a particular class is, or if you want to see all of the classes, you can select �Tree� in the Java documentation. Now you can find every single class that comes with Java. Then you can use the browser�s �find� function to find <emphasis role="bold">Date</emphasis>.<emphasis role="bold"/>When you do you�ll see it listed as <emphasis role="bold">java.util.Date</emphasis>, which lets you know that it�s in the <emphasis role="bold">util</emphasis> library and that you must <emphasis role="bold">import java.util.*</emphasis> in order to use <emphasis role="bold">Date</emphasis>.</para>
      <para>If you go back to the beginning, select <emphasis role="bold">java.lang</emphasis> and then <emphasis role="bold">System</emphasis>, you�ll see that the <emphasis role="bold">System</emphasis> class has several fields, and if you select <emphasis role="bold">out</emphasis> you�ll discover that it�s a <emphasis role="bold">static</emphasis><emphasis role="bold">PrintStream </emphasis>object. Since it�s <emphasis role="bold">static</emphasis> you don�t need to create anything. The <emphasis role="bold">out</emphasis> object is always there and you can just use it. What you can do with this <emphasis role="bold">out</emphasis> object is determined by the type it is: a <emphasis role="bold">PrintStream</emphasis>. Conveniently, <emphasis role="bold">PrintStream </emphasis>is shown in the description as a hyperlink, so if you click on that you�ll see a list of all the methods you can call for <emphasis role="bold">PrintStream</emphasis>. There are quite a few and these will be covered later in this book. For now all we�re interested in is <emphasis role="bold">println( )</emphasis>, which in effect means �print what I�m giving you out to the console and end with a new line.� Thus, in any Java program you write you can say <emphasis role="bold">System.out.println(�things�)</emphasis> whenever you want to print something to the console.</para>
      <para>The name of the class is the same as the name of the file. When you�re creating a stand-alone program such as this one, one of the classes in the file must have the same name as the file. (The compiler complains if you don�t do this.) That class must contain a method called <emphasis role="bold">main( )</emphasis> with the signature shown:</para>
      <para>public static void main(String[] args) {</para>
      <para> </para>
      <para>The <emphasis role="bold">public</emphasis> keyword means that the method is available to the outside world (described in detail in Chapter 5). The argument to <emphasis role="bold">main( )</emphasis> is an array of <emphasis role="bold">String</emphasis> objects. The <emphasis role="bold">args</emphasis> won�t be used in this program, but the Java compiler insists that they be there because they hold the arguments invoked on the command line.</para>
      <para>The line that prints the date is quite interesting:</para>
      <para>System.out.println(new Date());</para>
      <para> </para>
      <para>Consider the argument: a <emphasis role="bold">Date</emphasis> object is being created just to send its value to <emphasis role="bold">println( )</emphasis>. As soon as this statement is finished, that <emphasis role="bold">Date</emphasis> is unnecessary, and the garbage collector can come along and get it anytime. We don�t need to worry about cleaning it up.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545234"/><anchor xreflabel="Compiling
and running" xml:id="_Toc481064527"/>Compiling and running</title>
        <para>To compile�and run this program, and all the other programs in this book, you must first have a Java programming environment. There are a number of third-party development environments, but in this book we will assume that you are using the JDK from Sun, which is free. If you are using another development system, you will need to look in the documentation for that system to determine how to compile and run programs.</para>
        <para>Get on the Internet and go to <emphasis role="italic">java.sun.com</emphasis>. There you will find information and links that will lead you through the process of downloading and installing the JDK for your particular platform.</para>
        <para>Once the JDK is installed, and you�ve set up your computer�s path information so that it will find <emphasis role="bold">javac</emphasis> and <emphasis role="bold">java</emphasis>, download and unpack the source code for this book (you can find it on the CD ROM that�s bound in with this book, or at <emphasis role="italic">www.BruceEckel.com</emphasis>). This will create a subdirectory for each chapter in this book. Move to subdirectory <emphasis role="bold">c02</emphasis> and type:</para>
        <para>javac HelloDate.java</para>
        <para> </para>
        <para>This command should produce no response. If you get any kind of an error message it means you haven�t installed the JDK properly and you need to investigate those problems. </para>
        <para>On the other hand, if you just get your command prompt back, you can type:</para>
        <para>java HelloDate</para>
        <para> </para>
        <para>and you�ll get the message and the date as output.</para>
        <para>This is the process you can use to compile and run each of the programs in this book. However, you will see that the source code for this book also has a file called <emphasis role="bold">makefile</emphasis> in each chapter, and this contains �make� commands for automatically building the files for that chapter. See this book�s Web page at <emphasis role="italic">www.BruceEckel.com</emphasis> for details on how to use the makefiles.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Comments and embedded
documentation" xml:id="_Toc481064528"/>Comments and embedded documentation</title>
      <para>There are two types of comments in Java. The first is the traditional C-style comment that was inherited by C++. These comments begin with a <emphasis role="bold">/*</emphasis> and continue, possibly across many lines, until a <emphasis role="bold">*/</emphasis>. Note that many programmers will begin each line of a continued comment with a <emphasis role="bold">*</emphasis>, so you�ll often see:</para>
      <para>/* This is a comment</para>
      <para>*� that continues</para>
      <para>*� across lines</para>
      <para>*/</para>
      <para> </para>
      <para>Remember, however, that everything inside the <emphasis role="bold">/*</emphasis> and <emphasis role="bold">*/</emphasis> is ignored, so there�s no difference in saying:</para>
      <para>/* This is a comment that</para>
      <para>continues across lines */</para>
      <para> </para>
      <para>The second form of comment comes from C++. It is the single-line comment, which starts at a <emphasis role="bold">//</emphasis> and continues until the end of the line. This type of comment is convenient and commonly used because it�s easy. You don�t need to hunt on the keyboard to find <emphasis role="bold">/</emphasis> and then <emphasis role="bold">*</emphasis> (instead, you just press the same key twice), and you don�t need to close the comment. So you will often see:</para>
      <para>// this is a one-line comment</para>
      <para> </para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064529"/><anchor xreflabel="Comment
documentation" xml:id="_Toc375545235"/>Comment documentation</title>
        <para>One of the thoughtful parts of the Java language is that the designers didn�t consider writing code to be the only important activity�they also thought about documenting it. Possibly the biggest problem with documenting code has been maintaining that documentation. If the documentation and the code are separate, it becomes a hassle to change the documentation every time you change the code. The solution seems simple: link the code to the documentation. The easiest way to do this is to put everything in the same file. To complete the picture, however, you need a special comment syntax to mark special documentation, and a tool to extract those comments and put them in a useful form. This is what Java has done.</para>
        <para>The tool to extract the comments is called <emphasis role="italic">javadoc.</emphasis> It uses some of the technology from the Java compiler to look for special comment tags you put in your programs. It not only extracts the information marked by these tags, but it also pulls out the class name or method name that adjoins the comment. This way you can get away with the minimal amount of work to generate decent program documentation.</para>
        <para>The output of javadoc is an HTML file that you can view with your Web browser. This tool allows you to create and maintain a single source file and automatically generate useful documentation. Because of javadoc we have a standard for creating documentation, and it�s easy enough that we can expect or even demand documentation with all Java libraries.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064530"/><anchor xreflabel="" xml:id="_Toc375545236"/><anchor xreflabel="Syntax" xml:id="_Ref348399283"/>Syntax</title>
        <para>All of the javadoc commands occur only within <emphasis role="bold">/**</emphasis> comments. The comments end with <emphasis role="bold">*/ </emphasis>as usual. There are two primary ways to use javadoc: embed HTML, or use �doc tags.� Doc tags are commands that start with a �<emphasis role="bold">@</emphasis>� and are placed at the beginning of a comment line. (A leading �<emphasis role="bold">*</emphasis>�, however, is ignored.)</para>
        <para>There are three �types� of comment documentation, which correspond to the element the comment precedes: class, variable, or method. That is, a class comment appears right before the definition of a class; a variable comment appears right in front of the definition of a variable, and a method comment appears right in front of the definition of a method. As a simple example:</para>
        <para>/** A class comment */</para>
        <para>public class docTest {</para>
        <para>� /** A variable comment */</para>
        <para>� public int i;</para>
        <para>� /** A method comment */</para>
        <para>� public void f() {}</para>
        <para>}</para>
        <para> </para>
        <para>Note that javadoc will process comment documentation for only <emphasis role="bold">public </emphasis>and <emphasis role="bold">protected </emphasis>members. Comments for <emphasis role="bold">private </emphasis>and �friendly� members (see Chapter 5) are ignored and you�ll see no output. (However, you can use the <emphasis role="bold">-private </emphasis>flag to include <emphasis role="bold">private</emphasis> members as well.) This makes sense, since only <emphasis role="bold">public</emphasis> and <emphasis role="bold">protected</emphasis> members are available outside the file, which is the client programmer�s perspective. However, all <emphasis role="bold">class</emphasis> comments are included in the output.</para>
        <para>The output for the above code is an HTML file that has the same standard format as all the rest of the Java documentation, so users will be comfortable with the format and can easily navigate your classes. It�s worth entering the above code, sending it through javadoc and viewing the resulting HTML file to see the results.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064531"/><anchor xreflabel="Embedded
HTML" xml:id="_Toc375545237"/>Embedded HTML</title>
        <para>Javadoc passes HTML commands through to the generated HTML document. This allows you full use of HTML; however, the primary motive is to let you format code, such as:</para>
        <para>/**</para>
        <para>* &lt;pre&gt;</para>
        <para>* System.out.println(new Date());</para>
        <para>* &lt;/pre&gt;</para>
        <para>*/</para>
        <para> </para>
        <para>You can also use HTML just as you would in any other Web document to format the regular text in your descriptions:</para>
        <para>/**</para>
        <para>* You can &lt;em&gt;even&lt;/em&gt; insert a list:</para>
        <para>* &lt;ol&gt;</para>
        <para>* &lt;li&gt; Item one</para>
        <para>* &lt;li&gt; Item two</para>
        <para>* &lt;li&gt; Item three</para>
        <para>* &lt;/ol&gt;</para>
        <para>*/</para>
        <para> </para>
        <para>Note that within the documentation comment, asterisks at the beginning of a line are thrown away by javadoc, along with leading spaces. Javadoc reformats everything so that it conforms to the standard documentation appearance. Don�t use headings such as <emphasis role="bold">&lt;h1&gt;</emphasis> or <emphasis role="bold">&lt;hr&gt;</emphasis> as embedded HTML because javadoc inserts its own headings and yours will interfere with them.</para>
        <para>All types of comment documentation�class, variable, and method�can support embedded HTML.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064532"/><anchor xreflabel="@see: referring to other classes" xml:id="_Toc375545238"/><emphasis role="bold">@see</emphasis>: referring to other classes</title>
        <para>All three types of comment documentation (class, variable, and method) can contain <emphasis role="bold">@see</emphasis> tags, which allow you to refer to the documentation in other classes. Javadoc will generate HTML with the <emphasis role="bold">@see</emphasis> tags hyperlinked to the other documentation. The forms are:</para>
        <para>@see classname</para>
        <para>@see fully-qualified-classname</para>
        <para>@see fully-qualified-classname#method-name</para>
        <para> </para>
        <para>Each one adds a hyperlinked �See Also� entry to the generated documentation. Javadoc will not check the hyperlinks you give it to make sure they are valid.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064533"/><anchor xreflabel="Class
documentation tags" xml:id="_Toc375545239"/>Class documentation tags</title>
        <para>Along with embedded HTML and <emphasis role="bold">@see </emphasis>references, class documentation can include tags for version information and the author�s name. Class documentation can also be used for <emphasis role="italic">interfaces</emphasis> (see Chapter 8).</para>
        <section>
          <title>@version</title>
          <para>This is of the form:</para>
          <para>@version version-information</para>
          <para> </para>
          <para>in which <emphasis role="bold">version-information</emphasis> is any significant information you see fit to include. When the <emphasis role="bold">-version</emphasis> flag is placed on the javadoc command line, the version information will be called out specially in the generated HTML documentation.</para>
        </section>
        <section>
          <title>@author</title>
          <para>This is of the form:</para>
          <para>@author author-information</para>
          <para> </para>
          <para>in which <emphasis role="bold">author-information</emphasis> is, presumably, your name, but it could also include your email address or any other appropriate information. When the <emphasis role="bold">-author </emphasis>flag is placed on the javadoc command line, the author information will be called out specially in the generated HTML documentation.</para>
          <para>You can have multiple author tags for a list of authors, but they must be placed consecutively. All the author information will be lumped together into a single paragraph in the generated HTML.</para>
        </section>
        <section>
          <title>@since</title>
          <para>This tag allows you to indicate the version of this code that began using a particular feature. You�ll see it appearing in the HTML Java documentation to indicate what version of the JDK is used.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064534"/><anchor xreflabel="Variable
documentation tags" xml:id="_Toc375545240"/>Variable documentation tags</title>
        <para>Variable documentation can include only embedded HTML and <emphasis role="bold">@see</emphasis> references.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064535"/><anchor xreflabel="Method
documentation tags" xml:id="_Toc375545241"/>Method documentation tags</title>
        <para>As well as embedded documentation and <emphasis role="bold">@see</emphasis> references, methods allow documentation tags for parameters, return values, and exceptions.</para>
        <section>
          <title>@param</title>
          <para>This is of the form:</para>
          <para>@param <emphasis role="italic">parameter</emphasis>-<emphasis role="italic">name</emphasis><emphasis role="italic">description</emphasis></para>
          <para> </para>
          <para>in which <emphasis role="bold">parameter-name </emphasis>is the identifier in the parameter list, and <emphasis role="bold">description </emphasis>is text that can continue on subsequent lines. The description is considered finished when a new documentation tag is encountered. You can have any number of these, presumably one for each parameter.</para>
        </section>
        <section>
          <title>@return</title>
          <para>This is of the form:</para>
          <para>@return <emphasis role="italic">description</emphasis></para>
          <para> </para>
          <para>in which <emphasis role="bold">description</emphasis> gives you the meaning of the return value. It can continue on subsequent lines.</para>
        </section>
        <section>
          <title>@throws</title>
          <para>Exceptions will be demonstrated in Chapter 10, but briefly they are objects that can be �thrown� out of a method if that method fails. Although only one exception object can emerge when you call a method, a particular method might produce any number of different types of exceptions, all of which need descriptions. So the form for the exception tag is:</para>
          <para>@throws <emphasis role="italic">fully-qualified-class-name description</emphasis></para>
          <para> </para>
          <para>in which <emphasis role="bold">fully-qualified-class-name</emphasis> gives an unambiguous name of an exception class that�s defined somewhere, and <emphasis role="bold">description</emphasis> (which can continue on subsequent lines) tells you why this particular type of exception can emerge from the method call.</para>
        </section>
        <section>
          <title>@deprecated</title>
          <para>This is used to tag features that were superseded by an improved feature. The deprecated tag is a suggestion that you no longer use this particular feature, since sometime in the future it is likely to be removed. A method that is marked <emphasis role="bold">@deprecated</emphasis> causes the compiler to issue a warning if it is used.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064536"/><anchor xreflabel="Documentation
example" xml:id="_Toc375545242"/>Documentation example</title>
        <para>�Here is the first Java program again, this time with documentation comments added:</para>
        <para>//: c02:HelloDate.java</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>/** The first Thinking in Java example program.</para>
        <para>�* Displays a string and today&apos;s date.</para>
        <para>�* @author Bruce Eckel</para>
        <para>�* @author www.BruceEckel.com</para>
        <para>�* @version 2.0 </para>
        <para>*/</para>
        <para>public class HelloDate {</para>
        <para>� /** Sole entry point to class &amp; application</para>
        <para>�� * @param args array of string arguments</para>
        <para>�� * @return No return value</para>
        <para>�� * @exception exceptions No exceptions thrown</para>
        <para>� */</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� System.out.println(&quot;Hello, it&apos;s: &quot;);</para>
        <para>��� System.out.println(new Date());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The first line of the file uses my own technique of putting a �<emphasis role="bold">:</emphasis>� as a special marker for the comment line containing the source file name. That line contains the path information to the file (in this case, <emphasis role="bold">c02 </emphasis>indicates Chapter 2) followed by the file name<anchor xreflabel="[24]" xml:id="_ftnref24"/>[24]. The last line also finishes with a comment, and this one indicates the end of the source code listing, which allows it to be automatically extracted from the text of this book and checked with a compiler.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc312373851"/><anchor xreflabel="" xml:id="_Toc481064537"/><anchor xreflabel="Coding style" xml:id="_Toc375545243"/>Coding style</title>
      <para>The unofficial standard in Java is to capitalize the first letter of a class name. If the class name consists of several words, they are run together (that is, you don�t use underscores to separate the names), and the first letter of each embedded word is capitalized, such as:</para>
      <para>class AllTheColorsOfTheRainbow { // ...</para>
      <para> </para>
      <para>For almost everything else: methods, fields (member variables), and object reference names, the accepted style is just as it is for classes <emphasis role="italic">except</emphasis> that the first letter of the identifier is lowercase. For example:</para>
      <para>class AllTheColorsOfTheRainbow {</para>
      <para>� int anIntegerRepresentingColors;</para>
      <para>� void changeTheHueOfTheColor(int newHue) {</para>
      <para>��� // ...</para>
      <para>� }</para>
      <para>� // ...</para>
      <para>}</para>
      <para> </para>
      <para>Of course, you should remember that the user must also type all these long names, and so be merciful. </para>
      <para>The Java code you will see in the Sun libraries also follows the placement of open-and-close curly braces that you see used in this book.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064538"/><anchor xreflabel="Summary" xml:id="_Toc375545244"/>Summary</title>
      <para>In this chapter you have seen enough of Java programming to understand how to write a simple program, and you have gotten an overview of the language and some of its basic ideas. However, the examples so far have all been of the form �do this, then do that, then do something else.� What if you want the program to make choices, such as �if the result of doing this is red, do that; if not, then do something else�? The support in Java for this fundamental programming activity will be covered in the next chapter.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064539"/><anchor xreflabel="Exercises" xml:id="_Toc375545245"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>         1.         Following the <emphasis role="bold">HelloDate.java</emphasis> example in this chapter, create a �hello, world� program that simply prints out that statement. You need only a single method in your class (the �main� one that gets executed when the program starts). Remember to make it <emphasis role="bold">static</emphasis> and to include the argument list, even though you don�t use the argument list. Compile the program with <emphasis role="bold">javac</emphasis> and run it using <emphasis role="bold">java</emphasis>. If you are using a different development environment than the JDK, learn how to compile and run programs in that environment.</para>
      <para>         2.         Find the code fragments involving <emphasis role="bold">ATypeName</emphasis> and turn them into a program that compiles and runs.</para>
      <para>         3.         Turn the <emphasis role="bold">DataOnly</emphasis> code fragments into a program that compiles and runs.</para>
      <para>         4.         Modify Exercise 3 so that the values of the data in <emphasis role="bold">DataOnly</emphasis> are assigned to and printed in <emphasis role="bold">main( )</emphasis>.</para>
      <para>         5.         Write a program that includes and calls the <emphasis role="bold">storage( )</emphasis> method defined as a code fragment in this chapter.</para>
      <para>         6.         Turn the <emphasis role="bold">StaticFun</emphasis> code fragments into a working program.</para>
      <para>         7.         Write a program that prints three arguments taken from the command line. To do this, you�ll need to index into the command-line array of <emphasis role="bold">String</emphasis>s.</para>
      <para>         8.         Turn the <emphasis role="bold">AllTheColorsOfTheRainbow</emphasis> example into a program that compiles and runs.</para>
      <para>         9.         Find the code for the second version of <emphasis role="bold">HelloDate.java</emphasis>, which is the simple comment documentation example. Execute <emphasis role="bold">javadoc</emphasis> on the file and view the results with your Web browser.</para>
      <para>      10.         Turn <emphasis role="bold">docTest</emphasis> into a file that compiles and then run it through <emphasis role="bold">javadoc</emphasis>. Verify the resulting documentation with your Web browser.</para>
      <para>      11.         Add an HTML list of items to the documentation in Exercise 10.</para>
      <para>      12.         Take the program in Exercise 1 and add comment documentation to it. Extract this comment documentation into an HTML file using <emphasis role="bold">javadoc</emphasis> and view it with your Web browser.<anchor xreflabel="" xml:id="_Toc375545246"/><anchor xreflabel="" xml:id="Chapter_3"/></para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064540"/><anchor xreflabel="3: Controlling
Program Flow" xml:id="_Toc477690723"/>3: Controlling Program Flow</title>
    <para>Like a sentient creature, a program must manipulate its world and make choices during execution. </para>
    <para>In Java you manipulate objects and data using operators, and you make choices with execution control statements. Java was inherited from C++, so most of these statements and operators will be familiar to C and C++ programmers. Java has also added some improvements and simplifications.</para>
    <para>If you find yourself floundering a bit in this chapter, make sure you go through the multimedia CD ROM bound into this book: <emphasis role="italic">Thinking in C: Foundations for Java and C++</emphasis>. It contains audio lectures, slides, exercises, and solutions specifically designed to bring you up to speed with the C syntax necessary to learn Java.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064541"/><anchor xreflabel="Using
Java operators" xml:id="_Toc375545247"/>Using Java operators</title>
      <para>An operator takes one or more arguments and produces a new value. The arguments are in a different form than ordinary method calls, but the effect is the same. You should be reasonably comfortable with the general concept of operators from your previous programming experience. Addition (<emphasis role="bold">+</emphasis>), subtraction and unary minus (<emphasis role="bold">-</emphasis>), multiplication (<emphasis role="bold">*</emphasis>), division (<emphasis role="bold">/</emphasis>), and assignment (<emphasis role="bold">=</emphasis>) all work much the same in any programming language.</para>
      <para>All operators produce a value from their operands. In addition, an operator can change the value of an operand. This is called a <emphasis role="italic">side effect</emphasis>. The most common use for operators that modify their operands is to generate the side effect, but you should keep in mind that the value produced is available for your use just as in operators without side effects.</para>
      <para>Almost all operators work only with primitives. The exceptions are <emphasis role="bold">�=</emphasis>�, �<emphasis role="bold">==</emphasis>� and �<emphasis role="bold">!=</emphasis>�, which work with all objects (and are a point of confusion for objects). In addition, the <emphasis role="bold">String </emphasis>class supports �<emphasis role="bold">+</emphasis>� and �<emphasis role="bold">+=</emphasis>�.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064542"/><anchor xreflabel="Precedence" xml:id="_Toc375545248"/>Precedence</title>
        <para>Operator precedence defines how an expression evaluates when several operators are present. Java has specific rules that determine the order of evaluation. The easiest one to remember is that multiplication and division happen before addition and subtraction. Programmers often forget the other precedence rules, so you should use parentheses to make the order of evaluation explicit. For example:</para>
        <para>A = X + Y - 2/2 + Z;</para>
        <para> </para>
        <para>has a very different meaning from the same statement with a particular grouping of parentheses:</para>
        <para>A = X + (Y - 2)/(2 + Z);</para>
        <para> </para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064543"/><anchor xreflabel="Assignment" xml:id="_Toc375545249"/>Assignment</title>
        <para>Assignment is performed with the operator =. It means �take the value of the right-hand side (often called the <emphasis role="italic">rvalue</emphasis>) and copy it into the left-hand side (often called the <emphasis role="italic">lvalue</emphasis>). An rvalue is any constant, variable or expression that can produce a value, but an lvalue must be a distinct, named variable. (That is, there must be a physical space to store a value.) For instance, you can assign a constant value to a variable (<emphasis role="bold">A = 4;</emphasis>), but you cannot assign anything to constant value�it cannot be an lvalue. (You can�t say <emphasis role="bold">4 = A;</emphasis>.)</para>
        <para>Assignment of primitives is quite straightforward. Since the primitive holds the actual value and not a reference to an object, when you assign primitives you copy the contents from one place to another. For example, if you say <emphasis role="bold">A = B</emphasis> for primitives, then the contents of <emphasis role="bold">B</emphasis> are copied into <emphasis role="bold">A</emphasis>. If you then go on to modify <emphasis role="bold">A</emphasis>, <emphasis role="bold">B</emphasis> is naturally unaffected by this modification. As a programmer, this is what you�ve come to expect for most situations.</para>
        <para>When you assign objects, however, things change. Whenever you manipulate an object, what you�re manipulating is the reference, so when you assign �from one object to another� you�re actually copying a reference from one place to another. This means that if you say <emphasis role="bold">C = D</emphasis> for objects, you end up with both <emphasis role="bold">C</emphasis> and <emphasis role="bold">D</emphasis> pointing to the object that, originally, only <emphasis role="bold">D</emphasis> pointed to. The following example will demonstrate this. </para>
        <para><anchor xreflabel="" xml:id="Running_programs"/>Here�s the example:</para>
        <para>//: c03:Assignment.java</para>
        <para>// Assignment with objects is a bit tricky.</para>
        <para> </para>
        <para>class Number {</para>
        <para>� int i;</para>
        <para>}</para>
        <para> </para>
        <para>public class Assignment {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Number n1 = new Number();</para>
        <para>��� Number n2 = new Number();</para>
        <para>��� n1.i = 9;</para>
        <para>��� n2.i = 47;</para>
        <para>��� System.out.println(&quot;1: n1.i: &quot; + n1.i +</para>
        <para>����� &quot;, n2.i: &quot; + n2.i);</para>
        <para>��� n1 = n2;</para>
        <para>��� System.out.println(&quot;2: n1.i: &quot; + n1.i +</para>
        <para>����� &quot;, n2.i: &quot; + n2.i);</para>
        <para>��� n1.i = 27;</para>
        <para>��� System.out.println(&quot;3: n1.i: &quot; + n1.i +</para>
        <para>����� &quot;, n2.i: &quot; + n2.i);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">Number</emphasis> class is simple, and two instances of it (<emphasis role="bold">n1</emphasis> and <emphasis role="bold">n2</emphasis>) are created within <emphasis role="bold">main( )</emphasis>. The <emphasis role="bold">i</emphasis> value within each <emphasis role="bold">Number</emphasis> is given a different value, and then <emphasis role="bold">n2</emphasis> is assigned to <emphasis role="bold">n1</emphasis>, and <emphasis role="bold">n1</emphasis> is changed. In many programming languages you would expect <emphasis role="bold">n1</emphasis> and <emphasis role="bold">n2</emphasis> to be independent at all times, but because you�ve assigned a reference here�s the output you�ll see:</para>
        <para>1: n1.i: 9, n2.i: 47</para>
        <para>2: n1.i: 47, n2.i: 47</para>
        <para>3: n1.i: 27, n2.i: 27</para>
        <para> </para>
        <para>Changing the <emphasis role="bold">n1</emphasis> object appears to change the <emphasis role="bold">n2</emphasis> object as well! This is because both <emphasis role="bold">n1</emphasis> and <emphasis role="bold">n2</emphasis> contain the same reference, which is pointing to the same object. (The original reference that was in <emphasis role="bold">n1</emphasis> that pointed to the object holding a value of 9 was overwritten during the assignment and effectively lost; its object will be cleaned up by the garbage collector.)</para>
        <para>This phenomenon is often called <emphasis role="italic">aliasing</emphasis> and it�s a fundamental way that Java works with objects. But what if you don�t want aliasing to occur in this case? You could forego the assignment and say:</para>
        <para>n1.i = n2.i;</para>
        <para> </para>
        <para>This retains the two separate objects instead of tossing one and tying <emphasis role="bold">n1 </emphasis>and <emphasis role="bold">n2</emphasis> to the same object, but you�ll soon realize that manipulating the fields within objects is messy and goes against good object-oriented design principles. This is a nontrivial topic, so it is left for Appendix A, which is devoted to aliasing. In the meantime, you should keep in mind that assignment for objects can add surprises.</para>
        <section>
          <title>Aliasing during method calls</title>
          <para>Aliasing will also occur when you pass an object into a method:</para>
          <para>//: c03:PassObject.java</para>
          <para>// Passing objects to methods may not be what</para>
          <para>// you&apos;re used to.</para>
          <para> </para>
          <para>class Letter {</para>
          <para>� char c;</para>
          <para>}</para>
          <para> </para>
          <para>public class PassObject {</para>
          <para>� static void f(Letter y) {</para>
          <para>��� y.c = &apos;z&apos;;</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Letter x = new Letter();</para>
          <para>��� x.c = &apos;a&apos;;</para>
          <para>��� System.out.println(&quot;1: x.c: &quot; + x.c);</para>
          <para>��� f(x);</para>
          <para>��� System.out.println(&quot;2: x.c: &quot; + x.c);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>In many programming languages, the method <emphasis role="bold">f( )</emphasis> would appear to be making a copy of its argument <emphasis role="bold">Letter y</emphasis> inside the scope of the method. But once again a reference is being passed so the line</para>
          <para>y.c = &apos;z&apos;;</para>
          <para> </para>
          <para>is actually changing the object outside of <emphasis role="bold">f( )</emphasis>. The output shows this:</para>
          <para>1: x.c: a</para>
          <para>2: x.c: z</para>
          <para> </para>
          <para>Aliasing and its solution is a complex issue and, although you must wait until Appendix A for all the answers, you should be aware of it at this point so you can watch for pitfalls.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064544"/><anchor xreflabel="Mathematical
operators" xml:id="_Toc375545250"/>Mathematical operators</title>
        <para>The basic mathematical operators are the same as the ones available in most programming languages: addition (<emphasis role="bold">+</emphasis>), subtraction (<emphasis role="bold">-</emphasis>), division (<emphasis role="bold">/</emphasis>), multiplication (<emphasis role="bold">*</emphasis>) and modulus (<emphasis role="bold">%</emphasis>, which produces the remainder from integer division). Integer division truncates, rather than rounds, the result.</para>
        <para>Java also uses a shorthand notation to perform an operation and an assignment at the same time. This is denoted by an operator followed by an equal sign, and is consistent with all the operators in the language (whenever it makes sense). For example, to add 4 to the variable <emphasis role="bold">x</emphasis> and assign the result<emphasis role="bold"/>to <emphasis role="bold">x</emphasis>, use: <emphasis role="bold">x += 4</emphasis>. </para>
        <para>This example shows the use of the mathematical operators:</para>
        <para>//: c03:MathOps.java</para>
        <para>// Demonstrates the mathematical operators.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class MathOps {</para>
        <para>� // Create a shorthand to save typing:</para>
        <para>� static void prt(String s) {</para>
        <para>��� System.out.println(s);</para>
        <para>� }</para>
        <para>� // shorthand to print a string and an int:</para>
        <para>� static void pInt(String s, int i) {</para>
        <para>��� prt(s + &quot; = &quot; + i);</para>
        <para>� }</para>
        <para>� // shorthand to print a string and a float:</para>
        <para>� static void pFlt(String s, float f) {</para>
        <para>��� prt(s + &quot; = &quot; + f);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� // Create a random number generator,</para>
        <para>��� // seeds with current time by default:</para>
        <para>��� Random rand = new Random();</para>
        <para>��� int i, j, k;</para>
        <para>��� // &apos;%&apos; limits maximum value to 99:</para>
        <para>��� j = rand.nextInt() % 100;</para>
        <para>��� k = rand.nextInt() % 100;</para>
        <para>��� pInt(&quot;j&quot;,j);� pInt(&quot;k&quot;,k);</para>
        <para>��� i = j + k; pInt(&quot;j + k&quot;, i);</para>
        <para>��� i = j - k; pInt(&quot;j - k&quot;, i);</para>
        <para>��� i = k / j; pInt(&quot;k / j&quot;, i);</para>
        <para>��� i = k * j; pInt(&quot;k * j&quot;, i);</para>
        <para>��� i = k % j; pInt(&quot;k % j&quot;, i);</para>
        <para>��� j %= k; pInt(&quot;j %= k&quot;, j);</para>
        <para>��� // Floating-point number tests:</para>
        <para>��� float u,v,w;� // applies to doubles, too</para>
        <para>��� v = rand.nextFloat();</para>
        <para>��� w = rand.nextFloat();</para>
        <para>��� pFlt(&quot;v&quot;, v); pFlt(&quot;w&quot;, w);</para>
        <para>��� u = v + w; pFlt(&quot;v + w&quot;, u);</para>
        <para>��� u = v - w; pFlt(&quot;v - w&quot;, u);</para>
        <para>��� u = v * w; pFlt(&quot;v * w&quot;, u);</para>
        <para>��� u = v / w; pFlt(&quot;v / w&quot;, u);</para>
        <para>��� // the following also works for</para>
        <para>��� // char, byte, short, int, long,</para>
        <para>��� // and double:</para>
        <para>��� u += v; pFlt(&quot;u += v&quot;, u);</para>
        <para>��� u -= v; pFlt(&quot;u -= v&quot;, u);</para>
        <para>��� u *= v; pFlt(&quot;u *= v&quot;, u);</para>
        <para>��� u /= v; pFlt(&quot;u /= v&quot;, u);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The first thing you will see are some shorthand methods for printing: the <emphasis role="bold">prt( )</emphasis> method prints a <emphasis role="bold">String</emphasis>, the <emphasis role="bold">pInt( )</emphasis> prints a <emphasis role="bold">String</emphasis> followed by an <emphasis role="bold">int</emphasis> and the <emphasis role="bold">pFlt( )</emphasis> prints a <emphasis role="bold">String</emphasis> followed by a <emphasis role="bold">float</emphasis>. Of course, they all ultimately end up using <emphasis role="bold">System.out.println( )</emphasis>.</para>
        <para>To generate numbers, the program first creates a <emphasis role="bold">Random</emphasis> object. Because no arguments are passed during creation, Java uses the current time as a seed for the random number generator. The program generates a number of different types of random numbers with the <emphasis role="bold">Random</emphasis> object simply by calling different methods: <emphasis role="bold">nextInt( )</emphasis>, <emphasis role="bold">nextLong( )</emphasis>,<emphasis role="bold"> nextFloat( )</emphasis> or<emphasis role="bold"> nextDouble( )</emphasis>. </para>
        <para>The modulus operator, when used with the result of the random number generator, limits the result to an upper bound of the operand minus one (99 in this case).</para>
        <section>
          <title>Unary minus and plus operators</title>
          <para>The unary minus (-) and unary plus (+) are the same operators as binary minus and plus. The compiler figures out which use is intended by the way you write the expression. For instance, the statement</para>
          <para>x = -a;</para>
          <para> </para>
          <para>has an obvious meaning. The compiler is able to figure out:</para>
          <para>x = a * -b;</para>
          <para> </para>
          <para>but the reader might get confused, so it is clearer to say:</para>
          <para>x = a * (-b);</para>
          <para> </para>
          <para>The unary minus produces the negative of the value. Unary plus provides symmetry with unary minus, although it doesn�t have any effect.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064545"/><anchor xreflabel="Auto
increment and decrement" xml:id="_Toc375545251"/>Auto increment and decrement</title>
        <para>Java, like C, is full of shortcuts. Shortcuts can make code much easier to type, and either easier or harder to read. </para>
        <para>Two of the nicer shortcuts are the increment and decrement operators (often referred to as the auto-increment and auto-decrement operators). The decrement operator is <emphasis role="bold">--</emphasis> and means �decrease by one unit.� The increment operator is <emphasis role="bold">++</emphasis> and means �increase by one unit.� If <emphasis role="bold">a</emphasis> is an <emphasis role="bold">int</emphasis>, for example, the expression <emphasis role="bold">++a</emphasis> is equivalent to (<emphasis role="bold">a = a + 1</emphasis>). Increment and decrement operators produce the value of the variable as a result. </para>
        <para>There are two versions of each type of operator, often called the prefix and postfix versions. Pre-increment means the <emphasis role="bold">++ </emphasis>operator appears before the variable or expression, and post-increment means the <emphasis role="bold">++</emphasis> operator appears after the variable or expression. Similarly, pre-decrement means the <emphasis role="bold">‑‑ </emphasis>operator appears before the variable or expression, and post-decrement means the <emphasis role="bold">‑‑</emphasis> operator appears after the variable or expression. For pre-increment and pre-decrement, (i.e., <emphasis role="bold">++a</emphasis> or <emphasis role="bold">‑‑a</emphasis>), the operation is performed and the value is produced. For post-increment and post-decrement (i.e. <emphasis role="bold">a++ </emphasis>or <emphasis role="bold">a‑‑</emphasis>), the value is produced, then the operation is performed. As an example:</para>
        <para>//: c03:AutoInc.java</para>
        <para>// Demonstrates the ++ and -- operators.</para>
        <para> </para>
        <para>public class AutoInc {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int i = 1;</para>
        <para>��� prt(&quot;i : &quot; + i);</para>
        <para>��� prt(&quot;++i : &quot; + ++i); // Pre-increment</para>
        <para>��� prt(&quot;i++ : &quot; + i++); // Post-increment</para>
        <para>��� prt(&quot;i : &quot; + i);</para>
        <para>��� prt(&quot;--i : &quot; + --i); // Pre-decrement</para>
        <para>��� prt(&quot;i-- : &quot; + i--); // Post-decrement</para>
        <para>��� prt(&quot;i : &quot; + i);</para>
        <para>� }</para>
        <para>� static void prt(String s) {</para>
        <para>��� System.out.println(s);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The output for this program is:</para>
        <para>i : 1</para>
        <para>++i : 2</para>
        <para>i++ : 2</para>
        <para>i : 3</para>
        <para>--i : 2</para>
        <para>i-- : 2</para>
        <para>i : 1</para>
        <para> </para>
        <para>You can see that for the prefix form you get the value after the operation has been performed, but with the postfix form you get the value before the operation is performed. These are the only operators (other than those involving assignment) that have side effects. (That is, they change the operand rather than using just its value.)</para>
        <para>The increment operator is one explanation for the name C++, implying �one step beyond C.� In an early Java speech, Bill Joy (one of the creators), said that �Java=C++--� (C plus plus minus minus), suggesting that Java is C++ with the unnecessary hard parts removed and therefore a much simpler language. As you progress in this book you�ll see that many parts are simpler, and yet Java isn�t <emphasis role="italic">that </emphasis>much easier than C++. </para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064546"/><anchor xreflabel="Relational
operators" xml:id="_Toc375545252"/>Relational operators</title>
        <para>Relational operators generate a <emphasis role="bold">boolean</emphasis> result. They evaluate the relationship between the values of the operands. A relational expression produces <emphasis role="bold">true</emphasis> if the relationship is true, and <emphasis role="bold">false</emphasis> if the relationship is untrue. The relational operators are less than (&lt;), greater than (&gt;), less than or equal to (&lt;=), greater than or equal to (&gt;=), equivalent (==) and not equivalent (!=). Equivalence and nonequivalence works with all built-in data types, but the other comparisons won�t work with type <emphasis role="bold">boolean</emphasis>.</para>
        <section>
          <title>Testing object equivalence</title>
          <para>The relational operators <emphasis role="bold">==</emphasis> and <emphasis role="bold">!=</emphasis> also work with all objects, but their meaning often confuses the first-time Java programmer. Here�s an example:</para>
          <para>//: c03:Equivalence.java</para>
          <para> </para>
          <para>public class Equivalence {</para>
          <para>� public static void main(String[] args) {</para>
          <para>�� �Integer n1 = new Integer(47);</para>
          <para>��� Integer n2 = new Integer(47);</para>
          <para>��� System.out.println(n1 == n2);</para>
          <para>��� System.out.println(n1 != n2);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The expression <emphasis role="bold">System.out.println(n1 == n2)</emphasis> will print the result of the <emphasis role="bold">boolean</emphasis> comparison within it. Surely the output should be <emphasis role="bold">true</emphasis> and then <emphasis role="bold">false</emphasis>,<emphasis role="bold"/>since both <emphasis role="bold">Integer</emphasis> objects are the same. But while the <emphasis role="italic">contents</emphasis> of the objects are the same, the references are not the same and the operators <emphasis role="bold">==</emphasis> and <emphasis role="bold">!= </emphasis>compare object references. So the output is actually <emphasis role="bold">false</emphasis> and then <emphasis role="bold">true</emphasis>. Naturally, this surprises people at first.</para>
          <para>What if you want to compare the actual contents of an object for equivalence? You must use the special method <emphasis role="bold">equals( )</emphasis> that exists for all objects (not primitives, which work fine with <emphasis role="bold">==</emphasis> and <emphasis role="bold">!=</emphasis>). Here�s how it�s used:</para>
          <para>//: c03:EqualsMethod.java</para>
          <para> </para>
          <para>public class EqualsMethod {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Integer n1 = new Integer(47);</para>
          <para>��� Integer n2 = new Integer(47);</para>
          <para>��� System.out.println(n1.equals(n2));</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The result will be <emphasis role="bold">true</emphasis>, as you would expect. Ah, but it�s not as simple as that. If you create your own class, like this:</para>
          <para>//: c03:EqualsMethod2.java</para>
          <para> </para>
          <para>class Value {</para>
          <para>� int i;</para>
          <para>}</para>
          <para> </para>
          <para>public class EqualsMethod2 {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Value v1 = new Value();</para>
          <para>��� Value v2 = new Value();</para>
          <para>��� v1.i = v2.i = 100;</para>
          <para>��� System.out.println(v1.equals(v2));</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>you�re back to square one: the result is <emphasis role="bold">false</emphasis>. This is because the default behavior of <emphasis role="bold">equals( )</emphasis> is to compare references. So unless you <emphasis role="italic">override</emphasis><emphasis role="bold">equals( )</emphasis> in your new class you won�t get the desired behavior. Unfortunately, you won�t learn about overriding until Chapter 7, but being aware of the way <emphasis role="bold">equals( )</emphasis> behaves might save you some grief in the meantime.</para>
          <para>Most of the Java library classes implement <emphasis role="bold">equals( )</emphasis> so that it compares the contents of objects instead of their references.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064547"/><anchor xreflabel="Logical
operators" xml:id="_Toc375545253"/>Logical operators</title>
        <para>The logical operators AND (&amp;&amp;), OR (||) and NOT (!) produce a <emphasis role="bold">boolean</emphasis> value of <emphasis role="bold">true</emphasis> or <emphasis role="bold">false</emphasis>based on the logical relationship of its arguments. This example uses the relational and logical operators:</para>
        <para>//: c03:Bool.java</para>
        <para>// Relational and logical operators.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class Bool {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Random rand = new Random();</para>
        <para>��� int i = rand.nextInt() % 100;</para>
        <para>��� int j = rand.nextInt() % 100;</para>
        <para>��� prt(&quot;i = &quot; + i);</para>
        <para>��� prt(&quot;j = &quot; + j);</para>
        <para>��� prt(&quot;i &gt; j is &quot; + (i &gt; j));</para>
        <para>��� prt(&quot;i &lt; j is &quot; + (i &lt; j));</para>
        <para>��� prt(&quot;i &gt;= j is &quot; + (i &gt;= j));</para>
        <para>��� prt(&quot;i &lt;= j is &quot; + (i &lt;= j));</para>
        <para>��� prt(&quot;i == j is &quot; + (i == j));</para>
        <para>��� prt(&quot;i != j is &quot; + (i != j));</para>
        <para> </para>
        <para>��� // Treating an int as a boolean is </para>
        <para>��� // not legal Java</para>
        <para>//! prt(&quot;i &amp;&amp; j is &quot; + (i &amp;&amp; j));</para>
        <para>//! prt(&quot;i || j is &quot; + (i || j));</para>
        <para>//! prt(&quot;!i is &quot; + !i);</para>
        <para> </para>
        <para>��� prt(&quot;(i &lt; 10) &amp;&amp; (j &lt; 10) is &quot;</para>
        <para>������ + ((i &lt; 10) &amp;&amp; (j &lt; 10)) );</para>
        <para>��� prt(&quot;(i &lt; 10) || (j &lt; 10) is &quot;</para>
        <para>������ + ((i &lt; 10) || (j &lt; 10)) );</para>
        <para>� }</para>
        <para>� static void prt(String s) {</para>
        <para>��� System.out.println(s);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can apply AND, OR, or NOT to <emphasis role="bold">boolean</emphasis> values only. You can�t use a non-<emphasis role="bold">boolean</emphasis> as if it were a <emphasis role="bold">boolean</emphasis> in a logical expression as you can in C and C++. You can see the failed attempts at doing this commented out with a <emphasis role="bold">//!</emphasis> comment marker. The subsequent expressions, however, produce <emphasis role="bold">boolean</emphasis> values using relational comparisons, then use logical operations on the results.</para>
        <para>One output listing looked like this:</para>
        <para>i = 85</para>
        <para>j = 4</para>
        <para>i &gt; j is true</para>
        <para>i &lt; j is false</para>
        <para>i &gt;= j is true</para>
        <para>i &lt;= j is false</para>
        <para>i == j is false</para>
        <para>i != j is true</para>
        <para>(i &lt; 10) &amp;&amp; (j &lt; 10) is false</para>
        <para>(i &lt; 10) || (j &lt; 10) is true</para>
        <para> </para>
        <para>Note that a <emphasis role="bold">boolean</emphasis> value is automatically converted to an appropriate text form if it�s used where a <emphasis role="bold">String</emphasis> is expected.</para>
        <para>You can replace the definition for <emphasis role="bold">int</emphasis> in the above program with any other primitive data type except <emphasis role="bold">boolean</emphasis>. Be aware, however, that the comparison of floating-point numbers is very strict. A number that is the tiniest fraction different from another number is still �not equal.� A number that is the tiniest bit above zero is still nonzero.</para>
        <section>
          <title>Short-circuiting</title>
          <para>When dealing with logical operators you run into a phenomenon called �short circuiting.� This means that the expression will be evaluated only <emphasis role="italic">until</emphasis> the truth or falsehood of the entire expression can be unambiguously determined. As a result, all the parts of a logical expression might not be evaluated. Here�s an example that demonstrates short-circuiting:</para>
          <para>//: c03:ShortCircuit.java</para>
          <para>// Demonstrates short-circuiting behavior.</para>
          <para>// with logical operators.</para>
          <para> </para>
          <para>public class ShortCircuit {</para>
          <para>� static boolean test1(int val) {</para>
          <para>��� System.out.println(&quot;test1(&quot; + val + &quot;)&quot;);</para>
          <para>��� System.out.println(&quot;result: &quot; + (val &lt; 1));</para>
          <para>��� return val &lt; 1;</para>
          <para>� }</para>
          <para>� static boolean test2(int val) {</para>
          <para>��� System.out.println(&quot;test2(&quot; + val + &quot;)&quot;);</para>
          <para>��� System.out.println(&quot;result: &quot; + (val &lt; 2));</para>
          <para>��� return val &lt; 2;</para>
          <para>� }</para>
          <para>� static boolean test3(int val) {</para>
          <para>��� System.out.println(&quot;test3(&quot; + val + &quot;)&quot;);</para>
          <para>��� System.out.println(&quot;result: &quot; + (val &lt; 3));</para>
          <para>��� return val &lt; 3;</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� if(test1(0) &amp;&amp; test2(2) &amp;&amp; test3(2))</para>
          <para>����� System.out.println(&quot;expression is true&quot;);</para>
          <para>��� else</para>
          <para>����� System.out.println(&quot;expression is false&quot;);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>Each test performs a comparison against the argument and returns true or false. It also prints information to show you that it�s being called. The tests are used in the expression:</para>
          <para>if(test1(0) &amp;&amp; test2(2) &amp;&amp; test3(2))</para>
          <para> </para>
          <para>You might naturally think that all three tests would be executed, but the output shows otherwise:</para>
          <para>test1(0)</para>
          <para>result: true</para>
          <para>test2(2)</para>
          <para>result: false</para>
          <para>expression is false</para>
          <para> </para>
          <para>The first test produced a <emphasis role="bold">true</emphasis> result, so the expression evaluation continues. However, the second test produced a <emphasis role="bold">false</emphasis> result. Since this means that the whole expression must be <emphasis role="bold">false</emphasis>, why continue evaluating the rest of the expression? It could be expensive. The reason for short-circuiting, in fact, is precisely that; you can get a potential performance increase if all the parts of a logical expression do not need to be evaluated.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064548"/><anchor xreflabel="Bitwise
operators" xml:id="_Toc375545254"/>Bitwise operators</title>
        <para>The bitwise operators allow you to manipulate individual bits in an integral primitive data type. Bitwise operators perform boolean algebra on the corresponding bits in the two arguments to produce the result.</para>
        <para>The bitwise operators come from C�s low-level orientation; you were often manipulating hardware directly and had to set the bits in hardware registers. Java was originally designed to be embedded in TV set-top boxes, so this low-level orientation still made sense. However, you probably won�t use the bitwise operators much.</para>
        <para>The bitwise AND operator (<emphasis role="bold">&amp;</emphasis>) produces a one in the output bit if both input bits are one; otherwise it produces a zero. The bitwise OR operator (<emphasis role="bold">|</emphasis>) produces a one in the output bit if either input bit is a one and produces a zero only if both input bits are zero. The bitwise EXCLUSIVE OR, or XOR (<emphasis role="bold">^</emphasis>), produces a one in the output bit if one or the other input bit is a one, but not both. The bitwise NOT (<emphasis role="bold">~</emphasis>, also called the <emphasis role="italic">ones complement </emphasis>operator) is a unary operator; it takes only one argument. (All other bitwise operators are binary operators.) Bitwise NOT produces the opposite of the input bit�a one if the input bit is zero, a zero if the input bit is one.</para>
        <para>The bitwise operators and logical operators use the same characters, so it is helpful to have a mnemonic device to help you remember the meanings: since bits are �small,� there is only one character in the bitwise operators.</para>
        <para>Bitwise operators can be combined with the <emphasis role="bold">=</emphasis> sign to unite the operation and assignment: <emphasis role="bold">&amp;=</emphasis>, <emphasis role="bold">|=</emphasis> and <emphasis role="bold">^=</emphasis> are all legitimate. (Since <emphasis role="bold">~</emphasis> is a unary operator it cannot be combined with the <emphasis role="bold">=</emphasis> sign.)</para>
        <para>The <emphasis role="bold">boolean</emphasis> type is treated as a one-bit value so it is somewhat different. You can perform a bitwise AND, OR and XOR, but you can�t perform a bitwise NOT (presumably to prevent confusion with the logical NOT). For <emphasis role="bold">boolean</emphasis>s the bitwise operators have the same effect as the logical operators except that they do not short circuit. Also, bitwise operations on <emphasis role="bold">boolean</emphasis>s include an XOR logical operator that is not included under the list of �logical� operators. You�re prevented from using <emphasis role="bold">boolean</emphasis>s in shift expressions, which is described next.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064549"/><anchor xreflabel="Shift
operators" xml:id="_Toc375545255"/>Shift operators</title>
        <para>The shift operators also manipulate bits. They can be used solely with primitive, integral types. The left-shift operator (<emphasis role="bold">&lt;&lt;</emphasis>) produces the operand to the left of the operator shifted to the left by the number of bits specified after the operator (inserting zeroes at the lower-order bits). The signed right-shift operator (<emphasis role="bold">&gt;&gt;</emphasis>) produces the operand to the left of the operator shifted to the right by the number of bits specified after the operator. The signed right shift <emphasis role="bold">&gt;&gt; </emphasis>uses <emphasis role="italic">sign extension</emphasis>: if the value is positive, zeroes are inserted at the higher-order bits; if the value is negative, ones are inserted at the higher-order bits. Java has also added the unsigned right shift <emphasis role="bold">&gt;&gt;&gt;, </emphasis>which<emphasis role="bold"/>uses <emphasis role="italic">zero extension</emphasis>: regardless of the sign, zeroes are inserted at the higher-order bits.<emphasis role="italic"/>This operator does not exist in C or C++.</para>
        <para>If you shift a <emphasis role="bold">char</emphasis>, <emphasis role="bold">byte,</emphasis> or <emphasis role="bold">short</emphasis>, it will be promoted to <emphasis role="bold">int</emphasis> before the shift takes place, and the result will be an <emphasis role="bold">int</emphasis>. Only the five low-order bits of the right-hand side will be used. This prevents you from shifting more than the number of bits in an <emphasis role="bold">int</emphasis>. If you�re operating on a <emphasis role="bold">long</emphasis>, you�ll get a <emphasis role="bold">long</emphasis> result. Only the six low-order bits of the right-hand side will be used so you can�t shift more than the number of bits in a <emphasis role="bold">long</emphasis>. </para>
        <para>Shifts can be combined with the equal sign (<emphasis role="bold">&lt;&lt;=</emphasis> or <emphasis role="bold">&gt;&gt;=</emphasis> or <emphasis role="bold">&gt;&gt;&gt;=</emphasis>). The lvalue is replaced by the lvalue shifted by the rvalue. There is a problem, however, with the unsigned right shift combined with assignment. If you use it with <emphasis role="bold">byte</emphasis> or <emphasis role="bold">short</emphasis> you don�t get the correct results. Instead, these are promoted to <emphasis role="bold">int</emphasis> and right shifted, but then truncated as they are assigned back into their variables, so you get <emphasis role="bold">-1</emphasis> in those cases. The following example demonstrates this:</para>
        <para>//: c03:URShift.java</para>
        <para>// Test of unsigned right shift.</para>
        <para> </para>
        <para>public class URShift {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int i = -1;</para>
        <para>��� i &gt;&gt;&gt;= 10;</para>
        <para>��� System.out.println(i);</para>
        <para>��� long l = -1;</para>
        <para>��� l &gt;&gt;&gt;= 10;</para>
        <para>��� System.out.println(l);</para>
        <para>��� short s = -1;</para>
        <para>��� s &gt;&gt;&gt;= 10;</para>
        <para>��� System.out.println(s);</para>
        <para>��� byte b = -1;</para>
        <para>��� b &gt;&gt;&gt;= 10;</para>
        <para>��� System.out.println(b);</para>
        <para>��� b = -1;</para>
        <para>��� System.out.println(b&gt;&gt;&gt;10);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In the last line, the resulting value is not assigned back into <emphasis role="bold">b</emphasis>, but is printed directly and so the correct behavior occurs.</para>
        <para>Here�s an example that demonstrates the use of all the operators involving bits:</para>
        <para>//: c03:BitManipulation.java</para>
        <para>// Using the bitwise operators.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class BitManipulation {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Random rand = new Random();</para>
        <para>��� int i = rand.nextInt();</para>
        <para>��� int j = rand.nextInt();</para>
        <para>��� pBinInt(&quot;-1&quot;, -1);</para>
        <para>��� pBinInt(&quot;+1&quot;, +1);</para>
        <para>��� int maxpos = 2147483647;</para>
        <para>��� pBinInt(&quot;maxpos&quot;, maxpos);</para>
        <para>��� int maxneg = -2147483648;</para>
        <para>��� pBinInt(&quot;maxneg&quot;, maxneg);</para>
        <para>��� pBinInt(&quot;i&quot;, i);</para>
        <para>��� pBinInt(&quot;~i&quot;, ~i);</para>
        <para>��� pBinInt(&quot;-i&quot;, -i);</para>
        <para>��� pBinInt(&quot;j&quot;, j);</para>
        <para>��� pBinInt(&quot;i &amp; j&quot;, i &amp; j);</para>
        <para>��� pBinInt(&quot;i | j&quot;, i | j);</para>
        <para>��� pBinInt(&quot;i ^ j&quot;, i ^ j);</para>
        <para>��� pBinInt(&quot;i &lt;&lt; 5&quot;, i &lt;&lt; 5);</para>
        <para>��� pBinInt(&quot;i &gt;&gt; 5&quot;, i &gt;&gt; 5);</para>
        <para>��� pBinInt(&quot;(~i) &gt;&gt; 5&quot;, (~i) &gt;&gt; 5);</para>
        <para>��� pBinInt(&quot;i &gt;&gt;&gt; 5&quot;, i &gt;&gt;&gt; 5);</para>
        <para>��� pBinInt(&quot;(~i) &gt;&gt;&gt; 5&quot;, (~i) &gt;&gt;&gt; 5);</para>
        <para> </para>
        <para>��� long l = rand.nextLong();</para>
        <para>��� long m = rand.nextLong();</para>
        <para>��� pBinLong(&quot;-1L&quot;, -1L);</para>
        <para>��� pBinLong(&quot;+1L&quot;, +1L);</para>
        <para>��� long ll = 9223372036854775807L;</para>
        <para>��� pBinLong(&quot;maxpos&quot;, ll);</para>
        <para>��� long lln = -9223372036854775808L;</para>
        <para>��� pBinLong(&quot;maxneg&quot;, lln);</para>
        <para>��� pBinLong(&quot;l&quot;, l);</para>
        <para>��� pBinLong(&quot;~l&quot;, ~l);</para>
        <para>��� pBinLong(&quot;-l&quot;, -l);</para>
        <para>��� pBinLong(&quot;m&quot;, m);</para>
        <para>��� pBinLong(&quot;l &amp; m&quot;, l &amp; m);</para>
        <para>��� pBinLong(&quot;l | m&quot;, l | m);</para>
        <para>��� pBinLong(&quot;l ^ m&quot;, l ^ m);</para>
        <para>��� pBinLong(&quot;l &lt;&lt; 5&quot;, l &lt;&lt; 5);</para>
        <para>��� pBinLong(&quot;l &gt;&gt; 5&quot;, l &gt;&gt; 5);</para>
        <para>��� pBinLong(&quot;(~l) &gt;&gt; 5&quot;, (~l) &gt;&gt; 5);</para>
        <para>��� pBinLong(&quot;l &gt;&gt;&gt; 5&quot;, l &gt;&gt;&gt; 5);</para>
        <para>��� pBinLong(&quot;(~l) &gt;&gt;&gt; 5&quot;, (~l) &gt;&gt;&gt; 5);</para>
        <para>� }</para>
        <para>� static void pBinInt(String s, int i) {</para>
        <para>��� System.out.println(</para>
        <para>����� s + &quot;, int: &quot; + i + &quot;, binary: &quot;);</para>
        <para>��� System.out.print(&quot;�� &quot;);</para>
        <para>��� for(int j = 31; j &gt;=0; j--)</para>
        <para>����� if(((1 &lt;&lt; j) &amp;� i) != 0)</para>
        <para>������� System.out.print(&quot;1&quot;);</para>
        <para>����� else</para>
        <para>������� System.out.print(&quot;0&quot;);</para>
        <para>��� System.out.println();</para>
        <para>� }</para>
        <para>� static void pBinLong(String s, long l) {</para>
        <para>��� System.out.println(</para>
        <para>����� s + &quot;, long: &quot; + l + &quot;, binary: &quot;);</para>
        <para>��� System.out.print(&quot;�� &quot;);</para>
        <para>��� for(int i = 63; i &gt;=0; i--)</para>
        <para>����� if(((1L &lt;&lt; i) &amp; l) != 0)</para>
        <para>������� System.out.print(&quot;1&quot;);</para>
        <para>����� else</para>
        <para>������� System.out.print(&quot;0&quot;);</para>
        <para>��� System.out.println();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The two methods at the end, <emphasis role="bold">pBinInt( )</emphasis> and <emphasis role="bold">pBinLong( )</emphasis> take an <emphasis role="bold">int</emphasis> or a <emphasis role="bold">long</emphasis>, respectively, and print it out in binary format along with a descriptive string. You can ignore the implementation of these for now.</para>
        <para>You�ll note the use of <emphasis role="bold">System.out.print( )</emphasis> instead of <emphasis role="bold">System.out.println( )</emphasis>. The <emphasis role="bold">print( )</emphasis> method does not emit a new line, so it allows you to output a line in pieces.</para>
        <para>As well as demonstrating the effect of all the bitwise operators for <emphasis role="bold">int</emphasis> and <emphasis role="bold">long</emphasis>, this example also shows the minimum, maximum, +1 and -1 values for <emphasis role="bold">int</emphasis> and <emphasis role="bold">long</emphasis> so you can see what they look like. Note that the high bit represents the sign: 0 means positive and 1 means negative. The output for the <emphasis role="bold">int</emphasis> portion looks like this:</para>
        <para>-1, int: -1, binary: </para>
        <para>�� 11111111111111111111111111111111</para>
        <para>+1, int: 1, binary: </para>
        <para>�� 00000000000000000000000000000001</para>
        <para>maxpos, int: 2147483647, binary: </para>
        <para>�� 01111111111111111111111111111111</para>
        <para>maxneg, int: -2147483648, binary: </para>
        <para>�� 10000000000000000000000000000000</para>
        <para>i, int: 59081716, binary: </para>
        <para>�� 00000011100001011000001111110100</para>
        <para>~i, int: -59081717, binary: </para>
        <para>�� 11111100011110100111110000001011</para>
        <para>-i, int: -59081716, binary: </para>
        <para>�� 11111100011110100111110000001100</para>
        <para>j, int: 198850956, binary: </para>
        <para>�� 00001011110110100011100110001100</para>
        <para>i &amp; j, int: 58720644, binary: </para>
        <para>�� 00000011100000000000000110000100</para>
        <para>i | j, int: 199212028, binary: </para>
        <para>�� 00001011110111111011101111111100</para>
        <para>i ^ j, int: 140491384, binary: </para>
        <para>�� 00001000010111111011101001111000</para>
        <para>i &lt;&lt; 5, int: 1890614912, binary: </para>
        <para>�� 01110000101100000111111010000000</para>
        <para>i &gt;&gt; 5, int: 1846303, binary: </para>
        <para>�� 00000000000111000010110000011111</para>
        <para>(~i) &gt;&gt; 5, int: -1846304, binary: </para>
        <para>�� 11111111111000111101001111100000</para>
        <para>i &gt;&gt;&gt; 5, int: 1846303, binary: </para>
        <para>�� 00000000000111000010110000011111</para>
        <para>(~i) &gt;&gt;&gt; 5, int: 132371424, binary: </para>
        <para>�� 00000111111000111101001111100000</para>
        <para> </para>
        <para>The binary representation of the numbers is referred to as <emphasis role="italic">signed two�s complement</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064550"/><anchor xreflabel="Ternary
if-else operator" xml:id="_Toc375545256"/>Ternary if-else operator</title>
        <para>This operator is unusual because it has three operands. It is truly an operator because it produces a value, unlike the ordinary if-else statement that you�ll see in the next section of this chapter. The expression is of the form:</para>
        <para>boolean-exp ? value0 : value1</para>
        <para> </para>
        <para>If <emphasis role="italic">boolean-exp</emphasis> evaluates to <emphasis role="bold">true</emphasis>, <emphasis role="italic">value0</emphasis> is evaluated and its result becomes the value produced by the operator. If <emphasis role="italic">boolean-exp</emphasis> is <emphasis role="bold">false</emphasis>, <emphasis role="italic">value1</emphasis> is evaluated and its result becomes the value produced by the operator.</para>
        <para>Of course, you could use an ordinary <emphasis role="bold">if-else </emphasis>statement (described later), but the ternary operator is much terser. Although C (where this operator originated) prides itself on being a terse language, and the ternary operator might have been introduced partly for efficiency, you should be somewhat wary of using it on an everyday basis�it�s easy to produce unreadable code.</para>
        <para>The conditional operator can be used for its side effects or for the value it produces, but in general you want the value since that�s what makes the operator distinct from the <emphasis role="bold">if-else</emphasis>. Here�s an example:</para>
        <para>static int ternary(int i) {</para>
        <para>� return i &lt; 10 ? i * 100 : i * 10;</para>
        <para>} </para>
        <para> </para>
        <para>You can see that this code is more compact than what you�d need to write without the ternary operator:</para>
        <para>static int alternative(int i) {</para>
        <para>� if (i &lt; 10)</para>
        <para>��� return i * 100;</para>
        <para>� else</para>
        <para>��� return i * 10;</para>
        <para>}</para>
        <para> </para>
        <para>The second form is easier to understand, and doesn�t require a lot more typing. So be sure to ponder your reasons when choosing the ternary operator.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064551"/><anchor xreflabel="The
comma operator" xml:id="_Toc375545257"/>The comma operator</title>
        <para>The comma is used in C and C++ not only as a separator in function argument lists, but also as an operator for sequential evaluation. The sole place that the comma <emphasis role="italic">operator</emphasis> is used in Java is in <emphasis role="bold">for</emphasis> loops, which will be described later in this chapter.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064552"/><anchor xreflabel="String operator +" xml:id="_Toc375545258"/><emphasis role="bold">String</emphasis> operator +</title>
        <para>There�s one special usage of an operator in Java: the <emphasis role="bold">+</emphasis> operator can be used to concatenate strings, as you�ve already seen. It seems a natural use of the <emphasis role="bold">+</emphasis> even though it doesn�t fit with the traditional way that <emphasis role="bold">+</emphasis> is used. This capability seemed like a good idea in C++, so <emphasis role="italic">operator overloading</emphasis> was added to C++ to allow the C++ programmer to add meanings to almost any operator. Unfortunately, operator overloading combined with some of the other restrictions in C++ turns out to be a fairly complicated feature for programmers to design into their classes. Although operator overloading would have been much simpler to implement in Java than it was in C++, this feature was still considered too complex, so Java programmers cannot implement their own overloaded operators as C++ programmers can.</para>
        <para>The use of the <emphasis role="bold">String +</emphasis> has some interesting behavior. If an expression begins with a <emphasis role="bold">String</emphasis>, then all operands that follow must be <emphasis role="bold">String</emphasis>s (remember that the compiler will turn a quoted sequence of characters into a <emphasis role="bold">String</emphasis>):</para>
        <para>int x = 0, y = 1, z = 2;</para>
        <para>String sString = &quot;x, y, z &quot;;</para>
        <para>System.out.println(sString + x + y + z);</para>
        <para> </para>
        <para>Here, the Java compiler will convert <emphasis role="bold">x</emphasis>, <emphasis role="bold">y</emphasis>, and <emphasis role="bold">z</emphasis> into their <emphasis role="bold">String</emphasis> representations instead of adding them together first. And if you say:</para>
        <para>System.out.println(x + sString);</para>
        <para> </para>
        <para>Java will turn <emphasis role="bold">x </emphasis>into a <emphasis role="bold">String</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064553"/><anchor xreflabel="Common
pitfalls when using operators" xml:id="_Toc375545259"/>Common pitfalls when using operators</title>
        <para>One of the pitfalls when using operators is trying to get away without parentheses when you are even the least bit uncertain about how an expression will evaluate. This is still true in Java.</para>
        <para>An extremely common error in C and C++ looks like this:</para>
        <para>while(x = y) {</para>
        <para>��� // ....</para>
        <para>}</para>
        <para> </para>
        <para>The programmer was trying to test for equivalence (<emphasis role="bold">==</emphasis>) rather than do an assignment. In C and C++ the result of this assignment will always be <emphasis role="bold">true</emphasis> if <emphasis role="bold">y </emphasis>is nonzero, and you�ll probably get an infinite loop. In Java, the result of this expression is not a <emphasis role="bold">boolean,</emphasis> and the compiler expects a <emphasis role="bold">boolean</emphasis> and won�t convert from an <emphasis role="bold">int</emphasis>, so it will conveniently give you a compile-time error and catch the problem before you ever try to run the program. So the pitfall never happens in Java. (The only time you won�t get a compile-time error is when <emphasis role="bold">x</emphasis> and <emphasis role="bold">y</emphasis> are <emphasis role="bold">boolean</emphasis>, in which case <emphasis role="bold">x = y</emphasis> is a legal expression, and in the above case, probably an error.)</para>
        <para>A similar problem in C and C++ is using bitwise AND and OR instead of the logical versions. Bitwise AND and OR use one of the characters (<emphasis role="bold">&amp;</emphasis> or <emphasis role="bold">|</emphasis>) while logical AND and OR use two (<emphasis role="bold">&amp;&amp;</emphasis> and <emphasis role="bold">||</emphasis>). Just as with <emphasis role="bold">=</emphasis> and <emphasis role="bold">==</emphasis>, it�s easy to type just one character instead of two. In Java, the compiler again prevents this because it won�t let you cavalierly use one type where it doesn�t belong.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064554"/><anchor xreflabel="Casting
operators" xml:id="_Toc375545260"/>Casting operators</title>
        <para>The word <emphasis role="italic">cast</emphasis> is used in the sense of �casting into a mold.� Java will automatically change one type of data into another when appropriate. For instance, if you assign an integral value to a floating-point variable, the compiler will automatically convert the <emphasis role="bold">int</emphasis> to a <emphasis role="bold">float</emphasis>. Casting allows you to make this type conversion explicit, or to force it when it wouldn�t normally happen.</para>
        <para>To perform a cast, put the desired data type (including all modifiers) inside parentheses to the left of any value. Here�s an example:</para>
        <para>void casts() {</para>
        <para>� int i = 200;</para>
        <para>� long l = (long)i;</para>
        <para>� long l2 = (long)200;</para>
        <para>}</para>
        <para> </para>
        <para>As you can see, it�s possible to perform a cast on a numeric value as well as on a variable. In both casts shown here, however, the cast is superfluous, since the compiler will automatically promote an <emphasis role="bold">int</emphasis> value to a <emphasis role="bold">long</emphasis> when necessary. However, you are allowed to use superfluous casts in to make a point or to make your code more clear. In other situations, a cast may be essential just to get the code to compile.</para>
        <para>In C and C++, casting can cause some headaches. In Java, casting is safe, with the exception that when you perform a so-called <emphasis role="italic">narrowing conversion</emphasis> (that is, when you go from a data type that can hold more information to one that doesn�t hold as much) you run the risk of losing information.<emphasis role="italic"/>Here the compiler forces you to do a cast, in effect saying �this can be a dangerous thing to do�if you want me to do it anyway you must make the cast explicit.� With a <emphasis role="italic">widening conversion</emphasis> an explicit cast is not needed because the new type will more than hold the information from the old type so that no information is ever lost.</para>
        <para>Java allows you to cast any primitive type to any other primitive type, except for <emphasis role="bold">boolean,</emphasis> which doesn�t allow any casting at all. Class types do not allow casting. To convert one to the other there must be special methods. (<emphasis role="bold">String</emphasis> is a special case, and you�ll find out later in this book that objects can be cast within a <emphasis role="italic">family</emphasis> of types; an <emphasis role="bold">Oak</emphasis> can be cast to a <emphasis role="bold">Tree</emphasis> and vice-versa, but not to a foreign type such as a <emphasis role="bold">Rock</emphasis>.)</para>
        <section>
          <title>Literals</title>
          <para>Ordinarily when you insert a literal value into a program the compiler knows exactly what type to make it. Sometimes, however, the type is ambiguous. When this happens you must guide the compiler by adding some extra information in the form of characters associated with the literal value. The following code shows these characters:</para>
          <para>//: c03:Literals.java</para>
          <para> </para>
          <para>class Literals {</para>
          <para>� char c = 0xffff; // max char hex value</para>
          <para>� byte b = 0x7f; // max byte hex value</para>
          <para>� short s = 0x7fff; // max short hex value</para>
          <para>� int i1 = 0x2f; // Hexadecimal (lowercase)</para>
          <para>� int i2 = 0X2F; // Hexadecimal (uppercase)</para>
          <para>� int i3 = 0177; // Octal (leading zero)</para>
          <para>� // Hex and Oct also work with long.</para>
          <para>� long n1 = 200L; // long suffix</para>
          <para>� long n2 = 200l; // long suffix</para>
          <para>� long n3 = 200;</para>
          <para>� //! long l6(200); // not allowed</para>
          <para>� float f1 = 1;</para>
          <para>� float f2 = 1F; // float suffix</para>
          <para>� float f3 = 1f; // float suffix</para>
          <para>� float f4 = 1e-45f; // 10 to the power</para>
          <para>� float f5 = 1e+9f; // float suffix</para>
          <para>� double d1 = 1d; // double suffix</para>
          <para>� double d2 = 1D; // double suffix</para>
          <para>� double d3 = 47e47d; // 10 to the power</para>
          <para>} ///:~</para>
          <para> </para>
          <para>Hexadecimal (base 16), which works with all the integral data types, is denoted by a leading <emphasis role="bold">0x</emphasis> or <emphasis role="bold">0X</emphasis> followed by 0�9 and a�f either in upper or lowercase. If you try to initialize a variable with a value bigger than it can hold (regardless of the numerical form of the value), the compiler will give you an error message. Notice in the above code the maximum possible hexadecimal values for <emphasis role="bold">char</emphasis>, <emphasis role="bold">byte,</emphasis> and <emphasis role="bold">short</emphasis>. If you exceed these, the compiler will automatically make the value an <emphasis role="bold">int</emphasis> and tell you that you need a narrowing cast for the assignment. You�ll know you�ve stepped over the line.</para>
          <para>Octal (base 8) is denoted by a leading zero in the number and digits from 0-7. There is no literal representation for binary numbers in C, C++ or Java.</para>
          <para>A trailing character after a literal value establishes its type. Upper or lowercase <emphasis role="bold">L </emphasis>means <emphasis role="bold">long</emphasis>, upper or lowercase <emphasis role="bold">F</emphasis> means <emphasis role="bold">float</emphasis> and upper or lowercase <emphasis role="bold">D</emphasis> means <emphasis role="bold">double</emphasis>.</para>
          <para>Exponents use a notation that I�ve always found rather dismaying: <emphasis role="bold">1.39 e-47f</emphasis>. In science and engineering, �e� refers to the base of natural logarithms, approximately 2.718. (A more precise <emphasis role="bold">double </emphasis>value is available in Java as <emphasis role="bold">Math.E</emphasis>.) This is used in exponentiation expressions such as 1.39 x e<superscript>-47</superscript>, which means 1.39 x 2.718<superscript>-47</superscript>. However, when FORTRAN was invented they decided that <emphasis role="bold">e</emphasis> would naturally mean �ten to the power,� which is an odd decision because FORTRAN was designed for science and engineering and one would think its designers would be sensitive about introducing such an ambiguity.<anchor xreflabel="[25]" xml:id="_ftnref25"/>[25] At any rate, this custom was followed in C, C++ and now Java. So if you�re used to thinking in terms of <emphasis role="bold">e</emphasis> as the base of natural logarithms, you must do a mental translation when you see an expression such as <emphasis role="bold">1.39 e-47f</emphasis> in Java; it means 1.39 x 10<superscript>-47</superscript>. </para>
          <para>Note that you don�t need to use the trailing character when the compiler can figure out the appropriate type. With</para>
          <para>long n3 = 200;</para>
          <para> </para>
          <para>there�s no ambiguity, so an <emphasis role="bold">L</emphasis> after the 200 would be superfluous. However, with</para>
          <para>float f4 = 1e-47f; // 10 to the power</para>
          <para> </para>
          <para>the compiler normally takes exponential numbers as doubles, so without the trailing <emphasis role="bold">f</emphasis> it will give you an error telling you that you must use a cast to convert <emphasis role="bold">double</emphasis> to <emphasis role="bold">float</emphasis>.</para>
        </section>
        <section>
          <title>Promotion</title>
          <para>You�ll discover that if you perform any mathematical or bitwise operations on primitive data types that are smaller than an <emphasis role="bold">int</emphasis> (that is, <emphasis role="bold">char</emphasis>, <emphasis role="bold">byte,</emphasis> or <emphasis role="bold">short</emphasis>), those values will be promoted to <emphasis role="bold">int</emphasis> before performing the operations, and the resulting value will be of type <emphasis role="bold">int</emphasis>. So if you want to assign back into the smaller type, you must use a cast. (And, since you�re assigning back into a smaller type, you might be losing information.) In general, the largest data type in an expression is the one that determines the size of the result of that expression; if you multiply a <emphasis role="bold">float</emphasis> and a <emphasis role="bold">double</emphasis>, the result will be <emphasis role="bold">double</emphasis>; if you add an <emphasis role="bold">int</emphasis> and a <emphasis role="bold">long</emphasis>, the result will be <emphasis role="bold">long</emphasis>.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064555"/><anchor xreflabel="Java has
no �sizeof�" xml:id="_Toc375545261"/>Java has no �sizeof�</title>
        <para>In C and C++, the <emphasis role="bold">sizeof( )</emphasis> operator satisfies a specific need: it tells you the number of bytes allocated for data items. The most compelling need for <emphasis role="bold">sizeof( )</emphasis> in C and C++ is portability. Different data types might be different sizes on different machines, so the programmer must find out how big those types are when performing operations that are sensitive to size. For example, one computer might store integers in 32 bits, whereas another might store integers as 16 bits. Programs could store larger values in integers on the first machine. As you might imagine, portability is a huge headache for C and C++ programmers.</para>
        <para>Java does not need a <emphasis role="bold">sizeof( )</emphasis> operator for this purpose because all the data types are the same size on all machines. You do not need to think about portability on this level�it is designed into the language.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064556"/><anchor xreflabel="Precedence
revisited" xml:id="_Toc375545262"/>Precedence revisited</title>
        <para>Upon hearing me complain about the complexity of remembering operator precedence during one of my seminars, a student suggested a mnemonic that is simultaneously a commentary: �Ulcer Addicts Really Like C A lot.�</para>
        <informaltable frame="all">
          <tgroup cols="3">
            <colspec colname="c1" colwidth="10*"/>
            <colspec colname="c2" colwidth="17*"/>
            <colspec colname="c3" colwidth="17*"/>
            <tbody>
              <row>
                <entry valign="top"><para> Mnemonic</para></entry>
                <entry valign="top"><para> Operator type</para></entry>
                <entry valign="top"><para> Operators</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Ulcer</para></entry>
                <entry valign="top"><para> Unary</para></entry>
                <entry valign="top"><para> + - ++--</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Addicts</para></entry>
                <entry valign="top"><para> Arithmetic (and shift)</para></entry>
                <entry valign="top"><para> * / % + -� &lt;&lt; &gt;&gt;</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Really</para></entry>
                <entry valign="top"><para> Relational</para></entry>
                <entry valign="top"><para> &gt; &lt; &gt;= &lt;= == !=</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Like</para></entry>
                <entry valign="top"><para> Logical (and bitwise)</para></entry>
                <entry valign="top"><para> &amp;&amp; ||� &amp;� |� ^ </para></entry>
              </row>
              <row>
                <entry valign="top"><para> C</para></entry>
                <entry valign="top"><para> Conditional (ternary)</para></entry>
                <entry valign="top"><para> A &gt; B ? X : Y</para></entry>
              </row>
              <row>
                <entry valign="top"><para> A Lot</para></entry>
                <entry valign="top"><para> Assignment</para></entry>
                <entry valign="top"><para> = (and compound assignment like *=)</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>Of course, with the shift and bitwise operators distributed around the table it is not a perfect mnemonic, but for non-bit operations it works.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064557"/><anchor xreflabel="A
compendium of operators" xml:id="_Toc375545263"/>A compendium of operators</title>
        <para>The following example shows which primitive data types can be used with particular operators. Basically, it is the same example repeated over and over, but using different primitive data types. The file will compile without error because the lines that would cause errors are commented out with a <emphasis role="bold">//!</emphasis>.</para>
        <para>//: c03:AllOps.java</para>
        <para>// Tests all the operators on all the</para>
        <para>// primitive data types to show which</para>
        <para>// ones are accepted by the Java compiler.</para>
        <para> </para>
        <para>class AllOps {</para>
        <para>� // To accept the results of a boolean test:</para>
        <para>� void f(boolean b) {}</para>
        <para>� void boolTest(boolean x, boolean y) {</para>
        <para>��� // Arithmetic operators:</para>
        <para>��� //! x = x * y;</para>
        <para>��� //! x = x / y;</para>
        <para>��� //! x = x % y;</para>
        <para>��� //! x = x + y;</para>
        <para>��� //! x = x - y;</para>
        <para>�� �//! x++;</para>
        <para>��� //! x--;</para>
        <para>��� //! x = +y;</para>
        <para>��� //! x = -y;</para>
        <para>��� // Relational and logical:</para>
        <para>��� //! f(x &gt; y);</para>
        <para>��� //! f(x &gt;= y);</para>
        <para>��� //! f(x &lt; y);</para>
        <para>��� //! f(x &lt;= y);</para>
        <para>��� f(x == y);</para>
        <para>��� f(x != y);</para>
        <para>��� f(!y);</para>
        <para>��� x = x &amp;&amp; y;</para>
        <para>��� x = x || y;</para>
        <para>��� // Bitwise operators:</para>
        <para>��� //! x = ~y;</para>
        <para>��� x = x &amp; y;</para>
        <para>��� x = x | y;</para>
        <para>��� x = x ^ y;</para>
        <para>��� //! x = x &lt;&lt; 1;</para>
        <para>��� //! x = x &gt;&gt; 1;</para>
        <para>��� //! x = x &gt;&gt;&gt; 1;</para>
        <para>��� // Compound assignment:</para>
        <para>��� //! x += y;</para>
        <para>��� //! x -= y;</para>
        <para>��� //! x *= y;</para>
        <para>��� //! x /= y;</para>
        <para>��� //! x %= y;</para>
        <para>��� //! x &lt;&lt;= 1;</para>
        <para>��� //! x &gt;&gt;= 1;</para>
        <para>��� //! x &gt;&gt;&gt;= 1;</para>
        <para>��� x &amp;= y;</para>
        <para>��� x ^= y;</para>
        <para>��� x |= y;</para>
        <para>��� // Casting:</para>
        <para>��� //! char c = (char)x;</para>
        <para>��� //! byte B = (byte)x;</para>
        <para>��� //! short s = (short)x;</para>
        <para>��� //! int i = (int)x;</para>
        <para>��� //! long l = (long)x;</para>
        <para>��� //! float f = (float)x;</para>
        <para>��� //! double d = (double)x;</para>
        <para>� }</para>
        <para>� void charTest(char x, char y) {</para>
        <para>��� // Arithmetic operators:</para>
        <para>��� x = (char)(x * y);</para>
        <para>��� x = (char)(x / y);</para>
        <para>��� x = (char)(x % y);</para>
        <para>��� x = (char)(x + y);</para>
        <para>��� x = (char)(x - y);</para>
        <para>��� x++;</para>
        <para>��� x--;</para>
        <para>��� x = (char)+y;</para>
        <para>��� x = (char)-y;</para>
        <para>��� // Relational and logical:</para>
        <para>��� f(x &gt; y);</para>
        <para>��� f(x &gt;= y);</para>
        <para>��� f(x &lt; y);</para>
        <para>��� f(x &lt;= y);</para>
        <para>��� f(x == y);</para>
        <para>��� f(x != y);</para>
        <para>��� //! f(!x);</para>
        <para>��� //! f(x &amp;&amp; y);</para>
        <para>��� //! f(x || y);</para>
        <para>��� // Bitwise operators:</para>
        <para>��� x= (char)~y;</para>
        <para>��� x = (char)(x &amp; y);</para>
        <para>��� x� = (char)(x | y);</para>
        <para>��� x = (char)(x ^ y);</para>
        <para>��� x = (char)(x &lt;&lt; 1);</para>
        <para>��� x = (char)(x &gt;&gt; 1);</para>
        <para>��� x = (char)(x &gt;&gt;&gt; 1);</para>
        <para>��� // Compound assignment:</para>
        <para>��� x += y;</para>
        <para>��� x -= y;</para>
        <para>��� x *= y;</para>
        <para>��� x /= y;</para>
        <para>��� x %= y;</para>
        <para>��� x &lt;&lt;= 1;</para>
        <para>��� x &gt;&gt;= 1;</para>
        <para>��� x &gt;&gt;&gt;= 1;</para>
        <para>��� x &amp;= y;</para>
        <para>��� x ^= y;</para>
        <para>��� x |= y;</para>
        <para>��� // Casting:</para>
        <para>��� //! boolean b = (boolean)x;</para>
        <para>��� byte B = (byte)x;</para>
        <para>��� short s = (short)x;</para>
        <para>��� int i = (int)x;</para>
        <para>��� long l = (long)x;</para>
        <para>��� float f = (float)x;</para>
        <para>��� double d = (double)x;</para>
        <para>� }</para>
        <para>� void byteTest(byte x, byte y) {</para>
        <para>��� // Arithmetic operators:</para>
        <para>��� x = (byte)(x* y);</para>
        <para>��� x = (byte)(x / y);</para>
        <para>��� x = (byte)(x % y);</para>
        <para>��� x = (byte)(x + y);</para>
        <para>��� x = (byte)(x - y);</para>
        <para>��� x++;</para>
        <para>��� x--;</para>
        <para>��� x = (byte)+ y;</para>
        <para>��� x = (byte)- y;</para>
        <para>��� // Relational and logical:</para>
        <para>��� f(x &gt; y);</para>
        <para>��� f(x &gt;= y);</para>
        <para>��� f(x &lt; y);</para>
        <para>��� f(x &lt;= y);</para>
        <para>��� f(x == y);</para>
        <para>��� f(x != y);</para>
        <para>��� //! f(!x);</para>
        <para>��� //! f(x &amp;&amp; y);</para>
        <para>��� //! f(x || y);</para>
        <para>��� // Bitwise operators:</para>
        <para>��� x = (byte)~y;</para>
        <para>��� x = (byte)(x &amp; y);</para>
        <para>��� x = (byte)(x | y);</para>
        <para>��� x = (byte)(x ^ y);</para>
        <para>��� x = (byte)(x &lt;&lt; 1);</para>
        <para>��� x = (byte)(x &gt;&gt; 1);</para>
        <para>��� x = (byte)(x &gt;&gt;&gt; 1);</para>
        <para>��� // Compound assignment:</para>
        <para>��� x += y;</para>
        <para>��� x -= y;</para>
        <para>��� x *= y;</para>
        <para>��� x /= y;</para>
        <para>��� x %= y;</para>
        <para>��� x &lt;&lt;= 1;</para>
        <para>��� x &gt;&gt;= 1;</para>
        <para>��� x &gt;&gt;&gt;= 1;</para>
        <para>��� x &amp;= y;</para>
        <para>��� x ^= y;</para>
        <para>��� x |= y;</para>
        <para>��� // Casting:</para>
        <para>��� //! boolean b = (boolean)x;</para>
        <para>��� char c = (char)x;</para>
        <para>��� short s = (short)x;</para>
        <para>��� int i = (int)x;</para>
        <para>��� long l = (long)x;</para>
        <para>��� float f = (float)x;</para>
        <para>��� double d = (double)x;</para>
        <para>� }</para>
        <para>� void shortTest(short x, short y) {</para>
        <para>��� // Arithmetic operators:</para>
        <para>��� x = (short)(x * y);</para>
        <para>��� x = (short)(x / y);</para>
        <para>��� x = (short)(x % y);</para>
        <para>��� x = (short)(x + y);</para>
        <para>��� x = (short)(x - y);</para>
        <para>��� x++;</para>
        <para>��� x--;</para>
        <para>��� x = (short)+y;</para>
        <para>��� x = (short)-y;</para>
        <para>��� // Relational and logical:</para>
        <para>��� f(x &gt; y);</para>
        <para>��� f(x &gt;= y);</para>
        <para>��� f(x &lt; y);</para>
        <para>��� f(x &lt;= y);</para>
        <para>��� f(x == y);</para>
        <para>��� f(x != y);</para>
        <para>��� //! f(!x);</para>
        <para>��� //! f(x &amp;&amp; y);</para>
        <para>�� �//! f(x || y);</para>
        <para>��� // Bitwise operators:</para>
        <para>��� x = (short)~y;</para>
        <para>��� x = (short)(x &amp; y);</para>
        <para>��� x = (short)(x | y);</para>
        <para>��� x = (short)(x ^ y);</para>
        <para>��� x = (short)(x &lt;&lt; 1);</para>
        <para>��� x = (short)(x &gt;&gt; 1);</para>
        <para>��� x = (short)(x &gt;&gt;&gt; 1);</para>
        <para>��� // Compound assignment:</para>
        <para>��� x += y;</para>
        <para>��� x -= y;</para>
        <para>��� x *= y;</para>
        <para>��� x /= y;</para>
        <para>��� x %= y;</para>
        <para>��� x &lt;&lt;= 1;</para>
        <para>��� x &gt;&gt;= 1;</para>
        <para>��� x &gt;&gt;&gt;= 1;</para>
        <para>��� x &amp;= y;</para>
        <para>��� x ^= y;</para>
        <para>��� x |= y;</para>
        <para>��� // Casting:</para>
        <para>��� //! boolean b = (boolean)x;</para>
        <para>��� char c = (char)x;</para>
        <para>��� byte B = (byte)x;</para>
        <para>��� int i = (int)x;</para>
        <para>��� long l = (long)x;</para>
        <para>��� float f = (float)x;</para>
        <para>��� double d = (double)x;</para>
        <para>� }</para>
        <para>� void intTest(int x, int y) {</para>
        <para>��� // Arithmetic operators:</para>
        <para>��� x = x * y;</para>
        <para>��� x = x / y;</para>
        <para>��� x = x % y;</para>
        <para>��� x = x + y;</para>
        <para>��� x = x - y;</para>
        <para>��� x++;</para>
        <para>��� x--;</para>
        <para>��� x = +y;</para>
        <para>��� x = -y;</para>
        <para>��� // Relational and logical:</para>
        <para>��� f(x &gt; y);</para>
        <para>��� f(x &gt;= y);</para>
        <para>��� f(x &lt; y);</para>
        <para>��� f(x &lt;= y);</para>
        <para>��� f(x == y);</para>
        <para>��� f(x != y);</para>
        <para>��� //! f(!x);</para>
        <para>��� //! f(x &amp;&amp; y);</para>
        <para>��� //! f(x || y);</para>
        <para>��� // Bitwise operators:</para>
        <para>��� x = ~y;</para>
        <para>��� x = x &amp; y;</para>
        <para>��� x = x | y;</para>
        <para>��� x = x ^ y;</para>
        <para>��� x = x &lt;&lt; 1;</para>
        <para>��� x = x &gt;&gt; 1;</para>
        <para>��� x = x &gt;&gt;&gt; 1;</para>
        <para>��� // Compound assignment:</para>
        <para>��� x += y;</para>
        <para>��� x -= y;</para>
        <para>��� x *= y;</para>
        <para>��� x /= y;</para>
        <para>��� x %= y;</para>
        <para>��� x &lt;&lt;= 1;</para>
        <para>��� x &gt;&gt;= 1;</para>
        <para>��� x &gt;&gt;&gt;= 1;</para>
        <para>��� x &amp;= y;</para>
        <para>��� x ^= y;</para>
        <para>��� x |= y;</para>
        <para>��� // Casting:</para>
        <para>��� //! boolean b = (boolean)x;</para>
        <para>��� char c = (char)x;</para>
        <para>��� byte B = (byte)x;</para>
        <para>��� short s = (short)x;</para>
        <para>��� long l = (long)x;</para>
        <para>��� float f = (float)x;</para>
        <para>��� double d = (double)x;</para>
        <para>� }</para>
        <para>� void longTest(long x, long y) {</para>
        <para>��� // Arithmetic operators:</para>
        <para>��� x = x * y;</para>
        <para>��� x = x / y;</para>
        <para>��� x = x % y;</para>
        <para>��� x = x + y;</para>
        <para>��� x = x - y;</para>
        <para>��� x++;</para>
        <para>��� x--;</para>
        <para>��� x = +y;</para>
        <para>��� x = -y;</para>
        <para>��� // Relational and logical:</para>
        <para>��� f(x &gt; y);</para>
        <para>��� f(x &gt;= y);</para>
        <para>��� f(x &lt; y);</para>
        <para>��� f(x &lt;= y);</para>
        <para>��� f(x == y);</para>
        <para>��� f(x != y);</para>
        <para>��� //! f(!x);</para>
        <para>��� //! f(x &amp;&amp; y);</para>
        <para>��� //! f(x || y);</para>
        <para>��� // Bitwise operators:</para>
        <para>��� x = ~y;</para>
        <para>��� x = x &amp; y;</para>
        <para>��� x = x | y;</para>
        <para>��� x = x ^ y;</para>
        <para>��� x = x &lt;&lt; 1;</para>
        <para>��� x = x &gt;&gt; 1;</para>
        <para>��� x = x &gt;&gt;&gt; 1;</para>
        <para>��� // Compound assignment:</para>
        <para>��� x += y;</para>
        <para>��� x -= y;</para>
        <para>��� x *= y;</para>
        <para>��� x /= y;</para>
        <para>��� x %= y;</para>
        <para>��� x &lt;&lt;= 1;</para>
        <para>��� x &gt;&gt;= 1;</para>
        <para>��� x &gt;&gt;&gt;= 1;</para>
        <para>��� x &amp;= y;</para>
        <para>��� x ^= y;</para>
        <para>��� x |= y;</para>
        <para>� ��// Casting:</para>
        <para>��� //! boolean b = (boolean)x;</para>
        <para>��� char c = (char)x;</para>
        <para>��� byte B = (byte)x;</para>
        <para>��� short s = (short)x;</para>
        <para>��� int i = (int)x;</para>
        <para>��� float f = (float)x;</para>
        <para>��� double d = (double)x;</para>
        <para>� }</para>
        <para>� void floatTest(float x, float y) {</para>
        <para>��� // Arithmetic operators:</para>
        <para>� ��x = x * y;</para>
        <para>��� x = x / y;</para>
        <para>��� x = x % y;</para>
        <para>��� x = x + y;</para>
        <para>��� x = x - y;</para>
        <para>��� x++;</para>
        <para>��� x--;</para>
        <para>��� x = +y;</para>
        <para>��� x = -y;</para>
        <para>��� // Relational and logical:</para>
        <para>��� f(x &gt; y);</para>
        <para>��� f(x &gt;= y);</para>
        <para>��� f(x &lt; y);</para>
        <para>��� f(x &lt;= y);</para>
        <para>��� f(x == y);</para>
        <para>��� f(x != y);</para>
        <para>��� //! f(!x);</para>
        <para>��� //! f(x &amp;&amp; y);</para>
        <para>��� //! f(x || y);</para>
        <para>��� // Bitwise operators:</para>
        <para>��� //! x = ~y;</para>
        <para>��� //! x = x &amp; y;</para>
        <para>��� //! x = x | y;</para>
        <para>��� //! x = x ^ y;</para>
        <para>��� //! x = x &lt;&lt; 1;</para>
        <para>��� //! x = x &gt;&gt; 1;</para>
        <para>��� //! x = x &gt;&gt;&gt; 1;</para>
        <para>��� // Compound assignment:</para>
        <para>��� x += y;</para>
        <para>��� x -= y;</para>
        <para>��� x *= y;</para>
        <para>��� x /= y;</para>
        <para>��� x %= y;</para>
        <para>��� //! x &lt;&lt;= 1;</para>
        <para>��� //! x &gt;&gt;= 1;</para>
        <para>��� //! x &gt;&gt;&gt;= 1;</para>
        <para>��� //! x &amp;= y;</para>
        <para>��� //! x ^= y;</para>
        <para>��� //! x |= y;</para>
        <para>��� // Casting:</para>
        <para>��� //! boolean b = (boolean)x;</para>
        <para>��� char c = (char)x;</para>
        <para>��� byte B = (byte)x;</para>
        <para>��� short s = (short)x;</para>
        <para>��� int i = (int)x;</para>
        <para>��� long l = (long)x;</para>
        <para>��� double d = (double)x;</para>
        <para>� }</para>
        <para>� void doubleTest(double x, double y) {</para>
        <para>��� // Arithmetic operators:</para>
        <para>��� x = x * y;</para>
        <para>��� x = x / y;</para>
        <para>��� x = x % y;</para>
        <para>��� x = x + y;</para>
        <para>��� x = x - y;</para>
        <para>��� x++;</para>
        <para>��� x--;</para>
        <para>��� x = +y;</para>
        <para>��� x = -y;</para>
        <para>��� // Relational and logical:</para>
        <para>��� f(x &gt; y);</para>
        <para>��� f(x &gt;= y);</para>
        <para>��� f(x &lt; y);</para>
        <para>��� f(x &lt;= y);</para>
        <para>��� f(x == y);</para>
        <para>��� f(x != y);</para>
        <para>��� //! f(!x);</para>
        <para>��� //! f(x &amp;&amp; y);</para>
        <para>��� //! f(x || y);</para>
        <para>��� // Bitwise operators:</para>
        <para>��� //! x = ~y;</para>
        <para>��� //! x = x &amp; y;</para>
        <para>��� //! x = x | y;</para>
        <para>��� //! x = x ^ y;</para>
        <para>��� //! x = x &lt;&lt; 1;</para>
        <para>��� //! x = x &gt;&gt; 1;</para>
        <para>��� //! x = x &gt;&gt;&gt; 1;</para>
        <para>��� // Compound assignment:</para>
        <para>��� x += y;</para>
        <para>��� x -= y;</para>
        <para>��� x *= y;</para>
        <para>��� x /= y;</para>
        <para>��� x %= y;</para>
        <para>��� //! x &lt;&lt;= 1;</para>
        <para>��� //! x &gt;&gt;= 1;</para>
        <para>��� //! x &gt;&gt;&gt;= 1;</para>
        <para>��� //! x &amp;= y;</para>
        <para>��� //! x ^= y;</para>
        <para>��� //! x |= y;</para>
        <para>��� // Casting:</para>
        <para>��� //! boolean b = (boolean)x;</para>
        <para>��� char c = (char)x;</para>
        <para>��� byte B = (byte)x;</para>
        <para>��� short s = (short)x;</para>
        <para>��� int i = (int)x;</para>
        <para>��� long l = (long)x;</para>
        <para>��� float f = (float)x;</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Note that <emphasis role="bold">boolean</emphasis> is quite limited. You can assign to it the values <emphasis role="bold">true</emphasis> and <emphasis role="bold">false</emphasis>, and you can test it for truth or falsehood, but you cannot add booleans or perform any other type of operation on them.</para>
        <para>In <emphasis role="bold">char</emphasis>, <emphasis role="bold">byte</emphasis>, and <emphasis role="bold">short</emphasis> you can see the effect of promotion with the arithmetic operators. Each arithmetic operation on any of those types results in an <emphasis role="bold">int</emphasis> result, which must be explicitly cast back to the original type (a narrowing conversion that might lose information) to assign back to that type. With <emphasis role="bold">int</emphasis> values, however, you do not need to cast, because everything is already an <emphasis role="bold">int</emphasis>. Don�t be lulled into thinking everything is safe, though. If you multiply two <emphasis role="bold">int</emphasis>s that are big enough, you�ll overflow the result. The following example demonstrates this:</para>
        <para>//: c03:Overflow.java</para>
        <para>// Surprise! Java lets you overflow.</para>
        <para> </para>
        <para>public class Overflow {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int big = 0x7fffffff; // max int value</para>
        <para>��� prt(&quot;big = &quot; + big);</para>
        <para>��� int bigger = big * 4;</para>
        <para>��� prt(&quot;bigger = &quot; + bigger);</para>
        <para>� }</para>
        <para>� static void prt(String s) {</para>
        <para>��� System.out.println(s);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The output of this is:</para>
        <para>big = 2147483647</para>
        <para>bigger = -4</para>
        <para> </para>
        <para>and you get no errors or warnings from the compiler, and no exceptions at run-time. Java is good, but it�s not <emphasis role="italic">that</emphasis> good.</para>
        <para>Compound assignments do <emphasis role="italic">not</emphasis> require casts for <emphasis role="bold">char</emphasis>, <emphasis role="bold">byte,</emphasis> or <emphasis role="bold">short</emphasis>, even though they are performing promotions that have the same results as the direct arithmetic operations. On the other hand, the lack of the cast certainly simplifies the code.</para>
        <para>You can see that, with the exception of <emphasis role="bold">boolean</emphasis>, any primitive type can be cast to any other primitive type. Again, you must be aware of the effect of a narrowing conversion  when casting to a smaller type, otherwise you might unknowingly lose information during the cast.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064558"/><anchor xreflabel="Execution
control" xml:id="_Toc375545264"/>Execution control</title>
      <para>Java uses all of C�s execution control statements, so if you�ve programmed with C or C++ then most of what you see will be familiar. Most procedural programming languages have some kind of control statements, and there is often overlap among languages. In Java, the keywords include <emphasis role="bold">if-else</emphasis>, <emphasis role="bold">while</emphasis>, <emphasis role="bold">do-while</emphasis>, <emphasis role="bold">for</emphasis>, and a selection statement called <emphasis role="bold">switch</emphasis>. Java does not, however, support the much-maligned <emphasis role="bold">goto</emphasis> (which can still be the most expedient way to solve certain types of problems). You can still do a goto-like jump, but it is much more constrained than a typical <emphasis role="bold">goto</emphasis>.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064559"/><anchor xreflabel="true
and false" xml:id="_Toc375545265"/>true and false</title>
        <para>All conditional statements use the truth or falsehood of a conditional expression to determine the execution path. An example of a conditional expression is <emphasis role="bold">A == B</emphasis>. This uses the conditional operator <emphasis role="bold">==</emphasis> to see if the value of <emphasis role="bold">A</emphasis> is equivalent to the value of <emphasis role="bold">B</emphasis>. The expression returns <emphasis role="bold">true</emphasis> or <emphasis role="bold">false</emphasis>. Any of the relational operators you�ve seen earlier in this chapter can be used to produce a conditional statement. Note that Java doesn�t allow you to use a number as a <emphasis role="bold">boolean</emphasis>, even though it�s allowed in C and C++ (where truth is nonzero and falsehood is zero). If you want to use a non-<emphasis role="bold">boolean</emphasis> in a <emphasis role="bold">boolean</emphasis> test, such as <emphasis role="bold">if(a)</emphasis>, you must first convert it to a <emphasis role="bold">boolean</emphasis> value using a conditional expression, such as <emphasis role="bold">if(a != 0)</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064560"/><anchor xreflabel="if-else" xml:id="_Toc375545266"/>if-else</title>
        <para>The <emphasis role="bold">if-else</emphasis> statement is probably the most basic way to control program flow. The <emphasis role="bold">else</emphasis> is optional, so you can use <emphasis role="bold">if</emphasis> in two forms:</para>
        <para><emphasis role="bold">if(</emphasis>Boolean-expression<emphasis role="bold">)</emphasis></para>
        <para>� statement</para>
        <para> </para>
        <para>or</para>
        <para><emphasis role="bold">if(</emphasis>Boolean-expression<emphasis role="bold">)</emphasis></para>
        <para>� statement</para>
        <para><emphasis role="bold">else</emphasis></para>
        <para>� statement</para>
        <para> </para>
        <para>The conditional must produce a <emphasis role="bold">boolean</emphasis> result. The <emphasis role="italic">statement</emphasis> means either a simple statement terminated by a semicolon or a compound statement, which is a group of simple statements enclosed in braces. Any time the word �<emphasis role="italic">statement</emphasis>� is used, it always implies that the statement can be simple or compound. </para>
        <para>As an example of <emphasis role="bold">if-else</emphasis>, here is a<emphasis role="bold"> test( ) </emphasis>method that will tell you whether a guess is above, below, or equivalent to a target number:</para>
        <para>//: c03:IfElse.java</para>
        <para>public class IfElse {</para>
        <para>� static int test(int testval, int target) {</para>
        <para>��� int result = 0;</para>
        <para>��� if(testval &gt; target)</para>
        <para>����� result = +1;</para>
        <para>��� else if(testval &lt; target)</para>
        <para>����� result = -1;</para>
        <para>��� else</para>
        <para>����� result = 0; // Match</para>
        <para>��� return result;</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� System.out.println(test(10, 5));</para>
        <para>��� System.out.println(test(5, 10));</para>
        <para>��� System.out.println(test(5, 5));</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>It is conventional to indent the body of a control flow statement so the reader might easily determine where it begins and ends.</para>
        <section>
          <title><emphasis role="bold">return</emphasis></title>
          <para>The <emphasis role="bold">return</emphasis> keyword has two purposes: it specifies what value a method will return (if it doesn�t have a <emphasis role="bold">void</emphasis> return value) and it causes that value to be returned immediately. The <emphasis role="bold">test( )</emphasis> method above can be rewritten to take advantage of this:</para>
          <para>//: c03:IfElse2.java</para>
          <para>public class IfElse2 {</para>
          <para>� static int test(int testval, int target) {</para>
          <para>��� int result = 0;</para>
          <para>��� if(testval &gt; target)</para>
          <para>����� return +1;</para>
          <para>��� else if(testval &lt; target)</para>
          <para>����� return -1;</para>
          <para>��� else</para>
          <para>����� return 0; // Match</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� System.out.println(test(10, 5));</para>
          <para>��� System.out.println(test(5, 10));</para>
          <para>��� System.out.println(test(5, 5));</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>�There�s no need for <emphasis role="bold">else</emphasis> because the method will not continue after executing a <emphasis role="bold">return</emphasis>.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064561"/><anchor xreflabel="Iteration" xml:id="_Toc375545267"/>Iteration</title>
        <para><emphasis role="bold">while</emphasis>, <emphasis role="bold">do-while</emphasis> and <emphasis role="bold">for</emphasis> control looping and are sometimes classified as <emphasis role="italic">iteration statements</emphasis>. A <emphasis role="italic">statement</emphasis> repeats until the controlling <emphasis role="italic">Boolean</emphasis>-<emphasis role="italic">expression</emphasis> evaluates to false. The form for a <emphasis role="bold">while</emphasis> loop is</para>
        <para><emphasis role="bold">while(</emphasis>Boolean-expression<emphasis role="bold">)</emphasis></para>
        <para><emphasis role="bold">� </emphasis>statement</para>
        <para> </para>
        <para>The <emphasis role="italic">Boolean-expression</emphasis> is evaluated once at the beginning of the loop and again before each further iteration of the <emphasis role="italic">statement</emphasis>.</para>
        <para>Here�s a simple example that generates random numbers until a particular condition is met:</para>
        <para>//: c03:WhileTest.java</para>
        <para>// Demonstrates the while loop.</para>
        <para> </para>
        <para>public class WhileTest {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� double r = 0;</para>
        <para>��� while(r &lt; 0.99d) {</para>
        <para>����� r = Math.random();</para>
        <para>����� System.out.println(r);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This uses the <emphasis role="bold">static</emphasis> method <emphasis role="bold">random( )</emphasis> in the <emphasis role="bold">Math</emphasis> library, which generates a <emphasis role="bold">double </emphasis>value between 0 and 1. (It includes 0, but not 1.) The conditional expression for the <emphasis role="bold">while</emphasis> says �keep doing this loop until the number is 0.99 or greater.� Each time you run this program you�ll get a different-sized list of numbers.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064562"/><anchor xreflabel="do-while" xml:id="_Toc375545268"/>do-while</title>
        <para>The form for <emphasis role="bold">do-while</emphasis> is</para>
        <para><emphasis role="bold">do</emphasis></para>
        <para><emphasis role="bold">� </emphasis>statement</para>
        <para><emphasis role="bold">while(</emphasis>Boolean-expression<emphasis role="bold">);</emphasis></para>
        <para> </para>
        <para>The sole difference between <emphasis role="bold">while</emphasis> and <emphasis role="bold">do-while</emphasis> is that the statement of the <emphasis role="bold">do-while</emphasis> always executes at least once, even if the expression evaluates to false the first time. In a <emphasis role="bold">while</emphasis>, if the conditional is false the first time the statement never executes. In practice, <emphasis role="bold">do-while</emphasis> is less common than <emphasis role="bold">while</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064563"/><anchor xreflabel="for" xml:id="_Toc375545269"/>for</title>
        <para>A <emphasis role="bold">for</emphasis> loop performs initialization before the first iteration. Then it performs conditional testing and, at the end of each iteration, some form of �stepping.� The form of the <emphasis role="bold">for</emphasis> loop is:</para>
        <para><emphasis role="bold">for(</emphasis>initialization<emphasis role="bold">;</emphasis> Boolean-expression<emphasis role="bold">;</emphasis> step<emphasis role="bold">)</emphasis></para>
        <para><emphasis role="bold">� </emphasis>statement</para>
        <para> </para>
        <para>Any of the expressions <emphasis role="italic">initialization</emphasis>, <emphasis role="italic">Boolean-expression</emphasis> or <emphasis role="italic">step</emphasis> can be empty. The expression is tested before each iteration, and as soon as it evaluates to <emphasis role="bold">false</emphasis> execution will continue at the line following the <emphasis role="bold">for</emphasis> statement. At the end of each loop, the <emphasis role="italic">step</emphasis> executes.</para>
        <para><emphasis role="bold">for</emphasis> loops are usually used for �counting� tasks:</para>
        <para>//: c03:ListCharacters.java</para>
        <para>// Demonstrates &quot;for&quot; loop by listing</para>
        <para>// all the ASCII characters.</para>
        <para> </para>
        <para>public class ListCharacters {</para>
        <para>� public static void main(String[] args) {</para>
        <para>� for( char c = 0; c &lt; 128; c++)</para>
        <para>��� if (c != 26 )� // ANSI Clear screen</para>
        <para>����� System.out.println(</para>
        <para>������� &quot;value: &quot; + (int)c +</para>
        <para>������� &quot; character: &quot; + c);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Note that the variable <emphasis role="bold">c</emphasis> is defined at the point where it is used, inside the control expression of the <emphasis role="bold">for</emphasis> loop, rather than at the beginning of the block denoted by the open curly brace. The scope of <emphasis role="bold">c </emphasis>is the expression controlled by the <emphasis role="bold">for</emphasis>.</para>
        <para>Traditional procedural languages like C require that all variables be defined at the beginning of a block so when the compiler creates a block it can allocate space for those variables. In Java and C++ you can spread your variable declarations throughout the block, defining them at the point that you need them. This allows a more natural coding style and makes code easier to understand.</para>
        <para>You can define multiple variables within a <emphasis role="bold">for</emphasis> statement, but they must be of the same type:</para>
        <para>for(int i = 0, j = 1;</para>
        <para>��� i &lt; 10 &amp;&amp; j != 11;</para>
        <para>��� i++, j++)</para>
        <para>� /* body of for loop */;</para>
        <para> </para>
        <para>The <emphasis role="bold">int </emphasis>definition in the <emphasis role="bold">for </emphasis>statement covers both <emphasis role="bold">i </emphasis>and <emphasis role="bold">j</emphasis>.<emphasis role="bold"/>The ability to define variables in the control expression is limited to the <emphasis role="bold">for</emphasis> loop. You cannot use this approach with any of the other selection or iteration statements.</para>
        <section>
          <title><anchor xreflabel="The comma operator" xml:id="_Toc375545270"/>The comma operator</title>
          <para>Earlier in this chapter I stated that the comma <emphasis role="italic">operator</emphasis> (not the comma <emphasis role="italic">separator</emphasis>, which is used to separate definitions and function arguments) has only one use in Java: in the control expression of a <emphasis role="bold">for</emphasis> loop. In both the initialization and step portions of the control expression you can have a number of statements separated by commas, and those statements will be evaluated sequentially. The previous bit of code uses this ability. Here�s another example:</para>
          <para>//: c03:CommaOperator.java</para>
          <para>public class CommaOperator {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� for(int i = 1, j = i + 10; i &lt; 5;</para>
          <para>������� i++, j = i * 2) {</para>
          <para>����� System.out.println(&quot;i= &quot; + i + &quot; j= &quot; + j);</para>
          <para>��� }</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>Here�s the output:</para>
          <para>i= 1 j= 11</para>
          <para>i= 2 j= 4</para>
          <para>i= 3 j= 6</para>
          <para>i= 4 j= 8</para>
          <para> </para>
          <para>You can see that in both the initialization and step portions the statements are evaluated in sequential order. Also, the initialization portion can have any number of definitions <emphasis role="italic">of one type</emphasis>.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="break and continue" xml:id="_Toc481064564"/>break and continue</title>
        <para>Inside the body of any of the iteration statements you can also control the flow of the loop by using <emphasis role="bold">break</emphasis> and <emphasis role="bold">continue</emphasis>. <emphasis role="bold">break</emphasis> quits the loop without executing the rest of the statements in the loop. <emphasis role="bold">continue</emphasis> stops the execution of the current iteration and goes back to the beginning of the loop to begin the next iteration.</para>
        <para>This program shows examples of <emphasis role="bold">break</emphasis> and <emphasis role="bold">continue</emphasis> within <emphasis role="bold">for </emphasis>and <emphasis role="bold">while</emphasis> loops:</para>
        <para>//: c03:BreakAndContinue.java</para>
        <para>// Demonstrates break and continue keywords.</para>
        <para> </para>
        <para>public class BreakAndContinue {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� for(int i = 0; i &lt; 100; i++) {</para>
        <para>����� if(i == 74) break; // Out of for loop</para>
        <para>����� if(i % 9 != 0) continue; // Next iteration</para>
        <para>����� System.out.println(i);</para>
        <para>��� }</para>
        <para>��� int i = 0;</para>
        <para>��� // An &quot;infinite loop&quot;:</para>
        <para>��� while(true) {</para>
        <para>����� i++;</para>
        <para>����� int j = i * 27;</para>
        <para>����� if(j == 1269) break; // Out of loop</para>
        <para>����� if(i % 10 != 0) continue; // Top of loop</para>
        <para>����� System.out.println(i);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In the <emphasis role="bold">for</emphasis> loop the value of <emphasis role="bold">i</emphasis> never gets to 100 because the <emphasis role="bold">break</emphasis> statement breaks out of the loop when <emphasis role="bold">i</emphasis> is 74. Normally, you�d use a <emphasis role="bold">break</emphasis> like this only if you didn�t know when the terminating condition was going to occur. The <emphasis role="bold">continue</emphasis> statement causes execution to go back to the top of the iteration loop (thus incrementing <emphasis role="bold">i</emphasis>) whenever <emphasis role="bold">i</emphasis> is not evenly divisible by 9. When it is, the value is printed.</para>
        <para>The second portion shows an �infinite loop� that would, in theory, continue forever. However, inside the loop there is a <emphasis role="bold">break</emphasis> statement that will break out of the loop. In addition, you�ll see that the <emphasis role="bold">continue</emphasis> moves back to the top of the loop without completing the remainder. (Thus printing happens in the second loop only when the value of <emphasis role="bold">i</emphasis> is divisible by 10.) The output is:</para>
        <para>0</para>
        <para>9</para>
        <para>18</para>
        <para>27</para>
        <para>36</para>
        <para>45</para>
        <para>54</para>
        <para>63</para>
        <para>72</para>
        <para>10</para>
        <para>20</para>
        <para>30</para>
        <para>40</para>
        <para> </para>
        <para>The value 0 is printed because 0 % 9 produces 0.</para>
        <para>A second form of the infinite loop is <emphasis role="bold">for(;;)</emphasis>. The compiler treats both <emphasis role="bold">while(true)</emphasis> and <emphasis role="bold">for(;;)</emphasis> in the same way so whichever one you use is a matter of programming taste.</para>
        <section>
          <title>The infamous �goto�</title>
          <para>The <emphasis role="bold">goto </emphasis>keyword has been present in programming languages from the beginning. Indeed, <emphasis role="bold">goto</emphasis> was the genesis of program control in assembly language: �if condition A, then jump here, otherwise jump there.� If you read the assembly code that is ultimately generated by virtually any compiler, you�ll see that program control contains many jumps. However, a <emphasis role="bold">goto </emphasis>is a jump at the source-code level, and that�s what brought it into disrepute. If a program will always jump from one point to another, isn�t there some way to reorganize the code so the flow of control is not so jumpy? <emphasis role="bold">goto </emphasis>fell into true disfavor with the publication of the famous �Goto considered harmful� paper by Edsger Dijkstra, and since then goto-bashing has been a popular sport, with advocates of the cast-out keyword scurrying for cover.</para>
          <para>As is typical in situations like this, the middle ground is the most fruitful. The problem is not the use of <emphasis role="bold">goto</emphasis>, but the overuse of <emphasis role="bold">goto</emphasis>�in rare situations <emphasis role="bold">goto</emphasis> is actually the best way to structure control flow.</para>
          <para>Although <emphasis role="bold">goto </emphasis>is a reserved word in Java, it is not used in the language; Java has no <emphasis role="bold">goto</emphasis>. However, it does have something that looks a bit like a jump tied in with the <emphasis role="bold">break</emphasis> and <emphasis role="bold">continue</emphasis> keywords. It�s not a jump but rather a way to break out of an iteration statement. �The reason it�s often thrown in with discussions of <emphasis role="bold">goto</emphasis> is because it uses the same mechanism: a label.</para>
          <para>A label is an identifier followed by a colon, like this:</para>
          <para>label1:</para>
          <para> </para>
          <para>The <emphasis role="italic">only</emphasis> place a label is useful in Java is right before an iteration statement. And that means <emphasis role="italic">right</emphasis> before�it does no good to put any other statement between the label and the iteration. And the sole reason to put a label before an iteration is if you�re going to nest another iteration or a switch inside it. That�s because the <emphasis role="bold">break</emphasis> and <emphasis role="bold">continue</emphasis> keywords will normally interrupt only the current loop, but when used with a label they�ll interrupt the loops up to where the label exists:</para>
          <para>label1: </para>
          <para>outer-iteration {</para>
          <para>� inner-iteration {</para>
          <para>��� //�</para>
          <para>��� <emphasis role="bold">break</emphasis>; // 1</para>
          <para>��� //�</para>
          <para>��� <emphasis role="bold">continue</emphasis>;� // 2</para>
          <para>��� //�</para>
          <para>��� <emphasis role="bold">continue</emphasis> label1; // 3</para>
          <para>��� //�</para>
          <para>��� <emphasis role="bold">break</emphasis> label1;� // 4</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>In case 1, the <emphasis role="bold">break</emphasis> breaks out of the inner iteration and you end up in the outer iteration. In case 2, the <emphasis role="bold">continue</emphasis> moves back to the beginning of the inner iteration. But in case 3, the <emphasis role="bold">continue label1</emphasis> breaks out of the inner iteration <emphasis role="italic">and</emphasis> the outer iteration, all the way back to <emphasis role="bold">label1</emphasis>. Then it does in fact continue the iteration, but starting at the outer iteration. In case 4, the <emphasis role="bold">break label1</emphasis> also breaks all the way out to <emphasis role="bold">label1</emphasis>, but it does not re-enter the iteration. It actually does break out of both iterations.</para>
          <para>Here is an example using <emphasis role="bold">for</emphasis> loops:</para>
          <para>//: c03:LabeledFor.java</para>
          <para>// Java�s &quot;labeled for&quot; loop.</para>
          <para> </para>
          <para>public class LabeledFor {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� int i = 0;</para>
          <para>��� outer: // Can&apos;t have statements here</para>
          <para>��� for(; true ;) { // infinite loop</para>
          <para>����� inner: // Can&apos;t have statements here</para>
          <para>���� �for(; i &lt; 10; i++) {</para>
          <para>������� prt(&quot;i = &quot; + i);</para>
          <para>������� if(i == 2) {</para>
          <para>��������� prt(&quot;continue&quot;);</para>
          <para>��������� continue;</para>
          <para>������� }</para>
          <para>������� if(i == 3) {</para>
          <para>��������� prt(&quot;break&quot;);</para>
          <para>��������� i++; // Otherwise i never</para>
          <para>�������������� // gets incremented.</para>
          <para>��������� break;</para>
          <para>������� }</para>
          <para>������� if(i == 7) {</para>
          <para>��������� prt(&quot;continue outer&quot;);</para>
          <para>��������� i++; // Otherwise i never</para>
          <para>�������������� // gets incremented.</para>
          <para>��������� continue outer;</para>
          <para>������� }</para>
          <para>������� if(i == 8) {</para>
          <para>��������� prt(&quot;break outer&quot;);</para>
          <para>��������� break outer;</para>
          <para>������ �}</para>
          <para>������� for(int k = 0; k &lt; 5; k++) {</para>
          <para>��������� if(k == 3) {</para>
          <para>����������� prt(&quot;continue inner&quot;);</para>
          <para>����������� continue inner;</para>
          <para>��������� }</para>
          <para>������� }</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>��� // Can&apos;t break or continue</para>
          <para>��� // to labels here</para>
          <para>� }</para>
          <para>� static void prt(String s) {</para>
          <para>��� System.out.println(s);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>This uses the <emphasis role="bold">prt( )</emphasis> method that has been defined in the other examples.</para>
          <para>Note that <emphasis role="bold">break</emphasis> breaks out of the <emphasis role="bold">for</emphasis> loop, and that the increment-expression doesn�t occur until the end of the pass through the <emphasis role="bold">for</emphasis> loop. Since <emphasis role="bold">break</emphasis> skips the increment expression, the increment is performed directly in the case of <emphasis role="bold">i == 3</emphasis>. The <emphasis role="bold">continue outer</emphasis> statement in the case of <emphasis role="bold">i == 7 </emphasis>also goes to the top of the loop and also skips the increment, so it too is incremented directly.</para>
          <para>Here is the output:</para>
          <para>i = 0</para>
          <para>continue inner</para>
          <para>i = 1</para>
          <para>continue inner</para>
          <para>i = 2</para>
          <para>continue</para>
          <para>i = 3</para>
          <para>break</para>
          <para>i = 4</para>
          <para>continue inner</para>
          <para>i = 5</para>
          <para>continue inner</para>
          <para>i = 6</para>
          <para>continue inner</para>
          <para>i = 7</para>
          <para>continue outer</para>
          <para>i = 8</para>
          <para>break outer</para>
          <para> </para>
          <para>If not for the <emphasis role="bold">break outer</emphasis> statement, there would be no way to get out of the outer loop from within an inner loop, since <emphasis role="bold">break</emphasis> by itself can break out of only the innermost loop. (The same is true for <emphasis role="bold">continue</emphasis>.)</para>
          <para>Of course, in the cases where breaking out of a loop will also exit the method, you can simply use a <emphasis role="bold">return</emphasis>.</para>
          <para>Here is a demonstration of labeled <emphasis role="bold">break</emphasis> and <emphasis role="bold">continue</emphasis> statements with <emphasis role="bold">while</emphasis> loops:</para>
          <para>//: c03:LabeledWhile.java</para>
          <para>// Java&apos;s &quot;labeled while&quot; loop.</para>
          <para> </para>
          <para>public class LabeledWhile {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� int i = 0;</para>
          <para>��� outer:</para>
          <para>��� while(true) {</para>
          <para>����� prt(&quot;Outer while loop&quot;);</para>
          <para>����� while(true) {</para>
          <para>������� i++;</para>
          <para>������� prt(&quot;i = &quot; + i);</para>
          <para>������� if(i == 1) {</para>
          <para>��������� prt(&quot;continue&quot;);</para>
          <para>��������� continue;</para>
          <para>������� }</para>
          <para>������� if(i == 3) {</para>
          <para>��������� prt(&quot;continue outer&quot;);</para>
          <para>��������� continue outer;</para>
          <para>������� }</para>
          <para>������� if(i == 5) {</para>
          <para>��������� prt(&quot;break&quot;);</para>
          <para>��������� break;</para>
          <para>������� }</para>
          <para>������� if(i == 7) {</para>
          <para>��������� prt(&quot;break outer&quot;);</para>
          <para>��������� break outer;</para>
          <para>������� }</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� }</para>
          <para>� static void prt(String s) {</para>
          <para>��� System.out.println(s);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The same rules hold true for <emphasis role="bold">while</emphasis>:</para>
          <para>A plain <emphasis role="bold">continue</emphasis> goes to the top of the innermost loop and continues.</para>
          <para>23.      A labeled <emphasis role="bold">continue</emphasis> goes to the label and re-enters the loop right after that label.</para>
          <para>24.      A <emphasis role="bold">break</emphasis> �drops out of the bottom� of the loop.</para>
          <para>25.      A labeled <emphasis role="bold">break</emphasis> drops out of the bottom of the end of the loop denoted by the label. </para>
          <para>The output of this method makes it clear:</para>
          <para>Outer while loop</para>
          <para>i = 1</para>
          <para>continue</para>
          <para>i = 2</para>
          <para>i = 3</para>
          <para>continue outer</para>
          <para>Outer while loop</para>
          <para>i = 4</para>
          <para>i = 5</para>
          <para>break</para>
          <para>Outer while loop</para>
          <para>i = 6</para>
          <para>i = 7</para>
          <para>break outer</para>
          <para> </para>
          <para>It�s important to remember that the <emphasis role="italic">only</emphasis> reason to use labels in Java is when you have nested loops and you want to <emphasis role="bold">break</emphasis> or <emphasis role="bold">continue</emphasis> through more than one nested level.</para>
          <para>In Dijkstra�s �goto considered harmful� paper, what he specifically objected to was the labels, not the goto. He observed that the number of bugs seems to increase with the number of labels in a program. Labels and gotos make programs difficult to analyze statically, since it introduces cycles in the program execution graph. Note that Java labels don�t suffer from this problem, since they are constrained in their placement and can�t be used to transfer control in an ad hoc manner. It�s also interesting to note that this is a case where a language feature is made more useful by restricting the power of the statement.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064565"/><anchor xreflabel="switch" xml:id="_Toc375545271"/>switch</title>
        <para>The <emphasis role="bold">switch</emphasis> is sometimes classified as a <emphasis role="italic">selection statement</emphasis>. The <emphasis role="bold">switch </emphasis>statement selects from among pieces of code based on the value of an integral expression. Its form is:</para>
        <para><emphasis role="bold">switch(</emphasis>integral-selector<emphasis role="bold">) {</emphasis></para>
        <para>� <emphasis role="bold">case</emphasis> integral-value1<emphasis role="bold"> :</emphasis> statement<emphasis role="bold">;</emphasis><emphasis role="bold">break;</emphasis></para>
        <para>� <emphasis role="bold">case</emphasis> integral-value2 <emphasis role="bold">:</emphasis> statement<emphasis role="bold">;</emphasis><emphasis role="bold">break;</emphasis></para>
        <para>� <emphasis role="bold">case</emphasis> integral-value3 <emphasis role="bold">:</emphasis> statement<emphasis role="bold">;</emphasis><emphasis role="bold">break;</emphasis></para>
        <para>� <emphasis role="bold">case</emphasis> integral-value4 <emphasis role="bold">:</emphasis> statement<emphasis role="bold">;</emphasis><emphasis role="bold">break;</emphasis></para>
        <para>� <emphasis role="bold">case</emphasis> integral-value5 <emphasis role="bold">:</emphasis> statement<emphasis role="bold">;</emphasis><emphasis role="bold">break;</emphasis></para>
        <para><emphasis role="bold">��������� // ...</emphasis></para>
        <para>� <emphasis role="bold">default:</emphasis> statement<emphasis role="bold">;</emphasis></para>
        <para>}</para>
        <para> </para>
        <para><emphasis role="italic">Integral-selector</emphasis> is an expression that produces an integral value. The <emphasis role="bold">switch</emphasis> compares the result of <emphasis role="italic">integral-selector</emphasis> to each<emphasis role="italic"> integral-value</emphasis>. If it finds a match, the corresponding <emphasis role="italic">statement</emphasis> (simple or compound) executes. If no match occurs, the <emphasis role="bold">default</emphasis><emphasis role="italic">statement</emphasis> executes.</para>
        <para>You will notice in the above definition that each <emphasis role="bold">case</emphasis> ends with a <emphasis role="bold">break</emphasis>, which causes execution to jump to the end of the <emphasis role="bold">switch</emphasis> body. This is the conventional way to build a <emphasis role="bold">switch</emphasis> statement, but the <emphasis role="bold">break</emphasis> is optional. If it is missing, the code for the following case statements execute until a <emphasis role="bold">break</emphasis> is encountered. Although you don�t usually want this kind of behavior, it can be useful to an experienced programmer. Note the last statement, following the <emphasis role="bold">default</emphasis>, doesn�t have a <emphasis role="bold">break</emphasis> because the execution just falls through to where the <emphasis role="bold">break</emphasis> would have taken it anyway. You could put a <emphasis role="bold">break</emphasis> at the end of the <emphasis role="bold">default</emphasis> statement with no harm if you considered it important for style�s sake.</para>
        <para>The <emphasis role="bold">switch</emphasis> statement is a clean way to implement multi-way selection (i.e., selecting from among a number of different execution paths), but it requires a selector that evaluates to an integral value such as <emphasis role="bold">int</emphasis> or <emphasis role="bold">char</emphasis>. If you want to use, for example, a string or a floating-point number as a selector, it won�t work in a <emphasis role="bold">switch</emphasis> statement. For non-integral types, you must use a series of <emphasis role="bold">if</emphasis> statements.</para>
        <para>Here�s an example that creates letters randomly and determines whether they�re vowels or consonants:</para>
        <para>//: c03:VowelsAndConsonants.java</para>
        <para>// Demonstrates the switch statement.</para>
        <para> </para>
        <para>public class VowelsAndConsonants {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� for(int i = 0; i &lt; 100; i++) {</para>
        <para>����� char c = (char)(Math.random() * 26 + &apos;a&apos;);</para>
        <para>����� System.out.print(c + &quot;: &quot;);</para>
        <para>����� switch(c) {</para>
        <para>����� case &apos;a&apos;:</para>
        <para>����� case &apos;e&apos;:</para>
        <para>����� case &apos;i&apos;:</para>
        <para>����� case &apos;o&apos;:</para>
        <para>����� case &apos;u&apos;:</para>
        <para>��������������� System.out.println(&quot;vowel&quot;);</para>
        <para>��������������� break;</para>
        <para>����� case &apos;y&apos;:</para>
        <para>����� case &apos;w&apos;:</para>
        <para>��������������� System.out.println(</para>
        <para>����������������� &quot;Sometimes a vowel&quot;);</para>
        <para>��������������� break;</para>
        <para>����� default:</para>
        <para>��������������� System.out.println(&quot;consonant&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Since <emphasis role="bold">Math.random( )</emphasis> generates a value between 0 and 1, you need only multiply it by the upper bound of the range of numbers you want to produce (26 for the letters in the alphabet) and add an offset to establish the lower bound. </para>
        <para>Although it appears you�re switching on a character here, the <emphasis role="bold">switch</emphasis> statement is actually using the integral value of the character. The singly-quoted characters in the <emphasis role="bold">case</emphasis> statements also produce integral values that are used for comparison.</para>
        <para>Notice how the <emphasis role="bold">case</emphasis>s can be �stacked� on top of each other to provide multiple matches for a particular piece of code. You should also be aware that it�s essential to put the <emphasis role="bold">break</emphasis> statement at the end of a particular case, otherwise control will simply drop through and continue processing on the next case.</para>
        <section>
          <title>Calculation details</title>
          <para>The statement:</para>
          <para>char c = (char)(Math.random() * 26 + &apos;a&apos;);</para>
          <para> </para>
          <para>deserves a closer look. <emphasis role="bold">Math.random( )</emphasis> produces a <emphasis role="bold">double</emphasis>, so the value 26 is converted to a <emphasis role="bold">double</emphasis> to perform the multiplication, which also produces a <emphasis role="bold">double</emphasis>. This means that <emphasis role="bold">�a�</emphasis> must be converted to a <emphasis role="bold">double</emphasis> to perform the addition. The <emphasis role="bold">double</emphasis> result is turned back into a <emphasis role="bold">char</emphasis> with a cast.</para>
          <para>What does the cast to <emphasis role="bold">char</emphasis> do? That is, if you have the value 29.7 and you cast it to a <emphasis role="bold">char</emphasis>, is the resulting value 30 or 29? The answer to this can be seen in this example:</para>
          <para>//: c03:CastingNumbers.java</para>
          <para>// What happens when you cast a float </para>
          <para>// or double to an integral value?</para>
          <para> </para>
          <para>public class CastingNumbers {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� double</para>
          <para>����� above = 0.7,</para>
          <para>����� below = 0.4;</para>
          <para>��� System.out.println(&quot;above: &quot; + above);</para>
          <para>��� System.out.println(&quot;below: &quot; + below);</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;(int)above: &quot; + (int)above);</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;(int)below: &quot; + (int)below);</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;(char)(&apos;a&apos; + above): &quot; +</para>
          <para>����� (char)(&apos;a&apos; + above));</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;(char)(&apos;a&apos; + below): &quot; +</para>
          <para>����� (char)(&apos;a&apos; + below));</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The output is:</para>
          <para>above: 0.7</para>
          <para>below: 0.4</para>
          <para>(int)above: 0</para>
          <para>(int)below: 0</para>
          <para>(char)(&apos;a&apos; + above): a</para>
          <para>(char)(&apos;a&apos; + below): a</para>
          <para> </para>
          <para>So the answer is that casting from a <emphasis role="bold">float</emphasis> or <emphasis role="bold">double</emphasis> to an integral value always truncates.</para>
          <para>A second question concerns <emphasis role="bold">Math.random( )</emphasis>. Does it produce a value from zero to one, inclusive or exclusive of the value �1�? In math lingo, is it (0,1), or [0,1], or (0,1] or [0,1)? (The square bracket means �includes� whereas the parenthesis means �doesn�t include.�) Again, a test program might provide the answer:</para>
          <para>//: c03:RandomBounds.java</para>
          <para>// Does Math.random() produce 0.0 and 1.0?</para>
          <para> </para>
          <para>public class RandomBounds {</para>
          <para>� static void usage() {</para>
          <para>��� System.out.println(&quot;Usage: \n\t&quot; +</para>
          <para>����� &quot;RandomBounds lower\n\t&quot; +</para>
          <para>����� &quot;RandomBounds upper&quot;);</para>
          <para>��� System.exit(1);</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� if(args.length != 1) usage();</para>
          <para>� ��if(args[0].equals(&quot;lower&quot;)) {</para>
          <para>����� while(Math.random() != 0.0)</para>
          <para>������� ; // Keep trying</para>
          <para>����� System.out.println(&quot;Produced 0.0!&quot;);</para>
          <para>��� } </para>
          <para>��� else if(args[0].equals(&quot;upper&quot;)) {</para>
          <para>����� while(Math.random() != 1.0)</para>
          <para>������� ; // Keep trying</para>
          <para>����� System.out.println(&quot;Produced 1.0!&quot;);</para>
          <para>��� } </para>
          <para>��� else </para>
          <para>����� usage();</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>To run the program, you type a command line of either:</para>
          <para>java RandomBounds lower</para>
          <para> </para>
          <para>or</para>
          <para>java RandomBounds upper</para>
          <para> </para>
          <para>In both cases you are forced to break out of the program manually, so it would <emphasis role="italic">appear</emphasis> that <emphasis role="bold">Math.random( )</emphasis> never produces either 0.0 or 1.0. But this is where such an experiment can be deceiving. If you consider<anchor xreflabel="[26]" xml:id="_ftnref26"/>[26] that there are about 2<superscript>62</superscript> different double fractions between 0 and 1, the likelihood of reaching any one value experimentally might exceed the lifetime of one computer, or even one experimenter. It turns out that 0.0 <emphasis role="italic">is</emphasis> included in the output of <emphasis role="bold">Math.random( )</emphasis>. Or, in math lingo, it is [0,1).</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064566"/><anchor xreflabel="Summary" xml:id="_Toc375545272"/>Summary</title>
      <para>This chapter concludes the study of fundamental features that appear in most programming languages: calculation, operator precedence, type casting, and selection and iteration. Now you�re ready to begin taking steps that move you closer to the world of object-oriented programming. The next chapter will cover the important issues of initialization and cleanup of objects, followed in the subsequent chapter by the essential concept of implementation hiding.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064567"/><anchor xreflabel="Exercises" xml:id="_Toc375545273"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            There are two expressions in the section labeled �precedence� early in this chapter. Put these expressions into a program and demonstrate that they produce different results.</para>
      <para>      13.         Put the methods ternary( ) and alternative( ) into a working program.</para>
      <para>      14.         From the sections labeled �if-else� and �return�, put the methods test( ) and test2( ) into a working program.</para>
      <para>      15.         Write a program that prints values from one to 100.</para>
      <para>      16.         Modify Exercise 4 so that the program exits by using the break keyword at value 47. Try using return instead.</para>
      <para>      17.         Write a function that takes two String arguments, and uses all the Boolean comparisons to compare the two Strings and print the results. For the == and !=, also perform the equals( ) test. In main( ), call your function with some different String objects.</para>
      <para>      18.         Write a program that generates 25 random int values. For each value, use an if-then-else statement to classify it as greater than, less than or equal to a second randomly-generated value.</para>
      <para>      19.         Modify Exercise 7 so that your code is surrounded by an �infinite� while loop. It will then run until you interrupt it from the keyboard (typically by pressing Control-C).</para>
      <para>      20.         Write a program that uses two nested for loops and the modulus operator (%) to detect and print prime numbers (integral numbers that are not evenly divisible by any other numbers except for themselves and 1).</para>
      <para>      21.         Create a switch statement that prints a message for each case, and put the switch inside a for loop that tries each case. Put a break after each case and test it, then remove the breaks and see what happens.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064568"/><anchor xreflabel="" xml:id="_Toc477690724"/><anchor xreflabel="" xml:id="_Toc375545274"/><anchor xreflabel="" xml:id="Chapter_4"/>4: Initialization   &amp; Cleanup</title>
    <para>As the computer revolution progresses, �unsafe� programming has become one of the major culprits that makes programming expensive.</para>
    <para>Two of these safety issues are <emphasis role="italic">initialization</emphasis> and <emphasis role="italic">cleanup</emphasis>. Many C bugs occur when the programmer forgets to initialize a variable. This is especially true with libraries when users don�t know how to initialize a library component, or even that they must. Cleanup is a special problem because it�s easy to forget about an element when you�re done with it, since it no longer concerns you. Thus, the resources used by that element are retained and you can easily end up running out of resources (most notably, memory). </para>
    <para>C++ introduced the concept of a <emphasis role="italic">constructor</emphasis>, a special method automatically called when an object is created. Java also adopted the constructor, and in addition has a garbage collector that automatically releases memory resources when they�re no longer being used. This chapter examines the issues of initialization and cleanup, and their support in Java.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064569"/><anchor xreflabel="" xml:id="_Toc375545275"/><anchor xreflabel="Guaranteed initialization 
with the constructor" xml:id="_Toc312373853"/>Guaranteed initialization   with the constructor</title>
      <para>You can imagine creating a method called <emphasis role="bold">initialize( )</emphasis> for every class you write. The name is a hint that it should be called before using the object. Unfortunately, this means the user must remember to call the method. In Java, the class designer can guarantee initialization of every object by providing a special method called a <emphasis role="italic">constructor</emphasis>. If a class has a constructor, Java automatically calls that constructor when an object is created, before users can even get their hands on it. So initialization is guaranteed.</para>
      <para>The next challenge is what to name this method. There are two issues. The first is that any name you use could clash with a name you might like to use as a member in the class. The second is that because the compiler is responsible for calling the constructor, it must always know which method to call. The C++ solution seems the easiest and most logical, so it�s also used in Java: the name of the constructor is the same as the name of the class. It makes sense that such a method will be called automatically on initialization.</para>
      <para>Here�s a simple class with a constructor:</para>
      <para>//: c04:SimpleConstructor.java</para>
      <para>// Demonstration of a simple constructor.</para>
      <para> </para>
      <para>class Rock {</para>
      <para>� Rock() { // This is the constructor</para>
      <para>��� System.out.println(&quot;Creating Rock&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class SimpleConstructor {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� for(int i = 0; i &lt; 10; i++)</para>
      <para>����� new Rock();</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Now, when an object is created:</para>
      <para>new Rock();</para>
      <para> </para>
      <para>storage is allocated and the constructor is called. It is guaranteed that the object will be properly initialized before you can get your hands on it.</para>
      <para>Note that the coding style of making the first letter of all methods lowercase does not apply to constructors, since the name of the constructor must match the name of the class <emphasis role="italic">exactly</emphasis>.</para>
      <para>Like any method, the constructor can have arguments�to allow you to specify <emphasis role="italic">how</emphasis> an object is created. The above example can easily be changed so the constructor takes an argument:</para>
      <para>//: c04:SimpleConstructor2.java</para>
      <para>// Constructors can have arguments.</para>
      <para> </para>
      <para>class Rock2 {</para>
      <para>� Rock2(int i) {</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;Creating Rock number &quot; + i);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class SimpleConstructor2 {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� for(int i = 0; i &lt; 10; i++)</para>
      <para>����� new Rock2(i);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Constructor arguments provide you with a way to provide parameters for the initialization of an object. For example, if the class <emphasis role="bold">Tree</emphasis> has a constructor that takes a single integer argument denoting the height of the tree, you would create a <emphasis role="bold">Tree</emphasis> object like this:</para>
      <para>Tree t = new Tree(12);� // 12-foot tree</para>
      <para> </para>
      <para>If <emphasis role="bold">Tree(int)</emphasis> is your only constructor, then the compiler won�t let you create a <emphasis role="bold">Tree</emphasis> object any other way. </para>
      <para>Constructors eliminate a large class of problems and make the code easier to read. In the preceding code fragment, for example, you don�t see an explicit call to some <emphasis role="bold">initialize( )</emphasis> method that is conceptually separate from definition. In Java, definition and initialization are unified concepts�you can�t have one without the other.</para>
      <para>The constructor is an unusual type of method because it has no return value. This is distinctly different from a <emphasis role="bold">void</emphasis> return value, in which the method returns nothing but you still have the option to make it return something else. Constructors return nothing and you don�t have an option. If there was a return value, and if you could select your own, the compiler would somehow need to know what to do with that return value.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064570"/><anchor xreflabel="Method
overloading" xml:id="_Toc375545276"/>Method overloading</title>
      <para>One of the important features in any programming language is the use of names. When you create an object, you give a name to a region of storage. A method is a name for an action. By using names to describe your system, you create a program that is easier for people to understand and change. It�s a lot like writing prose�the goal is to communicate with your readers.</para>
      <para>You refer to all objects and methods by using names. Well-chosen names make it easier for you and others to understand your code. </para>
      <para>A problem arises when mapping the concept of nuance in human language onto a programming language. Often, the same word expresses a number of different meanings�it�s <emphasis role="italic">overloaded</emphasis>. This is useful, especially when it comes to trivial differences. You say �wash the shirt,� �wash the car,� and �wash the dog.� It would be silly to be forced to say, �shirtWash the shirt,� �carWash the car,� and �dogWash the dog� just so the listener doesn�t need to make any distinction about the action performed. Most human languages are redundant, so even if you miss a few words, you can still determine the meaning. We don�t need unique identifiers�we can deduce meaning from context.</para>
      <para>Most programming languages (C in particular) require you to have a unique identifier for each function. So you could not have one function called <emphasis role="bold">print( )</emphasis> for printing integers and another called <emphasis role="bold">print( )</emphasis> for printing floats�each function requires a unique name.</para>
      <para>In Java (and C++), another factor forces the overloading of method names: the constructor. Because the constructor�s name is predetermined by the name of the class, there can be only one constructor name. But what if you want to create an object in more than one way? For example, suppose you build a class that can initialize itself in a standard way or by reading information from a file. You need two constructors, one that takes no arguments (the <emphasis role="italic">default</emphasis> constructor, also called the <emphasis role="italic">no-arg</emphasis> constructor), and one that takes a <emphasis role="bold">String</emphasis> as an argument, which is the name of the file from which to initialize the object. Both are constructors, so they must have the same name�the name of the class. Thus, <emphasis role="italic">method overloading</emphasis> is essential to allow the same method name to be used with different argument types. And although method overloading is a must for constructors, it�s a general convenience and can be used with any method. </para>
      <para>Here�s an example that shows both overloaded constructors and overloaded ordinary methods:</para>
      <para>//: c04:Overloading.java</para>
      <para>// Demonstration of both constructor</para>
      <para>// and ordinary method overloading.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>class Tree {</para>
      <para>� int height;</para>
      <para>� Tree() {</para>
      <para>��� prt(&quot;Planting a seedling&quot;);</para>
      <para>��� height = 0;</para>
      <para>� }</para>
      <para>� Tree(int i) {</para>
      <para>��� prt(&quot;Creating new Tree that is &quot;</para>
      <para>������� + i + &quot; feet tall&quot;);</para>
      <para>��� height = i;</para>
      <para>� }</para>
      <para>� void info() {</para>
      <para>��� prt(&quot;Tree is &quot; + height</para>
      <para>������� + &quot; feet tall&quot;);</para>
      <para>� }</para>
      <para>� void info(String s) {</para>
      <para>��� prt(s + &quot;: Tree is &quot;</para>
      <para>������� + height + &quot; feet tall&quot;);</para>
      <para>� }</para>
      <para>� static void prt(String s) {</para>
      <para>��� System.out.println(s);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class Overloading {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� for(int i = 0; i &lt; 5; i++) {</para>
      <para>����� Tree t = new Tree(i);</para>
      <para>����� t.info();</para>
      <para>����� t.info(&quot;overloaded method&quot;);</para>
      <para>��� }</para>
      <para>��� // Overloaded constructor:</para>
      <para>��� new Tree();</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>A <emphasis role="bold">Tree</emphasis> object can be created either as a seedling, with no argument, or as a plant grown in a nursery, with an existing height. To support this, there are two constructors, one that takes no arguments (we call constructors that take no arguments <emphasis role="italic">default constructors</emphasis><anchor xreflabel="[27]" xml:id="_ftnref27"/>[27]) and one that takes the existing height.</para>
      <para>You might also want to call the <emphasis role="bold">info( )</emphasis> method in more than one way. For example, with a <emphasis role="bold">String</emphasis> argument if you have an extra message you want printed, and without if you have nothing more to say. It would seem strange to give two separate names to what is obviously the same concept. Fortunately, method overloading allows you to use the same name for both.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064571"/><anchor xreflabel="Distinguishing
overloaded methods" xml:id="_Toc375545277"/>Distinguishing overloaded methods</title>
        <para>If the methods have the same name, how can Java know which method you mean? There�s a simple rule: each overloaded method must take a unique list of argument types.</para>
        <para>If you think about this for a second, it makes sense: how else could a programmer tell the difference between two methods that have the same name, other than by the types of their arguments?</para>
        <para>Even differences in the ordering of arguments are sufficient to distinguish two methods: (Although you don�t normally want to take this approach, as it produces difficult-to-maintain code.)</para>
        <para>//: c04:OverloadingOrder.java</para>
        <para>// Overloading based on the order of</para>
        <para>// the arguments.</para>
        <para> </para>
        <para>public class OverloadingOrder {</para>
        <para>� static void print(String s, int i) {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;String: &quot; + s +</para>
        <para>����� &quot;, int: &quot; + i);</para>
        <para>� }</para>
        <para>� static void print(int i, String s) {</para>
        <para>��� System.out.println(</para>
        <para>� ����&quot;int: &quot; + i +</para>
        <para>����� &quot;, String: &quot; + s);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� print(&quot;String first&quot;, 11);</para>
        <para>��� print(99, &quot;Int first&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The two <emphasis role="bold">print( )</emphasis> methods have identical arguments, but the order is different, and that�s what makes them distinct.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545278"/><anchor xreflabel="" xml:id="_Toc312373866"/><anchor xreflabel="Overloading with primitives" xml:id="_Toc481064572"/>Overloading with primitives</title>
        <para>A primitive can be automatically promoted from a smaller type to a larger one and this can be slightly confusing in combination with overloading. The following example demonstrates what happens when a primitive is handed to an overloaded method:</para>
        <para>//: c04:PrimitiveOverloading.java</para>
        <para>// Promotion of primitives and overloading.</para>
        <para> </para>
        <para>public class PrimitiveOverloading {</para>
        <para>� // boolean can&apos;t be automatically converted</para>
        <para>� static void prt(String s) { </para>
        <para>��� System.out.println(s); </para>
        <para>� }</para>
        <para> </para>
        <para>� void f1(char x) { prt(&quot;f1(char)&quot;); }</para>
        <para>� void f1(byte x) { prt(&quot;f1(byte)&quot;); }</para>
        <para>� void f1(short x) { prt(&quot;f1(short)&quot;); }</para>
        <para>� void f1(int x) { prt(&quot;f1(int)&quot;); }</para>
        <para>� void f1(long x) { prt(&quot;f1(long)&quot;); }</para>
        <para>� void f1(float x) { prt(&quot;f1(float)&quot;); }</para>
        <para>� void f1(double x) { prt(&quot;f1(double)&quot;); }</para>
        <para> </para>
        <para>� void f2(byte x) { prt(&quot;f2(byte)&quot;); }</para>
        <para>� void f2(short x) { prt(&quot;f2(short)&quot;); }</para>
        <para>� void f2(int x) { prt(&quot;f2(int)&quot;); }</para>
        <para>� void f2(long x) { prt(&quot;f2(long)&quot;); }</para>
        <para>� void f2(float x) { prt(&quot;f2(float)&quot;); }</para>
        <para>� void f2(double x) { prt(&quot;f2(double)&quot;); }</para>
        <para> </para>
        <para>� void f3(short x) { prt(&quot;f3(short)&quot;); }</para>
        <para>� void f3(int x) { prt(&quot;f3(int)&quot;); }</para>
        <para>� void f3(long x) { prt(&quot;f3(long)&quot;); }</para>
        <para>� void f3(float x) { prt(&quot;f3(float)&quot;); }</para>
        <para>� void f3(double x) { prt(&quot;f3(double)&quot;); }</para>
        <para> </para>
        <para>� void f4(int x) { prt(&quot;f4(int)&quot;); }</para>
        <para>� void f4(long x) { prt(&quot;f4(long)&quot;); }</para>
        <para>� void f4(float x) { prt(&quot;f4(float)&quot;); }</para>
        <para>� void f4(double x) { prt(&quot;f4(double)&quot;); }</para>
        <para> </para>
        <para>� void f5(long x) { prt(&quot;f5(long)&quot;); }</para>
        <para>� void f5(float x) { prt(&quot;f5(float)&quot;); }</para>
        <para>� void f5(double x) { prt(&quot;f5(double)&quot;); }</para>
        <para> </para>
        <para>� void f6(float x) { prt(&quot;f6(float)&quot;); }</para>
        <para>� void f6(double x) { prt(&quot;f6(double)&quot;); }</para>
        <para> </para>
        <para>� void f7(double x) { prt(&quot;f7(double)&quot;); }</para>
        <para> </para>
        <para>� void testConstVal() {</para>
        <para>��� prt(&quot;Testing with 5&quot;);</para>
        <para>��� f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5);</para>
        <para>� }</para>
        <para>� void testChar() {</para>
        <para>��� char x = &apos;x&apos;;</para>
        <para>��� prt(&quot;char argument:&quot;);</para>
        <para>��� f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</para>
        <para>� }</para>
        <para>� void testByte() {</para>
        <para>��� byte x = 0;</para>
        <para>��� prt(&quot;byte argument:&quot;);</para>
        <para>��� f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</para>
        <para>� }</para>
        <para>� void testShort() {</para>
        <para>��� short x = 0;</para>
        <para>��� prt(&quot;short argument:&quot;);</para>
        <para>��� f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</para>
        <para>� }</para>
        <para>� void testInt() {</para>
        <para>��� int x = 0;</para>
        <para>��� prt(&quot;int argument:&quot;);</para>
        <para>��� f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</para>
        <para>� }</para>
        <para>� void testLong() {</para>
        <para>��� long x = 0;</para>
        <para>��� prt(&quot;long argument:&quot;);</para>
        <para>��� f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</para>
        <para>� }</para>
        <para>� void testFloat() {</para>
        <para>��� float x = 0;</para>
        <para>��� prt(&quot;float argument:&quot;);</para>
        <para>��� f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</para>
        <para>� }</para>
        <para>� void testDouble() {</para>
        <para>��� double x = 0;</para>
        <para>��� prt(&quot;double argument:&quot;);</para>
        <para>��� f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� PrimitiveOverloading p = </para>
        <para>����� new PrimitiveOverloading();</para>
        <para>��� p.testConstVal();</para>
        <para>��� p.testChar();</para>
        <para>��� p.testByte();</para>
        <para>��� p.testShort();</para>
        <para>��� p.testInt();</para>
        <para>��� p.testLong();</para>
        <para>��� p.testFloat();</para>
        <para>��� p.testDouble();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>If you view the output of this program, you�ll see that the constant value 5 is treated as an <emphasis role="bold">int</emphasis>, so if an overloaded method is available that takes an <emphasis role="bold">int</emphasis> it is used. In all other cases, if you have a data type that is smaller than the argument in the method, that data type is promoted. <emphasis role="bold">char</emphasis> produces a slightly different effect, since if it doesn�t find an exact <emphasis role="bold">char</emphasis> match, it is promoted to <emphasis role="bold">int</emphasis>.</para>
        <para>What happens if your argument is <emphasis role="italic">bigger</emphasis> than the argument expected by the overloaded method? A modification of the above program gives the answer:</para>
        <para>//: c04:Demotion.java</para>
        <para>// Demotion of primitives and overloading.</para>
        <para> </para>
        <para>public class Demotion {</para>
        <para>� static void prt(String s) { </para>
        <para>��� System.out.println(s); </para>
        <para>� }</para>
        <para> </para>
        <para>� void f1(char x) { prt(&quot;f1(char)&quot;); }</para>
        <para>� void f1(byte x) { prt(&quot;f1(byte)&quot;); }</para>
        <para>� void f1(short x) { prt(&quot;f1(short)&quot;); }</para>
        <para>� void f1(int x) { prt(&quot;f1(int)&quot;); }</para>
        <para>� void f1(long x) { prt(&quot;f1(long)&quot;); }</para>
        <para>� void f1(float x) { prt(&quot;f1(float)&quot;); }</para>
        <para>� void f1(double x) { prt(&quot;f1(double)&quot;); }</para>
        <para> </para>
        <para>� void f2(char x) { prt(&quot;f2(char)&quot;); }</para>
        <para>� void f2(byte x) { prt(&quot;f2(byte)&quot;); }</para>
        <para>� void f2(short x) { prt(&quot;f2(short)&quot;); }</para>
        <para>� void f2(int x) { prt(&quot;f2(int)&quot;); }</para>
        <para>� void f2(long x) { prt(&quot;f2(long)&quot;); }</para>
        <para>� void f2(float x) { prt(&quot;f2(float)&quot;); }</para>
        <para> </para>
        <para>� void f3(char x) { prt(&quot;f3(char)&quot;); }</para>
        <para>� void f3(byte x) { prt(&quot;f3(byte)&quot;); }</para>
        <para>� void f3(short x) { prt(&quot;f3(short)&quot;); }</para>
        <para>� void f3(int x) { prt(&quot;f3(int)&quot;); }</para>
        <para>� void f3(long x) { prt(&quot;f3(long)&quot;); }</para>
        <para> </para>
        <para>� void f4(char x) { prt(&quot;f4(char)&quot;); }</para>
        <para>� void f4(byte x) { prt(&quot;f4(byte)&quot;); }</para>
        <para>� void f4(short x) { prt(&quot;f4(short)&quot;); }</para>
        <para>� void f4(int x) { prt(&quot;f4(int)&quot;); }</para>
        <para> </para>
        <para>� void f5(char x) { prt(&quot;f5(char)&quot;); }</para>
        <para>� void f5(byte x) { prt(&quot;f5(byte)&quot;); }</para>
        <para>� void f5(short x) { prt(&quot;f5(short)&quot;); }</para>
        <para> </para>
        <para>� void f6(char x) { prt(&quot;f6(char)&quot;); }</para>
        <para>� void f6(byte x) { prt(&quot;f6(byte)&quot;); }</para>
        <para> </para>
        <para>� void f7(char x) { prt(&quot;f7(char)&quot;); }</para>
        <para> </para>
        <para>� void testDouble() {</para>
        <para>��� double x = 0;</para>
        <para>��� prt(&quot;double argument:&quot;);</para>
        <para>��� f1(x);f2((float)x);f3((long)x);f4((int)x);</para>
        <para>��� f5((short)x);f6((byte)x);f7((char)x);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Demotion p = new Demotion();</para>
        <para>��� p.testDouble();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Here, the methods take narrower primitive values. If your argument is wider then you must <emphasis role="italic">cast</emphasis> to the necessary type using the type name in parentheses. If you don�t do this, the compiler will issue an error message.</para>
        <para>You should be aware that this is a <emphasis role="italic">narrowing conversion,</emphasis> which means you might lose information during the cast. This is why the compiler forces you to do it�to flag the narrowing conversion. </para>
      </section>
      <section>
        <title><anchor xreflabel="Overloading on return values" xml:id="_Toc481064573"/>Overloading on return values</title>
        <para>It is common to wonder �Why only class names and method argument lists? Why not distinguish between methods based on their return values?� For example, these two methods, which have the same name and arguments, are easily distinguished from each other:</para>
        <para>void f() {}</para>
        <para>int f() {}</para>
        <para> </para>
        <para>This works fine when the compiler can unequivocally determine the meaning from the context, as in <emphasis role="bold">int x = f( )</emphasis>. However, you can call a method and ignore the return value; this is often referred to as <emphasis role="italic">calling a method for its </emphasis><emphasis role="italic">side effect</emphasis> since you don�t care about the return value but instead want the other effects of the method call. So if you call the method this way:</para>
        <para>f();</para>
        <para> </para>
        <para>how can Java determine which <emphasis role="bold">f( )</emphasis> should be called? And how could someone reading the code see it? Because of this sort of problem, you cannot use return value types to distinguish overloaded methods.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064574"/><anchor xreflabel="Default
constructors" xml:id="_Toc375545279"/>Default constructors</title>
        <para>As mentioned previously, a default constructor (a.k.a. a �no-arg� constructor) is one without arguments, used to create a �vanilla object.� If you create a class that has no constructors, the compiler will automatically create a default constructor for you. For example:</para>
        <para>//: c04:DefaultConstructor.java</para>
        <para> </para>
        <para>class Bird {</para>
        <para>� int i;</para>
        <para>}</para>
        <para> </para>
        <para>public class DefaultConstructor {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Bird nc = new Bird(); // default!</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The line</para>
        <para>new Bird();</para>
        <para> </para>
        <para>creates a new object and calls the default constructor, even though one was not explicitly defined. Without it we would have no method to call to build our object. However, if you define any constructors (with or without arguments), the compiler will <emphasis role="italic">not</emphasis> synthesize one for you:</para>
        <para>class Bush {</para>
        <para>� Bush(int i) {}</para>
        <para>� Bush(double d) {}</para>
        <para>}</para>
        <para> </para>
        <para>Now if you say:</para>
        <para>new Bush();</para>
        <para> </para>
        <para>the compiler will complain that it cannot find a constructor that matches. It�s as if when you don�t put in any constructors, the compiler says �You are bound to need <emphasis role="italic">some</emphasis> constructor, so let me make one for you.� But if you write a constructor, the compiler says �You�ve written a constructor so you know what you�re doing; if you didn�t put in a default it�s because you meant to leave it out.�</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064575"/><anchor xreflabel="The " xml:id="_Toc375545280"/>The <emphasis role="bold">this </emphasis>keyword</title>
        <para>If you have two objects of the same type called <emphasis role="bold">a</emphasis> and <emphasis role="bold">b</emphasis>, you might wonder how it is that you can call a method <emphasis role="bold">f( )</emphasis> for both those objects:</para>
        <para>class Banana { void f(int i) { /* ... */ } }</para>
        <para>Banana a = new Banana(), b = new Banana();</para>
        <para>a.f(1);</para>
        <para>b.f(2);</para>
        <para> </para>
        <para>If there�s only one method called <emphasis role="bold">f( )</emphasis>, how can that method know whether it�s being called for the object <emphasis role="bold">a</emphasis> or <emphasis role="bold">b</emphasis>? </para>
        <para>To allow you to write the code in a convenient object-oriented syntax in which you �send a message to an object,� the compiler does some undercover work for you. There�s a secret first argument passed to the method <emphasis role="bold">f( )</emphasis>, and that argument is the reference to the object that�s being manipulated. So the two method calls above become something like:</para>
        <para>Banana.f(a,1);</para>
        <para>Banana.f(b,2);</para>
        <para> </para>
        <para>This is internal and you can�t write these expressions and get the compiler to accept them, but it gives you an idea of what�s happening.</para>
        <para>Suppose you�re inside a method and you�d like to get the reference to the current object. Since that reference is passed <emphasis role="italic">secretly</emphasis> by the compiler, there�s no identifier for it. However, for this purpose there�s a keyword: <emphasis role="bold">this</emphasis>. The <emphasis role="bold">this</emphasis> keyword�which can be used only inside a method�produces the reference to the object the method has been called for. You can treat this reference just like any other object reference. Keep in mind that if you�re calling a method of your class from within another method of your class, you don�t need to use <emphasis role="bold">this</emphasis>; you simply call the method. The current <emphasis role="bold">this</emphasis> reference is automatically used for the other method. Thus you can say:</para>
        <para>class Apricot {</para>
        <para>� void pick() { /* ... */ }</para>
        <para>� void pit() { pick(); /* ... */ }</para>
        <para>}</para>
        <para> </para>
        <para>Inside <emphasis role="bold">pit( )</emphasis>, you <emphasis role="italic">could</emphasis> say <emphasis role="bold">this.pick( )</emphasis> but there�s no need to. The compiler does it for you automatically. The <emphasis role="bold">this</emphasis> keyword is used only for those special cases in which you need to explicitly use the reference to the current object. For example, it�s often used in <emphasis role="bold">return</emphasis> statements when you want to return the reference to the current object:</para>
        <para>//: c04:Leaf.java</para>
        <para>// Simple use of the &quot;this&quot; keyword.</para>
        <para> </para>
        <para>public class Leaf {</para>
        <para>� int i = 0;</para>
        <para>� Leaf increment() {</para>
        <para>��� i++;</para>
        <para>��� return this;</para>
        <para>� }</para>
        <para>� void print() {</para>
        <para>��� System.out.println(&quot;i = &quot; + i);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Leaf x = new Leaf();</para>
        <para>��� x.increment().increment().increment().print();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Because <emphasis role="bold">increment( )</emphasis> returns the reference to the current object via the <emphasis role="bold">this</emphasis> keyword, multiple operations can easily be performed on the same object.</para>
        <section>
          <title>Calling constructors from constructors</title>
          <para>When you write several constructors for a class, there are times when you�d like to call one constructor from another to avoid duplicating code. You can do this using the <emphasis role="bold">this</emphasis> keyword. </para>
          <para>Normally, when you say <emphasis role="bold">this</emphasis>, it is in the sense of �this object� or �the current object,� and by itself it produces the reference to the current object. In a constructor, the <emphasis role="bold">this</emphasis> keyword takes on a different meaning when you give it an argument list: it makes an explicit call to the constructor that matches that argument list. Thus you have a straightforward way to call other constructors:</para>
          <para>//: c04:Flower.java</para>
          <para>// Calling constructors with &quot;this.&quot;</para>
          <para> </para>
          <para>public class Flower {</para>
          <para>� int petalCount = 0;</para>
          <para>� String s = new String(&quot;null&quot;);</para>
          <para>� Flower(int petals) {</para>
          <para>��� petalCount = petals;</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;Constructor w/ int arg only, petalCount= &quot;</para>
          <para>����� + petalCount);</para>
          <para>� }</para>
          <para>� Flower(String ss) {</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;Constructor w/ String arg only, s=&quot; + ss);</para>
          <para>�� �s = ss;</para>
          <para>� }</para>
          <para>� Flower(String s, int petals) {</para>
          <para>��� this(petals);</para>
          <para>//!��� this(s); // Can&apos;t call two!</para>
          <para>��� this.s = s; // Another use of &quot;this&quot;</para>
          <para>��� System.out.println(&quot;String &amp; int args&quot;);</para>
          <para>� }</para>
          <para>� Flower() {</para>
          <para>��� this(&quot;hi&quot;, 47);</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;default constructor (no args)&quot;);</para>
          <para>� }</para>
          <para>� void print() {</para>
          <para>//!��� this(11); // Not inside non-constructor!</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;petalCount = &quot; + petalCount + &quot; s = &quot;+ s);</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Flower x = new Flower();</para>
          <para>��� x.print();</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The constructor <emphasis role="bold">Flower(String s, int petals)</emphasis> shows that, while you can call one constructor using <emphasis role="bold">this</emphasis>, you cannot call two. In addition, the constructor call must be the first thing you do or you�ll get a compiler error message.</para>
          <para>This example also shows another way you�ll see <emphasis role="bold">this</emphasis> used. Since the name of the argument <emphasis role="bold">s </emphasis>and the name of the member data <emphasis role="bold">s</emphasis> are the same, there�s an ambiguity. You can resolve it by saying <emphasis role="bold">this.s</emphasis> to refer to the member data. You�ll often see this form used in Java code, and it�s used in numerous places in this book.</para>
          <para>In <emphasis role="bold">print( )</emphasis> you can see that the compiler won�t let you call a constructor from inside any method other than a constructor.</para>
        </section>
        <section>
          <title>The meaning of <emphasis role="bold">static</emphasis></title>
          <para>With the <emphasis role="bold">this </emphasis>keyword in mind, you can more fully understand what it means to make a method <emphasis role="bold">static</emphasis>. It means that there is no <emphasis role="bold">this</emphasis> for that particular method. You cannot call non-<emphasis role="bold">static</emphasis> methods from inside <emphasis role="bold">static</emphasis> methods<anchor xreflabel="[28]" xml:id="_ftnref28"/>[28] (although the reverse is possible), and you can call a <emphasis role="bold">static</emphasis> method for the class itself, without any object. In fact, that�s primarily what a <emphasis role="bold">static</emphasis> method is for. It�s as if you�re creating the equivalent of a global function (from C). Except global functions are not permitted in Java, and putting the <emphasis role="bold">static</emphasis> method inside a class allows it access to other <emphasis role="bold">static </emphasis>methods and to <emphasis role="bold">static</emphasis> fields.</para>
          <para>Some people argue that <emphasis role="bold">static</emphasis> methods are not object-oriented since they do have the semantics of a global function; with a <emphasis role="bold">static</emphasis> method you don�t send a message to an object, since there�s no <emphasis role="bold">this</emphasis>. This is probably a fair argument, and if you find yourself using a <emphasis role="italic">lot</emphasis> of static methods you should probably rethink your strategy. However, <emphasis role="bold">static</emphasis>s are pragmatic and there are times when you genuinely need them, so whether or not they are �proper OOP� should be left to the theoreticians. Indeed, even Smalltalk has the equivalent in its �class methods.�</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064576"/><anchor xreflabel="Cleanup:
finalization and 
garbage collection" xml:id="_Toc375545281"/>Cleanup: finalization and   garbage collection</title>
      <para>Programmers know about the importance of initialization, but often forget the importance of cleanup. After all, who needs to clean up an <emphasis role="bold">int</emphasis>? But with libraries, simply �letting go� of an object once you�re done with it is not always safe. Of course, Java has the garbage collector to reclaim the memory of objects that are no longer used. Now consider a very unusual case. Suppose your object allocates �special� memory without using <emphasis role="bold">new</emphasis>. The garbage collector knows only how to release memory allocated <emphasis role="italic">with</emphasis><emphasis role="bold">new</emphasis>, so it won�t know how to release the object�s �special� memory. To handle this case, Java provides a method called <emphasis role="bold">finalize( )</emphasis> that you can define for your class. Here�s how it�s <emphasis role="italic">supposed</emphasis> to work. When the garbage collector is ready to release the storage used for your object, it will first call <emphasis role="bold">finalize( )</emphasis>, and only on the next garbage-collection pass will it reclaim the object�s memory. So if you choose to use <emphasis role="bold">finalize( )</emphasis>, it gives you the ability to perform some important cleanup <emphasis role="italic">at the time of garbage collection</emphasis>.</para>
      <para>This is a potential programming pitfall because some programmers, especially C++ programmers, might initially mistake <emphasis role="bold">finalize( )</emphasis> for the <emphasis role="italic">destructor</emphasis> in C++, which is a function that is always called when an object is destroyed. But it is important to distinguish between C++ and Java here, because in C++ <emphasis role="italic">objects always get destroyed</emphasis> (in a bug-free program), whereas in Java objects do not always get garbage-collected. Or, put another way:</para>
      <para>Garbage collection is not destruction.</para>
      <para>If you remember this, you will stay out of trouble. What it means is that if there is some activity that must be performed before you no longer need an object, you must perform that activity yourself. Java has no destructor or similar concept, so you must create an ordinary method to perform this cleanup. For example, suppose in the process of creating your object it draws itself on the screen. If you don�t explicitly erase its image from the screen, it might never get cleaned up. If you put some kind of erasing functionality inside <emphasis role="bold">finalize( )</emphasis>, then if an object is garbage-collected, the image will first be removed from the screen, but if it isn�t, the image will remain. So a second point to remember is:</para>
      <para>Your objects might not get garbage-collected.</para>
      <para>You might find that the storage for an object never gets released because your program never nears the point of running out of storage. If your program completes and the garbage collector never gets around to releasing the storage for any of your objects, that storage will be returned to the operating system <emphasis role="italic">en masse</emphasis> as the program exits. This is a good thing, because garbage collection has some overhead, and if you never do it you never incur that expense.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064577"/><anchor xreflabel="What
is finalize( ) for?" xml:id="_Toc375545282"/>What is <emphasis role="bold">finalize( )</emphasis> for?</title>
        <para>You might believe at this point that you should not use <emphasis role="bold">finalize( )</emphasis> as a general-purpose cleanup method. What good is it?</para>
        <para>A third point to remember is:</para>
        <para>Garbage collection is only about memory.</para>
        <para>That is, the sole reason for the existence of the garbage collector is to recover memory that your program is no longer using. So any activity that is associated with garbage collection, most notably your <emphasis role="bold">finalize( )</emphasis> method, must also be only about memory and its deallocation. </para>
        <para>Does this mean that if your object contains other objects <emphasis role="bold">finalize( )</emphasis> should explicitly release those objects? Well, no�the garbage collector takes care of the release of all object memory regardless of how the object is created. It turns out that the need for <emphasis role="bold">finalize( )</emphasis> is limited to special cases, in which your object can allocate some storage in some way other than creating an object. But, you might observe, everything in Java is an object so how can this be?</para>
        <para>It would seem that <emphasis role="bold">finalize( )</emphasis> is in place because of the possibility that you�ll do something C-like by allocating memory using a mechanism other than the normal one in Java. This can happen primarily through <emphasis role="italic">native methods</emphasis>, which are a way to call non-Java code from Java. (Native methods are discussed in Appendix B.) C and C++ are the only languages currently supported by native methods, but since they can call subprograms in other languages, you can effectively call anything. Inside the non-Java code, C�s <emphasis role="bold">malloc( )</emphasis> family of functions might be called to allocate storage, and unless you call <emphasis role="bold">free( )</emphasis> that storage will not be released, causing a memory leak. Of course, <emphasis role="bold">free( )</emphasis> is a C and C++ function, so you�d need to call it in a native method inside your <emphasis role="bold">finalize( )</emphasis>.</para>
        <para>After reading this, you probably get the idea that you won�t use <emphasis role="bold">finalize( )</emphasis> much. You�re correct; it is not the appropriate place for normal cleanup to occur. So where should normal cleanup be performed?</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc312373857"/><anchor xreflabel="" xml:id="_Toc481064578"/><anchor xreflabel="You must perform cleanup" xml:id="_Toc375545283"/>You must perform cleanup</title>
        <para>To clean up an object, the user of that object must call a cleanup method at the point the cleanup is desired. This sounds pretty straightforward, but it collides a bit with the C++ concept of the destructor. In C++, all objects are destroyed. Or rather, all objects <emphasis role="italic">should be</emphasis> destroyed. If the C++ object is created as a local (i.e., on the stack�not possible in Java), then the destruction happens at the closing curly brace of the scope in which the object was created. If the object was created using <emphasis role="bold">new</emphasis> (like in Java) the destructor is called when the programmer calls the C++ operator <emphasis role="bold">delete</emphasis> (which doesn�t exist in Java). If the C++ programmer forgets to call <emphasis role="bold">delete</emphasis>, the destructor is never called and you have a memory leak, plus the other parts of the object never get cleaned up. This kind of bug can be very difficult to track down.</para>
        <para>In contrast, Java doesn�t allow you to create local objects�you must always use <emphasis role="bold">new</emphasis>. But in Java, there�s no �delete� to call to release the object since the garbage collector releases the storage for you. So from a simplistic standpoint you could say that because of garbage collection, Java has no destructor. You�ll see as this book progresses, however, that the presence of a garbage collector does not remove the need for or utility of destructors. (And you should never call <emphasis role="bold">finalize( )</emphasis> directly, so that�s not an appropriate avenue for a solution.) If you want some kind of cleanup performed other than storage release you must <emphasis role="italic">still</emphasis> explicitly call an appropriate method in Java, which is the equivalent of a C++ destructor without the convenience.</para>
        <para>One of the things <emphasis role="bold">finalize( )</emphasis> can be useful for is observing the process of garbage collection. The following example shows you what�s going on and summarizes the previous descriptions of garbage collection:</para>
        <para>//: c04:Garbage.java</para>
        <para>// Demonstration of the garbage</para>
        <para>// collector and finalization</para>
        <para> </para>
        <para>class Chair {</para>
        <para>� static boolean gcrun = false;</para>
        <para>� static boolean f = false;</para>
        <para>� static int created = 0;</para>
        <para>� static int finalized = 0;</para>
        <para>� int i;</para>
        <para>� Chair() {</para>
        <para>��� i = ++created;</para>
        <para>��� if(created == 47) </para>
        <para>����� System.out.println(&quot;Created 47&quot;);</para>
        <para>� }</para>
        <para>� public void finalize() {</para>
        <para>��� if(!gcrun) {</para>
        <para>����� // The first time finalize() is called:</para>
        <para>����� gcrun = true;</para>
        <para>����� System.out.println(</para>
        <para>������� &quot;Beginning to finalize after &quot; +</para>
        <para>������� created + &quot; Chairs have been created&quot;);</para>
        <para>��� }</para>
        <para>��� if(i == 47) {</para>
        <para>����� System.out.println(</para>
        <para>������� &quot;Finalizing Chair #47, &quot; +</para>
        <para>������� &quot;Setting flag to stop Chair creation&quot;);</para>
        <para>����� f = true;</para>
        <para>��� }</para>
        <para>��� finalized++;</para>
        <para>��� if(finalized &gt;= created)</para>
        <para>����� System.out.println(</para>
        <para>������� &quot;All &quot; + finalized + &quot; finalized&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Garbage {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� // As long as the flag hasn&apos;t been set,</para>
        <para>��� // make Chairs and Strings:</para>
        <para>��� while(!Chair.f) {</para>
        <para>����� new Chair();</para>
        <para>����� new String(&quot;To take up space&quot;);</para>
        <para>��� }</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;After all Chairs have been created:\n&quot; +</para>
        <para>����� &quot;total created = &quot; + Chair.created +</para>
        <para>����� &quot;, total finalized = &quot; + Chair.finalized);</para>
        <para>��� // Optional arguments force garbage</para>
        <para>��� // collection &amp; finalization:</para>
        <para>��� if(args.length &gt; 0) {</para>
        <para>����� if(args[0].equals(&quot;gc&quot;) || </para>
        <para>�������� args[0].equals(&quot;all&quot;)) {</para>
        <para>������� System.out.println(&quot;gc():&quot;);</para>
        <para>������� System.gc();</para>
        <para>����� }</para>
        <para>����� if(args[0].equals(&quot;finalize&quot;) || </para>
        <para>� �������args[0].equals(&quot;all&quot;)) {</para>
        <para>������� System.out.println(&quot;runFinalization():&quot;);</para>
        <para>������� System.runFinalization();</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� System.out.println(&quot;bye!&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The above program creates many <emphasis role="bold">Chair</emphasis> objects, and at some point after the garbage collector begins running, the program stops creating <emphasis role="bold">Chair</emphasis>s. Since the garbage collector can run at any time, you don�t know exactly when it will start up, so there�s a flag called <emphasis role="bold">gcrun</emphasis> to indicate whether the garbage collector has started running yet. A second flag <emphasis role="bold">f</emphasis> is a way for <emphasis role="bold">Chair</emphasis> to tell the <emphasis role="bold">main( )</emphasis> loop that it should stop making objects. Both of these flags are set within <emphasis role="bold">finalize( )</emphasis>, which is called during garbage collection.</para>
        <para>Two other <emphasis role="bold">static</emphasis> variables, <emphasis role="bold">created</emphasis> and <emphasis role="bold">finalized</emphasis>, keep track of the number of <emphasis role="bold">Chair</emphasis>s created versus the number that get finalized by the garbage collector. Finally, each <emphasis role="bold">Chair</emphasis> has its own (non-<emphasis role="bold">static</emphasis>) <emphasis role="bold">int</emphasis><emphasis role="bold">i</emphasis> so it can keep track of what number it is. When <emphasis role="bold">Chair</emphasis> number 47 is finalized, the flag is set to <emphasis role="bold">true</emphasis> to bring the process of <emphasis role="bold">Chair </emphasis>creation to a stop.</para>
        <para>All this happens in <emphasis role="bold">main( )</emphasis>, in the loop</para>
        <para>��� while(!Chair.f) {</para>
        <para>����� new Chair();</para>
        <para>����� new String(&quot;To take up space&quot;);</para>
        <para>��� }</para>
        <para> </para>
        <para>You might wonder how this loop could ever finish, since there�s nothing inside the loop that changes the value of <emphasis role="bold">Chair.f</emphasis>. However, the <emphasis role="bold">finalize( )</emphasis> process will, eventually, when it finalizes number 47.</para>
        <para>The creation of a <emphasis role="bold">String</emphasis> object during each iteration is simply extra storage being allocated to encourage the garbage collector to kick in, which it will do when it starts to get nervous about the amount of memory available.</para>
        <para>When you run the program, you provide a command-line argument of �gc,� �finalize,� or �all.� The �gc� argument will call the <emphasis role="bold">System.gc( )</emphasis> method (to force execution of the garbage collector). Using the �finalize� argument calls <emphasis role="bold">System.runFinalization( )</emphasis> which�in theory�will cause any unfinalized objects to be finalized. And �all� causes both methods to be called.</para>
        <para>The behavior of this program and the version in the first edition of this book shows that the whole issue of garbage collection and finalization has been evolving, with much of the evolution happening behind closed doors. In fact, by the time you read this, the behavior of the program may have changed once again.</para>
        <para>If <emphasis role="bold">System.gc( )</emphasis> is called, then finalization happens to all the objects. This was not necessarily the case with previous implementations of the JDK, although the documentation claimed otherwise. In addition, you�ll see that it doesn�t seem to make any difference whether <emphasis role="bold">System.runFinalization( )</emphasis> is called.</para>
        <para>However, you will see that only if <emphasis role="bold">System.gc( )</emphasis> is called after all the objects are created and discarded will all the finalizers be called. If you do not call <emphasis role="bold">System.gc( )</emphasis>, then only some of the objects will be finalized. In Java 1.1, a method <emphasis role="bold">System.runFinalizersOnExit( )</emphasis> was introduced that caused programs to run all the finalizers as they exited, but the design turned out to be buggy and the method was deprecated. This is yet another clue that the Java designers were thrashing about trying to solve the garbage collection and finalization problem. We can only hope that things have been worked out in Java 2.</para>
        <para>The preceding program shows that the promise that finalizers will always be run holds true, but only if you explicitly force it to happen yourself. If you don�t cause <emphasis role="bold">System.gc( ) </emphasis>to be called, you�ll get an output like this:</para>
        <para>Created 47</para>
        <para>Beginning to finalize after 3486 Chairs have been created</para>
        <para>Finalizing Chair #47, Setting flag to stop Chair creation</para>
        <para>After all Chairs have been created:</para>
        <para>total created = 3881, total finalized = 2684</para>
        <para>bye!</para>
        <para> </para>
        <para>Thus, not all finalizers get called by the time the program completes. If <emphasis role="bold">System.gc( )</emphasis> is called, it will finalize and destroy all the objects that are no longer in use up to that point. </para>
        <para>Remember that neither garbage collection nor finalization is guaranteed. If the Java Virtual Machine (JVM) isn�t close to running out of memory, then it will (wisely) not waste time recovering memory through garbage collection.</para>
      </section>
      <section>
        <title><anchor xreflabel="The death condition" xml:id="_Toc481064579"/>The death condition</title>
        <para>In general, you can�t rely on <emphasis role="bold">finalize( ) </emphasis>being called, and you must create separate �cleanup� functions and call them explicitly. So it appears that <emphasis role="bold">finalize( )</emphasis> is only useful for obscure memory cleanup that most programmers will never use. However, there is a very interesting use of <emphasis role="bold">finalize( )</emphasis> which does not rely on it being called every time. This is the verification of the <emphasis role="italic">death condition</emphasis><anchor xreflabel="[29]" xml:id="_ftnref29"/>[29] of an object.</para>
        <para>At the point that you�re no longer interested in an object�when it�s ready to be cleaned up�that object should be in a state whereby its memory can be safely released. For example, if the object represents an open file, that file should be closed by the programmer before the object is garbage-collected. If any portions of the object are not properly cleaned up, then you have a bug in your program that could be very difficult to find. The value of <emphasis role="bold">finalize( )</emphasis> is that it can be used to discover this condition, even if it isn�t always called. If one of the finalizations happens to reveal the bug, then you discover the problem, which is all you really care about.</para>
        <para>Here�s a simple example of how you might use it:</para>
        <para>//: c04:DeathCondition.java</para>
        <para>// Using finalize() to detect an object that </para>
        <para>// hasn&apos;t been properly cleaned up.</para>
        <para> </para>
        <para>class Book {</para>
        <para>� boolean checkedOut = false;</para>
        <para>� Book(boolean checkOut) { </para>
        <para>��� checkedOut = checkOut; </para>
        <para>� }</para>
        <para>� void checkIn() {</para>
        <para>��� checkedOut = false;</para>
        <para>� }</para>
        <para>��public void finalize() {</para>
        <para>��� if(checkedOut)</para>
        <para>����� System.out.println(&quot;Error: checked out&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class DeathCondition {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Book novel = new Book(true);</para>
        <para>��� // Proper cleanup:</para>
        <para>��� novel.checkIn();</para>
        <para>��� // Drop the reference, forget to clean up:</para>
        <para>��� new Book(true);</para>
        <para>��� // Force garbage collection &amp; finalization:</para>
        <para>��� System.gc();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The death condition is that all <emphasis role="bold">Book</emphasis> objects are supposed to be checked in before they are garbage-collected, but in <emphasis role="bold">main( )</emphasis> a programmer error doesn�t check in one of the books. Without <emphasis role="bold">finalize( )</emphasis> to verify the death condition, this could be a difficult bug to find.</para>
        <para>Note that <emphasis role="bold">System.gc( )</emphasis> is used to force finalization (and you should do this during program development to speed debugging). But even if it isn�t, it�s highly probable that the errant <emphasis role="bold">Book</emphasis> will eventually be discovered through repeated executions of the program (assuming the program allocates enough storage to cause the garbage collector to execute).</para>
      </section>
      <section>
        <title><anchor xreflabel="How a garbage collector works" xml:id="_Toc481064580"/>How a garbage collector works</title>
        <para>If you come from a programming language where allocating objects on the heap is expensive, you may naturally assume that Java�s scheme of allocating everything (except primitives) on the heap is expensive. However, it turns out that the garbage collector can have a significant impact on <emphasis role="italic">increasing</emphasis> the speed of object creation. This might sound a bit odd at first�that storage release affects storage allocation�but it�s the way some JVMs work and it means that allocating storage for heap objects in Java can be nearly as fast as creating storage on the stack in other languages.</para>
        <para>For example, you can think of the C++ heap as a yard where each object stakes out its own piece of turf. This real estate can become abandoned sometime later and must be reused. In some JVMs, the Java heap is quite different; it�s more like a conveyor belt that moves forward every time you allocate a new object. This means that object storage allocation is remarkably rapid. The �heap pointer� is simply moved forward into virgin territory, so it�s effectively the same as C++�s stack allocation. (Of course, there�s a little extra overhead for bookkeeping but it�s nothing like searching for storage.)</para>
        <para>Now you might observe that the heap isn�t in fact a conveyor belt, and if you treat it that way you�ll eventually start paging memory a lot (which is a big performance hit) and later run out. The trick is that the garbage collector steps in and while it collects the garbage it compacts all the objects in the heap so that you�ve effectively moved the �heap pointer� closer to the beginning of the conveyor belt and further away from a page fault. The garbage collector rearranges things and makes it possible for the high-speed, infinite-free-heap model to be used while allocating storage.</para>
        <para>To understand how this works, you need to get a little better idea of the way the different garbage collector (GC) schemes work. A simple but slow GC technique is reference counting. This means that each object contains a reference counter, and every time a reference is attached to an object the reference count is increased. Every time a reference goes out of scope or is set to <emphasis role="bold">null</emphasis>, the reference count is decreased. Thus, managing reference counts is a small but constant overhead that happens throughout the lifetime of your program. The garbage collector moves through the entire list of objects and when it finds one with a reference count of zero it releases that storage. The one drawback is that if objects circularly refer to each other they can have nonzero reference counts while still being garbage. Locating such self-referential groups requires significant extra work for the garbage collector. Reference counting is commonly used to explain one kind of garbage collection but it doesn�t seem to be used in any JVM implementations.</para>
        <para>In faster schemes, garbage collection is not based on reference counting. Instead, it is based on the idea that any nondead object must ultimately be traceable back to a reference that lives either on the stack or in static storage. The chain might go through several layers of objects. Thus, if you start in the stack and the static storage area and walk through all the references you�ll find all the live objects. For each reference that you find, you must trace into the object that it points to and then follow all the references in <emphasis role="italic">that</emphasis> object, tracing into the objects they point to, etc., until you�ve moved through the entire web that originated with the reference on the stack or in static storage. Each object that you move through must still be alive. Note that there is no problem with detached self-referential groups�these are simply not found, and are therefore automatically garbage.</para>
        <para>In the approach described here, the JVM uses an <emphasis role="italic">adaptive </emphasis>garbage-collection scheme, and what it does with the live objects that it locates depends on the variant currently being used. One of these variants is <emphasis role="italic">stop-and-copy</emphasis>. This means that�for reasons that will become apparent�the program is first stopped (this is not a background collection scheme). Then, each live object that is found is copied from one heap to another, leaving behind all the garbage. In addition, as the objects are copied into the new heap they are packed end-to-end, thus compacting the new heap (and allowing new storage to simply be reeled off the end as previously described).</para>
        <para>Of course, when an object is moved from one place to another, all references that point at (i.e., that <emphasis role="italic">reference</emphasis>) the object must be changed. The reference that goes from the heap or the static storage area to the object can be changed right away, but there can be other references pointing to this object that will be encountered later during the �walk.� These are fixed up as they are found (you could imagine a table that maps old addresses to new ones).</para>
        <para>There are two issues that make these so-called �copy collectors� inefficient. The first is the idea that you have two heaps and you slosh all the memory back and forth between these two separate heaps, maintaining twice as much memory as you actually need. Some JVMs deal with this by allocating the heap in chunks as needed and simply copying from one chunk to another.</para>
        <para>The second issue is the copying. Once your program becomes stable it might be generating little or no garbage. Despite that, a copy collector will still copy all the memory from one place to another, which is wasteful. To prevent this, some JVMs detect that no new garbage is being generated and switch to a different scheme (this is the �adaptive� part). This other scheme is called <emphasis role="italic">mark and sweep</emphasis>, and it�s what earlier versions of Sun�s JVM used all the time. For general use, mark and sweep is fairly slow, but when you know you�re generating little or no garbage it�s fast.</para>
        <para>Mark and sweep follows the same logic of starting from the stack and static storage and tracing through all the references to find live objects. However, each time it finds a live object that object is marked by setting a flag in it, but the object isn�t collected yet. Only when the marking process is finished does the sweep occur. During the sweep, the dead objects are released. However, no copying happens, so if the collector chooses to compact a fragmented heap it does so by shuffling objects around.</para>
        <para>The �stop-and-copy� refers to the idea that this type of garbage collection is <emphasis role="italic">not</emphasis> done in the background; instead, the program is stopped while the GC occurs. In the Sun literature you�ll find many references to garbage collection as a low-priority background process, but it turns out that the GC was not implemented that way, at least in earlier versions of the Sun JVM. Instead, the Sun garbage collector ran when memory got low. In addition, mark-and-sweep requires that the program be stopped.</para>
        <para>As previously mentioned, in the JVM described here memory is allocated in big blocks. If you allocate a large object, it gets its own block. Strict stop-and-copy requires copying every live object from the source heap to a new heap before you could free the old one, which translates to lots of memory. With blocks, the GC can typically use dead blocks to copy objects to as it collects. Each block has a <emphasis role="italic">generation count</emphasis> to keep track of whether it�s alive. In the normal case, only the blocks created since the last GC are compacted; all other blocks get their generation count bumped if they have been referenced from somewhere. This handles the normal case of lots of short-lived temporary objects. Periodically, a full sweep is made�large objects are still not copied (just get their generation count bumped) and blocks containing small objects are copied and compacted. The JVM monitors the efficiency of GC and if it becomes a waste of time because all objects are long-lived then it switches to mark-and-sweep. Similarly, the JVM keeps track of how successful mark-and-sweep is, and if the heap starts to become fragmented it switches back to stop-and-copy. This is where the �adaptive� part comes in, so you end up with a mouthful: �adaptive generational stop-and-copy mark-and-sweep.�</para>
        <para>There are a number of additional speedups possible in a JVM. An especially important one involves the operation of the loader and Just-In-Time (JIT) compiler. When a class must be loaded (typically, the first time you want to create an object of that class), the <emphasis role="bold">.class</emphasis> file is located and the byte codes for that class are brought into memory. At this point, one approach is to simply JIT all the code, but this has two drawbacks: it takes a little more time, which, compounded throughout the life of the program, can add up; and it increases the size of the executable (byte codes are significantly more compact than expanded JIT code) and this might cause paging, which definitely slows down a program. An alternative approach is <emphasis role="italic">lazy evaluation,</emphasis> which means that the code is not JIT compiled until necessary. Thus, code that never gets executed might never get JIT compiled.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064581"/><anchor xreflabel="Member
initialization" xml:id="_Toc375545284"/>Member initialization</title>
      <para>Java goes out of its way to guarantee that variables are properly initialized before they are used. In the case of variables that are defined locally to a method, this guarantee comes in the form of a compile-time error. So if you say:</para>
      <para>� void f() {</para>
      <para>��� int i;</para>
      <para>��� i++;</para>
      <para>� }</para>
      <para> </para>
      <para>you�ll get an error message that says that <emphasis role="bold">i</emphasis> might not have been initialized. Of course, the compiler could have given <emphasis role="bold">i</emphasis> a default value, but it�s more likely that this is a programmer error and a default value would have covered that up. Forcing the programmer to provide an initialization value is more likely to catch a bug.</para>
      <para>If a primitive is a data member of a class, however, things are a bit different. Since any method can initialize or use that data, it might not be practical to force the user to initialize it to its appropriate value before the data is used. However, it�s unsafe to leave it with a garbage value, so each primitive data member of a class is guaranteed to get an initial value. Those values can be seen here:</para>
      <para>//: c04:InitialValues.java</para>
      <para>// Shows default initial values.</para>
      <para> </para>
      <para>class Measurement {</para>
      <para>� boolean t;</para>
      <para>� char c;</para>
      <para>� byte b;</para>
      <para>� short s;</para>
      <para>� int i;</para>
      <para>� long l;</para>
      <para>� float f;</para>
      <para>� double d;</para>
      <para>� void print() {</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;Data type����� Initial value\n&quot; +</para>
      <para>����� &quot;boolean������� &quot; + t + &quot;\n&quot; +</para>
      <para>����� &quot;char���������� [&quot; + c + &quot;] &quot;+ (int)c +&quot;\n&quot;+</para>
      <para>����� &quot;byte���������� &quot; + b + &quot;\n&quot; +</para>
      <para>����� &quot;short��������� &quot; + s + &quot;\n&quot; +</para>
      <para>����� &quot;int����������� &quot; + i + &quot;\n&quot; +</para>
      <para>����� &quot;long���������� &quot; + l + &quot;\n&quot; +</para>
      <para>����� &quot;float��������� &quot; + f + &quot;\n&quot; +</para>
      <para>����� &quot;double�������� &quot; + d);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class InitialValues {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Measurement d = new Measurement();</para>
      <para>��� d.print();</para>
      <para>��� /* In this case you could also say:</para>
      <para>��� new Measurement().print();</para>
      <para>��� */</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The output of this program is:</para>
      <para>Data type����� Initial value</para>
      <para>boolean������� false</para>
      <para>char���������� [ ] 0</para>
      <para>byte��� �������0</para>
      <para>short��������� 0</para>
      <para>int����������� 0</para>
      <para>long���������� 0</para>
      <para>float��������� 0.0</para>
      <para>double�������� 0.0</para>
      <para> </para>
      <para>The <emphasis role="bold">char</emphasis> value is a zero, which prints as a space.</para>
      <para>You�ll see later that when you define an object reference inside a class without initializing it to a new object, that reference is given a special value of <emphasis role="bold">null</emphasis> (which is a Java keyword).</para>
      <para>You can see that even though the values are not specified, they automatically get initialized. So at least there�s no threat of working with uninitialized variables.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064582"/><anchor xreflabel="Specifying
initialization" xml:id="_Toc375545285"/>Specifying initialization</title>
        <para>What happens if you want to give a variable an initial value? One direct way to do this is simply to assign the value at the point you define the variable in the class. (Notice you cannot do this in C++, although C++ novices always try.) Here the field definitions in class <emphasis role="bold">Measurement</emphasis> are changed to provide initial values: </para>
        <para>class Measurement {</para>
        <para>� boolean b = true;</para>
        <para>� char c = &apos;x&apos;;</para>
        <para>� byte B = 47;</para>
        <para>� short s = 0xff;</para>
        <para>� int i = 999;</para>
        <para>� long l = 1;</para>
        <para>� float f = 3.14f;</para>
        <para>� double d = 3.14159;</para>
        <para>� //. . .</para>
        <para> </para>
        <para>You can also initialize nonprimitive objects in this same way. If <emphasis role="bold">Depth</emphasis> is a class, you can insert a variable and initialize it like so:</para>
        <para>class Measurement {</para>
        <para>� Depth o = new Depth();</para>
        <para>� boolean b = true;</para>
        <para>� // . . .</para>
        <para> </para>
        <para>If you haven�t given <emphasis role="bold">o</emphasis> an initial value and you try to use it anyway, you�ll get a run-time error called an <emphasis role="italic">exception</emphasis> (covered in Chapter 10).</para>
        <para>You can even call a method to provide an initialization value:</para>
        <para>class CInit {</para>
        <para>� int i = f();</para>
        <para>� //...</para>
        <para>}</para>
        <para> </para>
        <para>This method can have arguments, of course, but those arguments cannot be other class members that haven�t been initialized yet. Thus, you can do this:</para>
        <para>class CInit {</para>
        <para>� int i = f();</para>
        <para>� int j = g(i);</para>
        <para>� //...</para>
        <para>}</para>
        <para> </para>
        <para>But you cannot do this:</para>
        <para>class CInit {</para>
        <para>� int j = g(i);</para>
        <para>� int i = f();</para>
        <para>� //...</para>
        <para>}</para>
        <para> </para>
        <para>This is one place in which the compiler, appropriately, <emphasis role="italic">does</emphasis> complain about forward referencing, since this has to do with the order of initialization and not the way the program is compiled.</para>
        <para>This approach to initialization is simple and straightforward. It has the limitation that <emphasis role="italic">every</emphasis> object of type <emphasis role="bold">Measurement</emphasis> will get these same initialization values. Sometimes this is exactly what you need, but at other times you need more flexibility.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064583"/><anchor xreflabel="Constructor
initialization" xml:id="_Toc375545286"/>Constructor initialization</title>
        <para>The constructor can be used to perform initialization, and this gives you greater flexibility in your programming since you can call methods and perform actions at run-time to determine the initial values. There�s one thing to keep in mind, however: you aren�t precluding the automatic initialization, which happens before the constructor is entered. So, for example, if you say:</para>
        <para>class Counter {</para>
        <para>� int i;</para>
        <para>� Counter() { i = 7; }</para>
        <para>� // . . .</para>
        <para> </para>
        <para>then <emphasis role="bold">i </emphasis>will first be initialized to 0, then to 7. This is true with all the primitive types and with object references, including those that are given explicit initialization at the point of definition. For this reason, the compiler doesn�t try to force you to initialize elements in the constructor at any particular place, or before they are used�initialization is already guaranteed<anchor xreflabel="[30]" xml:id="_ftnref30"/>[30].</para>
        <section>
          <title>Order of initialization</title>
          <para>Within a class, the order of initialization is determined by the order that the variables are defined within the class. The variable definitions may be scattered throughout and in between method definitions, but the variables are initialized before any methods can be called�even the constructor. For example:</para>
          <para>//: c04:OrderOfInitialization.java</para>
          <para>// Demonstrates initialization order.</para>
          <para> </para>
          <para>// When the constructor is called to create a</para>
          <para>// Tag object, you&apos;ll see a message:</para>
          <para>class Tag {</para>
          <para>� Tag(int marker) {</para>
          <para>��� System.out.println(&quot;Tag(&quot; + marker + &quot;)&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class Card {</para>
          <para>� Tag t1 = new Tag(1); // Before constructor</para>
          <para>� Card() {</para>
          <para>��� // Indicate we&apos;re in the constructor:</para>
          <para>��� System.out.println(&quot;Card()&quot;);</para>
          <para>��� t3 = new Tag(33); // Reinitialize t3</para>
          <para>� }</para>
          <para>� Tag t2 = new Tag(2); // After constructor</para>
          <para>� void f() {</para>
          <para>��� System.out.println(&quot;f()&quot;);</para>
          <para>� }</para>
          <para>� Tag t3 = new Tag(3); // At end</para>
          <para>}</para>
          <para> </para>
          <para>public class OrderOfInitialization {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Card t = new Card();</para>
          <para>��� t.f(); // Shows that construction is done</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>In <emphasis role="bold">Card</emphasis>, the definitions of the <emphasis role="bold">Tag</emphasis> objects are intentionally scattered about to prove that they�ll all get initialized before the constructor is entered or anything else can happen. In addition, <emphasis role="bold">t3</emphasis> is reinitialized inside the constructor. The output is:</para>
          <para>Tag(1)</para>
          <para>Tag(2)</para>
          <para>Tag(3)</para>
          <para>Card()</para>
          <para>Tag(33)</para>
          <para>f()</para>
          <para> </para>
          <para>Thus, the <emphasis role="bold">t3</emphasis> reference gets initialized twice, once before and once during the constructor call. (The first object is dropped, so it can be garbage-collected later.) This might not seem efficient at first, but it guarantees proper initialization�what would happen if an overloaded constructor were defined that did <emphasis role="italic">not</emphasis> initialize <emphasis role="bold">t3</emphasis> and there wasn�t a �default� initialization for <emphasis role="bold">t3</emphasis> in its definition?</para>
        </section>
        <section>
          <title>Static data initialization</title>
          <para>When the data is <emphasis role="bold">static</emphasis> the same thing happens; if it�s a primitive and you don�t initialize it, it gets the standard primitive initial values. If it�s a reference to an object, it�s <emphasis role="bold">null</emphasis> unless you create a new object and attach your reference to it.</para>
          <para>If you want to place initialization at the point of definition, it looks the same as for non-<emphasis role="bold">static</emphasis>s. There�s only a single piece of storage for a <emphasis role="bold">static</emphasis>, regardless of how many objects are created. But the question arises of when the <emphasis role="bold">static</emphasis> storage gets initialized. An example makes this question clear:</para>
          <para>//: c04:StaticInitialization.java</para>
          <para>// Specifying initial values in a</para>
          <para>// class definition.</para>
          <para> </para>
          <para>class Bowl {</para>
          <para>� Bowl(int marker) {</para>
          <para>��� System.out.println(&quot;Bowl(&quot; + marker + &quot;)&quot;);</para>
          <para>� }</para>
          <para>� void f(int marker) {</para>
          <para>��� System.out.println(&quot;f(&quot; + marker + &quot;)&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class Table {</para>
          <para>� static Bowl b1 = new Bowl(1);</para>
          <para>� Table() {</para>
          <para>��� System.out.println(&quot;Table()&quot;);</para>
          <para>��� b2.f(1);</para>
          <para>� }</para>
          <para>� void f2(int marker) {</para>
          <para>��� System.out.println(&quot;f2(&quot; + marker + &quot;)&quot;);</para>
          <para>� }</para>
          <para>� static Bowl b2 = new Bowl(2);</para>
          <para>}</para>
          <para> </para>
          <para>class Cupboard {</para>
          <para>� Bowl b3 = new Bowl(3);</para>
          <para>� static Bowl b4 = new Bowl(4);</para>
          <para>� Cupboard() {</para>
          <para>��� System.out.println(&quot;Cupboard()&quot;);</para>
          <para>��� b4.f(2);</para>
          <para>� }</para>
          <para>� void f3(int marker) {</para>
          <para>��� System.out.println(&quot;f3(&quot; + marker + &quot;)&quot;);</para>
          <para>� }</para>
          <para>� static Bowl b5 = new Bowl(5);</para>
          <para>}</para>
          <para> </para>
          <para>public class StaticInitialization {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;Creating new Cupboard() in main&quot;);</para>
          <para>��� new Cupboard();</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;Creating new Cupboard() in main&quot;);</para>
          <para>��� new Cupboard();</para>
          <para>��� t2.f2(1);</para>
          <para>��� t3.f3(1);</para>
          <para>� }</para>
          <para>� static Table t2 = new Table();</para>
          <para>� static Cupboard t3 = new Cupboard();</para>
          <para>} ///:~</para>
          <para> </para>
          <para><emphasis role="bold">Bowl</emphasis> allows you to view the creation of a class, and <emphasis role="bold">Table</emphasis> and <emphasis role="bold">Cupboard</emphasis> create <emphasis role="bold">static</emphasis> members of <emphasis role="bold">Bowl</emphasis> scattered through their class definitions. Note that <emphasis role="bold">Cupboard</emphasis> creates a non-<emphasis role="bold">static</emphasis><emphasis role="bold">Bowl b3</emphasis> prior to the <emphasis role="bold">static</emphasis> definitions. The output shows what happens:</para>
          <para>Bowl(1)</para>
          <para>Bowl(2)</para>
          <para>Table()</para>
          <para>f(1)</para>
          <para>Bowl(4)</para>
          <para>Bowl(5)</para>
          <para>Bowl(3)</para>
          <para>Cupboard()</para>
          <para>f(2)</para>
          <para>Creating new Cupboard() in main</para>
          <para>Bowl(3)</para>
          <para>Cupboard()</para>
          <para>f(2)</para>
          <para>Creating new Cupboard() in main</para>
          <para>Bowl(3)</para>
          <para>Cupboard()</para>
          <para>f(2)</para>
          <para>f2(1)</para>
          <para>f3(1)</para>
          <para> </para>
          <para>The <emphasis role="bold">static</emphasis> initialization occurs only if it�s necessary. If you don�t create a <emphasis role="bold">Table </emphasis>object and you never refer to <emphasis role="bold">Table.b1 </emphasis>or <emphasis role="bold">Table.b2</emphasis>, the <emphasis role="bold">static Bowl b1 </emphasis>and <emphasis role="bold">b2 </emphasis>will never be created. However, they are initialized only when the <emphasis role="italic">first </emphasis><emphasis role="bold">Table </emphasis>object is created (or the first <emphasis role="bold">static</emphasis> access occurs). After that, the <emphasis role="bold">static</emphasis> objects are not reinitialized.</para>
          <para>The order of initialization is <emphasis role="bold">static</emphasis>s first, if they haven�t already been initialized by a previous object creation, and then the non-<emphasis role="bold">static</emphasis> objects. You can see the evidence of this in the output.</para>
          <para>It�s helpful to summarize the process of creating an object. Consider a class called <emphasis role="bold">Dog</emphasis>:</para>
          <para>The first time an object of type <emphasis role="bold">Dog</emphasis> is created, <emphasis role="italic">or</emphasis> the first time a <emphasis role="bold">static</emphasis> method or <emphasis role="bold">static </emphasis>field of class <emphasis role="bold">Dog</emphasis> is accessed, the Java interpreter must locate <emphasis role="bold">Dog.class</emphasis>, which it does by searching through the classpath.</para>
          <para>26.      As <emphasis role="bold">Dog.class</emphasis> is loaded (creating a <emphasis role="bold">Class</emphasis> object, which you�ll learn about later), all of its <emphasis role="bold">static</emphasis> initializers are run. Thus, <emphasis role="bold">static </emphasis>initialization takes place only once, as the <emphasis role="bold">Class</emphasis> object is loaded for the first time.</para>
          <para>27.      When you create a <emphasis role="bold">new Dog( )</emphasis>, the construction process for a <emphasis role="bold">Dog</emphasis> object first allocates enough storage for a <emphasis role="bold">Dog</emphasis> object on the heap.</para>
          <para>28.      This storage is wiped to zero, automatically setting all the primitives in that <emphasis role="bold">Dog</emphasis> object to their default values (zero for numbers and the equivalent for <emphasis role="bold">boolean</emphasis> and <emphasis role="bold">char</emphasis>) and the references to <emphasis role="bold">null</emphasis>.</para>
          <para>29.      Any initializations that occur at the point of field definition are executed.</para>
          <para>30.      Constructors are executed. As you shall see in Chapter 6, this might actually involve a fair amount of activity, especially when inheritance is involved.</para>
        </section>
        <section>
          <title>Explicit static initialization</title>
          <para>Java allows you to group other <emphasis role="bold">static</emphasis> initializations inside a special �<emphasis role="bold">static</emphasis> construction clause� (sometimes called a <emphasis role="italic">static block</emphasis>)<emphasis role="italic"/>in a class. It looks like this:</para>
          <para>class Spoon {</para>
          <para>� static int i;</para>
          <para>� static {</para>
          <para>��� i = 47;</para>
          <para>� }</para>
          <para>� // . . .</para>
          <para> </para>
          <para>It appears to be a method, but it�s just the <emphasis role="bold">static</emphasis> keyword followed by a method body. This code, like other <emphasis role="bold">static</emphasis> initializations, is executed only once, the first time you make an object of that class <emphasis role="italic">or</emphasis> the first time you access a <emphasis role="bold">static</emphasis> member of that class (even if you never make an object of that class). For example:</para>
          <para>//: c04:ExplicitStatic.java</para>
          <para>// Explicit static initialization</para>
          <para>// with the &quot;static&quot; clause.</para>
          <para> </para>
          <para>class Cup {</para>
          <para>� Cup(int marker) {</para>
          <para>��� System.out.println(&quot;Cup(&quot; + marker + &quot;)&quot;);</para>
          <para>� }</para>
          <para>� void f(int marker) {</para>
          <para>��� System.out.println(&quot;f(&quot; + marker + &quot;)&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class Cups {</para>
          <para>� static Cup c1;</para>
          <para>� static Cup c2;</para>
          <para>� static {</para>
          <para>��� c1 = new Cup(1);</para>
          <para>��� c2 = new Cup(2);</para>
          <para>� }</para>
          <para>� Cups() {</para>
          <para>��� System.out.println(&quot;Cups()&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>public class ExplicitStatic {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� System.out.println(&quot;Inside main()&quot;);</para>
          <para>��� Cups.c1.f(99);� // (1)</para>
          <para>� }</para>
          <para>� // static Cups x = new Cups();� // (2)</para>
          <para>� // static Cups y = new Cups();� // (2) </para>
          <para>} ///:~</para>
          <para> </para>
          <para>The <emphasis role="bold">static</emphasis> initializers for <emphasis role="bold">Cups</emphasis> run when either the access of the <emphasis role="bold">static</emphasis> object <emphasis role="bold">c1</emphasis> occurs on the line marked (1), or if line (1) is commented out and the lines marked (2) are uncommented. If both (1) and (2) are commented out, the <emphasis role="bold">static</emphasis> initialization for <emphasis role="bold">Cups</emphasis> never occurs. Also, it doesn�t matter if one or both of the lines marked (2) are uncommented; the static initialization only occurs once.</para>
        </section>
        <section>
          <title>Non-static instance initialization</title>
          <para>Java provides a similar syntax for initializing non-<emphasis role="bold">static</emphasis> variables for each object. Here�s an example:</para>
          <para>//: c04:Mugs.java</para>
          <para>// Java &quot;Instance Initialization.&quot;</para>
          <para> </para>
          <para>class Mug {</para>
          <para>� Mug(int marker) {</para>
          <para>��� System.out.println(&quot;Mug(&quot; + marker + &quot;)&quot;);</para>
          <para>� }</para>
          <para>� void f(int marker) {</para>
          <para>��� System.out.println(&quot;f(&quot; + marker + &quot;)&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>public class Mugs {</para>
          <para>� Mug c1;</para>
          <para>� Mug c2;</para>
          <para>� {</para>
          <para>��� c1 = new Mug(1);</para>
          <para>��� c2 = new Mug(2);</para>
          <para>��� System.out.println(&quot;c1 &amp; c2 initialized&quot;);</para>
          <para>� }</para>
          <para>� Mugs() {</para>
          <para>��� System.out.println(&quot;Mugs()&quot;);</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� System.out.println(&quot;Inside main()&quot;);</para>
          <para>��� Mugs x = new Mugs();</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>You can see that the instance initialization clause:</para>
          <para>� {</para>
          <para>��� c1 = new Mug(1);</para>
          <para>��� c2 = new Mug(2);</para>
          <para>��� System.out.println(&quot;c1 &amp; c2 initialized&quot;);</para>
          <para>� }</para>
          <para> </para>
          <para>looks exactly like the static initialization clause except for the missing <emphasis role="bold">static</emphasis> keyword. This syntax is necessary to support the initialization of <emphasis role="italic">anonymous inner classes</emphasis> (see Chapter 8).</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc312373861"/><anchor xreflabel="" xml:id="_Toc481064584"/><anchor xreflabel="Array initialization" xml:id="_Toc375545287"/>Array initialization</title>
      <para>Initializing arrays in C is error-prone and tedious. C++ uses <emphasis role="italic">aggregate initialization</emphasis> to make it much safer<anchor xreflabel="[31]" xml:id="_ftnref31"/>[31]. Java has no �aggregates� like C++, since everything is an object in Java. It does have arrays, and these are supported with array initialization.</para>
      <para>An array is simply a sequence of either objects or primitives, all the same type and packaged together under one identifier name. Arrays are defined and used with the square-brackets <emphasis role="italic">indexing operator</emphasis><emphasis role="bold">[ ]</emphasis>. To define an array you simply follow your type name with empty square brackets:</para>
      <para>int[] a1;</para>
      <para> </para>
      <para>You can also put the square brackets after the identifier to produce exactly the same meaning:</para>
      <para>int a1[];</para>
      <para> </para>
      <para>This conforms to expectations from C and C++ programmers. The former style, however, is probably a more sensible syntax, since it says that the type is �an <emphasis role="bold">int</emphasis> array.� That style will be used in this book.</para>
      <para>The compiler doesn�t allow you to tell it how big the array is. This brings us back to that issue of �references.� All that you have at this point is a reference to an array, and there�s been no space allocated for the array. To create storage for the array you must write an initialization expression. For arrays, initialization can appear anywhere in your code, but you can also use a special kind of initialization expression that must occur at the point where the array is created. This special initialization is a set of values surrounded by curly braces. The storage allocation (the equivalent of using <emphasis role="bold">new</emphasis>) is taken care of by the compiler in this case. For example:</para>
      <para>int[] a1 = { 1, 2, 3, 4, 5 };</para>
      <para> </para>
      <para>So why would you ever define an array reference without an array?</para>
      <para>int[] a2;</para>
      <para> </para>
      <para>Well, it�s possible to assign one array to another in Java, so you can say:</para>
      <para>a2 = a1;</para>
      <para> </para>
      <para>What you�re really doing is copying a reference, as demonstrated here:</para>
      <para>//: c04:Arrays.java</para>
      <para>// Arrays of primitives.</para>
      <para> </para>
      <para>public class Arrays {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� int[] a1 = { 1, 2, 3, 4, 5 };</para>
      <para>��� int[] a2;</para>
      <para>��� a2 = a1;</para>
      <para>��� for(int i = 0; i &lt; a2.length; i++)</para>
      <para>����� a2[i]++;</para>
      <para>��� for(int i = 0; i &lt; a1.length; i++)</para>
      <para>����� System.out.println(</para>
      <para>������� &quot;a1[&quot; + i + &quot;] = &quot; + a1[i]);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>You can see that <emphasis role="bold">a1</emphasis> is given an initialization value while <emphasis role="bold">a2</emphasis> is not; <emphasis role="bold">a2</emphasis> is assigned later�in this case, to another array. </para>
      <para>There�s something new here: all arrays have an intrinsic member (whether they�re arrays of objects or arrays of primitives) that you can query�but not change�to tell you how many elements there are in the array. This member is <emphasis role="bold">length</emphasis>. Since arrays in Java, like C and C++, start counting from element zero, the largest element you can index is <emphasis role="bold">length - 1</emphasis>. If you go out of bounds, C and C++ quietly accept this and allow you to stomp all over your memory, which is the source of many infamous bugs. However, Java protects you against such problems by causing a run-time error (an <emphasis role="italic">exception</emphasis>, the subject of Chapter 10) if you step out of bounds. Of course, checking every array access costs time and code and there�s no way to turn it off, which means that array accesses might be a source of inefficiency in your program if they occur at a critical juncture. For Internet security and programmer productivity, the Java designers thought that this was a worthwhile trade-off.</para>
      <para>What if you don�t know how many elements you�re going to need in your array while you�re writing the program? You simply use <emphasis role="bold">new</emphasis> to create the elements in the array. Here, <emphasis role="bold">new</emphasis> works even though it�s creating an array of primitives (<emphasis role="bold">new</emphasis> won�t create a nonarray primitive):</para>
      <para>//: c04:ArrayNew.java</para>
      <para>// Creating arrays with new.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>public class ArrayNew {</para>
      <para>� static Random rand = new Random();</para>
      <para>� static int pRand(int mod) {</para>
      <para>��� return Math.abs(rand.nextInt()) % mod + 1;</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� int[] a;</para>
      <para>��� a = new int[pRand(20)];</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;length of a = &quot; + a.length);</para>
      <para>��� for(int i = 0; i &lt; a.length; i++)</para>
      <para>����� System.out.println(</para>
      <para>������� &quot;a[&quot; + i + &quot;] = &quot; + a[i]);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Since the size of the array is chosen at random (using the <emphasis role="bold">pRand( )</emphasis> method), it�s clear that array creation is actually happening at run-time. In addition, you�ll see from the output of this program that array elements of primitive types are automatically initialized to �empty� values. (For numerics and <emphasis role="bold">char</emphasis>, this is zero, and for <emphasis role="bold">boolean</emphasis>, it�s <emphasis role="bold">false</emphasis>.)</para>
      <para>Of course, the array could also have been defined and initialized in the same statement:</para>
      <para>int[] a = new int[pRand(20)];</para>
      <para> </para>
      <para>If you�re dealing with an array of nonprimitive objects, you must always use <emphasis role="bold">new</emphasis>. Here, the reference issue comes up again because what you create is an array of references. Consider the wrapper type <emphasis role="bold">Integer</emphasis><emphasis role="bold">,</emphasis> which is a class and not a primitive:</para>
      <para>//: c04:ArrayClassObj.java</para>
      <para>// Creating an array of nonprimitive objects.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>public class ArrayClassObj {</para>
      <para>� static Random rand = new Random();</para>
      <para>� static int pRand(int mod) {</para>
      <para>��� return Math.abs(rand.nextInt()) % mod + 1;</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Integer[] a = new Integer[pRand(20)];</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;length of a = &quot; + a.length);</para>
      <para>��� for(int i = 0; i &lt; a.length; i++) {</para>
      <para>����� a[i] = new Integer(pRand(500));</para>
      <para>����� System.out.println(</para>
      <para>������� &quot;a[&quot; + i + &quot;] = &quot; + a[i]);</para>
      <para>��� }</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Here, even after <emphasis role="bold">new</emphasis> is called to create the array:</para>
      <para>Integer[] a = new Integer[pRand(20)];</para>
      <para> </para>
      <para>it�s only an array of references, and not until the reference itself is initialized by creating a new <emphasis role="bold">Integer</emphasis> object is the initialization complete:</para>
      <para>a[i] = new Integer(pRand(500));</para>
      <para> </para>
      <para>If you forget to create the object, however, you�ll get an exception at run-time when you try to read the empty array location.</para>
      <para>Take a look at the formation of the <emphasis role="bold">String </emphasis>object inside the print statements. You can see that the reference to the <emphasis role="bold">Integer</emphasis> object is automatically converted to produce a <emphasis role="bold">String </emphasis>representing the value inside the object.</para>
      <para>It�s also possible to initialize arrays of objects using the curly-brace-enclosed list. There are two forms:</para>
      <para>//: c04:ArrayInit.java</para>
      <para>// Array initialization.</para>
      <para> </para>
      <para>public class ArrayInit {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Integer[] a = {</para>
      <para>����� new Integer(1),</para>
      <para>����� new Integer(2),</para>
      <para>����� new Integer(3),</para>
      <para>��� };</para>
      <para> </para>
      <para>��� Integer[] b = new Integer[] {</para>
      <para>����� new Integer(1),</para>
      <para>����� new Integer(2),</para>
      <para>����� new Integer(3),</para>
      <para>��� };</para>
      <para>��}</para>
      <para>} ///:~</para>
      <para> </para>
      <para>This is useful at times, but it�s more limited since the size of the array is determined at compile-time. The final comma in the list of initializers is optional. (This feature makes for easier maintenance of long lists.)</para>
      <para>The second form of array initialization provides a convenient syntax to create and call methods that can produce the same effect as C�s <emphasis role="italic">variable argument lists</emphasis> (known as �varargs� in C). These can include unknown quantity of arguments as well as unknown types. Since all classes are ultimately inherited from the common root class <emphasis role="bold">Object</emphasis> (a subject you will learn more about as this book progresses), you can create a method that takes an array of <emphasis role="bold">Object</emphasis> and call it like this:</para>
      <para>//: c04:VarArgs.java</para>
      <para>// Using the array syntax to create</para>
      <para>// variable argument lists.</para>
      <para> </para>
      <para>class A { int i; }</para>
      <para> </para>
      <para>public class VarArgs {</para>
      <para>� static void f(Object[] x) {</para>
      <para>��� for(int i = 0; i &lt; x.length; i++)</para>
      <para>����� System.out.println(x[i]);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� f(new Object[] { </para>
      <para>������� new Integer(47), new VarArgs(), </para>
      <para>������� new Float(3.14), new Double(11.11) });</para>
      <para>��� f(new Object[] {&quot;one&quot;, &quot;two&quot;, &quot;three&quot; });</para>
      <para>��� f(new Object[] {new A(), new A(), new A()});</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>At this point, there�s not much you can do with these unknown objects, and this program uses the automatic <emphasis role="bold">String</emphasis> conversion to do something useful with each <emphasis role="bold">Object</emphasis>. In Chapter 12, which covers <emphasis role="italic">run-time type identification</emphasis> (RTTI), you�ll learn how to discover the exact type of such objects so that you can do something more interesting with them.</para>
      <section>
        <title><anchor xreflabel="Multidimensional arrays" xml:id="_Toc481064585"/>Multidimensional arrays</title>
        <para>Java allows you to easily create multidimensional arrays:</para>
        <para>//: c04:MultiDimArray.java</para>
        <para>// Creating multidimensional arrays.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class MultiDimArray {</para>
        <para>� static Random rand = new Random();</para>
        <para>� static int pRand(int mod) {</para>
        <para>��� return Math.abs(rand.nextInt()) % mod + 1;</para>
        <para>� }</para>
        <para>� static void prt(String s) {</para>
        <para>��� System.out.println(s);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int[][] a1 = {</para>
        <para>����� { 1, 2, 3, },</para>
        <para>����� { 4, 5, 6, },</para>
        <para>��� };</para>
        <para>��� for(int i = 0; i &lt; a1.length; i++)</para>
        <para>����� for(int j = 0; j &lt; a1[i].length; j++)</para>
        <para>������� prt(&quot;a1[&quot; + i + &quot;][&quot; + j +</para>
        <para>����������� &quot;] = &quot; + a1[i][j]);</para>
        <para>��� // 3-D array with fixed length:</para>
        <para>��� int[][][] a2 = new int[2][2][4];</para>
        <para>��� for(int i = 0; i &lt; a2.length; i++)</para>
        <para>����� for(int j = 0; j &lt; a2[i].length; j++)</para>
        <para>������� for(int k = 0; k &lt; a2[i][j].length;</para>
        <para>����������� k++)</para>
        <para>��������� prt(&quot;a2[&quot; + i + &quot;][&quot; +</para>
        <para>������������� j + &quot;][&quot; + k +</para>
        <para>������������� &quot;] = &quot; + a2[i][j][k]);</para>
        <para>��� // 3-D array with varied-length vectors:</para>
        <para>��� int[][][] a3 = new int[pRand(7)][][];</para>
        <para>��� for(int i = 0; i &lt; a3.length; i++) {</para>
        <para>����� a3[i] = new int[pRand(5)][];</para>
        <para>����� for(int j = 0; j &lt; a3[i].length; j++)</para>
        <para>������� a3[i][j] = new int[pRand(5)];</para>
        <para>��� }</para>
        <para>��� for(int i = 0; i &lt; a3.length; i++)</para>
        <para>����� for(int j = 0; j &lt; a3[i].length; j++)</para>
        <para>��� ����for(int k = 0; k &lt; a3[i][j].length;</para>
        <para>����������� k++)</para>
        <para>��������� prt(&quot;a3[&quot; + i + &quot;][&quot; +</para>
        <para>������������� j + &quot;][&quot; + k +</para>
        <para>������������� &quot;] = &quot; + a3[i][j][k]);</para>
        <para>��� // Array of nonprimitive objects:</para>
        <para>��� Integer[][] a4 = {</para>
        <para>����� { new Integer(1), new Integer(2)},</para>
        <para>����� { new Integer(3), new Integer(4)},</para>
        <para>����� { new Integer(5), new Integer(6)},</para>
        <para>��� };</para>
        <para>��� for(int i = 0; i &lt; a4.length; i++)</para>
        <para>����� for(int j = 0; j &lt; a4[i].length; j++)</para>
        <para>������� prt(&quot;a4[&quot; + i + &quot;][&quot; + j +</para>
        <para>����������� &quot;] = &quot; + a4[i][j]);</para>
        <para>��� Integer[][] a5;</para>
        <para>��� a5 = new Integer[3][];</para>
        <para>��� for(int i = 0; i &lt; a5.length; i++) {</para>
        <para>����� a5[i] = new Integer[3];</para>
        <para>����� for(int j = 0; j &lt; a5[i].length; j++)</para>
        <para>������� a5[i][j] = new Integer(i*j);</para>
        <para>��� }</para>
        <para>��� for(int i = 0; i &lt; a5.length; i++)</para>
        <para>����� for(int j = 0; j &lt; a5[i].length; j++)</para>
        <para>������� prt(&quot;a5[&quot; + i + &quot;][&quot; + j +</para>
        <para>����������� &quot;] = &quot; + a5[i][j]);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The code used for printing uses <emphasis role="bold">length</emphasis> so that it doesn�t depend on fixed array sizes.</para>
        <para>The first example shows a multidimensional array of primitives. You delimit each vector in the array with curly braces:</para>
        <para>��� int[][] a1 = {</para>
        <para>����� { 1, 2, 3, },</para>
        <para>����� { 4, 5, 6, },</para>
        <para>��� };</para>
        <para> </para>
        <para>Each set of square brackets moves you into the next level of the array.</para>
        <para>The second example shows a three-dimensional array allocated with <emphasis role="bold">new</emphasis>. Here, the whole array is allocated at once:</para>
        <para>int[][][] a2 = new int[2][2][4];</para>
        <para> </para>
        <para>But the third example shows that each vector in the arrays that make up the matrix can be of any length:</para>
        <para>��� int[][][] a3 = new int[pRand(7)][][];</para>
        <para>��� for(int i = 0; i &lt; a3.length; i++) {</para>
        <para>����� a3[i] = new int[pRand(5)][];</para>
        <para>����� for(int j = 0; j &lt; a3[i].length; j++)</para>
        <para>������� a3[i][j] = new int[pRand(5)];</para>
        <para>��� }</para>
        <para> </para>
        <para>The first <emphasis role="bold">new</emphasis> creates an array with a random-length first element and the rest undetermined. The second <emphasis role="bold">new</emphasis> inside the <emphasis role="bold">for</emphasis> loop fills out the elements but leaves the third index undetermined until you hit the third <emphasis role="bold">new</emphasis>.</para>
        <para>You will see from the output that array values are automatically initialized to zero if you don�t give them an explicit initialization value.</para>
        <para>You can deal with arrays of nonprimitive objects in a similar fashion, which is shown in the fourth example, demonstrating the ability to collect many <emphasis role="bold">new</emphasis> expressions with curly braces:</para>
        <para>��� Integer[][] a4 = {</para>
        <para>����� { new Integer(1), new Integer(2)},</para>
        <para>����� { new Integer(3), new Integer(4)},</para>
        <para>����� { new Integer(5), new Integer(6)},</para>
        <para>��� };</para>
        <para> </para>
        <para>The fifth example shows how an array of nonprimitive objects can be built up piece by piece:</para>
        <para>��� Integer[][] a5;</para>
        <para>��� a5 = new Integer[3][];</para>
        <para>��� for(int i = 0; i &lt; a5.length; i++) {</para>
        <para>���� �a5[i] = new Integer[3];</para>
        <para>����� for(int j = 0; j &lt; a5[i].length; j++)</para>
        <para>������� a5[i][j] = new Integer(i*j);</para>
        <para>��� }</para>
        <para> </para>
        <para>The <emphasis role="bold">i*j</emphasis> is just to put an interesting value into the <emphasis role="bold">Integer</emphasis>.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064586"/><anchor xreflabel="Summary" xml:id="_Toc375545288"/>Summary</title>
      <para>This seemingly elaborate mechanism for initialization, the constructor, should give you a strong hint about the critical importance placed on initialization in the language. As Stroustrup was designing C++, one of the first observations he made about productivity in C was that improper initialization of variables causes a significant portion of programming problems. These kinds of bugs are hard to find, and similar issues apply to improper cleanup. Because constructors allow you to <emphasis role="italic">guarantee</emphasis> proper initialization and cleanup (the compiler will not allow an object to be created without the proper constructor calls), you get complete control and safety.</para>
      <para>In C++, destruction is quite important because objects created with <emphasis role="bold">new</emphasis> must be explicitly destroyed. In Java, the garbage collector automatically releases the memory for all objects, so the equivalent cleanup method in Java isn�t necessary much of the time. In cases where you don�t need destructor-like behavior, Java�s garbage collector greatly simplifies programming, and adds much-needed safety in managing memory. Some garbage collectors can even clean up other resources like graphics and file handles. However, the garbage collector does add a run-time cost, the expense of which is difficult to put into perspective because of the overall slowness of Java interpreters at this writing. As this changes, we�ll be able to discover if the overhead of the garbage collector will preclude the use of Java for certain types of programs. (One of the issues is the unpredictability of the garbage collector.)</para>
      <para>Because of the guarantee that all objects will be constructed, there�s actually more to the constructor than what is shown here. In particular, when you create new classes using either <emphasis role="italic">composition</emphasis> or <emphasis role="italic">inheritance</emphasis> the guarantee of construction also holds, and some additional syntax is necessary to support this. You�ll learn about composition, inheritance, and how they affect constructors in future chapters.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064587"/><anchor xreflabel="Exercises" xml:id="_Toc375545289"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Create a class with a default constructor (one that takes no arguments) that prints a message. Create an object of this class.</para>
      <para>      22.         Add an overloaded constructor to Exercise 1 that takes a <emphasis role="bold">String</emphasis> argument and prints it along with your message.</para>
      <para>      23.         Create an array of object references of the class you created in Exercise 2, but don�t actually create objects to assign into the array. When you run the program, notice whether the initialization messages from the constructor calls are printed.</para>
      <para>      24.         Complete Exercise 3 by creating objects to attach to the array of references. </para>
      <para>      25.         Create an array of <emphasis role="bold">String</emphasis> objects and assign a string to each element. Print the array using a <emphasis role="bold">for</emphasis> loop.</para>
      <para>      26.         Create a class called <emphasis role="bold">Dog</emphasis> with an overloaded <emphasis role="bold">bark( )</emphasis> method. This method should be overloaded based on various primitive data types, and print different types of barking, howling, etc., depending on which overloaded version is called. Write a <emphasis role="bold">main( )</emphasis> that calls all the different versions.</para>
      <para>      27.         Modify Exercise 6 so that two of the overloaded methods have two arguments (of two different types), but in reversed order relative to each other. Verify that this works.</para>
      <para>      28.         Create a class without a constructor, and then create an object of that class in <emphasis role="bold">main( )</emphasis> to verify that the default constructor is automatically synthesized.</para>
      <para>      29.         Create a class with two methods. Within the first method, call the second method twice: the first time without using <emphasis role="bold">this</emphasis>, and the second time using <emphasis role="bold">this</emphasis>.</para>
      <para>      30.         Create a class with two (overloaded) constructors. Using <emphasis role="bold">this</emphasis>, call the second constructor inside the first one.</para>
      <para>      31.         Create a class with a <emphasis role="bold">finalize( )</emphasis> method that prints a message. In <emphasis role="bold">main( )</emphasis>, create an object of your class. Explain the behavior of your program.</para>
      <para>      32.         Modify Exercise 11 so that your <emphasis role="bold">finalize( )</emphasis> will always be called.</para>
      <para>      33.         Create a class called <emphasis role="bold">Tank</emphasis> that can be filled and emptied, and has a <emphasis role="italic">death condition</emphasis> that it must be empty when the object is cleaned up. Write a <emphasis role="bold">finalize( )</emphasis> that verifies this death condition. In <emphasis role="bold">main( )</emphasis>, test the possible scenarios that can occur when your <emphasis role="bold">Tank</emphasis> is used.</para>
      <para>      34.         Create a class containing an <emphasis role="bold">int</emphasis> and a <emphasis role="bold">char</emphasis> that are not initialized, and print their values to verify that Java performs default initialization.</para>
      <para>      35.         Create a class containing an uninitialized <emphasis role="bold">String</emphasis> reference. Demonstrate that this reference is initialized by Java to <emphasis role="bold">null</emphasis>.</para>
      <para>      36.         Create a class with a <emphasis role="bold">String </emphasis>field that is initialized at the point of definition, and another one that is initialized by the constructor. What is the difference between the two approaches?</para>
      <para>      37.         Create a class with a <emphasis role="bold">static String </emphasis>field that is initialized at the point of definition, and another one that is initialized by the <emphasis role="bold">static </emphasis>block. Add a <emphasis role="bold">static</emphasis> method that prints both fields and demonstrates that they are both initialized before they are used.</para>
      <para>      38.         Create a class with a <emphasis role="bold">String</emphasis> that is initialized using �instance initialization.� Describe a use for this feature (other than the one specified in this book).</para>
      <para>      39.         Write a method that creates and initializes a two-dimensional array of <emphasis role="bold">double</emphasis>. The size of the array is determined by the arguments of the method, and the initialization values are a range determined by beginning and ending values that are also arguments of the method. Create a second method that will print the array generated by the first method. In <emphasis role="bold">main( )</emphasis> test the methods by creating and printing several different sizes of arrays.</para>
      <para>      40.         Repeat Exercise 19 for a three-dimensional array.</para>
      <para>      41.         Comment the line marked (1) in <emphasis role="bold">ExplicitStatic.java</emphasis> and verify that the static initialization clause is not called. Now uncomment one of the lines marked (2) and verify that the static initialization clause <emphasis role="italic">is</emphasis> called. Now uncomment the other line marked (2) and verify that static initialization only occurs once.</para>
      <para>      42.         Experiment with <emphasis role="bold">Garbage.java</emphasis> by running the program using the arguments �gc,� �finalize,� or �all.� Repeat the process and see if you detect any patterns in the output. Change the code so that <emphasis role="bold">System.runFinalization( ) </emphasis>is called <emphasis role="italic">before</emphasis><emphasis role="bold">System.gc( )</emphasis> and observe the results.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064588"/><anchor xreflabel="" xml:id="_Toc477690725"/><anchor xreflabel="" xml:id="_Toc375545290"/><anchor xreflabel="" xml:id="Chapter_5"/>5: Hiding the Implementation</title>
    <para>A primary consideration in object-oriented design is �separating the things that change from the things that stay the same.�</para>
    <para>This is particularly important for libraries. The user (<emphasis role="italic">client programmer</emphasis>) of that library must be able to rely on the part they use, and know that they won�t need to rewrite code if a new version of the library comes out. On the flip side, the library creator must have the freedom to make modifications and improvements with the certainty that the client programmer�s code won�t be affected by those changes.</para>
    <para>This can be achieved through convention. For example, the library programmer must agree to not remove existing methods when modifying a class in the library, since that would break the client programmer�s code. The reverse situation is thornier, however. In the case of a data member, how can the library creator know which data members have been accessed by client programmers? This is also true with methods that are only part of the implementation of a class, and not meant to be used directly by the client programmer. But what if the library creator wants to rip out an old implementation and put in a new one? Changing any of those members might break a client programmer�s code. Thus the library creator is in a strait jacket and can�t change anything.</para>
    <para>To solve this problem, Java provides <emphasis role="italic">access specifiers</emphasis> to allow the library creator to say what is available to the client programmer and what is not. The levels of access control from �most access� to �least access� are <emphasis role="bold">public</emphasis>, <emphasis role="bold">protected</emphasis>, �friendly� (which has no keyword), and<emphasis role="bold"/><emphasis role="bold">private</emphasis>. From the previous paragraph you might think that, as a library designer, you�ll want to keep everything as �private� as possible, and expose only the methods that you want the client programmer to use. This is exactly right, even though it�s often counterintuitive for people who program in other languages (especially C) and are used to accessing everything without restriction. By the end of this chapter you should be convinced of the value of access control in Java.</para>
    <para>The concept of a library of components and the control over who can access the components of that library is not complete, however. There�s still the question of how the components are bundled together into a cohesive library unit. This is controlled with the <emphasis role="bold">package</emphasis> keyword in Java, and the access specifiers are affected by whether a class is in the same package or in a separate package. So to begin this chapter, you�ll learn how library components are placed into packages. Then you�ll be able to understand the complete meaning of the access specifiers.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064589"/><anchor xreflabel="package: the library unit" xml:id="_Toc375545291"/>package: the library unit</title>
      <para>A package is what you get when you use the <emphasis role="bold">import</emphasis> keyword to bring in an entire library, such as</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>This brings in the entire utility library that�s part of the standard Java distribution. Since, for example, the class <emphasis role="bold">ArrayList</emphasis> is in <emphasis role="bold">java.util</emphasis>, you can now either specify the full name <emphasis role="bold">java.util.ArrayList</emphasis> (which you can do without the <emphasis role="bold">import</emphasis> statement), or you can simply say <emphasis role="bold">ArrayList</emphasis> (because of the <emphasis role="bold">import</emphasis>).</para>
      <para>If you want to bring in a single class, you can name that class in the <emphasis role="bold">import</emphasis> statement</para>
      <para>import java.util.ArrayList;</para>
      <para> </para>
      <para>Now you can use <emphasis role="bold">ArrayList</emphasis> with no qualification. However, none of the other classes in <emphasis role="bold">java.util</emphasis> are available.</para>
      <para>The reason for all this importing is to provide a mechanism to manage �name spaces.� The names of all your class members are insulated from each other. A method <emphasis role="bold">f( )</emphasis> inside a class <emphasis role="bold">A</emphasis> will not clash with an <emphasis role="bold">f( )</emphasis> that has the same signature (argument list) in class <emphasis role="bold">B</emphasis>. But what about the class names? Suppose you create a <emphasis role="bold">stack</emphasis> class that is installed on a machine that already has a <emphasis role="bold">stack</emphasis> class that�s written by someone else? With Java on the Internet, this can happen without the user knowing it, since classes can get downloaded automatically in the process of running a Java program.</para>
      <para>This potential clashing of names is why it�s important to have complete control over the name spaces in Java, and to be able to create a completely unique name regardless of the constraints of the Internet.</para>
      <para>So far, most of the examples in this book have existed in a single file and have been designed for local use, and haven�t bothered with package names. (In this case the class name is placed in the �default package.�) This is certainly an option, and for simplicity�s sake this approach will be used whenever possible throughout the rest of this book. However, if you�re planning to create libraries or programs that are friendly to other Java programs on the same machine, you must think about preventing class name clashes.</para>
      <para>When you create a source-code file for Java, it�s commonly called a <emphasis role="italic">compilation unit</emphasis> (sometimes a <emphasis role="italic">translation unit</emphasis>). Each compilation unit must have a name ending in <emphasis role="bold">.java</emphasis>, and inside the compilation unit there can be a <emphasis role="bold">public</emphasis> class that must have the same name as the file (including capitalization, but excluding the <emphasis role="bold">.java</emphasis> filename extension). There can be only<emphasis role="italic"> one</emphasis><emphasis role="bold">public</emphasis> class in each compilation unit, otherwise the compiler will complain. The rest of the classes in that compilation unit, if there are any, are hidden from the world outside that package because they�re <emphasis role="italic">not</emphasis><emphasis role="bold">public</emphasis>, and they comprise �support� classes for the main <emphasis role="bold">public</emphasis> class.</para>
      <para>When you compile a <emphasis role="bold">.java</emphasis> file you get an output file with exactly the same name but an extension of <emphasis role="bold">.class</emphasis><emphasis role="italic">for each class in the </emphasis><emphasis role="bold">.java</emphasis> file. Thus you can end up with quite a few <emphasis role="bold">.class</emphasis> files from a small number of <emphasis role="bold">.java</emphasis> files. If you�ve programmed with a compiled language, you might be used to the compiler spitting out an intermediate form (usually an �obj� file) that is then packaged together with others of its kind using a linker (to create an executable file) or a librarian (to create a library). That�s not how Java works. A working program is a bunch of <emphasis role="bold">.class</emphasis> files, which can be packaged and compressed into a JAR file (using Java�s <emphasis role="bold">jar </emphasis>archiver). The Java interpreter is responsible for finding, loading, and interpreting these files<anchor xreflabel="[32]" xml:id="_ftnref32"/>[32].</para>
      <para>A library is also a bunch of these class files. Each file has one class that is <emphasis role="bold">public</emphasis> (you�re not forced to have a <emphasis role="bold">public</emphasis> class, but it�s typical), so there�s one component for each file. If you want to say that all these components (that are in their own separate <emphasis role="bold">.java </emphasis>and <emphasis role="bold">.class </emphasis>files) belong together, that�s where the <emphasis role="bold">package</emphasis> keyword comes in.</para>
      <para>When you say:</para>
      <para>package mypackage;</para>
      <para> </para>
      <para>at the beginning of a file (if you use a <emphasis role="bold">package </emphasis>statement, it <emphasis role="italic">must </emphasis>appear as the first noncomment in the file), you�re stating that this compilation unit is part of a library named <emphasis role="bold">mypackage</emphasis>. Or, put another way, you�re saying that the <emphasis role="bold">public</emphasis> class name within this compilation unit is under the umbrella of the name <emphasis role="bold">mypackage</emphasis>, and if anyone wants to use the name they must either fully specify the name or use the <emphasis role="bold">import</emphasis> keyword in combination with <emphasis role="bold">mypackage</emphasis> (using the choices given previously). Note that the convention for Java package names is to use all lowercase letters, even for intermediate words.</para>
      <para>For example, suppose the name of the file is <emphasis role="bold">MyClass.java</emphasis>. This means there can be one and only one <emphasis role="bold">public</emphasis> class in that file, and the name of that class must be <emphasis role="bold">MyClass</emphasis> (including the capitalization):</para>
      <para>package mypackage;</para>
      <para>public class MyClass {</para>
      <para>� // . . .</para>
      <para> </para>
      <para>Now, if someone wants to use <emphasis role="bold">MyClass</emphasis> or, for that matter, any of the other <emphasis role="bold">public</emphasis> classes in <emphasis role="bold">mypackage</emphasis>, they must use the <emphasis role="bold">import</emphasis> keyword to make the name or names in <emphasis role="bold">mypackage</emphasis> available. The alternative is to give the fully qualified name:</para>
      <para>mypackage.MyClass m = new mypackage.MyClass();</para>
      <para> </para>
      <para>The <emphasis role="bold">import</emphasis> keyword can make this much cleaner:</para>
      <para>import mypackage.*;</para>
      <para>// . . . </para>
      <para>MyClass m = new MyClass();</para>
      <para> </para>
      <para>It�s worth keeping in mind that what the <emphasis role="bold">package</emphasis> and <emphasis role="bold">import</emphasis> keywords allow you to do, as a library designer, is to divide up the single global name space so you won�t have clashing names, no matter how many people get on the Internet and start writing classes in Java.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064590"/><anchor xreflabel="Creating
unique package names" xml:id="_Toc375545292"/>Creating unique package names</title>
        <para>You might observe that, since a package never really gets �packaged� into a single file, a package could be made up of many <emphasis role="bold">.class</emphasis> files, and things could get a bit cluttered. To prevent this, a logical thing to do is to place all the <emphasis role="bold">.class</emphasis> files for a particular package into a single directory; that is, use the hierarchical file structure of the operating system to your advantage. This is one way that Java references the problem of clutter; you�ll see the other way later when the <emphasis role="bold">jar</emphasis> utility is introduced. </para>
        <para>Collecting the package files into a single subdirectory solves two other problems: creating unique package names, and finding those classes that might be buried in a directory structure someplace. This is accomplished, as was introduced in Chapter 2, by encoding the path of the location of the <emphasis role="bold">.class</emphasis> file into the name of the <emphasis role="bold">package</emphasis>. The compiler enforces this, but by convention, the first part of the <emphasis role="bold">package</emphasis> name is the Internet domain name of the creator of the class, reversed. Since Internet domain names are guaranteed to be unique, <emphasis role="italic">if</emphasis> you follow this convention it�s guaranteed that your <emphasis role="bold">package</emphasis> name will be unique and thus you�ll never have a name clash. (That is, until you lose the domain name to someone else who starts writing Java code with the same path names as you did.) Of course, if you don�t have your own domain name then you must fabricate an unlikely combination (such as your first and last name) to create unique package names. If you�ve decided to start publishing Java code it�s worth the relatively small effort to get a domain name.</para>
        <para>The second part of this trick is resolving the <emphasis role="bold">package</emphasis> name into a directory on your machine, so when the Java program runs and it needs to load the <emphasis role="bold">.class </emphasis>file (which it does dynamically, at the point in the program where it needs to create an object of that particular class, or the first time you access a <emphasis role="bold">static </emphasis>member of the class), it can locate the directory where the <emphasis role="bold">.class </emphasis>file resides.</para>
        <para>The Java interpreter proceeds as follows. First, it finds the environment variable CLASSPATH (set via the operating system, sometimes by the installation program that installs Java or a Java-based tool on your machine). CLASSPATH contains one or more directories that are used as roots for a search for <emphasis role="bold">.class</emphasis> files. Starting at that root, the interpreter will take the package name and replace each dot with a slash to generate a path name from the CLASSPATH root (so <emphasis role="bold">package foo.bar.baz</emphasis> becomes <emphasis role="bold">foo\bar\baz </emphasis>or <emphasis role="bold">foo/bar/baz </emphasis>or possibly something else, depending on your operating system). This is then concatenated to the various entries in the CLASSPATH. That�s where it looks for the <emphasis role="bold">.class</emphasis> file with the name corresponding to the class you�re trying to create. (It also searches some standard directories relative to where the Java interpreter resides).</para>
        <para>To understand this, consider my domain name, which is <emphasis role="bold">bruceeckel.com</emphasis>. By reversing this, <emphasis role="bold">com.bruceeckel</emphasis> establishes my unique global name for my classes. (The com, edu, org, etc., extension was formerly capitalized in Java packages, but this was changed in Java 2 so the entire package name is lowercase.) I can further subdivide this by deciding that I want to create a library named <emphasis role="bold">simple</emphasis>, so I�ll end up with a package name:</para>
        <para>package com.bruceeckel.simple;</para>
        <para> </para>
        <para>Now this package name can be used as an umbrella name space for the following two files:</para>
        <para>//: com:bruceeckel:simple:Vector.java</para>
        <para>// Creating a package.</para>
        <para>package com.bruceeckel.simple;</para>
        <para> </para>
        <para>public class Vector {</para>
        <para>� public Vector() {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;com.bruceeckel.util.Vector&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>When you create your own packages, you�ll discover that the <emphasis role="bold">package</emphasis> statement must be the first noncomment code in the file. The second file looks much the same:</para>
        <para>//: com:bruceeckel:simple:List.java</para>
        <para>// Creating a package.</para>
        <para>package com.bruceeckel.simple;</para>
        <para> </para>
        <para>public class List {</para>
        <para>� public List() {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;com.bruceeckel.util.List&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Both of these files are placed in the subdirectory on my system:</para>
        <para>C:\DOC\JavaT\com\bruceeckel\simple</para>
        <para> </para>
        <para>If you walk back through this, you can see the package name <emphasis role="bold">com.bruceeckel.simple</emphasis>, but what about the first portion of the path? That�s taken care of in the CLASSPATH environment variable, which is, on my machine:</para>
        <para>CLASSPATH=.;D:\JAVA\LIB;C:\DOC\JavaT</para>
        <para> </para>
        <para>You can see that the CLASSPATH can contain a number of alternative search paths. </para>
        <para>There�s a variation when using JAR files, however. You must put the name of the JAR file in the classpath, not just the path where it�s located. So for a JAR named <emphasis role="bold">grape.jar</emphasis> your classpath would include:</para>
        <para>CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar</para>
        <para> </para>
        <para>Once the classpath is set up properly, the following file can be placed in any directory:</para>
        <para>//: c05:LibTest.java</para>
        <para>// Uses the library.</para>
        <para>import com.bruceeckel.simple.*;</para>
        <para> </para>
        <para>public class LibTest {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Vector v = new Vector();</para>
        <para>��� List l = new List();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>When the compiler encounters the <emphasis role="bold">import</emphasis> statement, it begins searching at the directories specified by CLASSPATH, looking for subdirectory com\bruceeckel\simple, then seeking the compiled files of the appropriate names (<emphasis role="bold">Vector.class</emphasis> for <emphasis role="bold">Vector</emphasis> and <emphasis role="bold">List.class</emphasis> for <emphasis role="bold">List</emphasis>). Note that both the classes and the desired methods in <emphasis role="bold">Vector</emphasis> and <emphasis role="bold">List</emphasis> must be <emphasis role="bold">public</emphasis>.</para>
        <para>Setting the CLASSPATH has been such a trial for beginning Java users (it was for me, when I started) that Sun made the JDK in Java 2 a bit smarter. You�ll find that, when you install it, even if you don�t set a CLASSPATH you�ll be able to compile and run basic Java programs. To compile and run the source-code package for this book (available on the CD ROM packaged with this book, or at <emphasis role="italic">www.BruceEckel.com</emphasis>), however, you will need to make some modifications to your CLASSPATH (these are explained in the source-code package).</para>
        <section>
          <title>Collisions</title>
          <para>What happens if two libraries are imported via * and they include the same names? For example, suppose a program does this:</para>
          <para>import com.bruceeckel.simple.*;</para>
          <para>import java.util.*;</para>
          <para> </para>
          <para>Since <emphasis role="bold">java.util.*</emphasis> also contains a <emphasis role="bold">Vector</emphasis> class, this causes a potential collision. However, as long as you don�t write the code that actually causes the collision, everything is OK�this is good because otherwise you might end up doing a lot of typing to prevent collisions that would never happen.</para>
          <para>The collision <emphasis role="italic">does</emphasis> occur if you now try to make a <emphasis role="bold">Vector</emphasis>:</para>
          <para>Vector v = new Vector();</para>
          <para> </para>
          <para>Which <emphasis role="bold">Vector</emphasis> class does this refer to? The compiler can�t know, and the reader can�t know either. So the compiler complains and forces you to be explicit. If I want the standard Java <emphasis role="bold">Vector</emphasis>, for example, I must say:</para>
          <para>java.util.Vector v = new java.util.Vector();</para>
          <para> </para>
          <para>Since this (along with the CLASSPATH) completely specifies the location of that <emphasis role="bold">Vector</emphasis>, there�s no need for the <emphasis role="bold">import java.util.*</emphasis> statement unless I�m using something else from <emphasis role="bold">java.util</emphasis>.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064591"/><anchor xreflabel="A
custom tool library" xml:id="_Toc375545293"/>A custom tool library<anchor xreflabel="" xml:id="COM_EckelObjects_tools"/></title>
        <para>With this knowledge, you can now create your own libraries of tools to reduce or eliminate duplicate code. Consider, for example, creating an alias for <emphasis role="bold">System.out.println( )</emphasis> to reduce typing. This can be part of a package called <emphasis role="bold">tools</emphasis>:</para>
        <para>//: com:bruceeckel:tools:P.java</para>
        <para>// The P.rint &amp; P.rintln shorthand.</para>
        <para>package com.bruceeckel.tools;</para>
        <para> </para>
        <para>public class P {</para>
        <para>� public static void rint(String s) {</para>
        <para>��� System.out.print(s);</para>
        <para>� }</para>
        <para>� public static void rintln(String s) {</para>
        <para>��� System.out.println(s);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can use this shorthand to print a <emphasis role="bold">String</emphasis> either with a newline (<emphasis role="bold">P.rintln( )</emphasis>) or without a newline (<emphasis role="bold">P.rint( )</emphasis>).<anchor xreflabel="" xml:id="AAASpellcheck"/></para>
        <para>You can guess that the location of this file must be in a directory that starts at one of the CLASSPATH locations, then continues <emphasis role="bold">com/bruceeckel/tools</emphasis>. After compiling, the <emphasis role="bold">P.class</emphasis> file can be used anywhere on your system with an <emphasis role="bold">import</emphasis> statement:</para>
        <para>//: c05:ToolTest.java</para>
        <para>// Uses the tools library.</para>
        <para>import com.bruceeckel.tools.*;</para>
        <para> </para>
        <para>public class ToolTest {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� P.rintln(&quot;Available from now on!&quot;);</para>
        <para>��� P.rintln(&quot;&quot; + 100); // Force it to be a String</para>
        <para>��� P.rintln(&quot;&quot; + 100L);</para>
        <para>��� P.rintln(&quot;&quot; + 3.14159);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Notice that all objects can easily be forced into <emphasis role="bold">String</emphasis> representations by putting them in a <emphasis role="bold">String </emphasis>expression; in the above case, starting the expression with an empty <emphasis role="bold">String </emphasis>does the trick. But this brings up an interesting observation. If you call <emphasis role="bold">System.out.println(100)</emphasis>, it works without casting it to a <emphasis role="bold">String</emphasis>. With some extra overloading, you can get the <emphasis role="bold">P</emphasis> class to do this as well (this is an exercise at the end of this chapter).</para>
        <para>So from now on, whenever you come up with a useful new utility, you can add it to the <emphasis role="bold">tools</emphasis> directory. (Or to your own personal <emphasis role="bold">util</emphasis> or <emphasis role="bold">tools</emphasis> directory.)</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545294"/><anchor xreflabel="Using
imports to change behavior" xml:id="_Toc481064592"/>Using imports to change behavior</title>
        <para>A feature that is missing from Java is C�s <emphasis role="italic">conditional compilation</emphasis>, which allows you to change a switch and get different behavior without changing any other code. The reason such a feature was left out of Java is probably because it is most often used in C to solve cross-platform issues: different portions of the code are compiled depending on the platform that the code is being compiled for. Since Java is intended to be automatically cross-platform, such a feature should not be necessary.</para>
        <para>However, there are other valuable uses for conditional compilation. A very common use is for debugging code. The debugging features are enabled during development, and disabled in the shipping product. Allen Holub (<emphasis role="italic">www.holub.com</emphasis>) came up with the idea of using packages to mimic conditional compilation. He used this to create a Java version of C�s very useful <emphasis role="italic">assertion mechanism</emphasis>, whereby you can say �this should be true� or �this should be false� and if the statement doesn�t agree with your assertion you�ll find out about it. Such a tool is quite helpful during debugging.</para>
        <para>Here is the class that you�ll use for debugging:</para>
        <para>//: com:bruceeckel:tools:debug:Assert.java</para>
        <para>// Assertion tool for debugging.</para>
        <para>package com.bruceeckel.tools.debug;</para>
        <para> </para>
        <para>public class Assert {</para>
        <para>� private static void perr(String msg) {</para>
        <para>��� System.err.println(msg);</para>
        <para>� }</para>
        <para>� public final static void is_true(boolean exp) {</para>
        <para>��� if(!exp) perr(&quot;Assertion failed&quot;);</para>
        <para>� }</para>
        <para>� public final static void is_false(boolean exp){</para>
        <para>��� if(exp) perr(&quot;Assertion failed&quot;);</para>
        <para>� }</para>
        <para>� public final static void </para>
        <para>� is_true(boolean exp, String msg) {</para>
        <para>��� if(!exp) perr(&quot;Assertion failed: &quot; + msg);</para>
        <para>� }</para>
        <para>� public final static void </para>
        <para>� is_false(boolean exp, String msg) {</para>
        <para>��� if(exp) perr(&quot;Assertion failed: &quot; + msg);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This class simply encapsulates Boolean tests, which print error messages if they fail. In Chapter 10, you�ll learn about a more sophisticated tool for dealing with errors called <emphasis role="italic">exception handling</emphasis>, but the <emphasis role="bold">perr( )</emphasis> method will work fine in the meantime.</para>
        <para>The output is printed to the console <emphasis role="italic">standard error</emphasis> stream by writing to <emphasis role="bold">System.err</emphasis>.</para>
        <para>When you want to use this class, you add a line in your program:</para>
        <para>import com.bruceeckel.tools.debug.*;</para>
        <para> </para>
        <para>To remove the assertions so you can ship the code, a second <emphasis role="bold">Assert</emphasis> class is created, but in a different package:</para>
        <para>//: com:bruceeckel:tools:Assert.java</para>
        <para>// Turning off the assertion output </para>
        <para>// so you can ship the program.</para>
        <para>package com.bruceeckel.tools;</para>
        <para> </para>
        <para>public class Assert {</para>
        <para>� public final static void is_true(boolean exp){}</para>
        <para>� public final static void is_false(boolean exp){}</para>
        <para>� public final static void </para>
        <para>� is_true(boolean exp, String msg) {}</para>
        <para>� public final static void </para>
        <para>� is_false(boolean exp, String msg) {}</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Now if you change the previous <emphasis role="bold">import</emphasis> statement to:</para>
        <para>import com.bruceeckel.tools.*;</para>
        <para> </para>
        <para>The program will no longer print assertions. Here�s an example:</para>
        <para>//: c05:TestAssert.java</para>
        <para>// Demonstrating the assertion tool.</para>
        <para>// Comment the following, and uncomment the</para>
        <para>// subsequent line to change assertion behavior:</para>
        <para>import com.bruceeckel.tools.debug.*;</para>
        <para>// import com.bruceeckel.tools.*;</para>
        <para> </para>
        <para>public class TestAssert {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Assert.is_true((2 + 2) == 5);</para>
        <para>��� Assert.is_false((1 + 1) == 2);</para>
        <para>��� Assert.is_true((2 + 2) == 5, &quot;2 + 2 == 5&quot;);</para>
        <para>��� Assert.is_false((1 + 1) == 2, &quot;1 +1 != 2&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>By changing the <emphasis role="bold">package</emphasis> that�s imported, you change your code from the debug version to the production version. This technique can be used for any kind of conditional code.</para>
      </section>
      <section>
        <title><anchor xreflabel="Package caveat" xml:id="_Toc481064593"/>Package caveat</title>
        <para>It�s worth remembering that anytime you create a package, you implicitly specify a directory structure when you give the package a name. The package <emphasis role="italic">must</emphasis> live in the directory indicated by its name, which must be a directory that is searchable starting from the CLASSPATH. Experimenting with the <emphasis role="bold">package</emphasis> keyword can be a bit frustrating at first, because unless you adhere to the package-name to directory-path rule, you�ll get a lot of mysterious run-time messages about not being able to find a particular class, even if that class is sitting there in the same directory. If you get a message like this, try commenting out the <emphasis role="bold">package</emphasis> statement, and if it runs you�ll know where the problem lies.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064594"/><anchor xreflabel="Java
access specifiers" xml:id="_Toc375545295"/>Java access specifiers</title>
      <para>When used, the Java access specifiers <emphasis role="bold">public</emphasis>, <emphasis role="bold">protected,</emphasis> and <emphasis role="bold">private</emphasis> are placed in front of each definition for each member in your class, whether it�s a field or a method. Each access specifier controls the access for only that particular definition. This is a distinct contrast to C++, in which the access specifier controls all the definitions following it until another access specifier comes along.</para>
      <para>One way or another, everything has some kind of access specified for it. In the following sections, you�ll learn all about the various types of access, starting with the default access.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064595"/><anchor xreflabel="" xml:id="_Toc375545296"/><anchor xreflabel="�Friend" xml:id="_Toc312373840"/>�Friendly�</title>
        <para>What if you give no access specifier at all, as in all the examples before this chapter? The default access has no keyword, but it is commonly referred to as �friendly.� It means that all the other classes in the current package have access to the friendly member, but to all the classes outside of this package the member appears to be <emphasis role="bold">private</emphasis>. Since a compilation unit�a file�can belong only to a single package, all the classes within a single compilation unit are automatically friendly with each other. Thus, friendly elements are also said to have <emphasis role="italic">package access</emphasis>.</para>
        <para>Friendly access allows you to group related classes together in a package so that they can easily interact with each other. When you put classes together in a package (thus granting mutual access to their friendly members; e.g., making them �friends�) you �own� the code in that package. It makes sense that only code you own should have friendly access to other code you own. You could say that friendly access gives a meaning or a reason for grouping classes together in a package. In many languages the way you organize your definitions in files can be willy-nilly, but in Java you�re compelled to organize them in a sensible fashion. In addition, you�ll probably want to exclude classes that shouldn�t have access to the classes being defined in the current package.</para>
        <para>The class controls which code has access to its members. There�s no magic way to �break in.� Code from another package can�t show up and say, �Hi, I�m a friend of <emphasis role="bold">Bob</emphasis>�s!� and expect to see the <emphasis role="bold">protected</emphasis>, friendly, and <emphasis role="bold">private</emphasis> members of <emphasis role="bold">Bob</emphasis>. The only way to grant access to a member is to:</para>
        <para>Make the member <emphasis role="bold">public</emphasis>. Then everybody, everywhere, can access it.</para>
        <para>31.      Make the member friendly by leaving off any access specifier, and put the other classes in the same package. Then the other classes can access the member.</para>
        <para>32.      As you�ll see in Chapter 6, when inheritance is introduced, an inherited class can access a <emphasis role="bold">protected</emphasis> member as well as a <emphasis role="bold">public</emphasis> member (but not <emphasis role="bold">private</emphasis> members). It can access friendly members only if the two classes are in the same package. But don�t worry about that now.</para>
        <para>33.      Provide �accessor/mutator� methods (also known as �get/set� methods) that read and change the value. This is the most civilized approach in terms of OOP, and it is fundamental to JavaBeans, as you�ll see in Chapter 13.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064596"/><anchor xreflabel="" xml:id="_Toc375545297"/><anchor xreflabel="public:
interface access" xml:id="_Ref351419800"/><emphasis role="bold">public</emphasis>: interface access</title>
        <para>When you use the <emphasis role="bold">public</emphasis> keyword, it means that the member declaration that immediately follows <emphasis role="bold">public</emphasis> is available to everyone, in particular to the client programmer who uses the library. Suppose you define a package <emphasis role="bold">dessert</emphasis> containing the following compilation unit:</para>
        <para>//: c05:dessert:Cookie.java</para>
        <para>// Creates a library.</para>
        <para>package c05.dessert;</para>
        <para> </para>
        <para>public class Cookie {</para>
        <para>� public Cookie() { </para>
        <para>�� System.out.println(&quot;Cookie constructor&quot;); </para>
        <para>� }</para>
        <para>� void bite() { System.out.println(&quot;bite&quot;); }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Remember, <emphasis role="bold">Cookie.java</emphasis> must reside in a subdirectory called <emphasis role="bold">dessert</emphasis>, in a directory under <emphasis role="bold">c05 </emphasis>(indicating Chapter 5 of this book) that must be under one of the CLASSPATH directories. Don�t make the mistake of thinking that Java will always look at the current directory as one of the starting points for searching. If you don�t have a �<emphasis role="bold">.</emphasis>� as one of the paths in your CLASSPATH, Java won�t look there.</para>
        <para>Now if you create a program that uses <emphasis role="bold">Cookie</emphasis>:</para>
        <para>//: c05:Dinner.java</para>
        <para>// Uses the library.</para>
        <para>import c05.dessert.*;</para>
        <para> </para>
        <para>public class Dinner {</para>
        <para>� public Dinner() {</para>
        <para>�� System.out.println(&quot;Dinner constructor&quot;);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Cookie x = new Cookie();</para>
        <para>��� //! x.bite(); // Can&apos;t access</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>you can create a <emphasis role="bold">Cookie</emphasis> object, since its constructor is <emphasis role="bold">public</emphasis> and the class is <emphasis role="bold">public</emphasis>. (We�ll look more at the concept of a <emphasis role="bold">public</emphasis> class later.) However, the <emphasis role="bold">bite( )</emphasis> member is inaccessible inside <emphasis role="bold">Dinner.java</emphasis> since <emphasis role="bold">bite( )</emphasis> is friendly only within package <emphasis role="bold">dessert</emphasis>.</para>
        <section>
          <title>The default package</title>
          <para>You might be surprised to discover that the following code compiles, even though it would appear that it breaks the rules:</para>
          <para>//: c05:Cake.java</para>
          <para>// Accesses a class in a </para>
          <para>// separate compilation unit.</para>
          <para> </para>
          <para>class Cake {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Pie x = new Pie();</para>
          <para>��� x.f();</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>In a second file, in the same directory:</para>
          <para>//: c05:Pie.java</para>
          <para>// The other class.</para>
          <para> </para>
          <para>class Pie {</para>
          <para>� void f() { System.out.println(&quot;Pie.f()&quot;); }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>You might initially view these as completely foreign files, and yet <emphasis role="bold">Cake</emphasis> is able to create a <emphasis role="bold">Pie</emphasis> object and call its <emphasis role="bold">f( )</emphasis> method! (Note that you must have �.� in your CLASSPATH in order for the files to compile.) You�d typically think that <emphasis role="bold">Pie</emphasis> and <emphasis role="bold">f( )</emphasis> are friendly and therefore not available to <emphasis role="bold">Cake</emphasis>. They <emphasis role="italic">are</emphasis> friendly�that part is correct. The reason that they are available in <emphasis role="bold">Cake.java</emphasis> is because they are in the same directory and have no explicit package name. Java treats files like this as implicitly part of the �default package� for that directory, and therefore friendly to all the other files in that directory.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064597"/><anchor xreflabel="private: you can�t touch that!" xml:id="_Toc375545298"/><emphasis role="bold">private</emphasis>: you can�t touch that!</title>
        <para>The <emphasis role="bold">private</emphasis>keyword means that no one can access that member except that particular class, inside methods of that class. Other classes in the same package cannot access <emphasis role="bold">private </emphasis>members, so it�s as if you�re even insulating the class against yourself. On the other hand, it�s not unlikely that a package might be created by several people collaborating together, so <emphasis role="bold">private</emphasis> allows you to freely change that member without concern that it will affect another class in the same package. </para>
        <para>The default �friendly� package access often provides an adequate amount of hiding; remember, a �friendly� member is inaccessible to the user of the package. This is nice, since the default access is the one that you normally use (and the one that you�ll get if you forget to add any access control). Thus, you�ll typically think about access for the members that you explicitly want to make <emphasis role="bold">public</emphasis> for the client programmer, and as a result, you might not<emphasis role="italic"/>initially think you�ll use the <emphasis role="bold">private </emphasis>keyword often since it�s tolerable to get away without it. (This is a distinct contrast with C++.) However, it turns out that the consistent use of <emphasis role="bold">private</emphasis> is very important, especially where multithreading is concerned. (As you�ll see in Chapter 14.)</para>
        <para>Here�s an example of the use of <emphasis role="bold">private</emphasis>:</para>
        <para>//: c05:IceCream.java</para>
        <para>// Demonstrates &quot;private&quot; keyword.</para>
        <para> </para>
        <para>class Sundae {</para>
        <para>� private Sundae() {}</para>
        <para>� static Sundae makeASundae() { </para>
        <para>��� return new Sundae(); </para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class IceCream {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� //! Sundae x = new Sundae();</para>
        <para>��� Sundae x = Sundae.makeASundae();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This shows an example in which <emphasis role="bold">private</emphasis> comes in handy: you might want to control how an object is created and prevent someone from directly accessing a particular constructor (or all of them). In the example above, you cannot create a <emphasis role="bold">Sundae</emphasis> object via its constructor; instead you must call the <emphasis role="bold">makeASundae( )</emphasis> method to do it for you<anchor xreflabel="[33]" xml:id="_ftnref33"/>[33].</para>
        <para>Any method that you�re certain is only a �helper� method for that class can be made <emphasis role="bold">private,</emphasis> to ensure that you don�t accidentally use it elsewhere in the package and thus prohibit yourself from changing or removing the method. Making a method <emphasis role="bold">private</emphasis> guarantees that you retain this option.</para>
        <para>The same is true for a <emphasis role="bold">private </emphasis>field inside a class. Unless you must expose the underlying implementation (which is a much rarer situation than you might think), you should make all fields <emphasis role="bold">private</emphasis>. However, just because a reference to an object is <emphasis role="bold">private</emphasis> inside a class doesn&apos;t mean that some other object can&apos;t have a <emphasis role="bold">public</emphasis> reference to the same object. (See Appendix A for issues about aliasing.)</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064598"/><anchor xreflabel="" xml:id="_Toc375545299"/><anchor xreflabel="protected" xml:id="_Toc312373839"/><emphasis role="bold">protected</emphasis>: �sort of friendly�</title>
        <para>The <emphasis role="bold">protected</emphasis> access specifier requires a jump ahead to understand. First, you should be aware that you don�t need to understand this section to continue through this book up through inheritance (Chapter 6). But for completeness, here is a brief description and example using <emphasis role="bold">protected</emphasis>. </para>
        <para>The <emphasis role="bold">protected</emphasis> keyword deals with a concept called <emphasis role="italic">inheritance</emphasis>, which takes an existing class and adds new members to that class without touching the existing class, which we refer to as the <emphasis role="italic">base</emphasis><emphasis role="italic">class</emphasis>. You can also change the behavior of existing members of the class. To inherit from an existing class, you say that your new class <emphasis role="bold">extends </emphasis>an existing class, like this:</para>
        <para>class Foo extends Bar {</para>
        <para> </para>
        <para>The rest of the class definition looks the same.</para>
        <para>If you create a new package and you inherit from a class in another package, the only members you have access to are the <emphasis role="bold">public</emphasis> members of the original package. (Of course, if you perform the inheritance in the <emphasis role="italic">same</emphasis> package, you have the normal package access to all the �friendly� members.) Sometimes the creator of the base class would like to take a particular member and grant access to derived classes but not the world in general. That�s what <emphasis role="bold">protected</emphasis> does. If you refer back to the file <emphasis role="bold">Cookie.java</emphasis>, the following class <emphasis role="italic">cannot</emphasis> access the �friendly� member:</para>
        <para>//: c05:ChocolateChip.java</para>
        <para>// Can&apos;t access friendly member</para>
        <para>// in another class.</para>
        <para>import c05.dessert.*;</para>
        <para> </para>
        <para>public class ChocolateChip extends Cookie {</para>
        <para>� public ChocolateChip() {</para>
        <para>�� System.out.println(</para>
        <para>���� &quot;ChocolateChip constructor&quot;);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� ChocolateChip x = new ChocolateChip();</para>
        <para>��� //! x.bite(); // Can&apos;t access bite</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>One of the interesting things about inheritance is that if a method <emphasis role="bold">bite( )</emphasis> exists in class <emphasis role="bold">Cookie</emphasis>, then it also exists in any class inherited from <emphasis role="bold">Cookie</emphasis>. But since <emphasis role="bold">bite( )</emphasis> is �friendly� in a foreign package, it�s unavailable to us in this one. Of course, you could make it <emphasis role="bold">public</emphasis>, but then everyone would have access and maybe that�s not what you want. If we change the class <emphasis role="bold">Cookie</emphasis> as follows:</para>
        <para>public class Cookie {</para>
        <para>� public Cookie() { </para>
        <para>��� System.out.println(&quot;Cookie constructor&quot;);</para>
        <para>� }</para>
        <para>� protected void bite() {</para>
        <para>��� System.out.println(&quot;bite&quot;); </para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>then <emphasis role="bold">bite( )</emphasis> still has �friendly� access within package <emphasis role="bold">dessert</emphasis>, but it is also accessible to anyone inheriting from <emphasis role="bold">Cookie</emphasis>. However, it is <emphasis role="italic">not</emphasis><emphasis role="bold">public</emphasis>.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064599"/><anchor xreflabel="Interface
and implementation" xml:id="_Toc375545301"/>Interface and implementation</title>
      <para>Access control is often referred to as <emphasis role="italic">implementation hiding</emphasis>. Wrapping data and methods within classes in combination with implementation hiding is often called <emphasis role="italic">encapsulation</emphasis><anchor xreflabel="[34]" xml:id="_ftnref34"/>[34]. The result is a data type with characteristics and behaviors. </para>
      <para>Access control puts boundaries within a data type for two important reasons. The first is to establish what the client programmers can and can�t use. You can build your internal mechanisms into the structure without worrying that the client programmers will accidentally treat the internals as part of the interface that they should be using.</para>
      <para>This feeds directly into the second reason, which is to separate the interface from the implementation. �If the structure is used in a set of programs, but client programmers can�t do anything but send messages to the <emphasis role="bold">public</emphasis> interface, then you can change anything that�s <emphasis role="italic">not</emphasis><emphasis role="bold">public</emphasis> (e.g., �friendly,� <emphasis role="bold">protected</emphasis>, or <emphasis role="bold">private</emphasis>) without requiring modifications to client code.</para>
      <para>We�re now in the world of object-oriented programming, where a <emphasis role="bold">class</emphasis> is actually describing �a class of objects,� as you would describe a class of fishes or a class of birds. Any object belonging to this class will share these characteristics and behaviors. The class is a description of the way all objects of this type will look and act.</para>
      <para>In the original OOP language, Simula-67, the keyword <emphasis role="bold">class</emphasis>was used to describe a new data type. The same keyword has been used for most object-oriented languages. This is the focal point of the whole language: the creation of new data types that are more than just boxes containing data and methods.</para>
      <para>The class is the fundamental OOP concept in Java. It is one of the keywords that will <emphasis role="italic">not </emphasis>be set in bold in this book�it becomes annoying with a word repeated as often as �class.�</para>
      <para>For clarity, you might prefer a style of creating classes that puts the <emphasis role="bold">public</emphasis> members at the beginning, followed by the <emphasis role="bold">protected</emphasis>, friendly, and <emphasis role="bold">private</emphasis> members. The advantage is that the user of the class can then read down from the top and see first what�s important to them (the <emphasis role="bold">public</emphasis> members, because they can be accessed outside the file), and stop reading when they encounter the non-<emphasis role="bold">public</emphasis> members, which are part of the internal implementation:</para>
      <para>public class X {</para>
      <para>� public void pub1( ) { /* . . . */ }</para>
      <para>� public void pub2( ) { /* . . . */ }</para>
      <para>� public void pub3( ) { /* . . . */ }</para>
      <para>� private void priv1( ) { /* . . . */ }</para>
      <para>� private void priv2( ) { /* . . . */ }</para>
      <para>� private void priv3( ) { /* . . . */ }</para>
      <para>� private int i;</para>
      <para>� // . . .</para>
      <para>}</para>
      <para> </para>
      <para>This will make it only partially easier to read because the interface and implementation are still mixed together. That is, you still see the source code�the implementation�because it�s right there in the class. In addition, the comment documentation supported by javadoc (described in Chapter 2) lessens the importance of code readability by the client programmer. Displaying the interface to the consumer of a class is really the job of the <emphasis role="italic">class browser</emphasis>, a tool whose job is to look at all the available classes and show you what you can do with them (i.e., what members are available) in a useful fashion. By the time you read this, browsers should be an expected part of any good Java development tool.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc312373850"/><anchor xreflabel="" xml:id="_Toc481064600"/><anchor xreflabel="Class access" xml:id="_Toc375545302"/>Class access</title>
      <para>In Java, the access specifiers can also be used to determine which classes <emphasis role="italic">within</emphasis> a library will be available to the users of that library. If you want a class to be available to a client programmer, you place the <emphasis role="bold">public</emphasis> keyword somewhere before the opening brace of the class body. This controls whether the client programmer can even create an object of the class. </para>
      <para>To control the access of a class, the specifier must appear before the keyword <emphasis role="bold">class</emphasis>.<emphasis role="bold"/>Thus you can say:</para>
      <para>public class Widget {</para>
      <para> </para>
      <para>Now if the name of your library is <emphasis role="bold">mylib</emphasis> any client programmer can access <emphasis role="bold">Widget</emphasis> by saying</para>
      <para>import mylib.Widget;</para>
      <para> </para>
      <para>or</para>
      <para>import mylib.*;</para>
      <para> </para>
      <para>However, there�s an extra set of constraints:</para>
      <para>There can be only one <emphasis role="bold">public</emphasis> class per compilation unit (file). The idea is that each compilation unit has a single public interface represented by that <emphasis role="bold">public</emphasis> class. It can have as many supporting �friendly� classes as you want. If you have more than one <emphasis role="bold">public</emphasis> class inside a compilation unit, the compiler will give you an error message.</para>
      <para>34.      The name of the <emphasis role="bold">public</emphasis> class must exactly match the name of the file containing the compilation unit, including capitalization. So for <emphasis role="bold">Widget</emphasis>, the name of the file must be <emphasis role="bold">Widget.java</emphasis>, not <emphasis role="bold">widget.java</emphasis> or <emphasis role="bold">WIDGET.java</emphasis>. Again, you�ll get a compile-time error if they don�t agree.</para>
      <para>35.      It is possible, though not typical, to have a compilation unit with no <emphasis role="bold">public</emphasis> class at all. In this case, you can name the file whatever you like.</para>
      <para>What if you�ve got a class inside <emphasis role="bold">mylib</emphasis> that you�re just using to accomplish the tasks performed by <emphasis role="bold">Widget</emphasis> or some other <emphasis role="bold">public</emphasis> class in <emphasis role="bold">mylib</emphasis>? You don�t want to go to the bother of creating documentation for the client programmer, and you think that sometime later you might want to completely change things and rip out your class altogether, substituting a different one. To give you this flexibility, you need to ensure that no client programmers become dependent on your particular implementation details hidden inside <emphasis role="bold">mylib</emphasis>. To accomplish this, you just leave the <emphasis role="bold">public</emphasis> keyword off the class, in which case it becomes friendly. (That class can be used only within that package.)</para>
      <para>Note that a class cannot be <emphasis role="bold">private </emphasis>(that would make it accessible to no one but the class), or <emphasis role="bold">protected</emphasis><anchor xreflabel="[35]" xml:id="_ftnref35"/>[35]. So you have only two choices for class access: �friendly� or <emphasis role="bold">public</emphasis>. If you don�t want anyone else to have access to that class, you can make all the constructors <emphasis role="bold">private</emphasis>, thereby preventing anyone but you, inside a <emphasis role="bold">static</emphasis> member of the class, from creating an object of that class<anchor xreflabel="[36]" xml:id="_ftnref36"/>[36]. Here�s an example:</para>
      <para>//: c05:Lunch.java</para>
      <para>// Demonstrates class access specifiers.</para>
      <para>// Make a class effectively private</para>
      <para>// with private constructors:</para>
      <para> </para>
      <para>class Soup {</para>
      <para>� private Soup() {}</para>
      <para>� // (1) Allow creation via static method:</para>
      <para>� public static Soup makeSoup() {</para>
      <para>��� return new Soup();</para>
      <para>� }</para>
      <para>� // (2) Create a static object and</para>
      <para>� // return a reference upon request.</para>
      <para>� // (The &quot;Singleton&quot; pattern):</para>
      <para>� private static Soup ps1 = new Soup();</para>
      <para>� public static Soup access() {</para>
      <para>��� return ps1;</para>
      <para>� }</para>
      <para>� public void f() {}</para>
      <para>}</para>
      <para> </para>
      <para>class Sandwich { // Uses Lunch</para>
      <para>� void f() { new Lunch(); }</para>
      <para>}</para>
      <para> </para>
      <para>// Only one public class allowed per file:</para>
      <para>public class Lunch {</para>
      <para>� void test() {</para>
      <para>��� // Can&apos;t do this! Private constructor:</para>
      <para>��� //! Soup priv1 = new Soup();</para>
      <para>��� Soup priv2 = Soup.makeSoup();</para>
      <para>��� Sandwich f1 = new Sandwich();</para>
      <para>��� Soup.access().f();</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Up to now, most of the methods have been returning either <emphasis role="bold">void</emphasis> or a primitive type, so the definition:</para>
      <para>� public static Soup access() {</para>
      <para>��� return ps1;</para>
      <para>� }</para>
      <para> </para>
      <para>might look a little confusing at first. The word before the method name (<emphasis role="bold">access</emphasis>) tells what the method returns. So far this has most often been <emphasis role="bold">void,</emphasis> which means it returns nothing. But you can also return a reference to an object, which is what happens here. This method returns a reference to an object of class <emphasis role="bold">Soup</emphasis>.</para>
      <para>The <emphasis role="bold">class Soup</emphasis> shows how to prevent direct creation of a class by making all the constructors <emphasis role="bold">private</emphasis>. Remember that if you don�t explicitly create at least one constructor, the default constructor (a constructor with no arguments) will be created for you. By writing the default constructor, it won�t be created automatically. By making it <emphasis role="bold">private</emphasis>, no one can create an object of that class. But now how does anyone use this class? The above example shows two options. First, a <emphasis role="bold">static</emphasis> method is created that creates a new <emphasis role="bold">Soup</emphasis> and returns a reference to it. This could be useful if you want to do some extra operations on the <emphasis role="bold">Soup</emphasis> before returning it, or if you want to keep count of how many <emphasis role="bold">Soup</emphasis> objects to create (perhaps to restrict their population).</para>
      <para>The second option uses what�s called a <emphasis role="italic">design pattern</emphasis>, which is covered in <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis>. This particular pattern is called a �singleton� because it allows only a single object to ever be created. The object of class <emphasis role="bold">Soup</emphasis> is created as a <emphasis role="bold">static</emphasis><emphasis role="bold">private </emphasis>member of <emphasis role="bold">Soup</emphasis>, so there�s one and only one, and you can�t get at it except through the <emphasis role="bold">public</emphasis> method <emphasis role="bold">access( )</emphasis>.</para>
      <para>As previously mentioned, if you don�t put an access specifier for class access it defaults to �friendly.� This means that an object of that class can be created by any other class in the package, but not outside the package. (Remember, all the files within the same directory that don�t have explicit <emphasis role="bold">package </emphasis>declarations are implicitly part of the default package for that directory.) However, if a <emphasis role="bold">static</emphasis> member of that class is <emphasis role="bold">public</emphasis>, the client programmer can still access that <emphasis role="bold">static</emphasis> member even though they cannot create an object of that class.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064601"/><anchor xreflabel="Summary" xml:id="_Toc375545303"/>Summary</title>
      <para>In any relationship it�s important to have boundaries that are respected by all parties involved. When you create a library, you establish a relationship with the user of that library�the client programmer�who is another programmer, but one putting together an application or using your library to build a bigger library.</para>
      <para>Without rules, client programmers can do anything they want with all the members of a class, even if you might prefer they don�t directly manipulate some of the members. Everything�s naked to the world.</para>
      <para>This chapter looked at how classes are built to form libraries; first, the way a group of classes is packaged within a library, and second, the way the class controls access to its members.</para>
      <para>It is estimated that a C programming project begins to break down somewhere between 50K and 100K lines of code because C has a single �name space� so names begin to collide, causing an extra management overhead. In Java, the <emphasis role="bold">package</emphasis> keyword, the package naming scheme, and the <emphasis role="bold">import</emphasis> keyword give you complete control over names, so the issue of name collision is easily avoided.</para>
      <para>There are two reasons for controlling access to members. The first is to keep users� hands off tools that they shouldn�t touch; tools that are necessary for the internal machinations of the data type, but not part of the interface that users need to solve their particular problems. So making methods and fields <emphasis role="bold">private</emphasis> is a service to users because they can easily see what�s important to them and what they can ignore. It simplifies their understanding of the class.</para>
      <para>The second and most important reason for access control is to allow the library designer to change the internal workings of the class without worrying about how it will affect the client programmer. You might build a class one way at first, and then discover that restructuring your code will provide much greater speed. If the interface and implementation are clearly separated and protected, you can accomplish this without forcing the user to rewrite their code.</para>
      <para>Access specifiers in Java give valuable control to the creator of a class. The users of the class can clearly see exactly what they can use and what to ignore. More important, though, is the ability to ensure that no user becomes dependent on any part of the underlying implementation of a class. If you know this as the creator of the class, you can change the underlying implementation with the knowledge that no client programmer will be affected by the changes because they can�t access that part of the class.</para>
      <para>When you have the ability to change the underlying implementation, you can not only improve your design later, but you also have the freedom to make mistakes. No matter how carefully you plan and design you�ll make mistakes. Knowing that it�s relatively safe to make these mistakes means you�ll be more experimental, you�ll learn faster, and you�ll finish your project sooner.</para>
      <para>The public interface to a class is what the user <emphasis role="italic">does</emphasis> see, so that is the most important part of the class to get �right� during analysis and design. Even that allows you some leeway for change. If you don�t get the interface right the first time, you can <emphasis role="italic">add</emphasis> more methods, as long as you don�t remove any that client programmers have already used in their code.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064602"/><anchor xreflabel="Exercises" xml:id="_Toc375545304"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Write a program that creates an <emphasis role="bold">ArrayList</emphasis> object without explicitly importing <emphasis role="bold">java.util.*</emphasis>.</para>
      <para>      43.         In the section labeled �package: the library unit,� turn the code fragments concerning <emphasis role="bold">mypackage</emphasis> into a compiling and running set of Java files.</para>
      <para>      44.         In the section labeled �Collisions,� take the code fragments and turn them into a program, and verify that collisions do in fact occur.</para>
      <para>      45.         Generalize the class <emphasis role="bold">P</emphasis> defined in this chapter by adding all the overloaded versions of <emphasis role="bold">rint( )</emphasis> and <emphasis role="bold">rintln( )</emphasis> necessary to handle all the different basic Java types.</para>
      <para>      46.         Change the import statement in <emphasis role="bold">TestAssert.java</emphasis> to enable and disable the assertion mechanism.</para>
      <para>      47.         Create a class with <emphasis role="bold">public</emphasis>, <emphasis role="bold">private</emphasis>, <emphasis role="bold">protected,</emphasis> and �friendly� data members and method members. Create an object of this class and see what kind of compiler messages you get when you try to access all the class members. Be aware that classes in the same directory are part of the �default� package.</para>
      <para>      48.         Create a class with <emphasis role="bold">protected</emphasis> data. Create a second class in the same file with a method that manipulates the <emphasis role="bold">protected</emphasis> data in the first class.</para>
      <para>      49.         Change the class <emphasis role="bold">Cookie </emphasis>as specified in the section labeled �<emphasis role="bold">protected</emphasis>: �sort of friendly.�� Verify that <emphasis role="bold">bite( ) </emphasis>is not <emphasis role="bold">public</emphasis>.</para>
      <para>      50.         In the section titled �Class access� you�ll find code fragments describing <emphasis role="bold">mylib</emphasis> and <emphasis role="bold">Widget</emphasis>. Create this library, then create a <emphasis role="bold">Widget</emphasis> in a class that is not part of the <emphasis role="bold">mylib</emphasis> package.</para>
      <para>      51.         Create a new directory and edit your CLASSPATH to include that new directory. Copy the <emphasis role="bold">P.class</emphasis> file (produced by compiling <emphasis role="bold">com.bruceeckel.tools.P.java</emphasis>)<emphasis role="bold"/>to your new directory and then change the names of the file, the <emphasis role="bold">P</emphasis> class inside and the method names. (You might also want to add additional output to watch how it works.) Create another program in a different directory that uses your new class.</para>
      <para>      52.         Following the form of the example <emphasis role="bold">Lunch.java</emphasis>, create a class called <emphasis role="bold">ConnectionManager</emphasis> that manages a fixed array of <emphasis role="bold">Connection</emphasis> objects. The client programmer must not be able to explicitly create <emphasis role="bold">Connection</emphasis> objects, but can only get them via a <emphasis role="bold">static</emphasis> method in <emphasis role="bold">ConnectionManager</emphasis>. When the <emphasis role="bold">ConnectionManager</emphasis> runs out of objects, it returns a <emphasis role="bold">null</emphasis> reference. Test the classes in <emphasis role="bold">main( )</emphasis>.</para>
      <para>      53.         Create the following file in the c05/local directory (presumably in your CLASSPATH):</para>
      <para>///: c05:local:PackagedClass.java</para>
      <para>package c05.local;</para>
      <para>class PackagedClass {</para>
      <para>� public PackagedClass() {</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;Creating a packaged class&quot;);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Then create the following file in a directory other than c05:</para>
      <para>///: c05:foreign:Foreign.java</para>
      <para>package c05.foreign;</para>
      <para>import c05.local.*;</para>
      <para>public class Foreign {</para>
      <para>�� public static void main (String[] args) {</para>
      <para>����� PackagedClass pc = new PackagedClass();</para>
      <para>�� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Explain why the compiler generates an error. Would making the <emphasis role="bold">Foreign</emphasis> class part of the <emphasis role="bold">c05.local</emphasis> package change anything?</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064603"/><anchor xreflabel="" xml:id="_Toc477690726"/><anchor xreflabel="" xml:id="_Toc375545305"/><anchor xreflabel="" xml:id="Chapter_6"/>6: Reusing Classes</title>
    <para>One of the most compelling features about Java is code reuse. But to be revolutionary, you�ve got to be able to do a lot more than copy code and change it.</para>
    <para>That�s the approach used in procedural languages like C, and it hasn�t worked very well. Like everything in Java, the solution revolves around the class. You reuse code by creating new classes, but instead of creating them from scratch, you use existing classes that someone has already built and debugged.</para>
    <para>The trick is to use the classes without soiling the existing code. In this chapter you�ll see two ways to accomplish this. The first is quite straightforward: You simply create objects of your existing class inside the new class. This is called <emphasis role="italic">composition,</emphasis>because the new class is composed of objects of existing classes. You�re simply reusing the functionality of the code, not its form.</para>
    <para>The second approach is more subtle. It creates a new class as a <emphasis role="italic">type of</emphasis> an existing class. You literally take the form of the existing class and add code to it without modifying the existing class. This magical act is called <emphasis role="italic">inheritance</emphasis>, and the compiler does most of the work. Inheritance is one of the cornerstones of object-oriented programming, and has additional implications that will be explored in Chapter 7.</para>
    <para>It turns out that much of the syntax and behavior are similar for both composition and inheritance (which makes sense because they are both ways of making new types from existing types). In this chapter, you�ll learn about these code reuse mechanisms.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064604"/><anchor xreflabel="" xml:id="_Toc375545306"/><anchor xreflabel="" xml:id="_Toc312374014"/><anchor xreflabel="" xml:id="_Toc305628723"/><anchor xreflabel="Composition syntax" xml:id="_Toc305593251"/>Composition syntax</title>
      <para>Until now, composition has been used quite frequently. You simply place object references inside new classes. For example, suppose you�d like an object that holds several <emphasis role="bold">String</emphasis> objects, a couple of primitives, and an object of another class. For the nonprimitive objects, you put references inside your new class, but you define the primitives directly:</para>
      <para>//: c06:SprinklerSystem.java</para>
      <para>// Composition for code reuse.</para>
      <para> </para>
      <para>class WaterSource {</para>
      <para>� private String s;</para>
      <para>� WaterSource() {</para>
      <para>��� System.out.println(&quot;WaterSource()&quot;);</para>
      <para>��� s = new String(&quot;Constructed&quot;);</para>
      <para>� }</para>
      <para>� public String toString() { return s; }</para>
      <para>}</para>
      <para> </para>
      <para>public class SprinklerSystem {</para>
      <para>� private String valve1, valve2, valve3, valve4;</para>
      <para>� WaterSource source;</para>
      <para>� int i;</para>
      <para>� float f;</para>
      <para>� void print() {</para>
      <para>��� System.out.println(&quot;valve1 = &quot; + valve1);</para>
      <para>��� System.out.println(&quot;valve2 = &quot; + valve2);</para>
      <para>��� System.out.println(&quot;valve3 = &quot; + valve3);</para>
      <para>��� System.out.println(&quot;valve4 = &quot; + valve4);</para>
      <para>��� System.out.println(&quot;i = &quot; + i);</para>
      <para>��� System.out.println(&quot;f = &quot; + f);</para>
      <para>��� System.out.println(&quot;source = &quot; + source);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� SprinklerSystem x = new SprinklerSystem();</para>
      <para>��� x.print();</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>One of the methods defined in <emphasis role="bold">WaterSource </emphasis>is special: <emphasis role="bold">toString( )</emphasis>. You will learn later that every nonprimitive object has a <emphasis role="bold">toString( )</emphasis> method, and it�s called in special situations when the compiler wants a <emphasis role="bold">String</emphasis> but it�s got one of these objects. So in the expression:</para>
      <para>System.out.println(&quot;source = &quot; + source);</para>
      <para> </para>
      <para>the compiler sees you trying to add a <emphasis role="bold">String</emphasis> object (&quot;<emphasis role="bold">source = </emphasis>&quot;) to a <emphasis role="bold">WaterSource</emphasis>. This doesn�t make sense to it, because you can only �add� a <emphasis role="bold">String</emphasis> to another <emphasis role="bold">String</emphasis>, so it says �I�ll turn <emphasis role="bold">source</emphasis> into a <emphasis role="bold">String</emphasis> by calling <emphasis role="bold">toString( )</emphasis>!� After doing this it can combine the two <emphasis role="bold">String</emphasis>s and pass the resulting <emphasis role="bold">String</emphasis> to <emphasis role="bold">System.out.println( )</emphasis>. Any time you want to allow this behavior with a class you create you need only write a <emphasis role="bold">toString( )</emphasis> method. </para>
      <para>At first glance, you might assume�Java being as safe and careful as it is�that the compiler would automatically construct objects for each of the references in the above code; for example, calling the default constructor for <emphasis role="bold">WaterSource</emphasis> to initialize <emphasis role="bold">source</emphasis>. The output of the print statement is in fact:</para>
      <para>valve1 = null</para>
      <para>valve2 = null</para>
      <para>valve3 = null</para>
      <para>valve4 = null</para>
      <para>i = 0</para>
      <para>f = 0.0</para>
      <para>source = null</para>
      <para> </para>
      <para>Primitives that are fields in a class are automatically initialized to zero, as noted in Chapter 2. But the object references are initialized to <emphasis role="bold">null</emphasis>, and if you try to call methods for any of them you�ll get an exception. It�s actually pretty good (and useful) that you can still print them out without throwing an exception.</para>
      <para>It makes sense that the compiler doesn�t just create a default object for every reference because that would incur unnecessary overhead in many cases. If you want the references initialized, you can do it:</para>
      <para>At the point the objects are defined. This means that they�ll always be initialized before the constructor is called.</para>
      <para>36.      In the constructor for that class.</para>
      <para>37.      Right before you actually need to use the object. This is often called <emphasis role="italic">lazy initialization</emphasis>. It can reduce overhead in situations where the object doesn�t need to be created every time.</para>
      <para>All three approaches are shown here:</para>
      <para>//: c06:Bath.java</para>
      <para>// Constructor initialization with composition.</para>
      <para> </para>
      <para>class Soap {</para>
      <para>� private String s;</para>
      <para>� Soap() {</para>
      <para>�� �System.out.println(&quot;Soap()&quot;);</para>
      <para>��� s = new String(&quot;Constructed&quot;);</para>
      <para>� }</para>
      <para>� public String toString() { return s; }</para>
      <para>}</para>
      <para> </para>
      <para>public class Bath {</para>
      <para>� private String </para>
      <para>��� // Initializing at point of definition:</para>
      <para>��� s1 = new String(&quot;Happy&quot;), </para>
      <para>��� s2 = &quot;Happy&quot;, </para>
      <para>��� s3, s4;</para>
      <para>� Soap castille;</para>
      <para>� int i;</para>
      <para>� float toy;</para>
      <para>� Bath() {</para>
      <para>��� System.out.println(&quot;Inside Bath()&quot;);</para>
      <para>��� s3 = new String(&quot;Joy&quot;);</para>
      <para>��� i = 47;</para>
      <para>��� toy = 3.14f;</para>
      <para>��� castille = new Soap();</para>
      <para>� }</para>
      <para>� void print() {</para>
      <para>��� // Delayed initialization:</para>
      <para>��� if(s4 == null)</para>
      <para>����� s4 = new String(&quot;Joy&quot;);</para>
      <para>��� System.out.println(&quot;s1 = &quot; + s1);</para>
      <para>��� System.out.println(&quot;s2 = &quot; + s2);</para>
      <para>��� System.out.println(&quot;s3 = &quot; + s3);</para>
      <para>��� System.out.println(&quot;s4 = &quot; + s4);</para>
      <para>��� System.out.println(&quot;i = &quot; + i);</para>
      <para>��� System.out.println(&quot;toy = &quot; + toy);</para>
      <para>��� System.out.println(&quot;castille = &quot; + castille);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Bath b = new Bath();</para>
      <para>��� b.print();</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Note that in the <emphasis role="bold">Bath </emphasis>constructor a statement is executed before any of the initializations take place. When you don�t initialize at the point of definition, there�s still no guarantee that you�ll perform any initialization before you send a message to an object reference�except for the inevitable run-time exception.</para>
      <para>Here�s the output for the program:</para>
      <para>Inside Bath()</para>
      <para>Soap()</para>
      <para>s1 = Happy</para>
      <para>s2 = Happy</para>
      <para>s3 = Joy</para>
      <para>s4 = Joy</para>
      <para>i = 47</para>
      <para>toy = 3.14</para>
      <para>castille = Constructed</para>
      <para> </para>
      <para>When <emphasis role="bold">print( )</emphasis> is called it fills in <emphasis role="bold">s4</emphasis> so that all the fields are properly initialized by the time they are used.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064605"/><anchor xreflabel="" xml:id="_Toc375545307"/><anchor xreflabel="" xml:id="_Toc312374015"/><anchor xreflabel="" xml:id="_Toc305628724"/><anchor xreflabel="Inheritance syntax" xml:id="_Toc305593252"/>Inheritance syntax</title>
      <para>Inheritance is an integral part of Java (and OOP languages in general). It turns out that you�re always doing inheritance when you create a class, because unless you explicitly inherit from some other class, you implicitly inherit from Java�s standard root class <emphasis role="bold">Object</emphasis>.</para>
      <para>The syntax for composition is obvious, but to perform inheritance there�s a distinctly different form. When you inherit, you say �This new class is like that old class.� You state this in code by giving the name of the class as usual, but before the opening brace of the class body, put the keyword <emphasis role="bold">extends</emphasis> followed by the name of the <emphasis role="italic">base class</emphasis>. When you do this, you automatically get all the data members and methods in the base class. Here�s an example:</para>
      <para>//: c06:Detergent.java</para>
      <para>// Inheritance syntax &amp; properties.</para>
      <para> </para>
      <para>class Cleanser {</para>
      <para>� private String s = new String(&quot;Cleanser&quot;);</para>
      <para>� public void append(String a) { s += a; }</para>
      <para>� public void dilute() { append(&quot; dilute()&quot;); }</para>
      <para>� public void apply() { append(&quot; apply()&quot;); }</para>
      <para>� public void scrub() { append(&quot; scrub()&quot;); }</para>
      <para>� public void print() { System.out.println(s); }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Cleanser x = new Cleanser();</para>
      <para>�� �x.dilute(); x.apply(); x.scrub();</para>
      <para>��� x.print();</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class Detergent extends Cleanser {</para>
      <para>� // Change a method:</para>
      <para>� public void scrub() {</para>
      <para>��� append(&quot; Detergent.scrub()&quot;);</para>
      <para>��� super.scrub(); // Call base-class version</para>
      <para>� }</para>
      <para>� // Add methods to the interface:</para>
      <para>� public void foam() { append(&quot; foam()&quot;); }</para>
      <para>� // Test the new class:</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Detergent x = new Detergent();</para>
      <para>��� x.dilute();</para>
      <para>��� x.apply();</para>
      <para>��� x.scrub();</para>
      <para>��� x.foam();</para>
      <para>��� x.print();</para>
      <para>��� System.out.println(&quot;Testing base class:&quot;);</para>
      <para>��� Cleanser.main(args);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>This demonstrates a number of features. First, in the <emphasis role="bold">Cleanser</emphasis><emphasis role="bold">append( )</emphasis> method, <emphasis role="bold">String</emphasis>s are concatenated to <emphasis role="bold">s</emphasis> using the <emphasis role="bold">+=</emphasis> operator, which is one of the operators (along with �<emphasis role="bold">+</emphasis>�) that the Java designers �overloaded� to work with <emphasis role="bold">String</emphasis>s.</para>
      <para>Second, both <emphasis role="bold">Cleanser</emphasis> and <emphasis role="bold">Detergent</emphasis> contain a <emphasis role="bold">main( )</emphasis> method. You can create a <emphasis role="bold">main( )</emphasis> for each one of your classes, and it�s often recommended to code this way so that your test code is wrapped in with the class. Even if you have a lot of classes in a program, only the <emphasis role="bold">main( )</emphasis> for the class invoked on the command line will be called. (As long as <emphasis role="bold">main( )</emphasis> is <emphasis role="bold">public</emphasis>, it doesn�t matter whether the class that it�s part of is <emphasis role="bold">public</emphasis>.) So in this case, when you say <emphasis role="bold">java Detergent</emphasis>, <emphasis role="bold">Detergent.main( )</emphasis> will be called. But you can also say <emphasis role="bold">java Cleanser </emphasis>to invoke <emphasis role="bold">Cleanser.main( )</emphasis>, even though <emphasis role="bold">Cleanser</emphasis> is not a <emphasis role="bold">public</emphasis> class. This technique of putting a <emphasis role="bold">main( )</emphasis> in each class allows easy unit testing for each class. And you don�t need to remove the <emphasis role="bold">main( )</emphasis> when you�re finished testing; you can leave it in for later testing.</para>
      <para>Here, you can see that <emphasis role="bold">Detergent.main( )</emphasis> calls <emphasis role="bold">Cleanser.main( )</emphasis> explicitly, passing it the same arguments from the command line (however, you could pass it any <emphasis role="bold">String</emphasis> array).</para>
      <para>It�s important that all of the methods in <emphasis role="bold">Cleanser </emphasis>are <emphasis role="bold">public</emphasis>. Remember that if you leave off any access specifier the member defaults to �friendly,� which allows access only to package members. Thus, <emphasis role="italic">within this package</emphasis>, anyone could use those methods if there were no access specifier. <emphasis role="bold">Detergent</emphasis> would have no trouble, for example. However, if a class from some other package were to inherit from <emphasis role="bold">Cleanser</emphasis> it could access only <emphasis role="bold">public </emphasis>members. So to plan for inheritance, as a general rule make all fields <emphasis role="bold">private </emphasis>and all methods <emphasis role="bold">public</emphasis>.<emphasis role="bold"/>(<emphasis role="bold">protected </emphasis>members also allow access by derived classes; you�ll learn about this later.) Of course, in particular cases you must make adjustments, but this is a useful guideline.</para>
      <para>Note that <emphasis role="bold">Cleanser</emphasis> has a set of methods in its interface: <emphasis role="bold">append( )</emphasis>, <emphasis role="bold">dilute( )</emphasis>, <emphasis role="bold">apply( )</emphasis>, <emphasis role="bold">scrub( )</emphasis>, and <emphasis role="bold">print( )</emphasis>. Because <emphasis role="bold">Detergent</emphasis> is <emphasis role="italic">derived from</emphasis><emphasis role="bold">Cleanser</emphasis> (via the <emphasis role="bold">extends</emphasis> keyword) it automatically gets all these methods in its interface, even though you don�t see them all explicitly defined in <emphasis role="bold">Detergent</emphasis>. You can think of inheritance, then, as <emphasis role="italic">reusing the interface.</emphasis> (The implementation also comes with it, but that part isn�t the primary point.)</para>
      <para>As seen in <emphasis role="bold">scrub( )</emphasis>, it�s possible to take a method that�s been defined in the base class and modify it. In this case, you might want to call the method from the base class inside the new version. But inside <emphasis role="bold">scrub( )</emphasis> you cannot simply call <emphasis role="bold">scrub( )</emphasis>, since that would produce a recursive call, which isn�t what you want. To solve this problem Java has the keyword <emphasis role="bold">super</emphasis> that refers to the �superclass� that the current class has been inherited from. Thus the expression <emphasis role="bold">super.scrub( )</emphasis> calls the base-class version of the method <emphasis role="bold">scrub( )</emphasis>.</para>
      <para>When inheriting you�re not restricted to using the methods of the base class. You can also add new methods to the derived class exactly the way you put any method in a class: just define it. The method <emphasis role="bold">foam( )</emphasis> is an example of this.</para>
      <para>In <emphasis role="bold">Detergent.main( ) </emphasis>you can see that for a <emphasis role="bold">Detergent</emphasis> object you can call all the methods that are available in <emphasis role="bold">Cleanser</emphasis> as well as in <emphasis role="bold">Detergent </emphasis>(i.e., <emphasis role="bold">foam( )</emphasis>).</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064606"/><anchor xreflabel="Initializing
the base class" xml:id="_Toc375545308"/>Initializing the base class</title>
        <para>Since there are now two classes involved�the base class and the derived class�instead of just one, it can be a bit confusing to try to imagine the resulting object produced by a derived class. From the outside, it looks like the new class has the same interface as the base class and maybe some additional methods and fields. But inheritance doesn�t just copy the interface of the base class. When you create an object of the derived class, it contains within it a <emphasis role="italic">subobject</emphasis> of the base class. This subobject is the same as if you had created an object of the base class by itself. It�s just that, from the outside, the subobject of the base class is wrapped within the derived-class object.</para>
        <para>Of course, it�s essential that the base-class subobject be initialized correctly and there�s only one way to guarantee that: perform the initialization in the constructor, by calling the base-class constructor, which has all the appropriate knowledge and privileges to perform the base-class initialization. Java automatically inserts calls to the base-class constructor in the derived-class constructor. The following example shows this working with three levels of inheritance:</para>
        <para>//: c06:Cartoon.java</para>
        <para>// Constructor calls during inheritance.</para>
        <para> </para>
        <para>class Art {</para>
        <para>� Art() {</para>
        <para>��� System.out.println(&quot;Art constructor&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Drawing extends Art {</para>
        <para>� Drawing() {</para>
        <para>��� System.out.println(&quot;Drawing constructor&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Cartoon extends Drawing {</para>
        <para>� Cartoon() {</para>
        <para>��� System.out.println(&quot;Cartoon constructor&quot;);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Cartoon x = new Cartoon();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The output for this program shows the automatic calls:</para>
        <para>Art constructor</para>
        <para>Drawing constructor</para>
        <para>Cartoon constructor</para>
        <para> </para>
        <para>You can see that the construction happens from the base �outward,� so the base class is initialized before the derived-class constructors can access it.</para>
        <para>Even if you don�t create a constructor for <emphasis role="bold">Cartoon( )</emphasis>, the compiler will synthesize a default constructor for you that calls the base class constructor.</para>
        <section>
          <title>Constructors with arguments</title>
          <para>The above example has default constructors; that is, they don�t have any arguments. It�s easy for the compiler to call these because there�s no question about what arguments to pass. If your class doesn�t have default arguments, or if you want to call a base-class constructor that has an argument, you must explicitly write the calls to the base-class constructor using the <emphasis role="bold">super</emphasis> keyword and the appropriate argument list:</para>
          <para>//: c06:Chess.java</para>
          <para>// Inheritance, constructors and arguments.</para>
          <para> </para>
          <para>class Game {</para>
          <para>� Game(int i) {</para>
          <para>��� System.out.println(&quot;Game constructor&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class BoardGame extends Game {</para>
          <para>� BoardGame(int i) {</para>
          <para>��� super(i);</para>
          <para>��� System.out.println(&quot;BoardGame constructor&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>public class Chess extends BoardGame {</para>
          <para>� Chess() {</para>
          <para>��� super(11);</para>
          <para>��� System.out.println(&quot;Chess constructor&quot;);</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Chess x = new Chess();</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>If you don�t call the base-class constructor in <emphasis role="bold">BoardGame( )</emphasis>, the compiler will complain that it can�t find a constructor of the form <emphasis role="bold">Game( )</emphasis>. In addition, the call to the base-class constructor <emphasis role="italic">must</emphasis> be the first thing you do in the derived-class constructor. (The compiler will remind you if you get it wrong.)</para>
        </section>
        <section>
          <title>Catching base constructor exceptions</title>
          <para>As just noted, the compiler forces you to place the base-class constructor call first in the body of the derived-class constructor. This means nothing else can appear before it. As you�ll see in Chapter 10, this also prevents a derived-class constructor from catching any exceptions that come from a base class. This can be inconvenient at times.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064607"/><anchor xreflabel="" xml:id="_Toc375545309"/><anchor xreflabel="" xml:id="_Toc312374019"/><anchor xreflabel="" xml:id="_Toc305628726"/><anchor xreflabel="Combining composition 
and inheritance" xml:id="_Toc305593254"/>Combining composition   and inheritance</title>
      <para>It is very common to use composition and inheritance together. The following example shows the creation of a more complex class, using both inheritance and composition, along with the necessary constructor initialization:</para>
      <para>//: c06:PlaceSetting.java</para>
      <para>// Combining composition &amp; inheritance.</para>
      <para> </para>
      <para>class Plate {</para>
      <para>� Plate(int i) {</para>
      <para>��� System.out.println(&quot;Plate constructor&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class DinnerPlate extends Plate {</para>
      <para>� DinnerPlate(int i) {</para>
      <para>��� super(i);</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;DinnerPlate constructor&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Utensil {</para>
      <para>� Utensil(int i) {</para>
      <para>��� System.out.println(&quot;Utensil constructor&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Spoon extends Utensil {</para>
      <para>� Spoon(int i) {</para>
      <para>��� super(i);</para>
      <para>��� System.out.println(&quot;Spoon constructor&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Fork extends Utensil {</para>
      <para>� Fork(int i) {</para>
      <para>��� super(i);</para>
      <para>�� �System.out.println(&quot;Fork constructor&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Knife extends Utensil {</para>
      <para>� Knife(int i) {</para>
      <para>��� super(i);</para>
      <para>��� System.out.println(&quot;Knife constructor&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>// A cultural way of doing something:</para>
      <para>class Custom {</para>
      <para>� Custom(int i) {</para>
      <para>��� System.out.println(&quot;Custom constructor&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class PlaceSetting extends Custom {</para>
      <para>� Spoon sp;</para>
      <para>� Fork frk;</para>
      <para>� Knife kn;</para>
      <para>� DinnerPlate pl;</para>
      <para>� PlaceSetting(int i) {</para>
      <para>��� super(i + 1);</para>
      <para>��� sp = new Spoon(i + 2);</para>
      <para>��� frk = new Fork(i + 3);</para>
      <para>��� kn = new Knife(i + 4);</para>
      <para>��� pl = new DinnerPlate(i + 5);</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;PlaceSetting constructor&quot;);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� PlaceSetting x = new PlaceSetting(9);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>While the compiler forces you to initialize the base classes, and requires that you do it right at the beginning of the constructor, it doesn�t watch over you to make sure that you initialize the member objects, so you must remember to pay attention to that.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064608"/><anchor xreflabel="Guaranteeing
proper cleanup" xml:id="_Toc375545310"/>Guaranteeing proper cleanup</title>
        <para>Java doesn�t have the C++ concept of a <emphasis role="italic">destructor</emphasis>, a method that is automatically called when an object is destroyed. The reason is probably that in Java the practice is simply to forget about objects rather than to destroy them, allowing the garbage collector to reclaim the memory as necessary.</para>
        <para>Often this is fine, but there are times when your class might perform some activities during its lifetime that require cleanup. As mentioned in Chapter 4, you can�t know when the garbage collector will be called, or if it will be called. So if you want something cleaned up for a class, you must explicitly write a special method to do it, and make sure that the client programmer knows that they must call this method. On top of this�as described in Chapter 10 (�Error Handling with Exceptions�)�you must guard against an exception by putting such cleanup in a <emphasis role="bold">finally</emphasis> clause.</para>
        <para>Consider an example of a computer-aided design system that draws pictures on the screen:</para>
        <para>//: c06:CADSystem.java</para>
        <para>// Ensuring proper cleanup.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Shape {</para>
        <para>� Shape(int i) {</para>
        <para>��� System.out.println(&quot;Shape constructor&quot;);</para>
        <para>� }</para>
        <para>� void cleanup() {</para>
        <para>��� System.out.println(&quot;Shape cleanup&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Circle extends Shape {</para>
        <para>� Circle(int i) {</para>
        <para>��� super(i);</para>
        <para>��� System.out.println(&quot;Drawing a Circle&quot;);</para>
        <para>� }</para>
        <para>� void cleanup() {</para>
        <para>��� System.out.println(&quot;Erasing a Circle&quot;);</para>
        <para>��� super.cleanup();</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Triangle extends Shape {</para>
        <para>� Triangle(int i) {</para>
        <para>��� super(i);</para>
        <para>��� System.out.println(&quot;Drawing a Triangle&quot;);</para>
        <para>� }</para>
        <para>� void cleanup() {</para>
        <para>��� System.out.println(&quot;Erasing a Triangle&quot;);</para>
        <para>��� super.cleanup();</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Line extends Shape {</para>
        <para>� private int start, end;</para>
        <para>� Line(int start, int end) {</para>
        <para>��� super(start);</para>
        <para>��� this.start = start;</para>
        <para>��� this.end = end;</para>
        <para>��� System.out.println(&quot;Drawing a Line: &quot; +</para>
        <para>���������� start + &quot;, &quot; + end);</para>
        <para>� }</para>
        <para>� void cleanup() {</para>
        <para>��� System.out.println(&quot;Erasing a Line: &quot; +</para>
        <para>���������� start + &quot;, &quot; + end);</para>
        <para>��� super.cleanup();</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class CADSystem extends Shape {</para>
        <para>� private Circle c;</para>
        <para>� private Triangle t;</para>
        <para>� private Line[] lines = new Line[10];</para>
        <para>� CADSystem(int i) {</para>
        <para>��� super(i + 1);</para>
        <para>��� for(int j = 0; j &lt; 10; j++)</para>
        <para>����� lines[j] = new Line(j, j*j);</para>
        <para>��� c = new Circle(1);</para>
        <para>��� t = new Triangle(1);</para>
        <para>��� System.out.println(&quot;Combined constructor&quot;);</para>
        <para>� }</para>
        <para>� void cleanup() {</para>
        <para>��� System.out.println(&quot;CADSystem.cleanup()&quot;);</para>
        <para>��� // The order of cleanup is the reverse </para>
        <para>��� // of the order of initialization</para>
        <para>��� t.cleanup();</para>
        <para>��� c.cleanup();</para>
        <para>��� for(int i = lines.length - 1; i &gt;= 0; i--)</para>
        <para>����� lines[i].cleanup();</para>
        <para>��� super.cleanup();</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� CADSystem x = new CADSystem(47);</para>
        <para>��� try {</para>
        <para>����� // Code and exception handling...</para>
        <para>��� } finally {</para>
        <para>����� x.cleanup();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Everything in this system is some kind of <emphasis role="bold">Shape</emphasis> (which is itself a kind of <emphasis role="bold">Object</emphasis> since it�s implicitly inherited from the root class). Each class redefines <emphasis role="bold">Shape</emphasis>�s <emphasis role="bold">cleanup( )</emphasis> method in addition to calling the base-class version of that method using <emphasis role="bold">super</emphasis>. The specific <emphasis role="bold">Shape</emphasis> classes�<emphasis role="bold">Circle</emphasis>, <emphasis role="bold">Triangle</emphasis> and <emphasis role="bold">Line</emphasis>�all have constructors that �draw,� although any method called during the lifetime of the object could be responsible for doing something that needs cleanup. Each class has its own <emphasis role="bold">cleanup( )</emphasis> method to restore nonmemory things back to the way they were before the object existed.</para>
        <para>In <emphasis role="bold">main( )</emphasis>, you can see two keywords that are new, and won�t officially be introduced until Chapter 10: <emphasis role="bold">try</emphasis> and <emphasis role="bold">finally</emphasis>. The <emphasis role="bold">try</emphasis> keyword indicates that the block that follows (delimited by curly braces) is a <emphasis role="italic">guarded region</emphasis>, which means that it is given special treatment. One of these special treatments is that the code in the <emphasis role="bold">finally</emphasis> clause following this guarded region is <emphasis role="italic">always</emphasis> executed, no matter how the <emphasis role="bold">try</emphasis> block exits. (With exception handling, it�s possible to leave a <emphasis role="bold">try</emphasis> block in a number of nonordinary ways.) Here, the <emphasis role="bold">finally</emphasis> clause is saying �always call <emphasis role="bold">cleanup( )</emphasis> for <emphasis role="bold">x</emphasis>, no matter what happens.� These keywords will be explained thoroughly in Chapter 10.</para>
        <para>Note that in your cleanup method you must also pay attention to the calling order for the base-class and member-object cleanup methods in case one subobject depends on another. In general, you should follow the same form that is imposed by a C++ compiler on its destructors: First perform all of the cleanup work specific to your class, in the reverse order of creation. (In general, this requires that base-class elements still be viable.) Then call the base-class cleanup method, as demonstrated here.</para>
        <para>There can be many cases in which the cleanup issue is not a problem; you just let the garbage collector do the work. But when you must do it explicitly, diligence and attention is required.</para>
        <section>
          <title><anchor xreflabel="Order of " xml:id="_Toc312374020"/>Order of garbage collection</title>
          <para>There�s not much you can rely on when it comes to garbage collection. The garbage collector might never be called. If it is, it can reclaim objects in any order it wants. It�s best to not rely on garbage collection for anything but memory reclamation. If you want cleanup to take place, make your own cleanup methods and don�t rely on <emphasis role="bold">finalize( )</emphasis>. (As mentioned in Chapter 4, Java can be forced to call all the finalizers.)</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064609"/><anchor xreflabel="" xml:id="_Toc375545311"/><anchor xreflabel="Name hiding" xml:id="_Toc312374021"/>Name hiding</title>
        <para>Only C++ programmers might be surprised by name hiding, since it works differently in that language. If a Java base class has a method name that�s overloaded several times, redefining that method name in the derived class will <emphasis role="italic">not </emphasis>hide any of the base-class versions. Thus overloading works regardless of whether the method was defined at this level or in a base class:</para>
        <para>//: c06:Hide.java</para>
        <para>// Overloading a base-class method name</para>
        <para>// in a derived class does not hide the</para>
        <para>// base-class versions.</para>
        <para> </para>
        <para>class Homer {</para>
        <para>� char doh(char c) {</para>
        <para>��� System.out.println(&quot;doh(char)&quot;);</para>
        <para>��� return &apos;d&apos;;</para>
        <para>� }</para>
        <para>� float doh(float f) {</para>
        <para>��� System.out.println(&quot;doh(float)&quot;);</para>
        <para>��� return 1.0f;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Milhouse {}</para>
        <para> </para>
        <para>class Bart extends Homer {</para>
        <para>� void doh(Milhouse m) {}</para>
        <para>}</para>
        <para> </para>
        <para>class Hide {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Bart b = new Bart();</para>
        <para>��� b.doh(1); // doh(float) used</para>
        <para>��� b.doh(&apos;x&apos;);</para>
        <para>��� b.doh(1.0f);</para>
        <para>��� b.doh(new Milhouse());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>As you�ll see in the next chapter, it�s far more common to override methods of the same name using exactly the same signature and return type as in the base class. It can be confusing otherwise (which is why C++ disallows it, to prevent you from making what is probably a mistake).</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064610"/><anchor xreflabel="" xml:id="_Toc375545312"/><anchor xreflabel="" xml:id="_Toc312374023"/><anchor xreflabel="" xml:id="_Toc305628727"/><anchor xreflabel="Choosing composition 
vs. inheritance" xml:id="_Toc305593255"/>Choosing composition   vs. inheritance</title>
      <para>Both composition and inheritance allow you to place subobjects�inside your new class. You might wonder about the difference between the two, and when to choose one over the other.</para>
      <para>Composition is generally used when you want the features of an existing class inside your new class, but not its interface. That is, you embed an object so that you can use it to implement functionality in your new class, but the user of your new class sees the interface you�ve defined for the new class rather than the interface from the embedded object. For this effect, you embed <emphasis role="bold">private</emphasis> objects of existing classes inside your new class. </para>
      <para>Sometimes it makes sense to allow the class user to directly access the composition of your new class; that is, to make the member objects <emphasis role="bold">public</emphasis>. The member objects use implementation hiding themselves, so this is a safe thing to do. When the user knows you�re assembling a bunch of parts, it makes the interface easier to understand. A <emphasis role="bold">car</emphasis> object is a good example:</para>
      <para>//: c06:Car.java</para>
      <para>// Composition with public objects.</para>
      <para> </para>
      <para>class Engine {</para>
      <para>� public void start() {}</para>
      <para>� public void rev() {}</para>
      <para>� public void stop() {}</para>
      <para>}</para>
      <para> </para>
      <para>class Wheel {</para>
      <para>� public void inflate(int psi) {}</para>
      <para>}</para>
      <para> </para>
      <para>class Window {</para>
      <para>� public void rollup() {}</para>
      <para>� public void rolldown() {}</para>
      <para>}</para>
      <para> </para>
      <para>class Door {</para>
      <para>� public Window window = new Window();</para>
      <para>� public void open() {}</para>
      <para>� public void close() {}</para>
      <para>}</para>
      <para> </para>
      <para>public class Car {</para>
      <para>� public Engine engine = new Engine();</para>
      <para>� public Wheel[] wheel = new Wheel[4];</para>
      <para>� public Door left = new Door(),</para>
      <para>������ right = new Door(); // 2-door</para>
      <para>� public Car() {</para>
      <para>��� for(int i = 0; i &lt; 4; i++)</para>
      <para>����� wheel[i] = new Wheel();</para>
      <para>��}</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Car car = new Car();</para>
      <para>��� car.left.window.rollup();</para>
      <para>��� car.wheel[0].inflate(72);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Because the composition of a car is part of the analysis of the problem (and not simply part of the underlying design), making the members <emphasis role="bold">public</emphasis> assists the client programmer�s understanding of how to use the class and requires less code complexity for the creator of the class. However, keep in mind that this is a special case and that in general you should make fields <emphasis role="bold">private</emphasis>.</para>
      <para>When you inherit, you take an existing class and make a special version of it. In general, this means that you�re taking a general-purpose class and specializing it for a particular need. With a little thought, you�ll see that it would make no sense to compose a car using a vehicle object�a car doesn�t contain a vehicle, it <emphasis role="italic">is</emphasis> a vehicle. The <emphasis role="italic">is-a</emphasis> relationship is expressed with inheritance, and the <emphasis role="italic">has-a</emphasis> relationship is expressed with composition.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064611"/><anchor xreflabel="" xml:id="_Toc375545313"/><anchor xreflabel="" xml:id="_Toc312374027"/><anchor xreflabel="" xml:id="_Toc305628728"/><anchor xreflabel="protected" xml:id="_Toc305593256"/>protected</title>
      <para>Now that you�ve been introduced to inheritance, the keyword <emphasis role="bold">protected</emphasis>�finally has meaning. In an ideal world, <emphasis role="bold">private</emphasis> members would always be hard-and-fast <emphasis role="bold">private</emphasis>, but in real projects there are times when you want to make something hidden from the world at large and yet allow access for members of derived classes. The <emphasis role="bold">protected</emphasis> keyword is a nod to pragmatism. It says �This is <emphasis role="bold">private</emphasis> as far as the class user is concerned, but available to anyone who inherits from this class or anyone else in the same <emphasis role="bold">package</emphasis>.� That is, <emphasis role="bold">protected</emphasis> in Java is automatically �friendly.�</para>
      <para>The best tack to take is to leave the data members <emphasis role="bold">private</emphasis>�you should always preserve your right to change the underlying implementation. You can then allow controlled access to inheritors of your class through <emphasis role="bold">protected </emphasis>methods:</para>
      <para>//: c06:Orc.java</para>
      <para>// The protected keyword.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>class Villain {</para>
      <para>� private int i;</para>
      <para>� protected int read() { return i; }</para>
      <para>� protected void set(int ii) { i = ii; }</para>
      <para>� public Villain(int ii) { i = ii; }</para>
      <para>� public int value(int m) { return m*i; }</para>
      <para>}</para>
      <para> </para>
      <para>public class Orc extends Villain {</para>
      <para>� private int j;</para>
      <para>� public Orc(int jj) { super(jj); j = jj; }</para>
      <para>� public void change(int x) { set(x); }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>You can see that <emphasis role="bold">change( )</emphasis> has access to <emphasis role="bold">set( )</emphasis> because it�s <emphasis role="bold">protected</emphasis>.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064612"/><anchor xreflabel="" xml:id="_Toc375545314"/><anchor xreflabel="" xml:id="_Toc312374030"/><anchor xreflabel="" xml:id="_Toc305628730"/><anchor xreflabel="Incremental development" xml:id="_Toc305593258"/>Incremental development</title>
      <para>One of the advantages of inheritance is that it supports <emphasis role="italic">incremental development</emphasis>�by allowing you to introduce new code without causing bugs in existing code. This also isolates new bugs inside the new code. By inheriting from an existing, functional class and adding data members and methods (and redefining existing methods), you leave the existing code�that someone else might still be using�untouched and unbugged. If a bug happens, you know that it�s in your new code, which is much shorter and easier to read than if you had modified the body of existing code.</para>
      <para>It�s rather amazing how cleanly the classes are separated. You don�t even need the source code for the methods in order to reuse the code. At most, you just import a package. (This is true for both inheritance and composition.)</para>
      <para>It�s important to realize that program development is an incremental process, just like human learning. You can do as much analysis as you want, but you still won�t know all the answers when you set out on a project. You�ll have much more success�and more immediate feedback�if you start out to �grow� your project as an organic, evolutionary creature, rather than constructing it all at once like a glass-box skyscraper.</para>
      <para>Although inheritance for experimentation can be a useful technique, at some point after things stabilize you need to take a new look at your class hierarchy with an eye to collapsing it into a sensible structure. Remember that underneath it all, inheritance is meant to express a relationship that says �This new class is a <emphasis role="italic">type of</emphasis> that old class.� Your program should not be concerned with pushing bits around, but instead with creating and manipulating objects of various types to express a model in the terms that come from the problem space.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064613"/><anchor xreflabel="" xml:id="_Toc375545315"/><anchor xreflabel="" xml:id="_Toc312374031"/><anchor xreflabel="" xml:id="_Toc305628731"/><anchor xreflabel="Upcasting" xml:id="_Toc305593259"/>Upcasting</title>
      <para>The most important aspect of inheritance is not that it provides methods for the new class. It�s the relationship expressed between the new class and the base class. This relationship can be summarized by saying �The new class <emphasis role="italic">is a type of</emphasis> the existing class.� </para>
      <para>This description is not just a fanciful way of explaining inheritance�it�s supported directly by the language. As an example, consider a base class called <emphasis role="bold">Instrument</emphasis> that represents musical instruments, and a derived class called <emphasis role="bold">Wind</emphasis>. Because inheritance means that all of the methods in the base class are also available in the derived class, any message you can send to the base class can also be sent to the derived class. If the <emphasis role="bold">Instrument</emphasis> class has a <emphasis role="bold">play( )</emphasis> method, so will <emphasis role="bold">Wind</emphasis> instruments. This means we can accurately say that a <emphasis role="bold">Wind</emphasis> object is also a type of <emphasis role="bold">Instrument</emphasis>. The following example shows how the compiler supports this notion:</para>
      <para>//: c06:Wind.java</para>
      <para>// Inheritance &amp; upcasting.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>class Instrument {</para>
      <para>� public void play() {}</para>
      <para>� static void tune(Instrument i) {</para>
      <para>��� // ...</para>
      <para>��� i.play();</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>// Wind objects are instruments</para>
      <para>// because they have the same interface:</para>
      <para>class Wind extends Instrument {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Wind flute = new Wind();</para>
      <para>��� Instrument.tune(flute); // Upcasting</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>What�s interesting in this example is the <emphasis role="bold">tune( )</emphasis> method, which accepts an <emphasis role="bold">Instrument</emphasis> reference. However, in <emphasis role="bold">Wind</emphasis>.<emphasis role="bold">main( )</emphasis> the <emphasis role="bold">tune( )</emphasis> method is called by giving it a <emphasis role="bold">Wind</emphasis> reference. Given that Java is particular about type checking, it seems strange that a method that accepts one type will readily accept another type, until you realize that a <emphasis role="bold">Wind</emphasis> object is also an <emphasis role="bold">Instrument</emphasis> object, and there�s no method that <emphasis role="bold">tune( )</emphasis> could call for an <emphasis role="bold">Instrument</emphasis> that isn�t also in <emphasis role="bold">Wind</emphasis>. Inside <emphasis role="bold">tune( )</emphasis>, the code works for <emphasis role="bold">Instrument</emphasis> and anything derived from <emphasis role="bold">Instrument</emphasis>, and the act of converting a <emphasis role="bold">Wind</emphasis> reference into an <emphasis role="bold">Instrument</emphasis> reference is called <emphasis role="italic">upcasting</emphasis>.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064614"/><anchor xreflabel="" xml:id="_Toc375545316"/><anchor xreflabel="Why �upcasting�?" xml:id="_Toc312374032"/>Why �upcasting�?</title>
        <para>The reason for the term is historical, and based on the way class inheritance diagrams have traditionally been drawn: with the root at the top of the page, growing downward. (Of course, you can draw your diagrams any way you find helpful.) The inheritance diagram for <emphasis role="bold">Wind.java</emphasis> is then: </para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="113" contentwidth="100" fileref="./TIJ2_files/image017.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image017.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>Casting from derived to base moves <emphasis role="italic">up</emphasis> on the inheritance diagram, so it�s commonly referred to as <emphasis role="italic">upcasting</emphasis>. Upcasting is always safe because you�re going from a more specific type to a more general type. That is, the derived class is a superset of the base class. It might contain more methods than the base class, but it must contain <emphasis role="italic">at least</emphasis> the methods in the base class. The only thing that can occur to the class interface during the upcast is that it can lose methods, not gain them. This is why the compiler allows upcasting without any explicit casts or other special notation.</para>
        <para>You can also perform the reverse of upcasting, called <emphasis role="italic">downcasting</emphasis>, but this involves a dilemma that is the subject of Chapter 12.</para>
        <section>
          <title><anchor xreflabel="Composition vs. inheritance" xml:id="_Toc312374033"/>Composition vs. inheritance revisited</title>
          <para>In object-oriented programming, the most likely way that you�ll create and use code is by simply packaging data and methods together into a class, and using objects of that class. You�ll also use existing classes to build new classes with composition. Less frequently, you�ll use inheritance. So although inheritance gets a lot of emphasis while learning OOP, it doesn�t mean that you should use it everywhere you possibly can. On the contrary, you should use it sparingly, only when it�s clear that inheritance is useful. One of the clearest ways to determine whether you should use composition or inheritance is to ask whether you�ll ever need to upcast from your new class to the base class. If you must upcast, then inheritance is necessary, but if you don�t need to upcast, then you should look closely at whether you need inheritance. The next chapter (polymorphism) provides one of the most compelling reasons for upcasting, but if you remember to ask �Do I need to upcast?� you�ll have a good tool for deciding between composition and inheritance.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc312374036"/><anchor xreflabel="" xml:id="_Toc305628732"/><anchor xreflabel="" xml:id="_Toc305593260"/><anchor xreflabel="" xml:id="_Toc481064615"/><anchor xreflabel="The final keyword" xml:id="_Toc375545317"/>The <emphasis role="bold">final</emphasis> keyword</title>
      <para>Java�s <emphasis role="bold">final</emphasis> keyword has slightly different meanings depending on the context, but in general it says �This cannot be changed.� You might want to prevent changes for two reasons: design or efficiency. Because these two reasons are quite different, it�s possible to misuse the <emphasis role="bold">final</emphasis> keyword.</para>
      <para>The following sections discuss the three places where <emphasis role="bold">final</emphasis> can be used: for data, methods, and classes.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064616"/><anchor xreflabel="Final
data" xml:id="_Toc375545318"/>Final data</title>
        <para>Many programming languages have a way to tell the compiler that a piece of data is �constant.� A constant is useful for two reasons: </para>
        <para>It can be a <emphasis role="italic">compile-time constant</emphasis> that won�t ever change.</para>
        <para>It can be a value initialized at run-time that you don�t want changed.</para>
        <para>In the case of a compile-time constant, the compiler is allowed to �fold� the constant value into any calculations in which it�s used; that is, the calculation can be performed at compile-time, eliminating some run-time overhead. In Java, these sorts of constants must be primitives and are expressed using the <emphasis role="bold">final</emphasis> keyword. A value must be given at the time of definition of such a constant.</para>
        <para>A field that is both <emphasis role="bold">static</emphasis> and <emphasis role="bold">final</emphasis> has only one piece of storage that cannot be changed.</para>
        <para>When using <emphasis role="bold">final</emphasis> with object references rather than primitives the meaning gets a bit confusing. With a primitive, <emphasis role="bold">final</emphasis> makes the <emphasis role="italic">value</emphasis> a constant, but with an object reference, <emphasis role="bold">final</emphasis> makes the <emphasis role="italic">reference</emphasis> a constant. Once the reference is initialized to an object, it can never be changed to point to another object. However, the object itself can be modified; Java does not provide a way to make any arbitrary object a constant. (You can, however, write your class so that objects have the effect of being constant.) This restriction includes arrays, which are also objects.</para>
        <para>Here�s an example that demonstrates <emphasis role="bold">final</emphasis> fields:</para>
        <para>//: c06:FinalData.java</para>
        <para>// The effect of final on fields.</para>
        <para> </para>
        <para>class Value {</para>
        <para>� int i = 1;</para>
        <para>}</para>
        <para> </para>
        <para>public class FinalData {</para>
        <para>� // Can be compile-time constants</para>
        <para>� final int i1 = 9;</para>
        <para>� static final int VAL_TWO = 99;</para>
        <para>� // Typical public constant:</para>
        <para>� public static final int VAL_THREE = 39;</para>
        <para>��// Cannot be compile-time constants:</para>
        <para>� final int i4 = (int)(Math.random()*20);</para>
        <para>� static final int i5 = (int)(Math.random()*20);</para>
        <para>� </para>
        <para>� Value v1 = new Value();</para>
        <para>� final Value v2 = new Value();</para>
        <para>� static final Value v3 = new Value();</para>
        <para>� // Arrays:</para>
        <para>� final int[] a = { 1, 2, 3, 4, 5, 6 };</para>
        <para> </para>
        <para>� public void print(String id) {</para>
        <para>��� System.out.println(</para>
        <para>����� id + &quot;: &quot; + &quot;i4 = &quot; + i4 + </para>
        <para>����� &quot;, i5 = &quot; + i5);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� FinalData fd1 = new FinalData();</para>
        <para>��� //! fd1.i1++; // Error: can&apos;t change value</para>
        <para>��� fd1.v2.i++; // Object isn&apos;t constant!</para>
        <para>��� fd1.v1 = new Value(); // OK -- not final</para>
        <para>��� for(int i = 0; i &lt; fd1.a.length; i++)</para>
        <para>����� fd1.a[i]++; // Object isn&apos;t constant!</para>
        <para>��� //! fd1.v2 = new Value(); // Error: Can&apos;t </para>
        <para>��� //! fd1.v3 = new Value(); // change reference</para>
        <para>��� //! fd1.a = new int[3];</para>
        <para> </para>
        <para>��� fd1.print(&quot;fd1&quot;);</para>
        <para>��� System.out.println(&quot;Creating new FinalData&quot;);</para>
        <para>��� FinalData fd2 = new FinalData();</para>
        <para>��� fd1.print(&quot;fd1&quot;);</para>
        <para>��� fd2.print(&quot;fd2&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Since <emphasis role="bold">i1</emphasis> and <emphasis role="bold">VAL_TWO</emphasis> are <emphasis role="bold">final</emphasis> primitives with compile-time values, they can both be used as compile-time constants and are not different in any important way. <emphasis role="bold">VAL_THREE</emphasis> is the more typical way you�ll see such constants defined: <emphasis role="bold">public</emphasis> so they�re usable outside the package, <emphasis role="bold">static</emphasis> to emphasize that there�s only one, and <emphasis role="bold">final</emphasis> to say that it�s a constant. Note that <emphasis role="bold">final static</emphasis> primitives with constant initial values (that is, compile-time constants) are named with all capitals by convention, with words separated by underscores (This is just like C constants, which is where the convention originated.) Also note that <emphasis role="bold">i5</emphasis> cannot be known at compile-time, so it is not capitalized.</para>
        <para>Just because something is <emphasis role="bold">final</emphasis> doesn�t mean that its value is known at compile-time. This is demonstrated by initializing <emphasis role="bold">i4</emphasis> and <emphasis role="bold">i5</emphasis> at run-time using randomly generated numbers. This portion of the example also shows the difference between making a <emphasis role="bold">final</emphasis> value <emphasis role="bold">static</emphasis> or non-<emphasis role="bold">static</emphasis>. This difference shows up only when the values are initialized at run-time, since the compile-time values are treated the same by the compiler. (And presumably optimized out of existence.) The difference is shown in the output from one run:</para>
        <para>fd1: i4 = 15, i5 = 9</para>
        <para>Creating new FinalData</para>
        <para>fd1: i4 = 15, i5 = 9</para>
        <para>fd2: i4 = 10, i5 = 9</para>
        <para> </para>
        <para>Note that the values of <emphasis role="bold">i4</emphasis> for <emphasis role="bold">fd1</emphasis> and <emphasis role="bold">fd2</emphasis> are unique, but the value for <emphasis role="bold">i5</emphasis> is not changed by creating the second <emphasis role="bold">FinalData</emphasis> object. That�s because it�s <emphasis role="bold">static</emphasis> and is initialized once upon loading and not each time a new object is created.</para>
        <para>The variables <emphasis role="bold">v1</emphasis> through <emphasis role="bold">v4</emphasis> demonstrate the meaning of a <emphasis role="bold">final</emphasis> reference. As you can see in <emphasis role="bold">main( )</emphasis>, just because <emphasis role="bold">v2</emphasis> is <emphasis role="bold">final</emphasis> doesn�t mean that you can�t change its value. However, you cannot rebind <emphasis role="bold">v2</emphasis> to a new object, precisely because it�s <emphasis role="bold">final</emphasis>. That�s what <emphasis role="bold">final</emphasis> means for a reference. You can also see the same meaning holds true for an array, which is just another kind of reference. (There is no way that I know of to make the array references themselves <emphasis role="bold">final</emphasis>.) Making references <emphasis role="bold">final</emphasis> seems less useful than making primitives <emphasis role="bold">final</emphasis>.</para>
        <section>
          <title>Blank finals</title>
          <para>Java allows the creation of <emphasis role="italic">blank finals</emphasis>, which are fields that are declared as <emphasis role="bold">final</emphasis> but are not given an initialization value. In all cases, the blank final <emphasis role="italic">must</emphasis> be initialized before it is used, and the compiler ensures this. However, blank finals provide much more flexibility in the use of the <emphasis role="bold">final</emphasis> keyword since, for example, a <emphasis role="bold">final</emphasis> field inside a class can now be different for each object and yet it retains its immutable quality. Here�s an example:</para>
          <para>//: c06:BlankFinal.java</para>
          <para>// &quot;Blank&quot; final data members.</para>
          <para> </para>
          <para>class Poppet { }</para>
          <para> </para>
          <para>class BlankFinal {</para>
          <para>� final int i = 0; // Initialized final</para>
          <para>� final int j; // Blank final</para>
          <para>� final Poppet p; // Blank final reference</para>
          <para>� // Blank finals MUST be initialized</para>
          <para>� // in the constructor:</para>
          <para>� BlankFinal() {</para>
          <para>��� j = 1; // Initialize blank final</para>
          <para>��� p = new Poppet();</para>
          <para>� }</para>
          <para>� BlankFinal(int x) {</para>
          <para>��� j = x; // Initialize blank final</para>
          <para>��� p = new Poppet();</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� BlankFinal bf = new BlankFinal();</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>You�re forced to perform assignments to <emphasis role="bold">final</emphasis>s either with an expression at the point of definition of the field or in every constructor. This way it�s guaranteed that the <emphasis role="bold">final</emphasis> field is always initialized before use.</para>
        </section>
        <section>
          <title>Final arguments</title>
          <para>Java allows you to make arguments <emphasis role="bold">final</emphasis> by declaring them as such in the argument list. This means that inside the method you cannot change what the argument reference points to:</para>
          <para>//: c06:FinalArguments.java</para>
          <para>// Using &quot;final&quot; with method arguments.</para>
          <para> </para>
          <para>class Gizmo {</para>
          <para>� public void spin() {}</para>
          <para>}</para>
          <para> </para>
          <para>public class FinalArguments {</para>
          <para>� void with(final Gizmo g) {</para>
          <para>��� //! g = new Gizmo(); // Illegal -- g is final</para>
          <para>� }</para>
          <para>� void without(Gizmo g) {</para>
          <para>��� g = new Gizmo(); // OK -- g not final</para>
          <para>��� g.spin();</para>
          <para>� }</para>
          <para>� // void f(final int i) { i++; } // Can&apos;t change</para>
          <para>� // You can only read from a final primitive:</para>
          <para>� int g(final int i) { return i + 1; }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� FinalArguments bf = new FinalArguments();</para>
          <para>��� bf.without(null);</para>
          <para>��� bf.with(null);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>Note that you can still assign a <emphasis role="bold">null</emphasis> reference to an argument that�s final without the compiler catching it, just like you can with a non-<emphasis role="bold">final</emphasis> argument.</para>
          <para>The methods <emphasis role="bold">f( )</emphasis> and <emphasis role="bold">g( )</emphasis> show what happens when primitive arguments are <emphasis role="bold">final</emphasis>: you can read the argument, but you can&apos;t change it.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064617"/><anchor xreflabel="Final
methods" xml:id="_Toc375545319"/>Final methods</title>
        <para>There are two reasons for <emphasis role="bold">final</emphasis> methods. The first is to put a �lock� on the method to prevent any inheriting class from changing its meaning. This is done for design reasons when you want to make sure that a method�s behavior is retained during inheritance and cannot be overridden.</para>
        <para>The second reason for <emphasis role="bold">final</emphasis> methods is efficiency. If you make a method <emphasis role="bold">final</emphasis>, you are allowing the compiler to turn any calls to that method into <emphasis role="italic">inline</emphasis> calls. When the compiler sees a <emphasis role="bold">final</emphasis> method call it can (at its discretion) skip the normal approach of inserting code to perform the method call mechanism (push arguments on the stack, hop over to the method code and execute it, hop back and clean off the stack arguments, and deal with the return value) and instead replace the method call with a copy of the actual code in the method body. This eliminates the overhead of the method call. Of course, if a method is big, then your code begins to bloat and you probably won�t see any performance gains from inlining, since any improvements will be dwarfed by the amount of time spent inside the method. It is implied that the Java compiler is able to detect these situations and choose wisely whether to inline a <emphasis role="bold">final</emphasis> method. However, it�s better to not trust that the compiler is able to do this and make a method <emphasis role="bold">final</emphasis> only if it�s quite small or if you want to explicitly prevent overriding.</para>
        <section>
          <title>final and private</title>
          <para>Any <emphasis role="bold">private</emphasis> methods in a class are implicitly <emphasis role="bold">final</emphasis>. Because you can�t access a <emphasis role="bold">private </emphasis>method, you can�t override it (even though the compiler doesn�t give an error message if you try to override it, you haven�t overridden the method, you�ve just created a new method). You can add the <emphasis role="bold">final</emphasis> specifier to a <emphasis role="bold">private</emphasis> method but it doesn�t give that method any extra meaning.</para>
          <para>This issue can cause confusion, because if you try to override a <emphasis role="bold">private</emphasis> method (which is implicitly <emphasis role="bold">final</emphasis>)<emphasis role="bold"/>it seems to work:</para>
          <para>//: c06:FinalOverridingIllusion.java</para>
          <para>// It only looks like you can override</para>
          <para>// a private or private final method.</para>
          <para> </para>
          <para>class WithFinals {</para>
          <para>� // Identical to &quot;private&quot; alone:</para>
          <para>� private final void f() {</para>
          <para>��� System.out.println(&quot;WithFinals.f()&quot;);</para>
          <para>� }</para>
          <para>� // Also automatically &quot;final&quot;:</para>
          <para>� private void g() {</para>
          <para>��� System.out.println(&quot;WithFinals.g()&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class OverridingPrivate extends WithFinals {</para>
          <para>� private final void f() {</para>
          <para>��� System.out.println(&quot;OverridingPrivate.f()&quot;);</para>
          <para>� }</para>
          <para>� private void g() {</para>
          <para>��� System.out.println(&quot;OverridingPrivate.g()&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class OverridingPrivate2 </para>
          <para>� extends OverridingPrivate {</para>
          <para>� public final void f() {</para>
          <para>��� System.out.println(&quot;OverridingPrivate2.f()&quot;);</para>
          <para>� }</para>
          <para>� public void g() {</para>
          <para>��� System.out.println(&quot;OverridingPrivate2.g()&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>public class FinalOverridingIllusion {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� OverridingPrivate2 op2 = </para>
          <para>����� new OverridingPrivate2();</para>
          <para>��� op2.f();</para>
          <para>��� op2.g();</para>
          <para>��� // You can upcast:</para>
          <para>��� OverridingPrivate op = op2;</para>
          <para>��� // But you can&apos;t call the methods:</para>
          <para>��� //! op.f();</para>
          <para>��� //! op.g();</para>
          <para>��� // Same here:</para>
          <para>��� WithFinals wf = op2;</para>
          <para>��� //! wf.f();</para>
          <para>��� //! wf.g();</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>�Overriding� can only occur if something is part of the base-class interface. That is, you must be able to upcast an object to its base type and call the same method (the point of this will become clear in the next chapter). If a method is <emphasis role="bold">private</emphasis>, it isn�t part of the base-class interface. It is just some code that�s hidden away inside the class, and it just happens to have that name, but if you create a <emphasis role="bold">public</emphasis>, <emphasis role="bold">protected</emphasis> or �friendly� method in the derived class, there�s no connection to the method that might happen to have that name in the base class. Since a <emphasis role="bold">private </emphasis>method is unreachable and effectively invisible, it doesn�t factor into anything except for the code organization of the class for which it was defined.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064618"/><anchor xreflabel="Final
classes" xml:id="_Toc375545320"/>Final classes</title>
        <para>When you say that an entire class is <emphasis role="bold">final</emphasis> (by preceding its definition with the <emphasis role="bold">final</emphasis> keyword), you state that you don�t want to inherit from this class or allow anyone else to do so. In other words, for some reason the design of your class is such that there is never a need to make any changes, or for safety or security reasons you don�t want subclassing. Alternatively, you might be dealing with an efficiency issue, and you want to make sure that any activity involved with objects of this class are as efficient as possible.</para>
        <para>//: c06:Jurassic.java</para>
        <para>// Making an entire class final.</para>
        <para> </para>
        <para>class SmallBrain {}</para>
        <para> </para>
        <para>final class Dinosaur {</para>
        <para>� int i = 7;</para>
        <para>� int j = 1;</para>
        <para>� SmallBrain x = new SmallBrain();</para>
        <para>� void f() {}</para>
        <para>}</para>
        <para> </para>
        <para>//! class Further extends Dinosaur {}</para>
        <para>// error: Cannot extend final class &apos;Dinosaur&apos;</para>
        <para> </para>
        <para>public class Jurassic {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Dinosaur n = new Dinosaur();</para>
        <para>��� n.f();</para>
        <para>��� n.i = 40;</para>
        <para>��� n.j++;</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Note that the data members can be <emphasis role="bold">final</emphasis> or not, as you choose. The same rules apply to <emphasis role="bold">final</emphasis> for data members regardless of whether the class is defined as <emphasis role="bold">final</emphasis>. Defining the class as <emphasis role="bold">final</emphasis> simply prevents inheritance�nothing more. However, because it prevents inheritance all methods in a <emphasis role="bold">final</emphasis> class are implicitly <emphasis role="bold">final</emphasis>, since there�s no way to override them. So the compiler has the same efficiency options as it does if you explicitly declare a method <emphasis role="bold">final</emphasis>.</para>
        <para>You can add the <emphasis role="bold">final</emphasis> specifier to a method in a <emphasis role="bold">final</emphasis> class, but it doesn�t add any meaning.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064619"/><anchor xreflabel="Final
caution" xml:id="_Toc375545321"/>Final caution</title>
        <para>It can seem to be sensible to make a method <emphasis role="bold">final</emphasis> while you�re designing a class. You might feel that efficiency is very important when using your class and that no one could possibly want to override your methods anyway. Sometimes this is true.</para>
        <para>But be careful with your assumptions. In general, it�s difficult to anticipate how a class can be reused, especially a general-purpose class. If you define a method as <emphasis role="bold">final</emphasis> you might prevent the possibility of reusing your class through inheritance in some other programmer�s project simply because you couldn�t imagine it being used that way.</para>
        <para>The standard Java library is a good example of this. In particular, the Java 1.0/1.1 <emphasis role="bold">Vector</emphasis> class was commonly used and might have been even more useful if, in the name of efficiency, all the methods hadn�t been made <emphasis role="bold">final</emphasis>. It�s easily conceivable that you might want to inherit and override with such a fundamentally useful class, but the designers somehow decided this wasn�t appropriate. This is ironic for two reasons. First, <emphasis role="bold">Stack </emphasis>is inherited from <emphasis role="bold">Vector</emphasis>, which says that a <emphasis role="bold">Stack </emphasis><emphasis role="italic">is</emphasis> a <emphasis role="bold">Vector</emphasis>, which isn�t really true from a logical standpoint. Second, many of the most important methods of <emphasis role="bold">Vector</emphasis>, such as <emphasis role="bold">addElement( ) </emphasis>and <emphasis role="bold">elementAt( )</emphasis> are <emphasis role="bold">synchronized</emphasis>. As you will see in Chapter 14, this incurs a significant performance overhead that probably wipes out any gains provided by <emphasis role="bold">final</emphasis>. This lends credence to the theory that programmers are consistently bad at guessing where optimizations should occur. It�s just too bad that such a clumsy design made it into the standard library where we must all cope with it. (Fortunately, the Java 2 container library replaces <emphasis role="bold">Vector</emphasis> with <emphasis role="bold">ArrayList</emphasis>, which behaves much more civilly. Unfortunately, there�s still plenty of new code being written that uses the old container library.)</para>
        <para>It�s also interesting to note that <emphasis role="bold">Hashtable</emphasis>, another important standard library class, does <emphasis role="italic">not</emphasis> have any <emphasis role="bold">final</emphasis> methods. As mentioned elsewhere in this book, it�s quite obvious that some classes were designed by completely different people than others. (You�ll see that the method names in <emphasis role="bold">Hashtable</emphasis> are much briefer compared to those in <emphasis role="bold">Vector</emphasis>, another piece of evidence.) This is precisely the sort of thing that should <emphasis role="italic">not</emphasis> be obvious to consumers of a class library. When things are inconsistent it just makes more work for the user. Yet another paean to the value of design and code walkthroughs. (Note that the Java 2 container library replaces <emphasis role="bold">Hashtable</emphasis> with <emphasis role="bold">HashMap</emphasis>.)</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064620"/><anchor xreflabel="Initialization
and 
class loading" xml:id="_Toc375545322"/>Initialization and   class loading</title>
      <para>In more traditional languages, programs are loaded all at once as part of the startup process. This is followed by initialization, and then the program begins. The process of initialization in these languages must be carefully controlled so that the order of initialization of <emphasis role="bold">static</emphasis>s doesn�t cause trouble. C++, for example, has problems if one <emphasis role="bold">static</emphasis> expects another <emphasis role="bold">static </emphasis>to be valid before the second one has been initialized.</para>
      <para>Java doesn�t have this problem because it takes a different approach to loading. Because everything in Java is an object, many activities become easier, and this is one of them. As you will learn more fully in the next chapter, the compiled code for each class exists in its own separate file. That file isn�t loaded until the code is needed. In general, you can say that �Class code is loaded at the point of first use.� This is often not until the first object of that class is constructed, but loading also occurs when a <emphasis role="bold">static </emphasis>field or <emphasis role="bold">static</emphasis> method is accessed.</para>
      <para>The point of first use is also where the <emphasis role="bold">static</emphasis> initialization takes place. All the <emphasis role="bold">static</emphasis> objects and the <emphasis role="bold">static</emphasis> code block will be initialized in textual order (that is, the order that you write them down in the class definition) at the point of loading. The <emphasis role="bold">static</emphasis>s, of course, are initialized only once.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064621"/><anchor xreflabel="Initialization
with inheritance" xml:id="_Toc375545323"/>Initialization with inheritance</title>
        <para>It�s helpful to look at the whole initialization process, including inheritance, to get a full picture of what happens. Consider the following code:</para>
        <para>//: c06:Beetle.java</para>
        <para>// The full process of initialization.</para>
        <para> </para>
        <para>class Insect {</para>
        <para>� int i = 9;</para>
        <para>� int j;</para>
        <para>� Insect() {</para>
        <para>��� prt(&quot;i = &quot; + i + &quot;, j = &quot; + j);</para>
        <para>��� j = 39;</para>
        <para>� }</para>
        <para>� static int x1 = </para>
        <para>��� prt(&quot;static Insect.x1 initialized&quot;);</para>
        <para>� static int prt(String s) {</para>
        <para>��� System.out.println(s);</para>
        <para>��� return 47;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Beetle extends Insect {</para>
        <para>� int k = prt(&quot;Beetle.k initialized&quot;);</para>
        <para>� Beetle() {</para>
        <para>��� prt(&quot;k = &quot; + k);</para>
        <para>��� prt(&quot;j = &quot; + j);</para>
        <para>� }</para>
        <para>� static int x2 =</para>
        <para>��� prt(&quot;static Beetle.x2 initialized&quot;);</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� prt(&quot;Beetle constructor&quot;);</para>
        <para>��� Beetle b = new Beetle();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The output for this program is:</para>
        <para>static Insect.x1 initialized</para>
        <para>static Beetle.x2 initialized</para>
        <para>Beetle constructor</para>
        <para>i = 9, j = 0</para>
        <para>Beetle.k initialized</para>
        <para>k = 47</para>
        <para>j = 39</para>
        <para> </para>
        <para>The first thing that happens when you run Java on <emphasis role="bold">Beetle</emphasis> is that you try to access <emphasis role="bold">Beetle.main( ) </emphasis>(a <emphasis role="bold">static </emphasis>method), so the loader goes out and finds the compiled code for the <emphasis role="bold">Beetle</emphasis>class (this happens to be in a file called <emphasis role="bold">Beetle.class</emphasis>). In the process of loading it, the loader notices that it has a base class (that�s what the <emphasis role="bold">extends </emphasis>keyword says), which it then loads. This will happen whether or not you�re going to make an object of that base class. (Try commenting out the object creation to prove it to yourself.)</para>
        <para>If the base class has a base class, that second base class would then be loaded, and so on. Next, the <emphasis role="bold">static</emphasis> initialization in the root base class (in this case, <emphasis role="bold">Insect</emphasis>) is performed, and then the next derived class, and so on. This is important because the derived-class static initialization might depend on the base class member being initialized properly.</para>
        <para>At this point, the necessary classes have all been loaded so the object can be created. First, all the primitives in this object are set to their default values and the object references are set to <emphasis role="bold">null</emphasis>�this happens in one fell swoop by setting the memory in the object to binary zero.<emphasis role="bold"/>Then the base-class constructor will be called. In this case the call is automatic, but you can also specify the base-class constructor call (as the first operation in the <emphasis role="bold">Beetle( )</emphasis> constructor) using <emphasis role="bold">super</emphasis>. The base class construction goes through the same process in the same order as the derived-class constructor. After the base-class constructor completes, the instance variables are initialized in textual order. Finally, the rest of the body of the constructor is executed.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064622"/><anchor xreflabel="Summary" xml:id="_Toc375545324"/>Summary</title>
      <para>Both inheritance and composition allow you to create a new type from existing types. Typically, however, you use composition to reuse existing types as part of the underlying implementation of the new type, and inheritance when you want to reuse the interface. Since the derived class has the base-class interface, it can be <emphasis role="italic">upcast</emphasis> to the base, which is critical for polymorphism, as you�ll see in the next chapter. </para>
      <para>Despite the strong emphasis on inheritance in object-oriented programming, when you start a design you should generally prefer composition during the first cut and use inheritance only when it is clearly necessary. Composition tends to be more flexible. In addition, by using the added artifice of inheritance with your member type, you can change the exact type, and thus the behavior, of those member objects at run-time. Therefore, you can change the behavior of the composed object at run-time.</para>
      <para>Although code reuse through composition and inheritance is helpful for rapid project development, you�ll generally want to redesign your class hierarchy before allowing other programmers to become dependent on it. Your goal is a hierarchy in which each class has a specific use and is neither too big (encompassing so much functionality that it�s unwieldy to reuse) nor annoyingly small (you can�t use it by itself or without adding functionality).</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064623"/><anchor xreflabel="Exercises" xml:id="_Toc375545325"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Create two classes, <emphasis role="bold">A</emphasis> and <emphasis role="bold">B</emphasis>, with default constructors (empty argument lists) that announce themselves. Inherit a new class called <emphasis role="bold">C</emphasis> from <emphasis role="bold">A</emphasis>, and create a member of class <emphasis role="bold">B</emphasis> inside <emphasis role="bold">C</emphasis>. Do not create a constructor for <emphasis role="bold">C</emphasis>. Create an object of class <emphasis role="bold">C</emphasis> and observe the results.</para>
      <para>      54.         Modify Exercise 1 so that <emphasis role="bold">A</emphasis> and <emphasis role="bold">B</emphasis> have constructors with arguments instead of default constructors. Write a constructor for <emphasis role="bold">C</emphasis> and perform all initialization within <emphasis role="bold">C</emphasis>�s constructor. </para>
      <para>      55.         Create a simple class. Inside a second class, define a field for an object of the first class. Use lazy initialization to instantiate this object.</para>
      <para>      56.         Inherit a new class from class <emphasis role="bold">Detergent</emphasis>. Override <emphasis role="bold">scrub( )</emphasis> and add a new method called <emphasis role="bold">sterilize( )</emphasis>.</para>
      <para>      57.         Take the file <emphasis role="bold">Cartoon.java</emphasis> and comment out the constructor for the <emphasis role="bold">Cartoon</emphasis> class. Explain what happens.</para>
      <para>      58.         Take the file <emphasis role="bold">Chess.java</emphasis> and comment out the constructor for the <emphasis role="bold">Chess</emphasis> class. Explain what happens.</para>
      <para>      59.         Prove that default constructors are created for you by the compiler.</para>
      <para>      60.         Prove that the base-class constructors are (a) always called, and (b) called before derived-class constructors.</para>
      <para>      61.         Create a base class with only a nondefault constructor, and a derived class with both a default and nondefault constructor. In the derived-class constructors, call the base-class constructor.</para>
      <para>      62.         Create a class called <emphasis role="bold">Root</emphasis> that contains an instance of each of classes (that you also create) named <emphasis role="bold">Component1</emphasis>, <emphasis role="bold">Component2</emphasis>,<emphasis role="bold"/>and <emphasis role="bold">Component3</emphasis>. Derive a class <emphasis role="bold">Stem</emphasis> from <emphasis role="bold">Root</emphasis> that also contains an instance of each �component.� All classes should have default constructors that print a message about that class.</para>
      <para>      63.         Modify Exercise 10 so that each class only has nondefault constructors.</para>
      <para>      64.         Add a proper hierarchy of <emphasis role="bold">cleanup( )</emphasis> methods to all the classes in Exercise 11.</para>
      <para>      65.         Create a class with a method that is overloaded three times. Inherit a new class, add a new overloading of the method, and show that all four methods are available in the derived class.</para>
      <para>      66.         In <emphasis role="bold">Car.java</emphasis> add a <emphasis role="bold">service( )</emphasis> method to <emphasis role="bold">Engine</emphasis> and call this method in <emphasis role="bold">main( )</emphasis>.</para>
      <para>      67.         Create a class inside a package. Your class should contain a <emphasis role="bold">protected</emphasis> method. Outside of the package, try to call the <emphasis role="bold">protected</emphasis> method and explain the results. Now inherit from your class and call the <emphasis role="bold">protected</emphasis> method from inside a method of your derived class.</para>
      <para>      68.         Create a class called <emphasis role="bold">Amphibian</emphasis>. From this, inherit a class called <emphasis role="bold">Frog</emphasis>. Put appropriate methods in the base class. In <emphasis role="bold">main( )</emphasis>, create a <emphasis role="bold">Frog</emphasis> and upcast it to <emphasis role="bold">Amphibian</emphasis>, and demonstrate that all the methods still work.</para>
      <para>      69.         Modify Exercise 16 so that <emphasis role="bold">Frog</emphasis> overrides the method definitions from the base class (provides new definitions using the same method signatures). Note what happens in <emphasis role="bold">main( )</emphasis>.</para>
      <para>      70.         Create a class with a <emphasis role="bold">static final</emphasis> field and a <emphasis role="bold">final</emphasis> field and demonstrate the difference between the two.</para>
      <para>      71.         Create a class with a blank <emphasis role="bold">final</emphasis> reference to an object. Perform the initialization of the blank <emphasis role="bold">final</emphasis> inside a method (not the constructor) right before you use it. Demonstrate the guarantee that the <emphasis role="bold">final</emphasis> must be initialized before use, and that it cannot be changed once initialized.</para>
      <para>      72.         Create a class with a <emphasis role="bold">final</emphasis> method. Inherit from that class and attempt to override that method.</para>
      <para>      73.         Create a <emphasis role="bold">final</emphasis> class and attempt to inherit from it.</para>
      <para>      74.         Prove that class loading takes place only once. Prove that loading may be caused by either the creation of the first instance of that class, or the access of a <emphasis role="bold">static</emphasis> member.</para>
      <para>      75.         In <emphasis role="bold">Beetle.java</emphasis>, inherit a specific type of� beetle from class <emphasis role="bold">Beetle</emphasis>, following the same format as the existing classes. Trace and explain the output.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064624"/><anchor xreflabel="" xml:id="_Toc477690727"/><anchor xreflabel="" xml:id="_Toc375545326"/><anchor xreflabel="" xml:id="Chapter_7"/>7: Polymorphism</title>
    <para><anchor xreflabel="" xml:id="A"/>Polymorphism is the third essential feature of an object-oriented programming language, after data abstraction and inheritance. </para>
    <para>It provides another dimension of separation of interface from implementation, to decouple <emphasis role="italic">what</emphasis> from <emphasis role="italic">how</emphasis>. Polymorphism allows improved code organization and readability as well as the creation of <emphasis role="italic">extensible</emphasis> programs that can be �grown� not only during the original creation of the project but also when new features are desired.</para>
    <para>Encapsulation creates new data types by combining characteristics and behaviors. Implementation hiding separates the interface from the implementation by making the details <emphasis role="bold">private</emphasis>. This sort of mechanical organization makes ready sense to someone with a procedural programming background. But polymorphism deals with decoupling in terms of <emphasis role="italic">types</emphasis>. In the last chapter, you saw how inheritance allows the treatment of an object as its own type <emphasis role="italic">or</emphasis> its base type. This ability is critical because it allows many types (derived from the same base type) to be treated as if they were one type, and a single piece of code to work on all those different types equally. The polymorphic method call allows one type to express its distinction from another, similar type, as long as they�re both derived from the same base type. This distinction is expressed through differences in behavior of the methods that you can call through the base class.</para>
    <para>In this chapter, you�ll learn about polymorphism (also called <emphasis role="italic">dynamic binding</emphasis> or <emphasis role="italic">late binding</emphasis> or <emphasis role="italic">run-time binding</emphasis>)<emphasis role="italic"/>starting from the basics, with simple examples that strip away everything but the polymorphic behavior of the program.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064625"/><anchor xreflabel="" xml:id="_Toc375545327"/><anchor xreflabel="" xml:id="_Toc312374040"/><anchor xreflabel="" xml:id="_Toc305628735"/><anchor xreflabel="Upcasting" xml:id="_Toc305593263"/>Upcasting revisited</title>
      <para>In Chapter 6 you saw how an object can be used as its own type or as an object of its base type. Taking an object reference and treating it as a reference to its base type is called <emphasis role="italic">upcasting,</emphasis>�because of the way inheritance trees are drawn with the base class at the top.</para>
      <para>You also saw a problem arise, which is embodied in the following:</para>
      <para>//: c07:music:Music.java </para>
      <para>// Inheritance &amp; upcasting.</para>
      <para> </para>
      <para>class Note {</para>
      <para>� private int value;</para>
      <para>� private Note(int val) { value = val; }</para>
      <para>� public static final Note</para>
      <para>��� MIDDLE_C = new Note(0), </para>
      <para>��� C_SHARP� = new Note(1),</para>
      <para>��� B_FLAT�� = new Note(2);</para>
      <para>} // Etc.</para>
      <para> </para>
      <para>class Instrument {</para>
      <para>� public void play(Note n) {</para>
      <para>��� System.out.println(&quot;Instrument.play()&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>// Wind objects are instruments</para>
      <para>// because they have the same interface:</para>
      <para>class Wind extends Instrument {</para>
      <para>� // Redefine interface method:</para>
      <para>� public void play(Note n) {</para>
      <para>��� System.out.println(&quot;Wind.play()&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class Music {</para>
      <para>� public static void tune(Instrument i) {</para>
      <para>��� // ...</para>
      <para>��� i.play(Note.MIDDLE_C);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Wind flute = new Wind();</para>
      <para>��� tune(flute); // Upcasting</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The method <emphasis role="bold">Music.tune( )</emphasis> accepts an <emphasis role="bold">Instrument </emphasis>reference, but also anything derived from <emphasis role="bold">Instrument</emphasis>. In <emphasis role="bold">main( )</emphasis>, you can see this happening as a <emphasis role="bold">Wind</emphasis> reference is passed to <emphasis role="bold">tune( )</emphasis>, with no cast necessary. This is acceptable; the interface in <emphasis role="bold">Instrument</emphasis> must exist in <emphasis role="bold">Wind</emphasis>, because <emphasis role="bold">Wind</emphasis> is inherited from <emphasis role="bold">Instrument</emphasis>. Upcasting from <emphasis role="bold">Wind</emphasis> to <emphasis role="bold">Instrument</emphasis> may �narrow� that interface, but it cannot make it anything less than the full interface to <emphasis role="bold">Instrument</emphasis>.</para>
      <section>
        <title><anchor xreflabel="Forgetting the object type" xml:id="_Toc481064626"/>Forgetting the object type</title>
        <para>This program might seem strange to you. Why should anyone intentionally <emphasis role="italic">forget</emphasis> the type of an object? This is what happens when you upcast, and it seems like it could be much more straightforward if <emphasis role="bold">tune( )</emphasis> simply takes a <emphasis role="bold">Wind</emphasis> reference as its argument. This brings up an essential point: If you did that, you�d need to write a new <emphasis role="bold">tune( )</emphasis> for every type of <emphasis role="bold">Instrument</emphasis> in your system. Suppose we follow this reasoning and add <emphasis role="bold">Stringed</emphasis> and <emphasis role="bold">Brass</emphasis> instruments:</para>
        <para>//: c07:music2:Music2.java </para>
        <para>// Overloading instead of upcasting.</para>
        <para> </para>
        <para>class Note {</para>
        <para>� private int value;</para>
        <para>� private Note(int val) { value = val; }</para>
        <para>� public static final Note</para>
        <para>��� MIDDLE_C = new Note(0), </para>
        <para>��� C_SHARP = new Note(1),</para>
        <para>��� B_FLAT = new Note(2);</para>
        <para>} // Etc.</para>
        <para> </para>
        <para>class Instrument {</para>
        <para>� public void play(Note n) {</para>
        <para>��� System.out.println(&quot;Instrument.play()&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Wind extends Instrument {</para>
        <para>� public void play(Note n) {</para>
        <para>��� System.out.println(&quot;Wind.play()&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Stringed extends Instrument {</para>
        <para>� public void play(Note n) {</para>
        <para>��� System.out.println(&quot;Stringed.play()&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Brass extends Instrument {</para>
        <para>� public void play(Note n) {</para>
        <para>��� System.out.println(&quot;Brass.play()&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Music2 {</para>
        <para>� public static void tune(Wind i) {</para>
        <para>��� i.play(Note.MIDDLE_C);</para>
        <para>� }</para>
        <para>� public static void tune(Stringed i) {</para>
        <para>��� i.play(Note.MIDDLE_C);</para>
        <para>� }</para>
        <para>� public static void tune(Brass i) {</para>
        <para>��� i.play(Note.MIDDLE_C);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Wind flute = new Wind();</para>
        <para>��� Stringed violin = new Stringed();</para>
        <para>��� Brass frenchHorn = new Brass();</para>
        <para>��� tune(flute); // No upcasting</para>
        <para>��� tune(violin);</para>
        <para>��� tune(frenchHorn);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This works, but there�s a major drawback: You must write type-specific methods for each new <emphasis role="bold">Instrument</emphasis> class you add. This means more programming in the first place, but it also means that if you want to add a new method like <emphasis role="bold">tune( )</emphasis> or a new type of <emphasis role="bold">Instrument</emphasis>, you�ve got a lot of work to do. Add the fact that the compiler won�t give you any error messages if you forget to overload one of your methods and the whole process of working with types becomes unmanageable.</para>
        <para>Wouldn�t it be much nicer if you could just write a single method that takes the base class as its argument, and not any of the specific derived classes? That is, wouldn�t it be nice if you could forget that there are derived classes, and write your code to talk only to the base class?</para>
        <para>That�s exactly what polymorphism allows you to do. However, most programmers who come from a procedural programming background have a bit of trouble with the way polymorphism works.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064627"/><anchor xreflabel="" xml:id="_Toc375545329"/><anchor xreflabel="" xml:id="_Toc312374041"/><anchor xreflabel="" xml:id="_Toc305628736"/><anchor xreflabel="The " xml:id="_Toc305593264"/>The twist</title>
      <para>The difficulty with <emphasis role="bold">Music</emphasis>.<emphasis role="bold">java</emphasis> can be seen by running the program. The output is <emphasis role="bold">Wind.play( )</emphasis>. This is clearly the desired output, but it doesn�t seem to make sense that it would work that way. Look at the <emphasis role="bold">tune( )</emphasis> method:</para>
      <para>� public static void tune(Instrument i) {</para>
      <para>��� // ...</para>
      <para>��� i.play(Note.MIDDLE_C);</para>
      <para>� }</para>
      <para> </para>
      <para>It receives an <emphasis role="bold">Instrument</emphasis> reference. So how can the compiler possibly know that this <emphasis role="bold">Instrument</emphasis> reference points to a <emphasis role="bold">Wind</emphasis> in this case and not a <emphasis role="bold">Brass </emphasis>or <emphasis role="bold">Stringed</emphasis>? The compiler can�t. To get a deeper understanding of the issue, it�s helpful to examine the subject of <emphasis role="italic">binding</emphasis>.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064628"/><anchor xreflabel="" xml:id="_Toc375545330"/><anchor xreflabel="Method-call binding" xml:id="_Toc312374042"/>Method-call binding</title>
        <para>Connecting a method call to a method body is called <emphasis role="italic">binding</emphasis>. When binding is performed before the program is run (by the compiler and linker, if there is one), it�s called <emphasis role="italic">early binding</emphasis>. You might not have heard the term before because it has never been an option with procedural languages. C compilers have only one kind of method call, and that�s early binding.</para>
        <para>The confusing part of the above program revolves around early binding because the compiler cannot know the correct method to call when it has only an <emphasis role="bold">Instrument</emphasis> reference.</para>
        <para>The solution is called <emphasis role="italic">late binding</emphasis>, which means that the binding occurs at run-time based on the type of object. Late binding is also called <emphasis role="italic">dynamic binding</emphasis>�or <emphasis role="italic">run-time binding</emphasis>. When a language implements late binding, there must be some mechanism to determine the type of the object at run-time and to call the appropriate method. That is, the compiler still doesn�t know the object type, but the method-call mechanism finds out and calls the correct method body. The late-binding mechanism varies from language to language, but you can imagine that some sort of type information must be installed in the objects.</para>
        <para>All method binding in Java uses late binding unless a method has been declared <emphasis role="bold">final</emphasis>. This means that ordinarily you don�t need to make any decisions about whether late binding will occur�it happens automatically.</para>
        <para>Why would you declare a method <emphasis role="bold">final</emphasis>? As noted in the last chapter, it prevents anyone from overriding that method. Perhaps more important, it effectively �turns off� dynamic binding, or rather it tells the compiler that dynamic binding isn�t necessary. This allows the compiler to generate slightly more efficient code for <emphasis role="bold">final</emphasis> method calls. However, in most cases it won�t make any overall performance difference in your program, so it�s best to only use <emphasis role="bold">final</emphasis> as a design decision, and not as an attempt to improve performance.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064629"/><anchor xreflabel="Producing
the right behavior" xml:id="_Toc375545331"/>Producing the right behavior</title>
        <para>Once you know that all method binding in Java happens polymorphically via late binding, you can write your code to talk to the base class and know that all the derived-class cases will work correctly using the same code. Or to put it another way, you �send a message to an object and let the object figure out the right thing to do.�</para>
        <para>The classic example in OOP is the �shape� example. This is commonly used because it is easy to visualize, but unfortunately it can confuse novice programmers into thinking that OOP is just for graphics programming, which is of course not the case.</para>
        <para>The shape example has a base class called <emphasis role="bold">Shape </emphasis>and various derived types: <emphasis role="bold">Circle</emphasis>, <emphasis role="bold">Square</emphasis>, <emphasis role="bold">Triangle</emphasis>, etc. The reason the example works so well is that it�s easy to say �a circle is a type of shape� and be understood.<emphasis role="bold"/>The inheritance diagram shows the relationships:</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="238" contentwidth="445" fileref="./TIJ2_files/image018.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image018.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>The upcast could occur in a statement as simple as:</para>
        <para>Shape s = new Circle();</para>
        <para> </para>
        <para>Here, a <emphasis role="bold">Circle</emphasis> object is created and the resulting reference is immediately assigned to a <emphasis role="bold">Shape</emphasis>, which would seem to be an error (assigning one type to another); and yet it�s fine because a <emphasis role="bold">Circle</emphasis><emphasis role="italic">is</emphasis> a <emphasis role="bold">Shape</emphasis> by inheritance. So the compiler agrees with the statement and doesn�t issue an error message.</para>
        <para>Suppose you call one of the base-class methods (that have been overridden in the derived classes):</para>
        <para>s.draw();</para>
        <para> </para>
        <para>Again, you might expect that <emphasis role="bold">Shape</emphasis>�s <emphasis role="bold">draw( )</emphasis> is called because this is, after all, a <emphasis role="bold">Shape</emphasis> reference�so how could the compiler know to do anything else? And yet the proper <emphasis role="bold">Circle.draw( )</emphasis> is called because of late binding (polymorphism).</para>
        <para>The following example puts it a slightly different way:</para>
        <para>//: c07:Shapes.java</para>
        <para>// Polymorphism in Java.</para>
        <para> </para>
        <para>class Shape { </para>
        <para>� void draw() {}</para>
        <para>� void erase() {} </para>
        <para>}</para>
        <para> </para>
        <para>class Circle extends Shape {</para>
        <para>� void draw() { </para>
        <para>��� System.out.println(&quot;Circle.draw()&quot;); </para>
        <para>� }</para>
        <para>� void erase() { </para>
        <para>��� System.out.println(&quot;Circle.erase()&quot;); </para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Square extends Shape {</para>
        <para>� void draw() { </para>
        <para>��� System.out.println(&quot;Square.draw()&quot;); </para>
        <para>� }</para>
        <para>� void erase() { </para>
        <para>��� System.out.println(&quot;Square.erase()&quot;); </para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Triangle extends Shape {</para>
        <para>� void draw() { </para>
        <para>��� System.out.println(&quot;Triangle.draw()&quot;); </para>
        <para>� }</para>
        <para>� void erase() { </para>
        <para>��� System.out.println(&quot;Triangle.erase()&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Shapes {</para>
        <para>� public static Shape randShape() {</para>
        <para>��� switch((int)(Math.random() * 3)) {</para>
        <para>����� default:</para>
        <para>����� case 0: return new Circle();</para>
        <para>����� case 1: return new Square();</para>
        <para>����� case 2: return new Triangle();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Shape[] s = new Shape[9];</para>
        <para>��� // Fill up the array with shapes:</para>
        <para>��� for(int i = 0; i &lt; s.length; i++)</para>
        <para>����� s[i] = randShape();</para>
        <para>��� // Make polymorphic method calls:</para>
        <para>��� for(int i = 0; i &lt; s.length; i++)</para>
        <para>����� s[i].draw();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The base class <emphasis role="bold">Shape</emphasis> establishes the common interface to anything inherited from <emphasis role="bold">Shape</emphasis>�that is, all shapes can be drawn and erased. The derived classes override these definitions to provide unique behavior for each specific type of shape.</para>
        <para>The main class <emphasis role="bold">Shapes</emphasis> contains a <emphasis role="bold">static</emphasis> method <emphasis role="bold">randShape( )</emphasis> that produces a reference to a randomly-selected <emphasis role="bold">Shape</emphasis> object each time you call it. Note that the upcasting happens in each of the <emphasis role="bold">return</emphasis> statements, which take a reference to a <emphasis role="bold">Circle</emphasis>, <emphasis role="bold">Square</emphasis>, or <emphasis role="bold">Triangle</emphasis> and sends it out of the method as the return type, <emphasis role="bold">Shape</emphasis>. So whenever you call this method you never get a chance to see what specific type it is, since you always get back a plain <emphasis role="bold">Shape</emphasis> reference.</para>
        <para><emphasis role="bold">main( )</emphasis> contains an array of <emphasis role="bold">Shape</emphasis> references filled through calls to <emphasis role="bold">randShape( )</emphasis>. At this point you know you have <emphasis role="bold">Shape</emphasis>s, but you don�t know anything more specific than that (and neither does the compiler). However, when you step through this array and call <emphasis role="bold">draw( )</emphasis> for each one, the correct type-specific behavior magically occurs, as you can see from one output example:</para>
        <para>Circle.draw()</para>
        <para>Triangle.draw()</para>
        <para>Circle.draw()</para>
        <para>Circle.draw()</para>
        <para>Circle.draw()</para>
        <para>Square.draw()</para>
        <para>Triangle.draw()</para>
        <para>Square.draw()</para>
        <para>Square.draw()</para>
        <para> </para>
        <para>Of course, since the shapes are all chosen randomly each time, your runs will have different results. The point of choosing the shapes randomly is to drive home the understanding that the compiler can have no special knowledge that allows it to make the correct calls at compile-time. All the calls to <emphasis role="bold">draw( )</emphasis> are made through dynamic binding.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064630"/><anchor xreflabel="Extensibility" xml:id="_Toc375545332"/>Extensibility</title>
        <para>Now let�s return to the musical instrument example. Because of polymorphism, you can add as many new types as you want to the system without changing the <emphasis role="bold">tune( )</emphasis> method. In a well-designed OOP program, most or all of your methods will follow the model of <emphasis role="bold">tune( )</emphasis> and communicate only with the base-class interface. Such a program is <emphasis role="italic">extensible</emphasis>�because you can add new functionality by inheriting new data types from the common base class. The methods that manipulate the base-class interface will not need to be changed at all to accommodate the new classes.</para>
        <para>Consider what happens if you take the instrument example and add more methods in the base class and a number of new classes. Here�s the diagram:</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="412" contentwidth="376" fileref="./TIJ2_files/image019.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image019.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>All these new classes work correctly with the old, unchanged <emphasis role="bold">tune( )</emphasis> method. Even if <emphasis role="bold">tune( )</emphasis> is in a separate file and new methods are added to the interface of <emphasis role="bold">Instrument</emphasis>, <emphasis role="bold">tune( )</emphasis> works correctly without recompilation. Here is the implementation of the above diagram:</para>
        <para>//: c07:music3:Music3.java</para>
        <para>// An extensible program.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Instrument {</para>
        <para>� public void play() {</para>
        <para>��� System.out.println(&quot;Instrument.play()&quot;);</para>
        <para>� }</para>
        <para>� public String what() {</para>
        <para>��� return &quot;Instrument&quot;;</para>
        <para>� }</para>
        <para>� public void adjust() {}</para>
        <para>}</para>
        <para> </para>
        <para>class Wind extends Instrument {</para>
        <para>� public void play() {</para>
        <para>��� System.out.println(&quot;Wind.play()&quot;);</para>
        <para>� }</para>
        <para>� public String what() { return &quot;Wind&quot;; }</para>
        <para>� public void adjust() {}</para>
        <para>}</para>
        <para> </para>
        <para>class Percussion extends Instrument {</para>
        <para>� public void play() {</para>
        <para>��� System.out.println(&quot;Percussion.play()&quot;);</para>
        <para>� }</para>
        <para>� public String what() { return &quot;Percussion&quot;; }</para>
        <para>� public void adjust() {}</para>
        <para>}</para>
        <para> </para>
        <para>class Stringed extends Instrument {</para>
        <para>� public void play() {</para>
        <para>��� System.out.println(&quot;Stringed.play()&quot;);</para>
        <para>� }</para>
        <para>� public String what() { return &quot;Stringed&quot;; }</para>
        <para>� public void adjust() {}</para>
        <para>}</para>
        <para> </para>
        <para>class Brass extends Wind {</para>
        <para>� public void play() {</para>
        <para>��� System.out.println(&quot;Brass.play()&quot;);</para>
        <para>� }</para>
        <para>� public void adjust() {</para>
        <para>��� System.out.println(&quot;Brass.adjust()&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Woodwind extends Wind {</para>
        <para>� public void play() {</para>
        <para>��� System.out.println(&quot;Woodwind.play()&quot;);</para>
        <para>� }</para>
        <para>� public String what() { return &quot;Woodwind&quot;; }</para>
        <para>}</para>
        <para> </para>
        <para>public class Music3 {</para>
        <para>� // Doesn&apos;t care about type, so new types</para>
        <para>� // added to the system still work right:</para>
        <para>� static void tune(Instrument i) {</para>
        <para>��� // ...</para>
        <para>��� i.play();</para>
        <para>� }</para>
        <para>� static void tuneAll(Instrument[] e) {</para>
        <para>��� for(int i = 0; i &lt; e.length; i++)</para>
        <para>����� tune(e[i]);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Instrument[] orchestra = new Instrument[5];</para>
        <para>��� int i = 0;</para>
        <para>��� // Upcasting during addition to the array:</para>
        <para>��� orchestra[i++] = new Wind();</para>
        <para>��� orchestra[i++] = new Percussion();</para>
        <para>��� orchestra[i++] = new Stringed();</para>
        <para>��� orchestra[i++] = new Brass();</para>
        <para>��� orchestra[i++] = new Woodwind();</para>
        <para>��� tuneAll(orchestra);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The new methods are <emphasis role="bold">what( )</emphasis>, which returns a <emphasis role="bold">String</emphasis> reference with a description of the class, and <emphasis role="bold">adjust( )</emphasis>, which provides some way to adjust each instrument.</para>
        <para>In <emphasis role="bold">main( )</emphasis>, when you place something inside the <emphasis role="bold">Instrument </emphasis>array you automatically upcast to <emphasis role="bold">Instrument</emphasis>.</para>
        <para>You can see that the <emphasis role="bold">tune( )</emphasis> method is blissfully ignorant of all the code changes that have happened around it, and yet it works correctly. This is exactly what polymorphism is supposed to provide. Your code changes don�t cause damage to parts of the program that should not be affected. Put another way, polymorphism is one of the most important techniques that allow the programmer to �separate the things that change from the things that stay the same.�</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064631"/><anchor xreflabel="Overriding
vs. overloading" xml:id="_Toc375545333"/>Overriding vs. overloading</title>
      <para>Let�s take a different look at the first example in this chapter. In the following program, the interface of the method <emphasis role="bold">play( )</emphasis> is changed in the process of overriding it, which means that you haven�t <emphasis role="italic">overridden</emphasis> the method, but instead <emphasis role="italic">overloaded </emphasis>it. The compiler allows you to overload methods so it gives no complaint. But the behavior is probably not what you want. Here�s the example:</para>
      <para>//: c07:WindError.java </para>
      <para>// Accidentally changing the interface.</para>
      <para> </para>
      <para>class NoteX {</para>
      <para>� public static final int</para>
      <para>��� MIDDLE_C = 0, C_SHARP = 1, C_FLAT = 2;</para>
      <para>}</para>
      <para> </para>
      <para>class InstrumentX {</para>
      <para>� public void play(int NoteX) {</para>
      <para>��� System.out.println(&quot;InstrumentX.play()&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class WindX extends InstrumentX {</para>
      <para>� // OOPS! Changes the method interface:</para>
      <para>� public void play(NoteX n) {</para>
      <para>��� System.out.println(&quot;WindX.play(NoteX n)&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class WindError {</para>
      <para>� public static void tune(InstrumentX i) {</para>
      <para>��� // ...</para>
      <para>��� i.play(NoteX.MIDDLE_C);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� WindX flute = new WindX();</para>
      <para>��� tune(flute); // Not the desired behavior!</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>There�s another confusing aspect thrown in here. In <emphasis role="bold">InstrumentX</emphasis>, the <emphasis role="bold">play( )</emphasis> method takes an <emphasis role="bold">int</emphasis> that has the identifier <emphasis role="bold">NoteX</emphasis>. That is, even though <emphasis role="bold">NoteX</emphasis> is a class name, it can also be used as an identifier without complaint. But in <emphasis role="bold">WindX</emphasis>, <emphasis role="bold">play( )</emphasis> takes a <emphasis role="bold">NoteX</emphasis> reference that has an identifier <emphasis role="bold">n.</emphasis> (Although you could even say <emphasis role="bold">play(NoteX NoteX)</emphasis> without an error.) Thus it appears that the programmer intended to override <emphasis role="bold">play( )</emphasis> but mistyped the method a bit. The compiler, however, assumed that an overload and not an override was intended. Note that if you follow the standard Java naming convention, the argument identifier would be <emphasis role="bold">noteX</emphasis> (lowercase �n�), which would distinguish it from the class name.</para>
      <para>In <emphasis role="bold">tune</emphasis>, the <emphasis role="bold">InstrumentX</emphasis><emphasis role="bold">i</emphasis> is sent the <emphasis role="bold">play( )</emphasis> message, with one of <emphasis role="bold">NoteX</emphasis>�s members (<emphasis role="bold">MIDDLE_C</emphasis>) as an argument. Since <emphasis role="bold">NoteX</emphasis> contains <emphasis role="bold">int</emphasis> definitions, this means that the <emphasis role="bold">int</emphasis> version of the now-overloaded <emphasis role="bold">play( )</emphasis> method is called, and since that has <emphasis role="italic">not</emphasis> been overridden the base-class version is used.</para>
      <para>The output is:</para>
      <para>InstrumentX.play()</para>
      <para> </para>
      <para>This certainly doesn�t appear to be a polymorphic method call. Once you understand what�s happening, you can fix the problem fairly easily, but imagine how difficult it might be to find the bug if it�s buried in a program of significant size.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064632"/><anchor xreflabel="Abstract
classes 
and methods" xml:id="_Toc375545334"/>Abstract classes   and methods</title>
      <para>In all the instrument examples, the methods in the base class <emphasis role="bold">Instrument</emphasis> were always �dummy� methods. If these methods are ever called, you�ve done something wrong. That�s because the intent of <emphasis role="bold">Instrument</emphasis> is to create a <emphasis role="italic">common interface</emphasis> for all the classes derived from it.</para>
      <para>The only reason to establish this common interface�is so it can be expressed differently for each different subtype. It establishes a basic form, so you can say what�s in common with all the derived classes. Another way of saying this is to call <emphasis role="bold">Instrument</emphasis> an <emphasis role="italic">abstract base class</emphasis>(or simply an <emphasis role="italic">abstract class</emphasis>). You create an abstract class when you want to manipulate a set of classes through this common interface. All derived-class methods that match the signature of the base-class declaration will be called using the dynamic binding mechanism. (However, as seen in the last section, if the method�s name is the same as the base class but the arguments are different, you�ve got overloading, which probably isn�t what you want.)</para>
      <para>If you have an abstract class like <emphasis role="bold">Instrument</emphasis>, objects of that class almost always have no meaning. That is, <emphasis role="bold">Instrument</emphasis> is meant to express only the interface, and not a particular implementation, so creating an <emphasis role="bold">Instrument</emphasis> object makes no sense, and you�ll probably want to prevent the user from doing it. This can be accomplished by making all the methods in <emphasis role="bold">Instrument</emphasis> print error messages, but that delays the information until run-time and requires reliable exhaustive testing on the user�s part. It�s always better to catch problems at compile-time.</para>
      <para>Java provides a mechanism for doing this called the <emphasis role="italic">abstract method</emphasis><anchor xreflabel="[37]" xml:id="_ftnref37"/>[37]. This is a method that is incomplete; it has only a declaration and no method body. Here is the syntax for an abstract method declaration:</para>
      <para>abstract void f();</para>
      <para> </para>
      <para>A class containing abstract methods is called an <emphasis role="italic">abstract class</emphasis>. If a class contains one or more abstract methods, the class must be qualified as <emphasis role="bold">abstract</emphasis>. (Otherwise, the compiler gives you an error message.)</para>
      <para>If an abstract class is incomplete, what is the compiler supposed to do when someone tries to make an object of that class? It cannot safely create an object of an abstract class, so you get an error message from the compiler. This way the compiler ensures the purity of the abstract class, and you don�t need to worry about misusing it.</para>
      <para>If you inherit from an abstract class and you want to make objects of the new type, you must provide method definitions for all the abstract methods in the base class. If you don�t (and you may choose not to), then the derived class is also abstract and the compiler will force you to qualify <emphasis role="italic">that</emphasis> class with the <emphasis role="bold">abstract</emphasis> keyword.</para>
      <para>It�s possible to create a class as <emphasis role="bold">abstract</emphasis> without including any <emphasis role="bold">abstract</emphasis> methods. This is useful when you�ve got a class in which it doesn�t make sense to have any <emphasis role="bold">abstract</emphasis> methods, and yet you want to prevent any instances of that class.</para>
      <para>The <emphasis role="bold">Instrument</emphasis> class can easily be turned into an <emphasis role="bold">abstract</emphasis> class. Only some of the methods will be <emphasis role="bold">abstract</emphasis>, since making a class abstract doesn�t force you to make all the methods <emphasis role="bold">abstract</emphasis>.<emphasis role="bold"/>Here�s what it looks like:</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="403" contentwidth="367" fileref="./TIJ2_files/image020.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image020.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>Here�s the orchestra example modified to use <emphasis role="bold">abstract</emphasis> classes and methods:</para>
      <para>//: c07:music4:Music4.java</para>
      <para>// Abstract classes and methods.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>abstract class Instrument {</para>
      <para>� int i; // storage allocated for each</para>
      <para>� public abstract void play();</para>
      <para>� public String what() {</para>
      <para>��� return &quot;Instrument&quot;;</para>
      <para>� }</para>
      <para>� public abstract void adjust();</para>
      <para>}</para>
      <para> </para>
      <para>class Wind extends Instrument {</para>
      <para>� public void play() {</para>
      <para>��� System.out.println(&quot;Wind.play()&quot;);</para>
      <para>� }</para>
      <para>� public String what() { return &quot;Wind&quot;; }</para>
      <para>� public void adjust() {}</para>
      <para>}</para>
      <para> </para>
      <para>class Percussion extends Instrument {</para>
      <para>� public void play() {</para>
      <para>��� System.out.println(&quot;Percussion.play()&quot;);</para>
      <para>� }</para>
      <para>� public String what() { return &quot;Percussion&quot;; }</para>
      <para>� public void adjust() {}</para>
      <para>}</para>
      <para> </para>
      <para>class Stringed extends Instrument {</para>
      <para>� public void play() {</para>
      <para>��� System.out.println(&quot;Stringed.play()&quot;);</para>
      <para>� }</para>
      <para>� public String what() { return &quot;Stringed&quot;; }</para>
      <para>� public void adjust() {}</para>
      <para>}</para>
      <para> </para>
      <para>class Brass extends Wind {</para>
      <para>� public void play() {</para>
      <para>��� System.out.println(&quot;Brass.play()&quot;);</para>
      <para>� }</para>
      <para>� public void adjust() { </para>
      <para>��� System.out.println(&quot;Brass.adjust()&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Woodwind extends Wind {</para>
      <para>� public void play() {</para>
      <para>��� System.out.println(&quot;Woodwind.play()&quot;);</para>
      <para>� }</para>
      <para>� public String what() { return &quot;Woodwind&quot;; }</para>
      <para>}</para>
      <para> </para>
      <para>public class Music4 {</para>
      <para>� // Doesn&apos;t care about type, so new types</para>
      <para>� // added to the system still work right:</para>
      <para>� static void tune(Instrument i) {</para>
      <para>��� // ...</para>
      <para>��� i.play();</para>
      <para>� }</para>
      <para>� static void tuneAll(Instrument[] e) {</para>
      <para>��� for(int i = 0; i &lt; e.length; i++)</para>
      <para>����� tune(e[i]);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Instrument[] orchestra = new Instrument[5];</para>
      <para>��� int i = 0;</para>
      <para>��� // Upcasting during addition to the array:</para>
      <para>��� orchestra[i++] = new Wind();</para>
      <para>��� orchestra[i++] = new Percussion();</para>
      <para>��� orchestra[i++] = new Stringed();</para>
      <para>��� orchestra[i++] = new Brass();</para>
      <para>��� orchestra[i++] = new Woodwind();</para>
      <para>��� tuneAll(orchestra);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>You can see that there�s really no change except in the base class.</para>
      <para>It�s helpful to create <emphasis role="bold">abstract </emphasis>classes and methods because they make the abstractness of a class explicit, and tell both the user and the compiler how it was int<anchor xreflabel="ended to
be used." xml:id="_Toc375545338"/>ended to be used.</para>
    </section>
    <section>
      <title><anchor xreflabel="Constructors and polymorphism" xml:id="_Toc481064633"/>Constructors and polymorphism</title>
      <para>As usual, constructors are different from other kinds of methods. This is also true when polymorphism is involved. Even though constructors are not polymorphic (although you can have a kind of �virtual constructor,� as you will see in Chapter 12), it�s important to understand the way constructors work in complex hierarchies and with polymorphism. This understanding will help you avoid unpleasant entanglements.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064634"/><anchor xreflabel="Order
of constructor calls" xml:id="_Toc375545339"/>Order of constructor calls</title>
        <para>The order of constructor calls was briefly discussed in Chapter 4 and again in Chapter 6, but that was before polymorphism was introduced. </para>
        <para>A constructor for the base class is always called in the constructor for a derived class, chaining up the inheritance hierarchy so that a constructor for every base class is called. This makes sense because the constructor has a special job: to see that the object is built properly. A derived class has access to its own members only, and not to those of the base class (whose members are typically <emphasis role="bold">private</emphasis>). Only the base-class constructor has the proper knowledge and access to initialize its own elements. Therefore, it�s essential that all constructors get called, otherwise the entire object wouldn�t be constructed. That�s why the compiler enforces a constructor call for every portion of a derived class. It will silently call the default constructor if you don�t explicitly call a base-class constructor in the derived-class constructor body. If there is no default constructor, the compiler will complain. (In the case where a class has no constructors, the compiler will automatically synthesize a default constructor.)</para>
        <para>Let�s take a look at an example that shows the effects of composition, inheritance, and polymorphism on the order of construction:</para>
        <para>//: c07:Sandwich.java</para>
        <para>// Order of constructor calls.</para>
        <para> </para>
        <para>class Meal {</para>
        <para>� Meal() { System.out.println(&quot;Meal()&quot;); }</para>
        <para>}</para>
        <para> </para>
        <para>class Bread {</para>
        <para>� Bread() { System.out.println(&quot;Bread()&quot;); }</para>
        <para>}</para>
        <para> </para>
        <para>class Cheese {</para>
        <para>� Cheese() { System.out.println(&quot;Cheese()&quot;); }</para>
        <para>}</para>
        <para> </para>
        <para>class Lettuce {</para>
        <para>� Lettuce() { System.out.println(&quot;Lettuce()&quot;); }</para>
        <para>}</para>
        <para> </para>
        <para>class Lunch extends Meal {</para>
        <para>� Lunch() { System.out.println(&quot;Lunch()&quot;);}</para>
        <para>}</para>
        <para> </para>
        <para>class PortableLunch extends Lunch {</para>
        <para>� PortableLunch() {</para>
        <para>��� System.out.println(&quot;PortableLunch()&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Sandwich extends PortableLunch {</para>
        <para>� Bread b = new Bread();</para>
        <para>� Cheese c = new Cheese();</para>
        <para>� Lettuce l = new Lettuce();</para>
        <para>� Sandwich() { </para>
        <para>��� System.out.println(&quot;Sandwich()&quot;);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� new Sandwich();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This example creates a complex class out of other classes, and each class has a constructor that announces itself. The important class is <emphasis role="bold">Sandwich</emphasis>, which reflects three levels of inheritance (four, if you count the implicit inheritance from <emphasis role="bold">Object</emphasis>) and three member objects. When a <emphasis role="bold">Sandwich</emphasis> object is created in <emphasis role="bold">main( )</emphasis>, the output is:</para>
        <para>Meal()</para>
        <para>Lunch()</para>
        <para>PortableLunch()</para>
        <para>Bread()</para>
        <para>Cheese()</para>
        <para>Lettuce()</para>
        <para>Sandwich()</para>
        <para> </para>
        <para>This means that the order of constructor calls for a complex object is as follows: </para>
        <para>The base-class constructor is called. This step is repeated recursively such that the root of the hierarchy is constructed first, followed by the next-derived class, etc., until the most-derived class is reached.</para>
        <para>38.      Member initializers are called in the order of declaration.</para>
        <para>39.      The body of the derived-class constructor is called.</para>
        <para>The order of the constructor calls is important. When you inherit, you know all about the base class and can access any <emphasis role="bold">public</emphasis> and <emphasis role="bold">protected</emphasis> members of the base class. This means that you must be able to assume that all the members of the base class are valid when you�re in the derived class. In a normal method, construction has already taken place, so all the members of all parts of the object have been built. inside the constructor, however, you must be able to assume that all members that you use have been built. The only way to guarantee this is for the base-class constructor to be called first. Then when you�re in the derived-class constructor, all the members you can access in the base class have been initialized. �Knowing that all members are valid� inside the constructor is also the reason that, whenever possible, you should initialize all member objects (that is, objects placed in the class using composition) at their point of definition in the class (e.g., <emphasis role="bold">b</emphasis>, <emphasis role="bold">c,</emphasis> and <emphasis role="bold">l</emphasis> in the example above). If you follow this practice, you will help ensure that all base class members <emphasis role="italic">and</emphasis> member objects of the current object have been initialized. Unfortunately, this doesn�t handle every case, as you will see in the next section.</para>
      </section>
      <section>
        <title><anchor xreflabel="Inheritance and finalize( )" xml:id="_Toc481064635"/>Inheritance and <emphasis role="bold">finalize( )</emphasis></title>
        <para>When you use composition to create a new class, you never worry about finalizing the member objects of that class. Each member is an independent object, and thus is garbage collected and finalized regardless of whether it happens to be a member of your class. With inheritance, however, you must override <emphasis role="bold">finalize( )</emphasis> in the derived class if you have any special cleanup that must happen as part of garbage collection. When you override <emphasis role="bold">finalize( )</emphasis> in an inherited class, it�s important to remember to call the base-class version of <emphasis role="bold">finalize( )</emphasis>, since otherwise the base-class finalization will not happen. The following example proves this:</para>
        <para>//: c07:Frog.java</para>
        <para>// Testing finalize with inheritance.</para>
        <para> </para>
        <para>class DoBaseFinalization {</para>
        <para>� public static boolean flag = false;</para>
        <para>}</para>
        <para> </para>
        <para>class Characteristic {</para>
        <para>� String s;</para>
        <para>� Characteristic(String c) {</para>
        <para>�� �s = c;</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;Creating Characteristic &quot; + s);</para>
        <para>� }</para>
        <para>� protected void finalize() {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;finalizing Characteristic &quot; + s);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class LivingCreature {</para>
        <para>� Characteristic p = </para>
        <para>��� new Characteristic(&quot;is alive&quot;);</para>
        <para>� LivingCreature() {</para>
        <para>��� System.out.println(&quot;LivingCreature()&quot;);</para>
        <para>� }</para>
        <para>� protected void finalize() throws Throwable {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;LivingCreature finalize&quot;);</para>
        <para>��� // Call base-class version LAST!</para>
        <para>��� if(DoBaseFinalization.flag)</para>
        <para>����� super.finalize();</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Animal extends LivingCreature {</para>
        <para>� Characteristic p = </para>
        <para>��� new Characteristic(&quot;has heart&quot;);</para>
        <para>� Animal() {</para>
        <para>��� System.out.println(&quot;Animal()&quot;);</para>
        <para>� }</para>
        <para>� protected void finalize() throws Throwable {</para>
        <para>��� System.out.println(&quot;Animal finalize&quot;);</para>
        <para>��� if(DoBaseFinalization.flag)</para>
        <para>����� super.finalize();</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Amphibian extends Animal {</para>
        <para>� Characteristic p = </para>
        <para>��� new Characteristic(&quot;can live in water&quot;);</para>
        <para>� Amphibian() {</para>
        <para>��� System.out.println(&quot;Amphibian()&quot;);</para>
        <para>� }</para>
        <para>� protected void finalize() throws Throwable {</para>
        <para>��� System.out.println(&quot;Amphibian finalize&quot;);</para>
        <para>��� if(DoBaseFinalization.flag)</para>
        <para>����� super.finalize();</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Frog extends Amphibian {</para>
        <para>� Frog() {</para>
        <para>��� System.out.println(&quot;Frog()&quot;);</para>
        <para>� }</para>
        <para>� protected void finalize() throws Throwable {</para>
        <para>��� System.out.println(&quot;Frog finalize&quot;);</para>
        <para>��� if(DoBaseFinalization.flag)</para>
        <para>����� super.finalize();</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� if(args.length != 0 &amp;&amp; </para>
        <para>������ args[0].equals(&quot;finalize&quot;))</para>
        <para>������ DoBaseFinalization.flag = true;</para>
        <para>��� else</para>
        <para>����� System.out.println(&quot;Not finalizing bases&quot;);</para>
        <para>��� new Frog(); // Instantly becomes garbage</para>
        <para>��� System.out.println(&quot;Bye!&quot;);</para>
        <para>��� // Force finalizers to be called:</para>
        <para>��� System.gc();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The class <emphasis role="bold">DoBaseFinalization</emphasis> simply holds a flag that indicates to each class in the hierarchy whether to call <emphasis role="bold">super.finalize( )</emphasis>. This flag is set based on a command-line argument, so you can view the behavior with and without base-class finalization.</para>
        <para>Each class in the hierarchy also contains a member object of class <emphasis role="bold">Characteristic</emphasis>. You will see that regardless of whether the base class finalizers are called, the <emphasis role="bold">Characteristic</emphasis> member objects are always finalized.</para>
        <para>Each overridden <emphasis role="bold">finalize( ) </emphasis>must have access to at least <emphasis role="bold">protected </emphasis>members since the <emphasis role="bold">finalize( ) </emphasis>method in class <emphasis role="bold">Object </emphasis>is <emphasis role="bold">protected</emphasis> and the compiler will not allow you to reduce the access during inheritance. (�Friendly� is less accessible than <emphasis role="bold">protected</emphasis>.)<emphasis role="bold"/></para>
        <para>In <emphasis role="bold">Frog.main( )</emphasis>,<emphasis role="bold"/>the <emphasis role="bold">DoBaseFinalization </emphasis>flag is configured and a single <emphasis role="bold">Frog </emphasis>object is created. Remember that garbage collection�and in particular finalization�might not happen for any particular object, so to enforce this, the call to <emphasis role="bold">System.gc( )</emphasis> triggers garbage collection, and thus finalization. Without base-class finalization, the output is:</para>
        <para>Not finalizing bases</para>
        <para>Creating Characteristic is alive</para>
        <para>LivingCreature()</para>
        <para>Creating Characteristic has heart</para>
        <para>Animal()</para>
        <para>Creating Characteristic can live in water</para>
        <para>Amphibian()</para>
        <para>Frog()</para>
        <para>Bye!</para>
        <para>Frog finalize</para>
        <para>finalizing Characteristic is alive</para>
        <para>finalizing Characteristic has heart</para>
        <para>finalizing Characteristic can live in water</para>
        <para> </para>
        <para>You can see that, indeed, no finalizers are called for the base classes of <emphasis role="bold">Frog</emphasis> (the member objects <emphasis role="italic">are</emphasis> finalized, as you would expect). But if you add the �finalize� argument on the command line, you get:</para>
        <para>Creating Characteristic is alive</para>
        <para>LivingCreature()</para>
        <para>Creating Characteristic has heart</para>
        <para>Animal()</para>
        <para>Creating Characteristic can live in water</para>
        <para>Amphibian()</para>
        <para>Frog()</para>
        <para>bye!</para>
        <para>Frog finalize</para>
        <para>Amphibian finalize</para>
        <para>Animal finalize</para>
        <para>LivingCreature finalize</para>
        <para>finalizing Characteristic is alive</para>
        <para>finalizing Characteristic has heart</para>
        <para>finalizing Characteristic can live in water</para>
        <para> </para>
        <para>Although the order the member objects are finalized is the same order that they are created, technically the order of finalization of objects is unspecified. With base classes, however, you have control over the order of finalization. The best order to use is the one that�s shown here, which is the reverse of the order of initialization. Following the form that�s used in C++ for destructors, you should perform the derived-class finalization first, then the base-class finalization. That�s because the derived-class finalization could call some methods in the base class that require that the base-class components are still alive, so you must not destroy them prematurely.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064636"/><anchor xreflabel="" xml:id="_Toc375545340"/><anchor xreflabel="Behavior of polymorphic methods 
inside constructors" xml:id="_Toc312374057"/>Behavior of polymorphic methods   inside constructors</title>
        <para>The hierarchy of constructor calls brings up an interesting dilemma. What happens if you�re inside a constructor and you call a dynamically bound method of the object being constructed? Inside an ordinary method you can imagine what will happen�the dynamically bound call is resolved at run-time because the object cannot know whether it belongs to the class that the method is in or some class derived from it. For consistency, you might think this is what should happen inside constructors.</para>
        <para>This is not exactly the case. If you call a dynamically bound method inside a constructor, the overridden definition for that method is used. However, the <emphasis role="italic">effect</emphasis> can be rather unexpected, and can conceal some difficult-to-find bugs.</para>
        <para>Conceptually, the constructor�s job is to bring the object into existence (which is hardly an ordinary feat). Inside any constructor, the entire object might be only partially formed�you can know only that the base-class objects have been initialized, but you cannot know which classes are inherited from you. A dynamically bound method call, however, reaches �outward� into the inheritance hierarchy. It calls a method in a derived class. If you do this inside a constructor, you call a method that might manipulate members that haven�t been initialized yet�a sure recipe for disaster.</para>
        <para>You can see the problem in the following example:</para>
        <para>//: c07:PolyConstructors.java</para>
        <para>// Constructors and polymorphism</para>
        <para>// don&apos;t produce what you might expect.</para>
        <para> </para>
        <para>abstract class Glyph {</para>
        <para>� abstract void draw();</para>
        <para>� Glyph() {</para>
        <para>��� System.out.println(&quot;Glyph() before draw()&quot;);</para>
        <para>��� draw(); </para>
        <para>��� System.out.println(&quot;Glyph() after draw()&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class RoundGlyph extends Glyph {</para>
        <para>� int radius = 1;</para>
        <para>� RoundGlyph(int r) {</para>
        <para>��� radius = r;</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;RoundGlyph.RoundGlyph(), radius = &quot;</para>
        <para>����� + radius);</para>
        <para>� }</para>
        <para>� void draw() { </para>
        <para>��� System.out.println(</para>
        <para>����� &quot;RoundGlyph.draw(), radius = &quot; + radius);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class PolyConstructors {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� new RoundGlyph(5);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In <emphasis role="bold">Glyph</emphasis>, the <emphasis role="bold">draw( )</emphasis> method is <emphasis role="bold">abstract</emphasis>, so it is designed to be overridden. Indeed, you are forced to override it in <emphasis role="bold">RoundGlyph</emphasis>. But the <emphasis role="bold">Glyph</emphasis> constructor calls this method, and the call ends up in <emphasis role="bold">RoundGlyph.draw( )</emphasis>, which would seem to be the intent. But look at the output:</para>
        <para>Glyph() before draw()</para>
        <para>RoundGlyph.draw(), radius = 0</para>
        <para>Glyph() after draw()</para>
        <para>RoundGlyph.RoundGlyph(), radius = 5</para>
        <para> </para>
        <para>When <emphasis role="bold">Glyph</emphasis>�s constructor calls <emphasis role="bold">draw( )</emphasis>, the value of <emphasis role="bold">radius</emphasis> isn�t even the default initial value 1. It�s 0. This would probably result in either a dot or nothing at all being drawn on the screen, and you�d be left staring, trying to figure out why the program won�t work.</para>
        <para>The order of initialization described in the previous section isn�t quite complete, and that�s the key to solving the mystery. The actual process of initialization is:</para>
        <para>The storage allocated for the object is initialized to binary zero before anything else happens.</para>
        <para>40.      The base-class constructors are called as described previously. At this point, the overridden <emphasis role="bold">draw( )</emphasis> method is called (yes, <emphasis role="italic">before </emphasis>the <emphasis role="bold">RoundGlyph </emphasis>constructor is called), which discovers a <emphasis role="bold">radius</emphasis> value of zero, due to step 1.</para>
        <para>41.      Member initializers are called in the order of declaration.</para>
        <para>42.      The body of the derived-class constructor is called.</para>
        <para>There�s an upside to this, which is that everything is at least initialized to zero (or whatever zero means for that particular data type) and not just left as garbage. This includes object references that are embedded inside a class via composition, which become <emphasis role="bold">null</emphasis>. So if you forget to initialize that reference you�ll get an exception at run-time. Everything else gets zero, which is usually a telltale value when looking at output.</para>
        <para>On the other hand, you should be pretty horrified at the outcome of this program. You�ve done a perfectly logical thing, and yet the behavior is mysteriously wrong, with no complaints from the compiler. (C++ produces more rational behavior in this situation.) Bugs like this could easily be buried and take a long time to discover.</para>
        <para>As a result, a good guideline for constructors is, �Do as little as possible to set the object into a good state, and if you can possibly avoid it, don�t call any methods.� The only safe methods to call inside a constructor are those that are <emphasis role="bold">final</emphasis> in the base class. (This also applies to <emphasis role="bold">private</emphasis> methods, which are automatically <emphasis role="bold">final</emphasis>.) These cannot be overridden and thus cannot produce this kind of surprise.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064637"/><anchor xreflabel="Designing
with inheritance" xml:id="_Toc375545341"/>Designing with inheritance</title>
      <para>Once you learn about polymorphism, it can seem that everything ought to be inherited because polymorphism is such a clever tool. This can burden your designs; in fact if you choose inheritance first when you�re using an existing class to make a new class, things can become needlessly complicated.</para>
      <para>A better approach is to choose composition first, when it�s not obvious which one you should use. Composition does not force a design into an inheritance hierarchy. But composition is also more flexible since it�s possible to dynamically choose a type (and thus behavior) when using composition, whereas inheritance requires an exact type to be known at compile-time. The following example illustrates this:</para>
      <para>//: c07:Transmogrify.java</para>
      <para>// Dynamically changing the behavior of</para>
      <para>// an object via composition.</para>
      <para> </para>
      <para>abstract class Actor {</para>
      <para>� abstract void act();</para>
      <para>}</para>
      <para> </para>
      <para>class HappyActor extends Actor {</para>
      <para>� public void act() { </para>
      <para>��� System.out.println(&quot;HappyActor&quot;); </para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class SadActor extends Actor {</para>
      <para>� public void act() { </para>
      <para>��� System.out.println(&quot;SadActor&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Stage {</para>
      <para>� Actor a = new HappyActor();</para>
      <para>� void change() { a = new SadActor(); }</para>
      <para>� void go() { a.act(); }</para>
      <para>}</para>
      <para> </para>
      <para>public class Transmogrify {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Stage s = new Stage();</para>
      <para>��� s.go(); // Prints &quot;HappyActor&quot;</para>
      <para>��� s.change();</para>
      <para>��� s.go(); // Prints &quot;SadActor&quot;</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>A <emphasis role="bold">Stage</emphasis> object contains a reference to an <emphasis role="bold">Actor</emphasis>, which is initialized to a <emphasis role="bold">HappyActor</emphasis> object. This means <emphasis role="bold">go( )</emphasis> produces a particular behavior. But since a reference can be rebound to a different object at run-time, a reference for a <emphasis role="bold">SadActor</emphasis> object can be substituted in <emphasis role="bold">a</emphasis> and then the behavior produced by <emphasis role="bold">go( )</emphasis> changes. Thus you gain dynamic flexibility at run-time. (This is also called the <emphasis role="italic">State Pattern.</emphasis> See <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com.</emphasis>) In contrast, you can�t decide to inherit differently at run-time; that must be completely determined at compile-time. </para>
      <para>A general guideline is �Use inheritance to express differences in behavior, and fields to express variations in state.� In the above example, both are used: two different classes are inherited to express the difference in the <emphasis role="bold">act( )</emphasis> method, and <emphasis role="bold">Stage</emphasis> uses composition to allow its state to be changed. In this case, that change in state happens to produce a change in behavior.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064638"/><anchor xreflabel="Pure
inheritance vs. extension" xml:id="_Toc375545342"/>Pure inheritance vs. extension</title>
        <para>When studying inheritance, it would seem that the cleanest way to create an inheritance hierarchy is to take the �pure� approach. That is, only methods that have been established in the base class or <emphasis role="bold">interface</emphasis> are to be overridden in the derived class, as seen in this diagram:</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="220" contentwidth="328" fileref="./TIJ2_files/image021.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image021.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>This can be termed a pure �is-a� relationship because the interface of a class establishes what it is. Inheritance guarantees that any derived class will have the interface of the base class and nothing less. If you follow the above diagram, derived classes will also have <emphasis role="italic">no more</emphasis> than the base class interface.</para>
        <para>This can be thought of as <emphasis role="italic">pure substitution</emphasis>, because derived class objects can be perfectly substituted for the base class, and you never need to know any extra information about the subclasses when you�re using them:</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="74" contentwidth="361" fileref="./TIJ2_files/image022.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image022.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>That is, the base class can receive any message you can send to the derived class because the two have exactly the same interface. All you need to do is upcast from the derived class and never look back to see what exact type of object you�re dealing with. Everything is handled through polymorphism.</para>
        <para>When you see it this way, it seems like a pure �is-a� relationship is the only sensible way to do things, and any other design indicates muddled thinking and is by definition broken. This too is a trap. As soon as you start thinking this way, you�ll turn around and discover that extending the interface (which, unfortunately, the keyword <emphasis role="bold">extends</emphasis> seems to encourage) is the perfect solution to a particular problem. This could be termed an �is-like-a� relationship because the derived class is <emphasis role="italic">like</emphasis> the base class�it has the same fundamental interface�but it has other features that require additional methods to implement:</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="273" contentwidth="228" fileref="./TIJ2_files/image023.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image023.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>While this is also a useful and sensible approach (depending on the situation) it has a drawback. The extended part of the interface in the derived class is not available from the base class, so once you upcast you can�t call the new methods:</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="97" contentwidth="325" fileref="./TIJ2_files/image024.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image024.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>If you�re not upcasting in this case, it won�t bother you, but often you�ll get into a situation in which you need to rediscover the exact type of the object so you can access the extended methods of that type. The following section shows how this is done.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064639"/><anchor xreflabel="Downcasting
and run-time 
type identification" xml:id="_Toc375545343"/>Downcasting and run-time   type identification</title>
        <para>Since you lose the specific type information via an <emphasis role="italic">upcast</emphasis> (moving up the inheritance hierarchy), it makes sense that to retrieve the type information�that is, to move back down the inheritance hierarchy�you use a <emphasis role="italic">downcast</emphasis>. However, you know an upcast is always safe; the base class cannot have a bigger interface than the derived class, therefore every message you send through the base class interface is guaranteed to be accepted. But with a downcast, you don�t really know that a shape (for example) is actually a circle. It could instead be a triangle or square or some other type.</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="247" contentwidth="232" fileref="./TIJ2_files/image025.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image025.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>To solve this problem there must be some way to guarantee that a downcast is correct, so you won�t accidentally cast to the wrong type and then send a message that the object can�t accept. This would be quite unsafe.</para>
        <para>In some languages (like C++) you must perform a special operation in order to get a type-safe downcast, but in Java <emphasis role="italic">every cast</emphasis> is checked! So even though it looks like you�re just performing an ordinary parenthesized cast, at run-time this cast is checked to ensure that it is in fact the type you think it is. If it isn�t, you get a <emphasis role="bold">ClassCastException</emphasis>. This act of checking types at run-time is called <emphasis role="italic">run-time type identification </emphasis>(RTTI). The following example demonstrates the behavior of RTTI:</para>
        <para>//: c07:RTTI.java</para>
        <para>// Downcasting &amp; Run-time Type</para>
        <para>// Identification (RTTI).</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Useful {</para>
        <para>� public void f() {}</para>
        <para>� public void g() {}</para>
        <para>}</para>
        <para> </para>
        <para>class MoreUseful extends Useful {</para>
        <para>� public void f() {}</para>
        <para>� public void g() {}</para>
        <para>� public void u() {}</para>
        <para>� public void v() {}</para>
        <para>� public void w() {}</para>
        <para>}</para>
        <para> </para>
        <para>public class RTTI {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Useful[] x = {</para>
        <para>����� new Useful(),</para>
        <para>����� new MoreUseful()</para>
        <para>��� };</para>
        <para>��� x[0].f();</para>
        <para>��� x[1].g();</para>
        <para>��� // Compile-time: method not found in Useful:</para>
        <para>��� //! x[1].u();</para>
        <para>��� ((MoreUseful)x[1]).u(); // Downcast/RTTI</para>
        <para>��� ((MoreUseful)x[0]).u(); // Exception thrown</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>As in the diagram, <emphasis role="bold">MoreUseful</emphasis> extends the interface of <emphasis role="bold">Useful</emphasis>. But since it�s inherited, it can also be upcast to a <emphasis role="bold">Useful</emphasis>. You can see this happening in the initialization of the array <emphasis role="bold">x</emphasis> in <emphasis role="bold">main( )</emphasis>. Since both objects in the array are of class <emphasis role="bold">Useful</emphasis>, you can send the <emphasis role="bold">f( )</emphasis> and <emphasis role="bold">g( )</emphasis> methods to both, and if you try to call <emphasis role="bold">u( )</emphasis> (which exists only in <emphasis role="bold">MoreUseful</emphasis>) you�ll get a compile-time error message.</para>
        <para>If you want to access the extended interface of a <emphasis role="bold">MoreUseful</emphasis> object, you can try to downcast. If it�s the correct type, it will be successful. Otherwise, you�ll get a <emphasis role="bold">ClassCastException</emphasis>. You don�t need to write any special code for this exception, since it indicates a programmer error that could happen anywhere in a program.</para>
        <para>There�s more to RTTI than a simple cast. For example, there�s a way to see what type you�re dealing with <emphasis role="italic">before</emphasis> you try to downcast it. All of Chapter 12 is devoted to the study of different aspects of Java run-time type identification.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064640"/><anchor xreflabel="Summary" xml:id="_Toc375545344"/>Summary</title>
      <para>Polymorphism means �different forms.� In object-oriented programming, you have the same face (the common interface in the base class) and different forms using that face: the different versions of the dynamically bound methods.</para>
      <para>You�ve seen in this chapter that it�s impossible to understand, or even create, an example of polymorphism without using data abstraction and inheritance. Polymorphism is a feature that cannot be viewed in isolation (like a <emphasis role="bold">switch</emphasis> statement can, for example), but instead works only in concert, as part of a �big picture� of class relationships. People are often confused by other, non-object-oriented features of Java, like method overloading, which are sometimes presented as object-oriented. Don�t be fooled: If it isn�t late binding, it isn�t polymorphism.</para>
      <para>To use polymorphism�and thus object-oriented techniques�effectively in your programs you must expand your view of programming to include not just members and messages of an individual class, but also the commonality among classes and their relationships with each other. Although this requires significant effort, it�s a worthy struggle, because the results are faster program development, better code organization, extensible programs, and easier code maintenance.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064641"/><anchor xreflabel="Exercises" xml:id="_Toc375545345"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Add a new method in the base class of <emphasis role="bold">Shapes.java</emphasis> that prints a message, but don�t override it in the derived classes. Explain what happens. Now override it in one of the derived classes but not the others, and see what happens. Finally, override it in all the derived classes.</para>
      <para>      76.         Add a new type of <emphasis role="bold">Shape</emphasis> to <emphasis role="bold">Shapes.java</emphasis> and verify in <emphasis role="bold">main( ) </emphasis>that polymorphism works for your new type as it does in the old types.</para>
      <para>      77.         Change <emphasis role="bold">Music3.java</emphasis> so that <emphasis role="bold">what( )</emphasis> becomes the root <emphasis role="bold">Object </emphasis>method <emphasis role="bold">toString( )</emphasis>. Try printing the <emphasis role="bold">Instrument</emphasis> objects using <emphasis role="bold">System.out.println( )</emphasis> (without any casting).</para>
      <para>      78.         Add a new type of <emphasis role="bold">Instrument</emphasis> to <emphasis role="bold">Music3.java</emphasis> and verify that polymorphism works for your new type.</para>
      <para>      79.         Modify <emphasis role="bold">Music3.java</emphasis> so that it randomly creates <emphasis role="bold">Instrument</emphasis> objects the way <emphasis role="bold">Shapes.java</emphasis> does.</para>
      <para>      80.         Create an inheritance hierarchy of <emphasis role="bold">Rodent</emphasis>: <emphasis role="bold">Mouse</emphasis>, <emphasis role="bold">Gerbil</emphasis>, <emphasis role="bold">Hamster</emphasis>, etc. In the base class, provide methods that are common to all <emphasis role="bold">Rodent</emphasis>s, and override these in the derived classes to perform different behaviors depending on the specific type of <emphasis role="bold">Rodent</emphasis>. Create an array of <emphasis role="bold">Rodent</emphasis>, fill it with different specific types of <emphasis role="bold">Rodent</emphasis>s, and call your base-class methods to see what happens.</para>
      <para>      81.         Modify Exercise 6 so that <emphasis role="bold">Rodent</emphasis> is an <emphasis role="bold">abstract</emphasis> class. Make the methods of <emphasis role="bold">Rodent</emphasis> abstract whenever possible.</para>
      <para>      82.         Create a class as <emphasis role="bold">abstract</emphasis> without including any <emphasis role="bold">abstract</emphasis> methods, and verify that you cannot create any instances of that class.</para>
      <para>      83.         Add class <emphasis role="bold">Pickle</emphasis> to <emphasis role="bold">Sandwich.java</emphasis>.</para>
      <para>      84.         Modify Exercise 6 so that it demonstrates the order of initialization of the base classes and derived classes. Now add member objects to both the base and derived classes, and show the order in which their initialization occurs during construction.</para>
      <para>      85.         Create a 3-level inheritance hierarchy. Each class in the hierarchy should have a <emphasis role="bold">finalize( )</emphasis> method, and it should properly call the base-class version of <emphasis role="bold">finalize( )</emphasis>. Demonstrate that your hierarchy works properly.</para>
      <para>      86.         Create a base class with two methods. In the first method, call the second method. Inherit a class and override the second method. Create an object of the derived class, upcast it to the base type, and call the first method. Explain what happens.</para>
      <para>      87.         Create a base class with an <emphasis role="bold">abstract</emphasis><emphasis role="bold">print( ) </emphasis>method that is overridden in a derived class. The overridden version of the method prints the value of an <emphasis role="bold">int </emphasis>variable defined in the derived class. At the point of definition of this variable, give it a nonzero value. In the base-class constructor, call this method. In <emphasis role="bold">main( )</emphasis>, create an object of the derived type, and then call its <emphasis role="bold">print( )</emphasis> method. Explain the results.</para>
      <para>      88.         Following the example in <emphasis role="bold">Transmogrify.java</emphasis>, create a <emphasis role="bold">Starship</emphasis> class containing an <emphasis role="bold">AlertStatus</emphasis> reference that can indicate three different states. Include methods to change the states.</para>
      <para>      89.         Create an <emphasis role="bold">abstract</emphasis> class with no methods. Derive a class and add a method. Create a <emphasis role="bold">static</emphasis> method that takes a reference to the base class, downcasts it to the derived class, and calls the method. In <emphasis role="bold">main( )</emphasis>, demonstrate that it works. Now put the <emphasis role="bold">abstract</emphasis> declaration for the method in the base class, thus eliminating the need for the downcast.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc375545346"/><anchor xreflabel="" xml:id="_Toc481064642"/><anchor xreflabel="" xml:id="_Toc477690728"/><anchor xreflabel="" xml:id="Chapter_8"/>8: Interfaces &amp; Inner Classes</title>
    <para>Interfaces and inner classes provide more sophisticated ways to organize and control the objects in your system.</para>
    <para>C++, for example, does not contain such mechanisms, although the clever programmer may simulate them. The fact that they exist in Java indicates that they were considered important enough to provide direct support through language keywords.</para>
    <para>In Chapter 7, you learned about the <emphasis role="bold">abstract</emphasis> keyword, which allows you to create one or more methods in a class that have no definitions�you provide part of the interface without providing a corresponding implementation, which is created by inheritors. The <emphasis role="bold">interface</emphasis> keyword produces a completely abstract class, one that provides no implementation at all. You�ll learn that the <emphasis role="bold">interface </emphasis>is more than just an abstract class taken to the extreme, since it allows you to perform a variation on C++�s �multiple inheritance,� by creating a class that can be upcast to more than one base type.</para>
    <para>At first, inner classes look like a simple code-hiding mechanism: you place classes inside other classes. You�ll learn, however, that the inner class does more than that�it knows about and can communicate with the surrounding class�and that the kind of code you can write with inner classes is more elegant and clear, although it is a new concept to most. It takes some time to become comfortable with design using inner classes.</para>
    <section>
      <title><anchor xreflabel="Interfaces" xml:id="_Toc481064643"/>Interfaces</title>
      <para>The <emphasis role="bold">interface</emphasis> keyword takes the <emphasis role="bold">abstract</emphasis><emphasis role="bold"/>concept one step further. You could think of it as a �pure� <emphasis role="bold">abstract</emphasis><emphasis role="bold"/>class. It allows the creator to establish the form for a class: method names, argument lists, and return types, but no method bodies. An <emphasis role="bold">interface</emphasis> can also contain fields, but these are implicitly <emphasis role="bold">static</emphasis> and <emphasis role="bold">final</emphasis>. An <emphasis role="bold">interface</emphasis> provides only a form, but no implementation.</para>
      <para>An <emphasis role="bold">interface</emphasis> says: �This is what all classes that <emphasis role="italic">implement</emphasis> this particular interface will look like.� Thus, any code that uses a particular <emphasis role="bold">interface</emphasis> knows what methods might be called for that <emphasis role="bold">interface</emphasis>, and that�s all. So the <emphasis role="bold">interface</emphasis> is used to establish a �protocol� between classes. (Some object-oriented programming languages have a keyword called <emphasis role="italic">protocol</emphasis> to do the same thing.)</para>
      <para>To create an <emphasis role="bold">interface</emphasis>, use the <emphasis role="bold">interface</emphasis> keyword instead of the <emphasis role="bold">class</emphasis> keyword. Like a class, you can add the <emphasis role="bold">public</emphasis> keyword before the <emphasis role="bold">interface </emphasis>keyword (but only if that <emphasis role="bold">interface</emphasis> is defined in a file of the same name) or leave it off to give �friendly� status so that it is only usable within the same package.</para>
      <para>To make a class that conforms to a particular <emphasis role="bold">interface</emphasis> (or group of <emphasis role="bold">interface</emphasis>s) use the <emphasis role="bold">implements</emphasis> keyword. You�re saying �The <emphasis role="bold">interface</emphasis> is what it looks like but now I�m going to say how it <emphasis role="italic">works</emphasis>.� Other than that, it looks like inheritance. The diagram for the instrument example shows this:</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="406" contentwidth="376" fileref="./TIJ2_files/image026.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image026.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>Once you�ve implemented an <emphasis role="bold">interface</emphasis>, that implementation becomes an ordinary class that can be extended in the regular way.</para>
      <para>You can choose to explicitly declare the method declarations in an <emphasis role="bold">interface</emphasis> as <emphasis role="bold">public</emphasis>. But they are <emphasis role="bold">public</emphasis> even if you don�t say it. So when you <emphasis role="bold">implement</emphasis> an <emphasis role="bold">interface</emphasis>, the methods from the <emphasis role="bold">interface</emphasis> must be defined as <emphasis role="bold">public</emphasis>. Otherwise they would default to �friendly,� and you�d be reducing the accessibility of a method during inheritance, which is not allowed by the Java compiler.</para>
      <para>You can see this in the modified version of the <emphasis role="bold">Instrument</emphasis> example. Note that every method in the <emphasis role="bold">interface</emphasis> is strictly a declaration, which is the only thing the compiler allows. In addition, none of the methods in <emphasis role="bold">Instrument</emphasis> are declared as <emphasis role="bold">public</emphasis>, but they�re automatically <emphasis role="bold">public</emphasis> anyway:</para>
      <para>//: c08:music5:Music5.java</para>
      <para>// Interfaces.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>interface Instrument {</para>
      <para>� // Compile-time constant:</para>
      <para>� int i = 5; // static &amp; final</para>
      <para>� // Cannot have method definitions:</para>
      <para>� void play(); // Automatically public</para>
      <para>� String what();</para>
      <para>� void adjust();</para>
      <para>}</para>
      <para> </para>
      <para>class Wind implements Instrument {</para>
      <para>� public void play() {</para>
      <para>��� System.out.println(&quot;Wind.play()&quot;);</para>
      <para>� }</para>
      <para>� public String what() { return &quot;Wind&quot;; }</para>
      <para>� public void adjust() {}</para>
      <para>}</para>
      <para> </para>
      <para>class Percussion implements Instrument {</para>
      <para>� public void play() {</para>
      <para>��� System.out.println(&quot;Percussion.play()&quot;);</para>
      <para>� }</para>
      <para>� public String what() { return &quot;Percussion&quot;; }</para>
      <para>� public void adjust() {}</para>
      <para>}</para>
      <para> </para>
      <para>class Stringed implements Instrument {</para>
      <para>� public void play() {</para>
      <para>��� System.out.println(&quot;Stringed.play()&quot;);</para>
      <para>� }</para>
      <para>� public String what() { return &quot;Stringed&quot;; }</para>
      <para>� public void adjust() {}</para>
      <para>}</para>
      <para> </para>
      <para>class Brass extends Wind {</para>
      <para>� public void play() {</para>
      <para>��� System.out.println(&quot;Brass.play()&quot;);</para>
      <para>� }</para>
      <para>� public void adjust() { </para>
      <para>��� System.out.println(&quot;Brass.adjust()&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Woodwind extends Wind {</para>
      <para>� public void play() {</para>
      <para>��� System.out.println(&quot;Woodwind.play()&quot;);</para>
      <para>� }</para>
      <para>� public String what() { return &quot;Woodwind&quot;; }</para>
      <para>}</para>
      <para> </para>
      <para>public class Music5 {</para>
      <para>� // Doesn&apos;t care about type, so new types</para>
      <para>� // added to the system still work right:</para>
      <para>� static void tune(Instrument i) {</para>
      <para>��� // ...</para>
      <para>��� i.play();</para>
      <para>� }</para>
      <para>� static void tuneAll(Instrument[] e) {</para>
      <para>��� for(int i = 0; i &lt; e.length; i++)</para>
      <para>����� tune(e[i]);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Instrument[] orchestra = new Instrument[5];</para>
      <para>��� int i = 0;</para>
      <para>��� // Upcasting during addition to the array:</para>
      <para>��� orchestra[i++] = new Wind();</para>
      <para>��� orchestra[i++] = new Percussion();</para>
      <para>��� orchestra[i++] = new Stringed();</para>
      <para>��� orchestra[i++] = new Brass();</para>
      <para>��� orchestra[i++] = new Woodwind();</para>
      <para>��� tuneAll(orchestra);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The rest of the code works the same. It doesn�t matter if you are upcasting to a �regular� class called <emphasis role="bold">Instrument</emphasis>, an <emphasis role="bold">abstract</emphasis> class called <emphasis role="bold">Instrument</emphasis>, or to an <emphasis role="bold">interface</emphasis> called <emphasis role="bold">Instrument</emphasis>. The behavior is the same. In fact, you can see in the <emphasis role="bold">tune( )</emphasis> method that there isn�t any evidence about whether <emphasis role="bold">Instrument</emphasis> is a �regular� class, an <emphasis role="bold">abstract</emphasis> class, or an <emphasis role="bold">interface</emphasis>. This is the intent: Each approach gives the programmer different control over the way objects are created and used.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064644"/><anchor xreflabel="�Multiple
inheritance� in Java" xml:id="_Toc375545336"/>�Multiple inheritance� in Java</title>
        <para>The <emphasis role="bold">interface</emphasis> isn�t simply a �more pure� form of <emphasis role="bold">abstract</emphasis> class. It has a higher purpose than that. Because an <emphasis role="bold">interface</emphasis> has no implementation at all�that is, there is no storage associated with an <emphasis role="bold">interface�</emphasis>there�s nothing to prevent many <emphasis role="bold">interface</emphasis>s from being combined. This is valuable because there are times when you need to say �An <emphasis role="bold">x</emphasis> is an <emphasis role="bold">a</emphasis><emphasis role="italic">and</emphasis> a <emphasis role="bold">b</emphasis><emphasis role="italic">and</emphasis> a <emphasis role="bold">c</emphasis>.� In C++, this act of combining multiple class interfaces is called <emphasis role="italic">multiple inheritance</emphasis>, and it carries some rather sticky baggage because each class can have an implementation. In Java, you can perform the same act, but only one of the classes can have an implementation, so the problems seen in C++ do not occur with Java when combining multiple interfaces:</para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="172" contentwidth="454" fileref="./TIJ2_files/image027.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image027.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>In a derived class, you aren�t forced to have a base class that is either an <emphasis role="bold">abstract</emphasis> or �concrete� (one with no <emphasis role="bold">abstract</emphasis> methods). If you <emphasis role="italic">do</emphasis> inherit from a non-<emphasis role="bold">interface</emphasis>,<emphasis role="bold"/>you can inherit from only one. All the rest of the base elements must be <emphasis role="bold">interface</emphasis>s. You place all the interface names after the <emphasis role="bold">implements </emphasis>keyword and separate them with commas. You can have as many <emphasis role="bold">interface</emphasis>s as you want�each one becomes an independent type that you can upcast to. The following example shows a concrete class combined with several <emphasis role="bold">interface</emphasis>s to produce a new class:</para>
        <para>//: c08:Adventure.java</para>
        <para>// Multiple interfaces.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>interface CanFight {</para>
        <para>� void fight();</para>
        <para>}</para>
        <para> </para>
        <para>interface CanSwim {</para>
        <para>� void swim();</para>
        <para>}</para>
        <para> </para>
        <para>interface CanFly {</para>
        <para>� void fly();</para>
        <para>}</para>
        <para> </para>
        <para>class ActionCharacter {</para>
        <para>� public void fight() {}</para>
        <para>}</para>
        <para> </para>
        <para>class Hero extends ActionCharacter </para>
        <para>��� implements CanFight, CanSwim, CanFly {</para>
        <para>� public void swim() {}</para>
        <para>� public void fly() {}</para>
        <para>}</para>
        <para> </para>
        <para>public class Adventure {</para>
        <para>� static void t(CanFight x) { x.fight(); }</para>
        <para>� static void u(CanSwim x) { x.swim(); }</para>
        <para>� static void v(CanFly x) { x.fly(); }</para>
        <para>� static void w(ActionCharacter x) { x.fight(); }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Hero h = new Hero();</para>
        <para>��� t(h); // Treat it as a CanFight</para>
        <para>��� u(h); // Treat it as a CanSwim</para>
        <para>��� v(h); // Treat it as a CanFly</para>
        <para>��� w(h); // Treat it as an ActionCharacter</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can see that <emphasis role="bold">Hero</emphasis> combines the concrete class <emphasis role="bold">ActionCharacter</emphasis> with the interfaces <emphasis role="bold">CanFight</emphasis>, <emphasis role="bold">CanSwim</emphasis>, and <emphasis role="bold">CanFly</emphasis>. When you combine a concrete class with interfaces this way, the concrete class must come first, then the interfaces. (The compiler gives an error otherwise.)</para>
        <para>Note that the signature for <emphasis role="bold">fight( )</emphasis> is the same in the <emphasis role="bold">interface CanFight</emphasis> and the class <emphasis role="bold">ActionCharacter</emphasis>, and that <emphasis role="bold">fight( )</emphasis> is <emphasis role="italic">not</emphasis> provided with a definition in <emphasis role="bold">Hero</emphasis>. The rule for an <emphasis role="bold">interface</emphasis> is that you can inherit from it (as you will see shortly), but then you�ve got another <emphasis role="bold">interface</emphasis>. If you want to create an object of the new type, it must be a class with all definitions provided. Even though <emphasis role="bold">Hero</emphasis> does not explicitly provide a definition for <emphasis role="bold">fight( )</emphasis>, the definition comes along with <emphasis role="bold">ActionCharacter</emphasis> so it is automatically provided and it�s possible to create objects of <emphasis role="bold">Hero</emphasis>.</para>
        <para>In class <emphasis role="bold">Adventure</emphasis>, you can see that there are four methods that take as arguments the various interfaces and the concrete class. When a <emphasis role="bold">Hero</emphasis> object is created, it can be passed to any of these methods, which means it is being upcast to each <emphasis role="bold">interface</emphasis> in turn. Because of the way interfaces are designed in Java, this works without a hitch and without any particular effort on the part of the programmer.</para>
        <para>Keep in mind that the core reason for interfaces is shown in the above example: to be able to upcast to more than one base type. However, a second reason for using interfaces is the same as using an <emphasis role="bold">abstract </emphasis>base class: to prevent the client programmer from making an object of this class and to establish that it is only an interface. This brings up a question: Should you use an <emphasis role="bold">interface</emphasis> or an <emphasis role="bold">abstract</emphasis> class? An <emphasis role="bold">interface</emphasis> gives you the benefits of an <emphasis role="bold">abstract</emphasis> class <emphasis role="italic">and</emphasis> the benefits of an <emphasis role="bold">interface</emphasis>, so if it�s possible to create your base class without any method definitions or member variables you should always prefer <emphasis role="bold">interface</emphasis>s to <emphasis role="bold">abstract</emphasis> classes. In fact, if you know something is going to be a base class, your first choice should be to make it an <emphasis role="bold">interface</emphasis>, and only if you�re forced to have method definitions or member variables should you change to an <emphasis role="bold">abstract</emphasis> class, or if necessary a concrete class.</para>
        <section>
          <title>Name collisions when combining interfaces</title>
          <para>You can encounter a small pitfall when implementing multiple interfaces. In the above example, both <emphasis role="bold">CanFight</emphasis> and <emphasis role="bold">ActionCharacter</emphasis> have an identical <emphasis role="bold">void fight( )</emphasis> method. This is no problem because the method is identical in both cases, but what if it�s not? Here�s an example:</para>
          <para>//: c08:InterfaceCollision.java</para>
          <para> </para>
          <para>interface I1 { void f(); }</para>
          <para>interface I2 { int f(int i); }</para>
          <para>interface I3 { int f(); }</para>
          <para>class C { public int f() { return 1; } }</para>
          <para> </para>
          <para>class C2 implements I1, I2 {</para>
          <para>� public void f() {}</para>
          <para>� public int f(int i) { return 1; } // overloaded</para>
          <para>}</para>
          <para> </para>
          <para>class C3 extends C implements I2 {</para>
          <para>� public int f(int i) { return 1; } // overloaded</para>
          <para>}</para>
          <para> </para>
          <para>class C4 extends C implements I3 {</para>
          <para>� // Identical, no problem:</para>
          <para>� public int f() { return 1; } </para>
          <para>}</para>
          <para> </para>
          <para>// Methods differ only by return type:</para>
          <para>//! class C5 extends C implements I1 {}</para>
          <para>//! interface I4 extends I1, I3 {} ///:~</para>
          <para> </para>
          <para>The difficulty occurs because overriding, implementation, and overloading get unpleasantly mixed together, and overloaded functions cannot differ only by return type. When the last two lines are uncommented, the error messages say it all:</para>
          <para>InterfaceCollision.java:23: f() in C cannot </para>
          <para>implement f() in I1; attempting to use </para>
          <para>incompatible return type</para>
          <para>found�� : int</para>
          <para>required: void</para>
          <para>InterfaceCollision.java:24: interfaces I3 and I1 are incompatible; both define f</para>
          <para>(), but with different return type</para>
          <para> </para>
          <para>Using the same method names in different interfaces that are intended to be combined generally causes confusion in the readability of the code, as well. Strive to avoid it.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064645"/><anchor xreflabel="Extending
an interface 
with inheritance" xml:id="_Toc375545337"/>Extending an interface   with inheritance</title>
        <para>You can easily add new method declarations to an <emphasis role="bold">interface</emphasis> using inheritance, and you can also combine several <emphasis role="bold">interface</emphasis>s into a new <emphasis role="bold">interface</emphasis> with inheritance. In both cases you get a new <emphasis role="bold">interface</emphasis>, as seen in this example:</para>
        <para>//: c08:HorrorShow.java</para>
        <para>// Extending an interface with inheritance.</para>
        <para> </para>
        <para>interface Monster {</para>
        <para>� void menace();</para>
        <para>}</para>
        <para> </para>
        <para>interface DangerousMonster extends Monster {</para>
        <para>� void destroy();</para>
        <para>}</para>
        <para> </para>
        <para>interface Lethal {</para>
        <para>� void kill();</para>
        <para>}</para>
        <para> </para>
        <para>class DragonZilla implements DangerousMonster {</para>
        <para>� public void menace() {}</para>
        <para>� public void destroy() {}</para>
        <para>}</para>
        <para> </para>
        <para>interface Vampire </para>
        <para>��� extends DangerousMonster, Lethal {</para>
        <para>� void drinkBlood();</para>
        <para>}</para>
        <para> </para>
        <para>class HorrorShow {</para>
        <para>� static void u(Monster b) { b.menace(); }</para>
        <para>� static void v(DangerousMonster d) {</para>
        <para>��� d.menace();</para>
        <para>��� d.destroy();</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� DragonZilla if2 = new DragonZilla();</para>
        <para>��� u(if2);</para>
        <para>��� v(if2);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">DangerousMonster</emphasis> is a simple extension to <emphasis role="bold">Monster</emphasis> that produces a new <emphasis role="bold">interface</emphasis>. This is implemented in <emphasis role="bold">DragonZilla</emphasis>.</para>
        <para>The syntax used in <emphasis role="bold">Vampire</emphasis> works <emphasis role="italic">only</emphasis> when inheriting interfaces. Normally, you can use <emphasis role="bold">extends</emphasis> with only a single class, but since an <emphasis role="bold">interface</emphasis> can be made from multiple other interfaces, <emphasis role="bold">extends</emphasis> can refer to multiple base interfaces when building a new <emphasis role="bold">interface</emphasis>. As you can see, the <emphasis role="bold">interface</emphasis> names are simply separated with commas.</para>
      </section>
      <section>
        <title><anchor xreflabel="Grouping constants" xml:id="_Toc481064646"/>Grouping constants</title>
        <para>Because any fields you put into an <emphasis role="bold">interface</emphasis> are automatically <emphasis role="bold">static</emphasis> and <emphasis role="bold">final</emphasis>, the <emphasis role="bold">interface</emphasis> is a convenient tool for creating groups of constant values, much as you would with an <emphasis role="bold">enum</emphasis> in C or C++. For example:</para>
        <para>//: c08:Months.java</para>
        <para>// Using interfaces to create groups of constants.</para>
        <para>package c08;</para>
        <para> </para>
        <para>public interface Months {</para>
        <para>� int</para>
        <para>��� JANUARY = 1, FEBRUARY = 2, MARCH = 3, </para>
        <para>��� APRIL = 4, MAY = 5, JUNE = 6, JULY = 7, </para>
        <para>��� AUGUST = 8, SEPTEMBER = 9, OCTOBER = 10,</para>
        <para>��� NOVEMBER = 11, DECEMBER = 12;</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Notice the Java style of using all uppercase letters (with underscores to separate multiple words in a single identifier) for <emphasis role="bold">static</emphasis><emphasis role="bold">final</emphasis>s that have constant initializers.</para>
        <para>The fields in an <emphasis role="bold">interface </emphasis>are automatically <emphasis role="bold">public</emphasis>, so it�s unnecessary to specify that.</para>
        <para>Now you can use the constants from outside the package by importing <emphasis role="bold">c08.*</emphasis> or <emphasis role="bold">c08.Months</emphasis> just as you would with any other package, and referencing the values with expressions like <emphasis role="bold">Months.JANUARY</emphasis>. Of course, what you get is just an <emphasis role="bold">int</emphasis>, so there isn�t the extra type safety that C++�s <emphasis role="bold">enum</emphasis> has, but this (commonly used) technique is certainly an improvement over hard-coding numbers into your programs. (That approach is often referred to as using �magic numbers� and it produces very difficult-to-maintain code.)</para>
        <para>If you do want extra type safety, you can build a class like this<anchor xreflabel="[38]" xml:id="_ftnref38"/>[38]:</para>
        <para>//: c08:Month2.java</para>
        <para>// A more robust enumeration system.</para>
        <para>package c08;</para>
        <para> </para>
        <para>public final class Month2 {</para>
        <para>� private String name;</para>
        <para>� private Month2(String nm) { name = nm; }</para>
        <para>� public String toString() { return name; }</para>
        <para>� public final static Month2</para>
        <para>��� JAN = new Month2(&quot;January&quot;), </para>
        <para>��� FEB = new Month2(&quot;February&quot;),</para>
        <para>��� MAR = new Month2(&quot;March&quot;),</para>
        <para>��� APR = new Month2(&quot;April&quot;),</para>
        <para>��� MAY = new Month2(&quot;May&quot;),</para>
        <para>��� JUN = new Month2(&quot;June&quot;),</para>
        <para>��� JUL = new Month2(&quot;July&quot;),</para>
        <para>��� AUG = new Month2(&quot;August&quot;),</para>
        <para>��� SEP = new Month2(&quot;September&quot;),</para>
        <para>��� OCT = new Month2(&quot;October&quot;),</para>
        <para>��� NOV = new Month2(&quot;November&quot;),</para>
        <para>��� DEC = new Month2(&quot;December&quot;);</para>
        <para>� public final static Month2[] month =� {</para>
        <para>��� JAN, JAN, FEB, MAR, APR, MAY, JUN,</para>
        <para>��� JUL, AUG, SEP, OCT, NOV, DEC</para>
        <para>� };</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Month2 m = Month2.JAN;</para>
        <para>��� System.out.println(m);</para>
        <para>��� m = Month2.month[12];</para>
        <para>��� System.out.println(m);</para>
        <para>��� System.out.println(m == Month2.DEC);</para>
        <para>��� System.out.println(m.equals(Month2.DEC));</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The class is called <emphasis role="bold">Month2</emphasis>, since there�s already a <emphasis role="bold">Month</emphasis> in the standard Java library. It�s a <emphasis role="bold">final</emphasis> class with a <emphasis role="bold">private</emphasis> constructor so no one can inherit from it or make any instances of it. The only instances are the <emphasis role="bold">final static</emphasis> ones created in the class itself: <emphasis role="bold">JAN</emphasis>, <emphasis role="bold">FEB</emphasis>, <emphasis role="bold">MAR</emphasis>, etc. These objects are also used in the array <emphasis role="bold">month</emphasis>, which lets you choose months by number instead of by name. (Notice the extra <emphasis role="bold">JAN</emphasis> in the array to provide an offset by one, so that December is month 12.) In <emphasis role="bold">main( )</emphasis> you can see the type safety: <emphasis role="bold">m</emphasis> is a <emphasis role="bold">Month2</emphasis> object so it can be assigned only to a <emphasis role="bold">Month2</emphasis>. The previous example <emphasis role="bold">Months.java </emphasis>provided only <emphasis role="bold">int</emphasis> values, so an <emphasis role="bold">int</emphasis> variable intended to represent a month could actually be given any integer value, which wasn�t very safe.</para>
        <para>This approach also allows you to use <emphasis role="bold">==</emphasis> or <emphasis role="bold">equals( )</emphasis> interchangeably, as shown at the end of <emphasis role="bold">main( )</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="Initializing fields in interfaces" xml:id="_Toc481064647"/>Initializing fields in interfaces</title>
        <para>Fields defined in interfaces are automatically <emphasis role="bold">static</emphasis> and <emphasis role="bold">final</emphasis>. These cannot be �blank finals,� but they can be initialized with nonconstant expressions. For example:</para>
        <para>//: c08:RandVals.java</para>
        <para>// Initializing interface fields with </para>
        <para>// non-constant initializers.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public interface RandVals {</para>
        <para>� int rint = (int)(Math.random() * 10);</para>
        <para>� long rlong = (long)(Math.random() * 10);</para>
        <para>� float rfloat = (float)(Math.random() * 10);</para>
        <para>� double rdouble = Math.random() * 10;</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Since the fields are <emphasis role="bold">static</emphasis>, they are initialized when the class is first loaded, which happens when any of the fields are accessed for the first time. Here�s a simple test:</para>
        <para>//: c08:TestRandVals.java</para>
        <para> </para>
        <para>public class TestRandVals {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� System.out.println(RandVals.rint);</para>
        <para>��� System.out.println(RandVals.rlong);</para>
        <para>��� System.out.println(RandVals.rfloat);</para>
        <para>��� System.out.println(RandVals.rdouble);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The fields, of course, are not part of the interface but instead are stored in the <emphasis role="bold">static</emphasis> storage area for that interface.</para>
      </section>
      <section>
        <title><anchor xreflabel="Nesting interfaces" xml:id="_Toc481064648"/>Nesting interfaces</title>
        <para><anchor xreflabel="[39]" xml:id="_ftnref39"/>[39]Interfaces may be nested within classes and within other interfaces. This reveals a number of very interesting features:</para>
        <para>//: c08:NestingInterfaces.java</para>
        <para> </para>
        <para>class A {</para>
        <para>� interface B {</para>
        <para>��� void f();</para>
        <para>� }</para>
        <para>� public class BImp implements B {</para>
        <para>��� public void f() {}</para>
        <para>� }</para>
        <para>� private class BImp2 implements B {</para>
        <para>��� public void f() {}</para>
        <para>� }</para>
        <para>� public interface C {</para>
        <para>��� void f();</para>
        <para>� }</para>
        <para>� class CImp implements C {</para>
        <para>��� public void f() {}</para>
        <para>� }</para>
        <para>� private class CImp2 implements C {</para>
        <para>��� public void f() {}</para>
        <para>� }</para>
        <para>� private interface D {</para>
        <para>��� void f();</para>
        <para>� }</para>
        <para>� private class DImp implements D {</para>
        <para>��� public void f() {}</para>
        <para>� }</para>
        <para>� public class DImp2 implements D {</para>
        <para>��� public void f() {}</para>
        <para>� }</para>
        <para>� public D getD() { return new DImp2(); }</para>
        <para>� private D dRef;</para>
        <para>� public void receiveD(D d) { </para>
        <para>��� dRef = d; </para>
        <para>��� dRef.f();</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>interface E {</para>
        <para>� interface G {</para>
        <para>��� void f();</para>
        <para>� }</para>
        <para>� // Redundant &quot;public&quot;:</para>
        <para>� public interface H {</para>
        <para>��� void f();</para>
        <para>� }</para>
        <para>� void g();</para>
        <para>� // Cannot be private within an interface:</para>
        <para>� //! private interface I {}</para>
        <para>}</para>
        <para> </para>
        <para>public class NestingInterfaces {</para>
        <para>� public class BImp implements A.B {</para>
        <para>��� public void f() {}</para>
        <para>� }</para>
        <para>� class CImp implements A.C {</para>
        <para>��� public void f() {}</para>
        <para>� }</para>
        <para>� // Cannot implement a private interface except</para>
        <para>� // within that interface&apos;s defining class:</para>
        <para>� //! class DImp implements A.D {</para>
        <para>� //!� public void f() {}</para>
        <para>� //! }</para>
        <para>� class EImp implements E {</para>
        <para>��� public void g() {}</para>
        <para>� }</para>
        <para>� class EGImp implements E.G {</para>
        <para>��� public void f() {}</para>
        <para>� }</para>
        <para>� class EImp2 implements E {</para>
        <para>��� public void g() {}</para>
        <para>��� class EG implements E.G {</para>
        <para>����� public void f() {}</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� A a = new A();</para>
        <para>��� // Can&apos;t access A.D:</para>
        <para>��� //! A.D ad = a.getD();</para>
        <para>��� // Doesn&apos;t return anything but A.D:</para>
        <para>��� //! A.DImp2 di2 = a.getD();</para>
        <para>��� // Cannot access a member of the interface:</para>
        <para>��� //! a.getD().f();</para>
        <para>��� // Only another A can do anything with getD():</para>
        <para>��� A a2 = new A();</para>
        <para>��� a2.receiveD(a.getD());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The syntax for nesting an interface within a class is reasonably obvious, and just like non-nested interfaces these can have <emphasis role="bold">public</emphasis> or �friendly� visibility. You can also see that both <emphasis role="bold">public</emphasis> and �friendly� nested interfaces can be implemented as a <emphasis role="bold">public</emphasis>, �friendly,� and <emphasis role="bold">private</emphasis> nested classes.</para>
        <para>As a new twist, interfaces can also be <emphasis role="bold">private</emphasis> as seen in <emphasis role="bold">A.D</emphasis> (the same qualification syntax is used for nested interfaces as for nested classes). What good is a <emphasis role="bold">private</emphasis> nested interface? You might guess that it can only be implemented as a <emphasis role="bold">private</emphasis> nested class as in <emphasis role="bold">DImp</emphasis>, but <emphasis role="bold">A.DImp2</emphasis> shows that it can also be implemented as a <emphasis role="bold">public</emphasis> class. However, <emphasis role="bold">A.DImp2</emphasis> can only be used as itself. You are not allowed to mention the fact that it implements the <emphasis role="bold">private</emphasis> interface, so implementing a <emphasis role="bold">private</emphasis> interface is a way to force the definition of the methods in that interface without adding any type information (that is, without allowing any upcasting).</para>
        <para>The method <emphasis role="bold">getD( )</emphasis> produces a further quandary concerning the <emphasis role="bold">private</emphasis> interface: it�s a <emphasis role="bold">public</emphasis> method that returns a reference to a <emphasis role="bold">private</emphasis> interface. What can you do with the return value of this method? In <emphasis role="bold">main( )</emphasis>, you can see several attempts to use the return value, all of which fail. The only thing that works is if the return value is handed to an object that has permission to use it�in this case, another <emphasis role="bold">A</emphasis>, via the <emphasis role="bold">received( )</emphasis> method.</para>
        <para>Interface <emphasis role="bold">E</emphasis> shows that interfaces can be nested within each other. However, the rules about interfaces�in particular, that all interface elements must be <emphasis role="bold">public</emphasis>�are strictly enforced here, so an interface nested within another interface is automatically <emphasis role="bold">public</emphasis> and cannot be made <emphasis role="bold">private</emphasis>.</para>
        <para><emphasis role="bold">NestingInterfaces</emphasis> shows the various ways that nested interfaces can be implemented. In particular, notice that when you implement an interface, you are not required to implement any interfaces nested within. Also, <emphasis role="bold">private</emphasis> interfaces cannot be implemented outside of their defining classes.</para>
        <para>Initially, these features may seem like they are added strictly for syntactic consistency, but I generally find that once you know about a feature, you often discover places where it is useful.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Inner classes" xml:id="_Toc481064649"/>Inner classes</title>
      <para>It�s possible to place a class definition within another class definition. This is called an <emphasis role="italic">inner class</emphasis>. The inner class is a valuable feature because it allows you to group classes that logically belong together and to control the visibility of one within the other. However, it�s important to understand that inner classes are distinctly different from composition.</para>
      <para>Often, while you�re learning about them, the need for inner classes isn�t immediately obvious. At the end of this section, after all of the syntax and semantics of inner classes have been described, you�ll find examples that should make clear the benefits of inner classes.</para>
      <para>You create an inner class just as you�d expect�by placing the class definition inside a surrounding class:</para>
      <para>//: c08:Parcel1.java</para>
      <para>// Creating inner classes.</para>
      <para> </para>
      <para>public class Parcel1 {</para>
      <para>� class Contents {</para>
      <para>��� private int i = 11;</para>
      <para>��� public int value() { return i; }</para>
      <para>� }</para>
      <para>� class Destination {</para>
      <para>��� private String label;</para>
      <para>��� Destination(String whereTo) {</para>
      <para>����� label = whereTo;</para>
      <para>��� }</para>
      <para>��� String readLabel() { return label; }</para>
      <para>� }</para>
      <para>� // Using inner classes looks just like</para>
      <para>� // using any other class, within Parcel1:</para>
      <para>� public void ship(String dest) {</para>
      <para>��� Contents c = new Contents();</para>
      <para>��� Destination d = new Destination(dest);</para>
      <para>��� System.out.println(d.readLabel());</para>
      <para>� }� </para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Parcel1 p = new Parcel1();</para>
      <para>��� p.ship(&quot;Tanzania&quot;);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The inner classes, when used inside <emphasis role="bold">ship( )</emphasis>, look just like the use of any other classes. Here, the only practical difference is that the names are nested within <emphasis role="bold">Parcel1</emphasis>. You�ll see in a while that this isn�t the only difference.</para>
      <para>More typically, an outer class will have a method that returns a reference to an inner class, like this:</para>
      <para>//: c08:Parcel2.java</para>
      <para>// Returning a reference to an inner class.</para>
      <para> </para>
      <para>public class Parcel2 {</para>
      <para>� class Contents {</para>
      <para>��� private int i = 11;</para>
      <para>��� public int value() { return i; }</para>
      <para>� }</para>
      <para>� class Destination {</para>
      <para>��� private String label;</para>
      <para>��� Destination(String whereTo) {</para>
      <para>����� label = whereTo;</para>
      <para>��� }</para>
      <para>��� String readLabel() { return label; }</para>
      <para>� }</para>
      <para>� public Destination to(String s) {</para>
      <para>��� return new Destination(s);</para>
      <para>� }</para>
      <para>� public Contents cont() { </para>
      <para>��� return new Contents(); </para>
      <para>� }</para>
      <para>� public void ship(String dest) {</para>
      <para>��� Contents c = cont();</para>
      <para>��� Destination d = to(dest);</para>
      <para>��� System.out.println(d.readLabel());</para>
      <para>� }� </para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Parcel2 p = new Parcel2();</para>
      <para>��� p.ship(&quot;Tanzania&quot;);</para>
      <para>��� Parcel2 q = new Parcel2();</para>
      <para>��� // Defining references to inner classes:</para>
      <para>��� Parcel2.Contents c = q.cont();</para>
      <para>��� Parcel2.Destination d = q.to(&quot;Borneo&quot;);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>If you want to make an object of the inner class anywhere except from within a non-<emphasis role="bold">static</emphasis> method of the outer class, you must specify the type of that object as <emphasis role="italic">OuterClassName.InnerClassName</emphasis>, as seen in <emphasis role="bold">main( )</emphasis>.</para>
      <section>
        <title><anchor xreflabel="Inner classes and upcasting" xml:id="_Toc481064650"/>Inner classes and upcasting</title>
        <para>So far, inner classes don�t seem that dramatic. After all, if it�s hiding you�re after, Java already has a perfectly good hiding mechanism�just allow the class to be �friendly� (visible only within a package) rather than creating it as an inner class.</para>
        <para>However, inner classes really come into their own when you start upcasting to a base class, and in particular to an <emphasis role="bold">interface</emphasis>. (The effect of producing an interface reference from an object that implements it is essentially the same as upcasting to a base class.) That�s because the inner class�the implementation of the <emphasis role="bold">interface</emphasis>�can then be completely unseen and unavailable to anyone, which is convenient for hiding the implementation. All you get back is a reference to the base class or the <emphasis role="bold">interface</emphasis>. </para>
        <para>First, the common interfaces will be defined in their own files so they can be used in all the examples:</para>
        <para>//: c08:Destination.java</para>
        <para>public interface Destination {</para>
        <para>� String readLabel();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>//: c08:Contents.java</para>
        <para>public interface Contents {</para>
        <para>� int value();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Now <emphasis role="bold">Contents</emphasis> and <emphasis role="bold">Destination</emphasis> represent interfaces available to the client programmer. (The <emphasis role="bold">interface</emphasis>, remember, automatically makes all of its members <emphasis role="bold">public</emphasis>.) </para>
        <para>When you get back a reference to the base class or the <emphasis role="bold">interface</emphasis>, it�s possible that you can�t even find out the exact type, as shown here:</para>
        <para>//: c08:Parcel3.java</para>
        <para>// Returning a reference to an inner class.</para>
        <para> </para>
        <para>public class Parcel3 {</para>
        <para>� private class PContents implements Contents {</para>
        <para>��� private int i = 11;</para>
        <para>��� public int value() { return i; }</para>
        <para>� }</para>
        <para>� protected class PDestination</para>
        <para>����� implements Destination {</para>
        <para>��� private String label;</para>
        <para>��� private PDestination(String whereTo) {</para>
        <para>����� label = whereTo;</para>
        <para>��� }</para>
        <para>��� public String readLabel() { return label; }</para>
        <para>� }</para>
        <para>� public Destination dest(String s) {</para>
        <para>��� return new PDestination(s);</para>
        <para>� }</para>
        <para>� public Contents cont() { </para>
        <para>��� return new PContents(); </para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Test {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Parcel3 p = new Parcel3();</para>
        <para>��� Contents c = p.cont();</para>
        <para>��� Destination d = p.dest(&quot;Tanzania&quot;);</para>
        <para>��� // Illegal -- can&apos;t access private class:</para>
        <para>��� //! Parcel3.PContents pc = p.new PContents();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Note that since <emphasis role="bold">main( ) </emphasis>is in <emphasis role="bold">Test</emphasis>, when you want to run this program you don�t execute <emphasis role="bold">Parcel3</emphasis>, but instead:</para>
        <para>java Test</para>
        <para> </para>
        <para>In the example, <emphasis role="bold">main( ) </emphasis>must be in a separate class in order to demonstrate the privateness of the inner class <emphasis role="bold">PContents</emphasis>.</para>
        <para>In <emphasis role="bold">Parcel3</emphasis>, something new has been added: the inner class <emphasis role="bold">PContents</emphasis> is <emphasis role="bold">private </emphasis>so no one but <emphasis role="bold">Parcel3</emphasis> can access it. <emphasis role="bold">PDestination</emphasis> is <emphasis role="bold">protected</emphasis>, so no one but <emphasis role="bold">Parcel3</emphasis>, classes in the <emphasis role="bold">Parcel3</emphasis> package (since <emphasis role="bold">protected</emphasis> also gives package access�that is, <emphasis role="bold">protected</emphasis> is also �friendly�), and the inheritors of <emphasis role="bold">Parcel3 </emphasis>can access <emphasis role="bold">PDestination</emphasis>. This means that the client programmer has restricted knowledge and access to these members. In fact, you can�t even downcast to a <emphasis role="bold">private</emphasis> inner class (or a <emphasis role="bold">protected</emphasis> inner class unless you�re an inheritor), because you can�t access the name, as you can see in <emphasis role="bold">class Test</emphasis>. Thus, the <emphasis role="bold">private</emphasis> inner class provides a way for the class designer to completely prevent any type-coding dependencies and to completely hide details about implementation. In addition, extension of an <emphasis role="bold">interface</emphasis> is useless from the client programmer�s perspective since the client programmer cannot access any additional methods that aren�t part of the <emphasis role="bold">public</emphasis><emphasis role="bold">interface</emphasis> class. This also provides an opportunity for the Java compiler to generate more efficient code.</para>
        <para>Normal (non-inner) classes cannot be made <emphasis role="bold">private</emphasis> or <emphasis role="bold">protected�</emphasis>only <emphasis role="bold">public</emphasis> or �friendly.�</para>
      </section>
      <section>
        <title><anchor xreflabel="Inner classes 
in methods and scopes" xml:id="_Toc481064651"/>Inner classes   in methods and scopes</title>
        <para>What you�ve seen so far encompasses the typical use for inner classes. In general, the code that you�ll write and read involving inner classes will be �plain� inner classes that are simple and easy to understand. However, the design for inner classes is quite complete and there are a number of other, more obscure, ways that you can use them if you choose: inner classes can be created within a method or even an arbitrary scope. There are two reasons for doing this:</para>
        <para>As shown previously, you�re implementing an interface of some kind so that you can create and return a reference.</para>
        <para>43.      You�re solving a complicated problem and you want to create a class to aid in your solution, but you don�t want it publicly available.</para>
        <para>In the following examples, the previous code will be modified to use: </para>
        <para>A class defined within a method </para>
        <para>44.      A class defined within a scope inside a method</para>
        <para>45.      An anonymous class implementing an interface</para>
        <para>46.      An anonymous class extending a class that has a nondefault constructor</para>
        <para>47.      An anonymous class that performs field initialization</para>
        <para>48.      An anonymous class that performs construction using instance initialization (anonymous inner classes cannot have constructors)</para>
        <para>Although it�s an ordinary class with an implementation, <emphasis role="bold">Wrapping</emphasis> is also being used as a common �interface� to its derived classes:</para>
        <para>//: c08:Wrapping.java</para>
        <para>public class Wrapping {</para>
        <para>� private int i;</para>
        <para>� public Wrapping(int x) { i = x; }</para>
        <para>� public int value() { return i; }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You�ll notice above that <emphasis role="bold">Wrapping</emphasis> has a constructor that requires an argument, to make things a bit more interesting.</para>
        <para>The first example shows the creation of an entire class within the scope of a method (instead of the scope of another class):</para>
        <para>//: c08:Parcel4.java</para>
        <para>// Nesting a class within a method.</para>
        <para> </para>
        <para>public class Parcel4 {</para>
        <para>� public Destination dest(String s) {</para>
        <para>��� class PDestination</para>
        <para>������� implements Destination {</para>
        <para>����� private String label;</para>
        <para>����� private PDestination(String whereTo) {</para>
        <para>������� label = whereTo;</para>
        <para>����� }</para>
        <para>����� public String readLabel() { return label; }</para>
        <para>��� }</para>
        <para>��� return new PDestination(s);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Parcel4 p = new Parcel4();</para>
        <para>��� Destination d = p.dest(&quot;Tanzania&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The class <emphasis role="bold">PDestination</emphasis> is part of <emphasis role="bold">dest( )</emphasis> rather than being part of <emphasis role="bold">Parcel4</emphasis>. (Also notice that you could use the class identifier <emphasis role="bold">PDestination </emphasis>for an inner class inside each class in the same subdirectory without a name clash.) Therefore, <emphasis role="bold">PDestination </emphasis>cannot be accessed outside of <emphasis role="bold">dest( )</emphasis>.<emphasis role="bold"/>Notice the upcasting that occurs in the return statement�nothing comes out of <emphasis role="bold">dest( )</emphasis> except a reference to <emphasis role="bold">Destination</emphasis>, the base class. Of course, the fact that the name of the class <emphasis role="bold">PDestination</emphasis> is placed inside <emphasis role="bold">dest( )</emphasis> doesn�t mean that <emphasis role="bold">PDestination</emphasis> is not a valid object once <emphasis role="bold">dest( )</emphasis> returns.</para>
        <para>The next example shows how you can nest an inner class within any arbitrary scope:</para>
        <para>//: c08:Parcel5.java</para>
        <para>// Nesting a class within a scope.</para>
        <para> </para>
        <para>public class Parcel5 {</para>
        <para>� private void internalTracking(boolean b) {</para>
        <para>��� if(b) {</para>
        <para>����� class TrackingSlip {</para>
        <para>������� private String id;</para>
        <para>������� TrackingSlip(String s) {</para>
        <para>��������� id = s;</para>
        <para>������� }</para>
        <para>������� String getSlip() { return id; }</para>
        <para>����� }</para>
        <para>����� TrackingSlip ts = new TrackingSlip(&quot;slip&quot;);</para>
        <para>����� String s = ts.getSlip();</para>
        <para>��� }</para>
        <para>��� // Can&apos;t use it here! Out of scope:</para>
        <para>��� //! TrackingSlip ts = new TrackingSlip(&quot;x&quot;);</para>
        <para>� }</para>
        <para>� public void track() { internalTracking(true); }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Parcel5 p = new Parcel5();</para>
        <para>��� p.track();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The class <emphasis role="bold">TrackingSlip</emphasis> is nested inside the scope of an <emphasis role="bold">if</emphasis> statement. This does not mean that the class is conditionally created�it gets compiled along with everything else. However, it�s not available outside the scope in which it is defined.<emphasis role="bold"/>Other than that, it looks just like an ordinary class.</para>
      </section>
      <section>
        <title><anchor xreflabel="Anonymous inner classes" xml:id="_Toc481064652"/>Anonymous inner classes</title>
        <para>The next example looks a little strange:</para>
        <para>//: c08:Parcel6.java</para>
        <para>// A method that returns an anonymous inner class.</para>
        <para> </para>
        <para>public class Parcel6 {</para>
        <para>� public Contents cont() {</para>
        <para>��� return new Contents() {</para>
        <para>����� private int i = 11;</para>
        <para>����� public int value() { return i; }</para>
        <para>��� }; // Semicolon required in this case</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Parcel6 p = new Parcel6();</para>
        <para>��� Contents c = p.cont();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">cont( )</emphasis> method combines the creation of the return value with the definition of the class that represents that return value! In addition, the class is anonymous�it has no name. To make matters a bit worse, it looks like you�re starting out to create a <emphasis role="bold">Contents</emphasis> object:</para>
        <para>return new Contents()</para>
        <para> </para>
        <para>But then, before you get to the semicolon, you say, �But wait, I think I�ll slip in a class definition�:</para>
        <para>return new Contents() {</para>
        <para>� private int i = 11;</para>
        <para>� public int value() { return i; }</para>
        <para>};</para>
        <para> </para>
        <para>What this strange syntax means is: �Create an object of an anonymous class that�s inherited from <emphasis role="bold">Contents</emphasis>.� The reference returned by the <emphasis role="bold">new</emphasis> expression is automatically upcast to a <emphasis role="bold">Contents</emphasis> reference. The anonymous inner-class syntax is a shorthand for:</para>
        <para>class MyContents implements Contents {</para>
        <para>� private int i = 11;</para>
        <para>� public int value() { return i; }</para>
        <para>}</para>
        <para>return new MyContents();</para>
        <para> </para>
        <para>In the anonymous inner class, <emphasis role="bold">Contents</emphasis> is created using a default constructor. The following code shows what to do if your base class needs a constructor with an argument:</para>
        <para>//: c08:Parcel7.java</para>
        <para>// An anonymous inner class that calls </para>
        <para>// the base-class constructor.</para>
        <para> </para>
        <para>public class Parcel7 {</para>
        <para>� public Wrapping wrap(int x) {</para>
        <para>��� // Base constructor call:</para>
        <para>��� return new Wrapping(x) { </para>
        <para>����� public int value() {</para>
        <para>������� return super.value() * 47;</para>
        <para>����� }</para>
        <para>��� }; // Semicolon required</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Parcel7 p = new Parcel7();</para>
        <para>��� Wrapping w = p.wrap(10);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>That is, you simply pass the appropriate argument to the base-class constructor, seen here as the <emphasis role="bold">x </emphasis>passed in <emphasis role="bold">new Wrapping(x)</emphasis>. An anonymous class cannot have a constructor where you would normally call <emphasis role="bold">super( )</emphasis>.</para>
        <para>In both of the previous examples, the semicolon doesn�t mark the end of the class body (as it does in C++). Instead, it marks the end of the expression that happens to contain the anonymous class. Thus, it�s identical to the use of the semicolon everywhere else.</para>
        <para>What happens if you need to perform some kind of initialization for an object of an anonymous inner class? Since it�s anonymous, there�s no name to give the constructor�so you can�t have a constructor. You can, however, perform initialization at the point of definition of your fields:</para>
        <para>//: c08:Parcel8.java</para>
        <para>// An anonymous inner class that performs </para>
        <para>// initialization. A briefer version</para>
        <para>// of Parcel5.java.</para>
        <para> </para>
        <para>public class Parcel8 {</para>
        <para>� // Argument must be final to use inside </para>
        <para>� // anonymous inner class:</para>
        <para>� public Destination dest(final String dest) {</para>
        <para>��� return new Destination() {</para>
        <para>����� private String label = dest;</para>
        <para>����� public String readLabel() { return label; }</para>
        <para>��� };</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Parcel8 p = new Parcel8();</para>
        <para>��� Destination d = p.dest(&quot;Tanzania&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>If you�re defining an anonymous inner class and want to use an object that�s defined outside the anonymous inner class, the compiler requires that the outside object be <emphasis role="bold">final</emphasis>. This is why the argument to <emphasis role="bold">dest( ) </emphasis>is <emphasis role="bold">final</emphasis>.<emphasis role="bold"/>If you forget, you�ll get a compile-time error message.</para>
        <para>As long as you�re simply assigning a field, the above approach is fine. But what if you need to perform some constructor-like activity? With <emphasis role="italic">instance initialization</emphasis>, you can, in effect, create a constructor for an anonymous inner class:</para>
        <para>//: c08:Parcel9.java</para>
        <para>// Using &quot;instance initialization&quot; to perform </para>
        <para>// construction on an anonymous inner class.</para>
        <para> </para>
        <para>public class Parcel9 {</para>
        <para>� public Destination </para>
        <para>� dest(final String dest, final float price) {</para>
        <para>��� return new Destination() {</para>
        <para>����� private int cost;</para>
        <para>����� // Instance initialization for each object:</para>
        <para>����� {</para>
        <para>������� cost = Math.round(price);</para>
        <para>������� if(cost &gt; 100)</para>
        <para>��������� System.out.println(&quot;Over budget!&quot;);</para>
        <para>����� }</para>
        <para>����� private String label = dest;</para>
        <para>����� public String readLabel() { return label; }</para>
        <para>��� };</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Parcel9 p = new Parcel9();</para>
        <para>��� Destination d = p.dest(&quot;Tanzania&quot;, 101.395F);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Inside the instance initializer you can see code that couldn�t be executed as part of a field initializer (that is, the <emphasis role="bold">if</emphasis> statement). So in effect, an instance initializer is the constructor for an anonymous inner class. Of course, it�s limited; you can�t overload instance initializers so you can have only one of these constructors.</para>
      </section>
      <section>
        <title><anchor xreflabel="The link to the outer class" xml:id="_Toc481064653"/>The link to the outer class</title>
        <para>So far, it appears that inner classes are just a name-hiding and code-organization scheme, which is helpful but not totally compelling. However, there�s another twist. When you create an inner class, an object of that inner class has a link to the enclosing object that made it, and so it can access the members of that enclosing object�<emphasis role="italic">without </emphasis>any special qualifications. In addition, inner classes have access rights to all the elements in the enclosing class<anchor xreflabel="[40]" xml:id="_ftnref40"/>[40]. The following example demonstrates this:</para>
        <para>//: c08:Sequence.java</para>
        <para>// Holds a sequence of Objects.</para>
        <para> </para>
        <para>interface Selector {</para>
        <para>� boolean end();</para>
        <para>� Object current();</para>
        <para>� void next();</para>
        <para>}</para>
        <para> </para>
        <para>public class Sequence {</para>
        <para>� private Object[] obs;</para>
        <para>� private int next = 0;</para>
        <para>� public Sequence(int size) {</para>
        <para>��� obs = new Object[size];</para>
        <para>� }</para>
        <para>� public void add(Object x) {</para>
        <para>��� if(next &lt; obs.length) {</para>
        <para>����� obs[next] = x;</para>
        <para>����� next++;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� private class SSelector implements Selector {</para>
        <para>��� int i = 0;</para>
        <para>��� public boolean end() {</para>
        <para>����� return i == obs.length;</para>
        <para>��� }</para>
        <para>��� public Object current() {</para>
        <para>����� return obs[i];</para>
        <para>��� }</para>
        <para>��� public void next() {</para>
        <para>����� if(i &lt; obs.length) i++;</para>
        <para>�� �}</para>
        <para>� }</para>
        <para>� public Selector getSelector() {</para>
        <para>��� return new SSelector();</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Sequence s = new Sequence(10);</para>
        <para>��� for(int i = 0; i &lt; 10; i++)</para>
        <para>����� s.add(Integer.toString(i));</para>
        <para>��� Selector sl = s.getSelector();��� </para>
        <para>��� while(!sl.end()) {</para>
        <para>����� System.out.println(sl.current());</para>
        <para>����� sl.next();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">Sequence</emphasis> is simply a fixed-sized array of <emphasis role="bold">Object</emphasis> with a class wrapped around it. You call <emphasis role="bold">add( )</emphasis> to add a new <emphasis role="bold">Object</emphasis> to the end of the sequence (if there�s room left). To fetch each of the objects in a <emphasis role="bold">Sequence</emphasis>, there�s an interface called <emphasis role="bold">Selector</emphasis>, which allows you to see if you�re at the <emphasis role="bold">end( )</emphasis>, to look at the <emphasis role="bold">current( )</emphasis><emphasis role="bold">Object</emphasis>, and to move to the <emphasis role="bold">next( )</emphasis><emphasis role="bold">Object</emphasis> in the <emphasis role="bold">Sequence</emphasis>. Because <emphasis role="bold">Selector</emphasis> is an <emphasis role="bold">interface</emphasis>, many other classes can implement the <emphasis role="bold">interface</emphasis> in their own ways, and many methods can take the <emphasis role="bold">interface</emphasis> as an argument, in order to create generic code.</para>
        <para>Here, the <emphasis role="bold">SSelector</emphasis> is a <emphasis role="bold">private</emphasis> class that provides <emphasis role="bold">Selector</emphasis> functionality. In <emphasis role="bold">main( )</emphasis>, you can see the creation of a <emphasis role="bold">Sequence</emphasis>, followed by the addition of a number of <emphasis role="bold">String</emphasis> objects. Then, a <emphasis role="bold">Selector</emphasis> is produced with a call to <emphasis role="bold">getSelector( )</emphasis> and this is used to move through the <emphasis role="bold">Sequence</emphasis> and select each item.</para>
        <para>At first, the creation of <emphasis role="bold">SSelector</emphasis> looks like just another inner class. But examine it closely. Note that each of the methods <emphasis role="bold">end( )</emphasis>, <emphasis role="bold">current( ),</emphasis> and <emphasis role="bold">next( )</emphasis> refer to <emphasis role="bold">obs</emphasis>, which is a reference that isn�t part of <emphasis role="bold">SSelector</emphasis>, but is instead a <emphasis role="bold">private </emphasis>field in the enclosing class. However, the inner class can access methods and fields from the enclosing class as if they owned them. This turns out to be very convenient, as you can see in the above example.</para>
        <para>So an inner class has automatic access to the members of the enclosing class. How can this happen? The inner class must keep a reference to the particular object of the enclosing class that was responsible for creating it. Then when you refer to a member of the enclosing class, that (hidden) reference is used to select that member. Fortunately, the compiler takes care of all these details for you, but you can also understand now that an object of an inner class can be created only in association with an object of the enclosing class. Construction of the inner class object requires the reference to the object of the enclosing class, and the compiler will complain if it cannot access that reference. Most of the time this occurs without any intervention on the part of the programmer.</para>
      </section>
      <section>
        <title><anchor xreflabel="static inner classes" xml:id="_Toc481064654"/><emphasis role="bold">static</emphasis> inner classes</title>
        <para>If you don�t need a connection between the inner class object and the outer class object, then you can make the inner class <emphasis role="bold">static</emphasis>. To understand the meaning of <emphasis role="bold">static</emphasis> when applied to inner classes, you must remember that the object of an ordinary inner class implicitly keeps a reference to the object of the enclosing class that created it. This is not true, however, when you say an inner class is <emphasis role="bold">static</emphasis>. A <emphasis role="bold">static </emphasis>inner class means:</para>
        <para>You don�t need an outer-class object in order to create an object of a <emphasis role="bold">static</emphasis> inner class.</para>
        <para>49.      You can�t access an outer-class object from an object of a <emphasis role="bold">static</emphasis> inner class.</para>
        <para><emphasis role="bold">static</emphasis> inner classes are different than non-<emphasis role="bold">static</emphasis> inner classes in another way, as well. Fields and methods in non-<emphasis role="bold">static</emphasis> inner classes can only be at the outer level of a class, so non-<emphasis role="bold">static</emphasis> inner classes cannot have <emphasis role="bold">static</emphasis> data, <emphasis role="bold">static</emphasis> fields, or <emphasis role="bold">static</emphasis> inner classes. However, <emphasis role="bold">static</emphasis> inner classes can have all of these:</para>
        <para>//: c08:Parcel10.java</para>
        <para>// Static inner classes.</para>
        <para> </para>
        <para>public class Parcel10 {</para>
        <para>� private static class PContents </para>
        <para>� implements Contents {</para>
        <para>��� private int i = 11;</para>
        <para>��� public int value() { return i; }</para>
        <para>� }</para>
        <para>� protected static class PDestination</para>
        <para>����� implements Destination {</para>
        <para>��� private String label;</para>
        <para>��� private PDestination(String whereTo) {</para>
        <para>����� label = whereTo;</para>
        <para>��� }</para>
        <para>��� public String readLabel() { return label; }</para>
        <para>��� // Static inner classes can contain </para>
        <para>��� // other static elements:</para>
        <para>��� public static void f() {}</para>
        <para>��� static int x = 10;</para>
        <para>��� static class AnotherLevel {</para>
        <para>����� public static void f() {}</para>
        <para>����� static int x = 10;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static Destination dest(String s) {</para>
        <para>��� return new PDestination(s);</para>
        <para>� }</para>
        <para>� public static Contents cont() {</para>
        <para>��� return new PContents();</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Contents c = cont();</para>
        <para>��� Destination d = dest(&quot;Tanzania&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In <emphasis role="bold">main( )</emphasis>, no object of <emphasis role="bold">Parcel10</emphasis> is necessary; instead you use the normal syntax for selecting a <emphasis role="bold">static</emphasis> member to call the methods that return references to <emphasis role="bold">Contents</emphasis> and <emphasis role="bold">Destination</emphasis>.</para>
        <para>As you will see shortly, in an ordinary (non-<emphasis role="bold">static</emphasis>) inner class, the link to the outer class object is achieved with a special <emphasis role="bold">this</emphasis> reference. A <emphasis role="bold">static</emphasis> inner class does not have this special <emphasis role="bold">this</emphasis> reference, which makes it analogous to a <emphasis role="bold">static</emphasis> method.</para>
        <para>Normally you can�t put any code inside an <emphasis role="bold">interface</emphasis>, but a <emphasis role="bold">static</emphasis> inner class can be part of an <emphasis role="bold">interface</emphasis>. Since the class is <emphasis role="bold">static </emphasis>it doesn�t violate the rules for interfaces�the <emphasis role="bold">static </emphasis>inner class is only placed inside the namespace of the interface:</para>
        <para>//: c08:IInterface.java</para>
        <para>// Static inner classes inside interfaces.</para>
        <para> </para>
        <para>interface IInterface {</para>
        <para>� static class Inner {</para>
        <para>��� int i, j, k;</para>
        <para>��� public Inner() {}</para>
        <para>�� �void f() {}</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Earlier in this book I suggested putting a <emphasis role="bold">main( ) </emphasis>in every class to act as a test�bed for that class. One drawback to this is the amount of extra compiled code you must carry around. If this is a problem, you can use a <emphasis role="bold">static</emphasis> inner class to hold your test code:</para>
        <para>//: c08:TestBed.java</para>
        <para>// Putting test code in a static inner class.</para>
        <para> </para>
        <para>class TestBed {</para>
        <para>� TestBed() {}</para>
        <para>� void f() { System.out.println(&quot;f()&quot;); }</para>
        <para>� public static class Tester {</para>
        <para>��� public static void main(String[] args) {</para>
        <para>����� TestBed t = new TestBed();</para>
        <para>����� t.f();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This generates a separate class called <emphasis role="bold">TestBed$Tester</emphasis> (to run the program, you say <emphasis role="bold">java TestBed$Tester</emphasis>). You can use this class for testing, but you don�t need to include it in your shipping product.</para>
      </section>
      <section>
        <title><anchor xreflabel="Referring to the outer class
object" xml:id="_Toc481064655"/>Referring to the outer class object</title>
        <para>If you need to produce the reference to the outer class object, you name the outer class followed by a dot and <emphasis role="bold">this</emphasis>. For example, in the class <emphasis role="bold">Sequence.SSelector</emphasis>, any of its methods can produce the stored reference to the outer class <emphasis role="bold">Sequence</emphasis> by saying <emphasis role="bold">Sequence.this</emphasis>. The resulting reference is automatically the correct type. (This is known and checked at compile-time, so there is no run-time overhead.)</para>
        <para>Sometimes you want to tell some other object to create an object of one of its inner classes. To do this you must provide a reference to the other outer class object in the <emphasis role="bold">new</emphasis> expression, like this:</para>
        <para>//: c08:Parcel11.java</para>
        <para>// Creating instances of inner classes.</para>
        <para> </para>
        <para>public class Parcel11 {</para>
        <para>� class Contents {</para>
        <para>��� private int i = 11;</para>
        <para>��� public int value() { return i; }</para>
        <para>� }</para>
        <para>� class Destination {</para>
        <para>��� private String label;</para>
        <para>��� Destination(String whereTo) {</para>
        <para>����� label = whereTo;</para>
        <para>��� }</para>
        <para>��� String readLabel() { return label; }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Parcel11 p = new Parcel11();</para>
        <para>��� // Must use instance of outer class</para>
        <para>��� // to create an instances of the inner class:</para>
        <para>��� Parcel11.Contents c = p.new Contents();</para>
        <para>��� Parcel11.Destination d =</para>
        <para>����� p.new Destination(&quot;Tanzania&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>To create an object of the inner class directly, you don�t follow the same form and refer to the outer class name <emphasis role="bold">Parcel11</emphasis> as you might expect, but instead you must use an <emphasis role="italic">object</emphasis> of the outer class to make an object of the inner class:</para>
        <para>Parcel11.Contents c = p.new Contents();</para>
        <para> </para>
        <para>Thus, it�s not possible to create an object of the inner class unless you already have an object of the outer class. This is because the object of the inner class is quietly connected to the object of the outer class that it was made from. However, if you make a <emphasis role="bold">static</emphasis> inner class, then it doesn�t need a reference to the outer class object.</para>
      </section>
      <section>
        <title><anchor xreflabel="Reaching outward from a
multiply-nested class" xml:id="_Toc481064656"/>Reaching outward from a multiply-nested class</title>
        <para><anchor xreflabel="[41]" xml:id="_ftnref41"/>[41]It doesn�t matter how deeply an inner class may be nested�it can transparently access all of the members of all the classes it is nested within, as seen here:</para>
        <para>//: c08:MultiNestingAccess.java</para>
        <para>// Nested classes can access all members of all</para>
        <para>// levels of the classes they are nested within.</para>
        <para> </para>
        <para>class MNA {</para>
        <para>� private void f() {}</para>
        <para>� class A {</para>
        <para>��� private void g() {}</para>
        <para>��� public class B {</para>
        <para>����� void h() {</para>
        <para>������� g();</para>
        <para>������� f();</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class MultiNestingAccess {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� MNA mna = new MNA();</para>
        <para>��� MNA.A mnaa = mna.new A();</para>
        <para>��� MNA.A.B mnaab = mnaa.new B();</para>
        <para>��� mnaab.h();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can see that in <emphasis role="bold">MNA.A.B</emphasis>, the methods <emphasis role="bold">g( )</emphasis> and <emphasis role="bold">f( )</emphasis> are callable without any qualification (despite the fact that they are <emphasis role="bold">private</emphasis>). This example also demonstrates the syntax necessary to create objects of multiply-nested inner classes when you create the objects in a different class. The �<emphasis role="bold">.new</emphasis>� syntax produces the correct scope so you do not have to qualify the class name in the constructor call.</para>
      </section>
      <section>
        <title><anchor xreflabel="Inheriting from inner classes" xml:id="_Toc481064657"/>Inheriting from inner classes</title>
        <para>Because the inner class constructor must attach to a reference of the enclosing class object, things are slightly complicated when you inherit from an inner class. The problem is that the �secret� reference to the enclosing class object <emphasis role="italic">must</emphasis> be initialized, and yet in the derived class there�s no longer a default object to attach to. The answer is to use a syntax provided to make the association explicit:</para>
        <para>//: c08:InheritInner.java</para>
        <para>// Inheriting an inner class.</para>
        <para> </para>
        <para>class WithInner {</para>
        <para>� class Inner {}</para>
        <para>}</para>
        <para> </para>
        <para>public class InheritInner </para>
        <para>��� extends WithInner.Inner {</para>
        <para>� //! InheritInner() {} // Won&apos;t compile</para>
        <para>� InheritInner(WithInner wi) {</para>
        <para>��� wi.super();</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� WithInner wi = new WithInner();</para>
        <para>��� InheritInner ii = new InheritInner(wi);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can see that <emphasis role="bold">InheritInner</emphasis> is extending only the inner class, not the outer one. But when it comes time to create a constructor, the default one is no good and you can�t just pass a reference to an enclosing object. In addition, you must use the syntax</para>
        <para>enclosingClassReference.super();</para>
        <para> </para>
        <para>inside the constructor. This provides the necessary reference and the program will then compile.</para>
      </section>
      <section>
        <title><anchor xreflabel="Can inner classes be overridden?" xml:id="_Toc481064658"/>Can inner classes be overridden?</title>
        <para>What happens when you create an inner class, then inherit from the enclosing class and redefine the inner class? That is, is it possible to override an inner class? This seems like it would be a powerful concept, but �overriding� an inner class as if it were another method of the outer class doesn�t really do anything:</para>
        <para>//: c08:BigEgg.java</para>
        <para>// An inner class cannot be overriden </para>
        <para>// like a method.</para>
        <para> </para>
        <para>class Egg {</para>
        <para>� protected class Yolk {</para>
        <para>��� public Yolk() {</para>
        <para>����� System.out.println(&quot;Egg.Yolk()&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� private Yolk y;</para>
        <para>� public Egg() {</para>
        <para>��� System.out.println(&quot;New Egg()&quot;);</para>
        <para>��� y = new Yolk();</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class BigEgg extends Egg {</para>
        <para>� public class Yolk {</para>
        <para>��� public Yolk() {</para>
        <para>����� System.out.println(&quot;BigEgg.Yolk()&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� new BigEgg();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The default constructor is synthesized automatically by the compiler, and this calls the base-class default constructor. You might think that since a <emphasis role="bold">BigEgg</emphasis> is being created, the �overridden� version of <emphasis role="bold">Yolk</emphasis> would be used, but this is not the case. The output is:</para>
        <para>New Egg()</para>
        <para>Egg.Yolk()</para>
        <para> </para>
        <para>This example simply shows that there isn�t any extra inner class magic going on when you inherit from the outer class. The two inner classes are completely separate entities, each in their own namespace. However, it�s still possible to explicitly inherit from the inner class:</para>
        <para>//: c08:BigEgg2.java</para>
        <para>// Proper inheritance of an inner class.</para>
        <para> </para>
        <para>class Egg2 {</para>
        <para>� protected class Yolk {</para>
        <para>��� public Yolk() {</para>
        <para>����� System.out.println(&quot;Egg2.Yolk()&quot;);</para>
        <para>��� }</para>
        <para>��� public void f() {</para>
        <para>����� System.out.println(&quot;Egg2.Yolk.f()&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� private Yolk y = new Yolk();</para>
        <para>� public Egg2() {</para>
        <para>��� System.out.println(&quot;New Egg2()&quot;);</para>
        <para>� }</para>
        <para>� public void insertYolk(Yolk yy) { y = yy; }</para>
        <para>� public void g() { y.f(); }</para>
        <para>}</para>
        <para> </para>
        <para>public class BigEgg2 extends Egg2 {</para>
        <para>� public class Yolk extends Egg2.Yolk {</para>
        <para>��� public Yolk() {</para>
        <para>����� System.out.println(&quot;BigEgg2.Yolk()&quot;);</para>
        <para>��� }</para>
        <para>��� public void f() {</para>
        <para>����� System.out.println(&quot;BigEgg2.Yolk.f()&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public BigEgg2() { insertYolk(new Yolk()); }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Egg2 e2 = new BigEgg2();</para>
        <para>��� e2.g();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Now <emphasis role="bold">BigEgg2.Yolk</emphasis> explicitly <emphasis role="bold">extends</emphasis><emphasis role="bold">Egg2.Yolk</emphasis> and overrides its methods. The method <emphasis role="bold">insertYolk( ) </emphasis>allows <emphasis role="bold">BigEgg2 </emphasis>to upcast one of its own <emphasis role="bold">Yolk </emphasis>objects into the <emphasis role="bold">y</emphasis> reference in <emphasis role="bold">Egg2</emphasis>, so when <emphasis role="bold">g( )</emphasis> calls <emphasis role="bold">y.f( )</emphasis> the overridden version of <emphasis role="bold">f( )</emphasis> is used. The output is:</para>
        <para>Egg2.Yolk()</para>
        <para>New Egg2()</para>
        <para>Egg2.Yolk()</para>
        <para>BigEgg2.Yolk()</para>
        <para>BigEgg2.Yolk.f()</para>
        <para> </para>
        <para>The second call to <emphasis role="bold">Egg2.Yolk( )</emphasis> is the base-class constructor call of the <emphasis role="bold">BigEgg2.Yolk</emphasis> constructor. You can see that the overridden version of <emphasis role="bold">f( )</emphasis> is used when <emphasis role="bold">g( )</emphasis> is called.</para>
      </section>
      <section>
        <title><anchor xreflabel="Inner class identifiers" xml:id="_Toc481064659"/>Inner class identifiers</title>
        <para>Since every class produces a <emphasis role="bold">.class </emphasis>file that holds all the information about how to create objects of this type (this information produces a �meta-class� called the <emphasis role="bold">Class </emphasis>object), you might guess that inner classes must also produce <emphasis role="bold">.class</emphasis> files to contain the information for <emphasis role="italic">their</emphasis><emphasis role="bold">Class</emphasis> objects. The names of these files/classes have a strict formula: the name of the enclosing class, followed by a �<emphasis role="bold">$</emphasis>�, followed by the name of the inner class. For example, the <emphasis role="bold">.class</emphasis> files created by <emphasis role="bold">InheritInner.java</emphasis> include:</para>
        <para>InheritInner.class</para>
        <para>WithInner$Inner.class</para>
        <para>WithInner.class</para>
        <para> </para>
        <para>If inner classes are anonymous, the compiler simply starts generating numbers as inner class identifiers. If inner classes are nested within inner classes, their names are simply appended after a �<emphasis role="bold">$</emphasis>� and the outer class identifier(s).</para>
        <para>Although this scheme of generating internal names is simple and straightforward, it�s also robust and handles most situations<anchor xreflabel="[42]" xml:id="_ftnref42"/>[42]. Since it is the standard naming scheme for Java, the generated files are automatically platform-independent. (Note that the Java compiler is changing your inner classes in all sorts of other ways in order to make them work.)</para>
      </section>
      <section>
        <title><anchor xreflabel="Why inner classes?" xml:id="_Toc481064660"/>Why inner classes?</title>
        <para>At this point you�ve seen a lot of syntax and semantics describing the way inner classes work, but this doesn�t answer the question of why they exist. Why did Sun go to so much trouble to add this fundamental language feature?</para>
        <para>Typically, the inner class inherits from a class or implements an <emphasis role="bold">interface</emphasis>, and the code in the inner class manipulates the outer class object that it was created within. So you could say that an inner class provides a kind of window into the outer class.</para>
        <para>A question that cuts to the heart of inner classes is this: if I just need a reference to an <emphasis role="bold">interface</emphasis>, why don�t I just make the outer class implement that <emphasis role="bold">interface</emphasis>? The answer is �If that�s all you need, then that�s how you should do it.� So what is it that distinguishes an inner class implementing an <emphasis role="bold">interface</emphasis> from an outer class implementing the same <emphasis role="bold">interface</emphasis>? The answer is that you can�t always have the convenience of <emphasis role="bold">interface</emphasis>s�sometimes you�re working with implementations. So the most compelling reason for inner classes is:</para>
        <para><emphasis role="italic">Each inner class can independently inherit from an implementation. Thus, the inner class is not limited by whether the outer class is already inheriting from an implementation.</emphasis></para>
        <para>Without the ability that inner classes provide to inherit�in effect�from more than one concrete or <emphasis role="bold">abstract </emphasis>class, some design and programming problems would be intractable. So one way to look at the inner class is as the completion of the solution of the multiple-inheritance problem. Interfaces solve part of the problem, but inner classes effectively allow �multiple implementation inheritance.� That is, inner classes effectively allow you to inherit from more than one non-<emphasis role="bold">interface</emphasis>.</para>
        <para>To see this in more detail, consider a situation where you have two interfaces that must somehow be implemented within a class. Because of the flexibility of interfaces, you have two choices: a single class or an inner class:</para>
        <para>//: c08:MultiInterfaces.java</para>
        <para>// Two ways that a class can </para>
        <para>// implement multiple interfaces.</para>
        <para> </para>
        <para>interface A {}</para>
        <para>interface B {}</para>
        <para> </para>
        <para>class X implements A, B {}</para>
        <para> </para>
        <para>class Y implements A {</para>
        <para>� B makeB() {</para>
        <para>��� // Anonymous inner class:</para>
        <para>��� return new B() {};</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class MultiInterfaces {</para>
        <para>� static void takesA(A a) {}</para>
        <para>� static void takesB(B b) {}</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� X x = new X();</para>
        <para>��� Y y = new Y();</para>
        <para>��� takesA(x);</para>
        <para>��� takesA(y);</para>
        <para>��� takesB(x);</para>
        <para>��� takesB(y.makeB());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Of course, this assumes that the structure of your code makes logical sense either way. However, you�ll ordinarily have some kind of guidance from the nature of the problem about whether to use a single class or an inner class. But without any other constraints, in the above example the approach you take doesn�t really make much difference from an implementation standpoint. Both of them work.</para>
        <para>However, if you have <emphasis role="bold">abstract</emphasis> or concrete classes instead of <emphasis role="bold">interface</emphasis>s, you are suddenly limited to using inner classes if your class must somehow implement both of the others:</para>
        <para>//: c08:MultiImplementation.java</para>
        <para>// With concrete or abstract classes, inner </para>
        <para>// classes are the only way to produce the effect</para>
        <para>// of &quot;multiple implementation inheritance.&quot;</para>
        <para> </para>
        <para>class C {}</para>
        <para>abstract class D {}</para>
        <para> </para>
        <para>class Z extends C {</para>
        <para>� D makeD() { return new D() {}; }</para>
        <para>} </para>
        <para> </para>
        <para>public class MultiImplementation {</para>
        <para>� static void takesC(C c) {}</para>
        <para>� static void takesD(D d) {}</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Z z = new Z();</para>
        <para>��� takesC(z);</para>
        <para>��� takesD(z.makeD());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>If you didn�t need to solve the �multiple implementation inheritance� problem, you could conceivably code around everything else without the need for inner classes. But with inner classes you have these additional features:</para>
        <para>The inner class can have multiple instances, each with its own state information that is independent of the information in the outer class object.</para>
        <para>50.      In a single outer class you can have several inner classes, each of which implement the same <emphasis role="bold">interface</emphasis> or inherit from the same class in a different way. An example of this will be shown shortly.</para>
        <para>51.      The point of creation of the inner class object is not tied to the creation of the outer class object.</para>
        <para>52.      There is no potentially confusing �is-a� relationship with the inner class; it�s a separate entity.</para>
        <para>As an example, if <emphasis role="bold">Sequence.java</emphasis> did not use inner classes, you�d have to say �a <emphasis role="bold">Sequence</emphasis> is a <emphasis role="bold">Selector</emphasis>,� and you�d only be able to have one <emphasis role="bold">Selector</emphasis> in existence for a particular <emphasis role="bold">Sequence</emphasis>. Also, you can have a second method, <emphasis role="bold">getRSelector( )</emphasis>, that produces a <emphasis role="bold">Selector</emphasis> that moves backward through the sequence. This kind of flexibility is only available with inner classes.</para>
        <section>
          <title>Closures &amp; Callbacks</title>
          <para>A <emphasis role="italic">closure</emphasis> is a callable object that retains information from the scope in which it was created. From this definition, you can see that an inner class is an object-oriented closure, because it doesn�t just contain each piece of information from the outer class object (�the scope in which it was created�), but it automatically holds a reference back to the whole outer class object, where it has permission to manipulate all the members, even <emphasis role="bold">private</emphasis> ones.</para>
          <para>One of the most compelling arguments made to include some kind of pointer mechanism in Java was to allow <emphasis role="italic">callbacks</emphasis>. With a callback, some other object is given a piece of information that allows it to call back into the originating object at some later point. This is a very powerful concept, as you will see in Chapters 13 and 16. If a callback is implemented using a pointer, however, you must rely on the programmer to behave and not misuse the pointer. As you�ve seen by now, Java tends to be more careful than that, so pointers were not included in the language.</para>
          <para>The closure provided by the inner class is a perfect solution; more flexible and far safer than a pointer. Here�s a simple example:</para>
          <para>//: c08:Callbacks.java</para>
          <para>// Using inner classes for callbacks</para>
          <para> </para>
          <para>interface Incrementable {</para>
          <para>� void increment();</para>
          <para>}</para>
          <para> </para>
          <para>// Very simple to just implement the interface:</para>
          <para>class Callee1 implements Incrementable {</para>
          <para>� private int i = 0;</para>
          <para>� public void increment() { </para>
          <para>��� i++;</para>
          <para>��� System.out.println(i);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class MyIncrement {</para>
          <para>� public void increment() {</para>
          <para>��� System.out.println(&quot;Other operation&quot;);</para>
          <para>� }</para>
          <para>� public static void f(MyIncrement mi) {</para>
          <para>��� mi.increment();</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>// If your class must implement increment() in</para>
          <para>// some other way, you must use an inner class:</para>
          <para>class Callee2 extends MyIncrement {</para>
          <para>� private int i = 0;</para>
          <para>� private void incr() { </para>
          <para>��� i++;</para>
          <para>��� System.out.println(i);</para>
          <para>� }</para>
          <para>� private class Closure implements Incrementable {</para>
          <para>��� public void increment() { incr(); }</para>
          <para>� }</para>
          <para>� Incrementable getCallbackReference() {</para>
          <para>��� return new Closure();</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class Caller {</para>
          <para>� private Incrementable callbackReference;</para>
          <para>� Caller(Incrementable cbh) {</para>
          <para>��� callbackReference = cbh;</para>
          <para>� }</para>
          <para>� void go() {</para>
          <para>��� callbackReference.increment();</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>public class Callbacks {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Callee1 c1 = new Callee1();</para>
          <para>��� Callee2 c2 = new Callee2();</para>
          <para>��� MyIncrement.f(c2);</para>
          <para>��� Caller caller1 = new Caller(c1);</para>
          <para>��� Caller caller2 = </para>
          <para>����� new Caller(c2.getCallbackReference());</para>
          <para>��� caller1.go();</para>
          <para>��� caller1.go();</para>
          <para>��� caller2.go();</para>
          <para>��� caller2.go();</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>This example also provides a further distinction between implementing an interface in an outer class vs. doing so in an inner class. <emphasis role="bold">Callee1</emphasis> is clearly the simpler solution in terms of the code. <emphasis role="bold">Callee2</emphasis> inherits from <emphasis role="bold">MyIncrement</emphasis> which already has a different <emphasis role="bold">increment( )</emphasis> method which does something unrelated to that which is expected by the <emphasis role="bold">Incrementable</emphasis> interface. When <emphasis role="bold">MyIncrement</emphasis> is inherited into <emphasis role="bold">Callee2</emphasis>, <emphasis role="bold">increment( )</emphasis> can�t be overridden for use by <emphasis role="bold">Incrementable</emphasis>, so you�re forced to provide a separate implementation using an inner class. Also note that when you create an inner class you do not add to or modify the interface of the outer class.</para>
          <para>Notice that everything except <emphasis role="bold">getCallbackReference( )</emphasis> in <emphasis role="bold">Callee2</emphasis> is <emphasis role="bold">private</emphasis>. To allow <emphasis role="italic">any</emphasis> connection to the outside world, the <emphasis role="bold">interface Incrementable</emphasis> is essential. Here you can see how <emphasis role="bold">interface</emphasis>s allow for a complete separation of interface from implementation.</para>
          <para>The inner class <emphasis role="bold">Closure</emphasis> simply implements <emphasis role="bold">Incrementable</emphasis> to provide a hook back into <emphasis role="bold">Callee2</emphasis>�but a safe hook. Whoever gets the <emphasis role="bold">Incrementable</emphasis> reference can, of course, only call <emphasis role="bold">increment( )</emphasis> and has no other abilities (unlike a pointer, which would allow you to run wild).</para>
          <para><emphasis role="bold">Caller</emphasis> takes an <emphasis role="bold">Incrementable</emphasis> reference in its constructor (although the capturing of the callback reference could happen at any time) and then, sometime latter, uses the reference to �call back� into the <emphasis role="bold">Callee</emphasis> class.</para>
          <para>The value of the callback is in its flexibility�you can dynamically decide what functions will be called at run-time. The benefit of this will become more evident in Chapter 13, where callbacks are used everywhere to implement graphical user interface (GUI) functionality.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Inner classes &amp; control
frameworks" xml:id="_Toc481064661"/>Inner classes &amp; control frameworks</title>
        <para>A more concrete example of the use of inner classes can be found in something that I will refer to here as a <emphasis role="italic">control framework</emphasis>. </para>
        <para>An <emphasis role="italic">application framework</emphasis> is a class or a set of classes that�s designed to solve a particular type of problem. To apply an application framework, you inherit from one or more classes and override some of the methods. The code you write in the overridden methods customizes the general solution provided by that application framework, in order to solve your specific problem. The control framework is a particular type of application<emphasis role="italic"/>framework dominated by the need to respond to events; a system that primarily responds to events is called an <emphasis role="italic">event-driven</emphasis><emphasis role="italic">system</emphasis>. One of the most important problems in application programming is the graphical user interface (GUI), which is almost entirely event-driven. As you will see in Chapter 13, the Java Swing library is a control framework that elegantly solves the GUI problem and that heavily uses inner classes.</para>
        <para>To see how inner classes allow the simple creation and use of control frameworks, consider a control framework whose job is to execute events whenever those events are �ready.� Although �ready� could mean anything, in this case the default will be based on clock time. What follows is a control framework that contains no specific information about what it�s controlling. First, here is the interface that describes any control event. It�s an <emphasis role="bold">abstract</emphasis> class instead of an actual <emphasis role="bold">interface</emphasis> because the default behavior is to perform the control based on time, so some of the implementation can be included here:</para>
        <para>//: c08:controller:Event.java</para>
        <para>// The common methods for any control event.</para>
        <para>package c08.controller;</para>
        <para> </para>
        <para>abstract public class Event {</para>
        <para>� private long evtTime;</para>
        <para>� public Event(long eventTime) {</para>
        <para>��� evtTime = eventTime;</para>
        <para>� }</para>
        <para>� public boolean ready() {</para>
        <para>��� return System.currentTimeMillis() &gt;= evtTime;</para>
        <para>� }</para>
        <para>� abstract public void action();</para>
        <para>� abstract public String description();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The constructor simply captures the time when you want the <emphasis role="bold">Event</emphasis> to run, while <emphasis role="bold">ready( )</emphasis> tells you when it�s time to run it. Of course, <emphasis role="bold">ready( )</emphasis> could be overridden in a derived class to base the <emphasis role="bold">Event</emphasis> on something other than time.</para>
        <para><emphasis role="bold">action( )</emphasis> is the method that�s called when the <emphasis role="bold">Event</emphasis> is <emphasis role="bold">ready( )</emphasis>, and <emphasis role="bold">description( )</emphasis> gives textual information about the <emphasis role="bold">Event</emphasis>.</para>
        <para>The following file contains the actual control framework that manages and fires events. The first class is really just a �helper� class whose job is to hold <emphasis role="bold">Event</emphasis> objects. You can replace it with any appropriate container, and in Chapter 9 you�ll discover other containers that will do the trick without requiring you to write this extra code:</para>
        <para>//: c08:controller:Controller.java</para>
        <para>// Along with Event, the generic</para>
        <para>// framework for all control systems:</para>
        <para>package c08.controller;</para>
        <para> </para>
        <para>// This is just a way to hold Event objects.</para>
        <para>class EventSet {</para>
        <para>� private Event[] events = new Event[100];</para>
        <para>� private int index = 0;</para>
        <para>� private int next = 0;</para>
        <para>� public void add(Event e) {</para>
        <para>��� if(index &gt;= events.length)</para>
        <para>����� return; // (In real life, throw exception)</para>
        <para>��� events[index++] = e;</para>
        <para>� }</para>
        <para>� public Event getNext() {</para>
        <para>��� boolean looped = false;</para>
        <para>��� int start = next;</para>
        <para>��� do {</para>
        <para>����� next = (next + 1) % events.length;</para>
        <para>����� // See if it has looped to the beginning:</para>
        <para>����� if(start == next) looped = true;</para>
        <para>����� // If it loops past start, the list </para>
        <para>����� // is empty:</para>
        <para>����� if((next == (start + 1) % events.length)</para>
        <para>�������� &amp;&amp; looped)</para>
        <para>������� return null;</para>
        <para>��� } while(events[next] == null);</para>
        <para>��� return events[next];</para>
        <para>� }</para>
        <para>� public void removeCurrent() {</para>
        <para>��� events[next] = null;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Controller {</para>
        <para>� private EventSet es = new EventSet();</para>
        <para>� public void addEvent(Event c) { es.add(c); }</para>
        <para>� public void run() {</para>
        <para>��� Event e;</para>
        <para>��� while((e = es.getNext()) != null) {</para>
        <para>����� if(e.ready()) {</para>
        <para>������� e.action();</para>
        <para>������� System.out.println(e.description());</para>
        <para>������� es.removeCurrent();</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">EventSet</emphasis> arbitrarily holds 100 <emphasis role="bold">Event</emphasis>s. (If a �real� container from Chapter 9 is used here you don�t need to worry about its maximum size, since it will resize itself). The <emphasis role="bold">index</emphasis> is used to keep track of the next available space, and <emphasis role="bold">next</emphasis> is used when you�re looking for the next <emphasis role="bold">Event</emphasis> in the list, to see whether you�ve looped around. This is important during a call to <emphasis role="bold">getNext( )</emphasis>, because <emphasis role="bold">Event</emphasis> objects are removed from the list (using <emphasis role="bold">removeCurrent( )</emphasis>)<emphasis role="bold"/>once they�re run, so <emphasis role="bold">getNext( )</emphasis> will encounter holes in the list as it moves through it.</para>
        <para>Note that <emphasis role="bold">removeCurrent( )</emphasis> doesn�t just set some flag indicating that the object is no longer in use. Instead, it sets the reference to <emphasis role="bold">null</emphasis>. This is important because if the garbage collector sees a reference that�s still in use then it can�t clean up the object. If you think your references might hang around (as they would here), then it�s a good idea to set them to <emphasis role="bold">null</emphasis> to give the garbage collector permission to clean them up.</para>
        <para><emphasis role="bold">Controller</emphasis> is where the actual work goes on. It uses an <emphasis role="bold">EventSet</emphasis> to hold its <emphasis role="bold">Event</emphasis> objects, and <emphasis role="bold">addEvent( )</emphasis> allows you to add new events to this list. But the important method is <emphasis role="bold">run( )</emphasis>. This method loops through the <emphasis role="bold">EventSet</emphasis>, hunting for an <emphasis role="bold">Event</emphasis> object that�s <emphasis role="bold">ready( )</emphasis> to run. For each one it finds <emphasis role="bold">ready( )</emphasis>,<emphasis role="bold"/>it calls the <emphasis role="bold">action( )</emphasis> method, prints out the <emphasis role="bold">description( ),</emphasis> and then removes the <emphasis role="bold">Event</emphasis> from the list. </para>
        <para>Note that so far in this design you know nothing about exactly <emphasis role="italic">what</emphasis> an <emphasis role="bold">Event</emphasis> does. And this is the crux of the design; how it �separates the things that change from the things that stay the same.� Or, to use my term, the �vector of change� is the different actions of the various kinds of <emphasis role="bold">Event</emphasis> objects, and you express different actions by creating different <emphasis role="bold">Event</emphasis> subclasses.</para>
        <para>This is where inner classes come into play. They allow two things: </para>
        <para>To create the entire implementation of a control-framework application in a single class, thereby encapsulating everything that�s unique about that implementation. Inner classes are used to express the many different kinds of <emphasis role="bold">action( )</emphasis> necessary to solve the problem. In addition, the following example uses <emphasis role="bold">private</emphasis> inner classes so the implementation is completely hidden and can be changed with impunity.</para>
        <para>53.      Inner classes keep this implementation from becoming awkward, since you�re able to easily access any of the members in the outer class. Without this ability the code might become unpleasant enough that you�d end up seeking an alternative.</para>
        <para>Consider a particular implementation of the control framework designed to control greenhouse functions<anchor xreflabel="[43]" xml:id="_ftnref43"/>[43]. Each action is entirely different: turning lights, water, and thermostats on and off, ringing bells, and restarting the system. But the control framework is designed to easily isolate this different code. Inner classes allow you to have multiple derived versions of the same base class, <emphasis role="bold">Event</emphasis>, within a single class. For each type of action you inherit a new <emphasis role="bold">Event</emphasis> inner class, and write the control code inside of <emphasis role="bold">action( )</emphasis>. </para>
        <para>As is typical with an application framework, the class <emphasis role="bold">GreenhouseControls</emphasis> is inherited from <emphasis role="bold">Controller</emphasis>:</para>
        <para>//: c08:GreenhouseControls.java</para>
        <para>// This produces a specific application of the</para>
        <para>// control system, all in a single class. Inner</para>
        <para>// classes allow you to encapsulate different</para>
        <para>// functionality for each type of event.</para>
        <para>import c08.controller.*;</para>
        <para> </para>
        <para>public class GreenhouseControls </para>
        <para>��� extends Controller {</para>
        <para>� private boolean light = false;</para>
        <para>� private boolean water = false;</para>
        <para>� private String thermostat = &quot;Day&quot;;</para>
        <para>� private class LightOn extends Event {</para>
        <para>��� public LightOn(long eventTime) {</para>
        <para>����� super(eventTime);</para>
        <para>��� }</para>
        <para>��� public void action() {</para>
        <para>����� // Put hardware control code here to </para>
        <para>����� // physically turn on the light.</para>
        <para>����� light = true;</para>
        <para>��� }</para>
        <para>��� public String description() {</para>
        <para>����� return &quot;Light is on&quot;;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� private class LightOff extends Event {</para>
        <para>��� public LightOff(long eventTime) {</para>
        <para>����� super(eventTime);</para>
        <para>��� }</para>
        <para>��� public void action() {</para>
        <para>����� // Put hardware control code here to </para>
        <para>����� // physically turn off the light.</para>
        <para>����� light = false;</para>
        <para>��� }</para>
        <para>��� public String description() {</para>
        <para>����� return &quot;Light is off&quot;;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� private class WaterOn extends Event {</para>
        <para>��� public WaterOn(long eventTime) {</para>
        <para>����� super(eventTime);</para>
        <para>��� }</para>
        <para>��� public void action() {</para>
        <para>����� // Put hardware control code here</para>
        <para>����� water = true;</para>
        <para>��� }</para>
        <para>��� public String description() {</para>
        <para>����� return &quot;Greenhouse water is on&quot;;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� private class WaterOff extends Event {</para>
        <para>��� public WaterOff(long eventTime) {</para>
        <para>����� super(eventTime);</para>
        <para>��� }</para>
        <para>��� public void action() {</para>
        <para>����� // Put hardware control code here</para>
        <para>����� water = false;</para>
        <para>��� }</para>
        <para>��� public String description() {</para>
        <para>����� return &quot;Greenhouse water is off&quot;;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� private class ThermostatNight extends Event {</para>
        <para>��� public ThermostatNight(long eventTime) {</para>
        <para>����� super(eventTime);</para>
        <para>��� }</para>
        <para>��� public void action() {</para>
        <para>����� // Put hardware control code here</para>
        <para>����� thermostat = &quot;Night&quot;;</para>
        <para>��� }</para>
        <para>��� public String description() {</para>
        <para>����� return &quot;Thermostat on night setting&quot;;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� private class ThermostatDay extends Event {</para>
        <para>��� public ThermostatDay(long eventTime) {</para>
        <para>����� super(eventTime);</para>
        <para>��� }</para>
        <para>��� public void action() {</para>
        <para>����� // Put hardware control code here</para>
        <para>����� thermostat = &quot;Day&quot;;</para>
        <para>��� }</para>
        <para>��� public String description() {</para>
        <para>�� ���return &quot;Thermostat on day setting&quot;;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� // An example of an action() that inserts a </para>
        <para>� // new one of itself into the event list:</para>
        <para>� private int rings;</para>
        <para>� private class Bell extends Event {</para>
        <para>��� public Bell(long eventTime) {</para>
        <para>����� super(eventTime);</para>
        <para>��� }</para>
        <para>��� public void action() {</para>
        <para>����� // Ring every 2 seconds, &apos;rings&apos; times:</para>
        <para>����� System.out.println(&quot;Bing!&quot;);</para>
        <para>����� if(--rings &gt; 0)</para>
        <para>������� addEvent(new Bell(</para>
        <para>��������� System.currentTimeMillis() + 2000));</para>
        <para>��� }</para>
        <para>��� public String description() {</para>
        <para>����� return &quot;Ring bell&quot;;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� private class Restart extends Event {</para>
        <para>��� public Restart(long eventTime) {</para>
        <para>����� super(eventTime);</para>
        <para>��� }</para>
        <para>��� public void action() {</para>
        <para>����� long tm = System.currentTimeMillis();</para>
        <para>����� // Instead of hard-wiring, you could parse</para>
        <para>����� // configuration information from a text</para>
        <para>����� // file here:</para>
        <para>����� rings = 5;</para>
        <para>����� addEvent(new ThermostatNight(tm));</para>
        <para>����� addEvent(new LightOn(tm + 1000));</para>
        <para>����� addEvent(new LightOff(tm + 2000));</para>
        <para>����� addEvent(new WaterOn(tm + 3000));</para>
        <para>����� addEvent(new WaterOff(tm + 8000));</para>
        <para>����� addEvent(new Bell(tm + 9000));</para>
        <para>����� addEvent(new ThermostatDay(tm + 10000));</para>
        <para>����� // Can even add a Restart object!</para>
        <para>����� addEvent(new Restart(tm + 20000));</para>
        <para>��� }</para>
        <para>��� public String description() {</para>
        <para>����� return &quot;Restarting system&quot;;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� GreenhouseControls gc = </para>
        <para>����� new GreenhouseControls();</para>
        <para>��� long tm = System.currentTimeMillis();</para>
        <para>��� gc.addEvent(gc.new Restart(tm));</para>
        <para>��� gc.run();</para>
        <para>� } </para>
        <para>} ///:~</para>
        <para> </para>
        <para>Note that <emphasis role="bold">light</emphasis>, <emphasis role="bold">water</emphasis>, <emphasis role="bold">thermostat,</emphasis> and <emphasis role="bold">rings</emphasis> all belong to the outer class <emphasis role="bold">GreenhouseControls</emphasis>, and yet the inner classes can access those fields without qualification or special permission. Also, most of the <emphasis role="bold">action( )</emphasis> methods involve some sort of hardware control, which would most likely involve calls to non-Java code.</para>
        <para>Most of the <emphasis role="bold">Event</emphasis> classes look similar, but <emphasis role="bold">Bell</emphasis> and <emphasis role="bold">Restart</emphasis> are special. <emphasis role="bold">Bell</emphasis> rings, and if it hasn�t yet rung enough times it adds a new <emphasis role="bold">Bell</emphasis> object to the event list, so it will ring again later. Notice how inner classes <emphasis role="italic">almost</emphasis> look like multiple inheritance: <emphasis role="bold">Bell</emphasis> has all the methods of <emphasis role="bold">Event</emphasis> and it also appears to have all the methods of the outer class <emphasis role="bold">GreenhouseControls</emphasis>.</para>
        <para><emphasis role="bold">Restart</emphasis> is responsible for initializing the system, so it adds all the appropriate events. Of course, a more flexible way to accomplish this is to avoid hard-coding the events and instead read them from a file. (An exercise in Chapter 11 asks you to modify this example to do just that.) Since <emphasis role="bold">Restart( )</emphasis> is just another <emphasis role="bold">Event</emphasis> object, you can also add a <emphasis role="bold">Restart</emphasis> object within <emphasis role="bold">Restart.action( )</emphasis> so that the system regularly restarts itself. And all you need to do in <emphasis role="bold">main( )</emphasis> is create a <emphasis role="bold">GreenhouseControls</emphasis> object and add a <emphasis role="bold">Restart</emphasis> object to get it going.</para>
        <para>This example should move you a long way toward appreciating the value of inner classes, especially when used within a control framework. However, in Chapter 13 you�ll see how elegantly inner classes are used to describe the actions of a graphical user interface. By the time you finish that chapter you should be fully convinced.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Summary" xml:id="_Toc481064662"/>Summary</title>
      <para>Interfaces and inner classes are more sophisticated concepts than what you�ll find in many OOP languages. For example, there�s nothing like them in C++. Together, they solve the same problem that C++ attempts to solve with its multiple inheritance (MI) feature. However, MI in C++ turns out to be rather difficult to use, while Java interfaces and inner classes are, by comparison, much more accessible.</para>
      <para>Although the features themselves are reasonably straightforward, the use of these features is a design issue, much the same as polymorphism. Over time, you�ll become better at recognizing situations where you should use an interface, or an inner class, or both. But at this point in this book you should at least be comfortable with the syntax and semantics. As you see these language features in use you�ll eventually internalize them.</para>
    </section>
    <section>
      <title><anchor xreflabel="Exercises" xml:id="_Toc481064663"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Prove that the fields in an <emphasis role="bold">interface</emphasis> are implicitly <emphasis role="bold">static</emphasis> and <emphasis role="bold">final</emphasis>.</para>
      <para>      90.         Create an <emphasis role="bold">interface</emphasis> containing three methods, in its own <emphasis role="bold">package</emphasis>. Implement the interface in a different <emphasis role="bold">package</emphasis>.</para>
      <para>      91.         Prove that all the methods in an <emphasis role="bold">interface</emphasis> are automatically <emphasis role="bold">public</emphasis>.</para>
      <para>      92.         In <emphasis role="bold">c07:Sandwich.java</emphasis>, create an interface called <emphasis role="bold">FastFood</emphasis> (with appropriate methods) and change <emphasis role="bold">Sandwich</emphasis> so that it also implements <emphasis role="bold">FastFood</emphasis>.</para>
      <para>      93.         Create three <emphasis role="bold">interface</emphasis>s, each with two methods. Inherit a new <emphasis role="bold">interface</emphasis> from the three, adding a new method. Create a class by implementing the new <emphasis role="bold">interface</emphasis> and also inheriting from a concrete class. Now write four methods, each of which takes one of the four <emphasis role="bold">interface</emphasis>s as an argument. In <emphasis role="bold">main( )</emphasis>, create an object of your class and pass it to each of the methods.</para>
      <para>      94.         Modify Exercise 5 by creating an <emphasis role="bold">abstract</emphasis> class and inheriting that into the derived class.</para>
      <para>      95.         Modify <emphasis role="bold">Music5.java</emphasis> by adding a <emphasis role="bold">Playable</emphasis><emphasis role="bold">interface</emphasis>. Remove the <emphasis role="bold">play( )</emphasis> declaration from <emphasis role="bold">Instrument</emphasis>. Add <emphasis role="bold">Playable</emphasis> to the derived classes by including it in the <emphasis role="bold">implements</emphasis> list. Change <emphasis role="bold">tune( )</emphasis> so that it takes a <emphasis role="bold">Playable</emphasis> instead of an <emphasis role="bold">Instrument</emphasis>.</para>
      <para>      96.         Change Exercise 6 in Chapter 7 so that <emphasis role="bold">Rodent</emphasis> is an <emphasis role="bold">interface</emphasis>.</para>
      <para>      97.         In <emphasis role="bold">Adventure.java</emphasis>, add an <emphasis role="bold">interface</emphasis> called <emphasis role="bold">CanClimb</emphasis>, following the form of the other interfaces.</para>
      <para>      98.         Write a program that imports and uses <emphasis role="bold">Month2.java</emphasis>.</para>
      <para>      99.         Following the example given in <emphasis role="bold">Month2.java</emphasis>, create an enumeration of days of the week.</para>
      <para>  100.         Create an <emphasis role="bold">interface</emphasis> with at least one method, in its own package. Create a class in a separate package. Add a <emphasis role="bold">protected</emphasis> inner class that implements the <emphasis role="bold">interface</emphasis>. In a third package, inherit from your class and, inside a method, return an object of the <emphasis role="bold">protected</emphasis> inner class, upcasting to the <emphasis role="bold">interface</emphasis> during the return.</para>
      <para>  101.         Create an <emphasis role="bold">interface</emphasis> with at least one method, and implement that <emphasis role="bold">interface</emphasis> by defining an inner class within a method, which returns a reference to your <emphasis role="bold">interface</emphasis>.</para>
      <para>  102.         Repeat Exercise 13 but define the inner class within a scope within a method.</para>
      <para>  103.         Repeat Exercise 13 using an anonymous inner class.</para>
      <para>  104.         Create a <emphasis role="bold">private</emphasis> inner class that implements a <emphasis role="bold">public</emphasis><emphasis role="bold">interface</emphasis>. Write a method that returns a reference to an instance of the <emphasis role="bold">private</emphasis> inner class, upcast to the <emphasis role="bold">interface</emphasis>. Show that the inner class is completely hidden by trying to downcast to it.</para>
      <para>  105.         Create a class with a nondefault constructor and no default constructor. Create a second class that has a method which returns a reference to the first class. Create the object to return by making an anonymous inner class that inherits from the first class.</para>
      <para>  106.         Create a class with a <emphasis role="bold">private</emphasis> field and a <emphasis role="bold">private</emphasis> method. Create an inner class with a method that modifies the outer class field and calls the outer class method. In a second outer class method, create an object of the inner class and call it�s method, then show the effect on the outer class object.</para>
      <para>  107.         Repeat Exercise 18 using an anonymous inner class.</para>
      <para>  108.         Create a class containing a <emphasis role="bold">static</emphasis> inner class. In <emphasis role="bold">main( )</emphasis>, create an instance of the inner class.</para>
      <para>  109.         Create an <emphasis role="bold">interface</emphasis> containing a <emphasis role="bold">static</emphasis> inner class. Implement this <emphasis role="bold">interface</emphasis> and create an instance of the inner class.</para>
      <para>  110.         Create a class containing an inner class that itself contains an inner class. Repeat this using <emphasis role="bold">static</emphasis> inner classes. Note the names of the <emphasis role="bold">.class</emphasis> files produced by the compiler.</para>
      <para>  111.         Create a class with an inner class. In a separate class, make an instance of the inner class.</para>
      <para>  112.         Create a class with an inner class that has a nondefault constructor. Create a second class with an inner class that inherits from the first inner class.</para>
      <para>  113.         Repair the problem in <emphasis role="bold">WindError.java</emphasis>.</para>
      <para>  114.         Modify <emphasis role="bold">Sequence.java</emphasis> by adding a method <emphasis role="bold">getRSelector( )</emphasis> that produces a different implementation of the <emphasis role="bold">Selector</emphasis><emphasis role="bold">interface</emphasis> that moves backward through the sequence from the end to the beginning.</para>
      <para>  115.         Create an <emphasis role="bold">interface</emphasis><emphasis role="bold">U </emphasis>with three methods. Create a class <emphasis role="bold">A </emphasis>with a method that produces a reference to a <emphasis role="bold">U</emphasis> by building an anonymous inner class. Create a second class <emphasis role="bold">B </emphasis>that contains an array of <emphasis role="bold">U</emphasis>. <emphasis role="bold">B</emphasis> should have one method that accepts and stores a reference to a <emphasis role="bold">U</emphasis> in the array, a second method that sets a reference in the array (specified by the method argument) to <emphasis role="bold">null</emphasis> and a third method that moves through the array and calls the methods in <emphasis role="bold">U</emphasis>. In <emphasis role="bold">main( )</emphasis>, create a group of <emphasis role="bold">A</emphasis> objects and a single <emphasis role="bold">B</emphasis>. Fill the <emphasis role="bold">B</emphasis> with <emphasis role="bold">U</emphasis> references produced by the <emphasis role="bold">A</emphasis> objects. Use the <emphasis role="bold">B</emphasis> to call back into all the <emphasis role="bold">A</emphasis> objects. Remove some of the <emphasis role="bold">U</emphasis> references from the <emphasis role="bold">B</emphasis>.</para>
      <para>  116.         In <emphasis role="bold">GreenhouseControls.java</emphasis>, add <emphasis role="bold">Event</emphasis> inner classes that turn fans on and off.</para>
      <para>  117.         Show that an inner class has access to the <emphasis role="bold">private</emphasis> elements of its outer class. Determine whether the reverse is true.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064664"/><anchor xreflabel="9:
Holding 
Your Objects" xml:id="_Toc477690729"/>9: Holding   Your Objects</title>
    <para><anchor xreflabel="It�s a fairly simple
program that has only a fixed quantity of objects with known lifetimes." xml:id="OLE_LINK2"/>It�s a fairly simple program that has only a fixed quantity of objects with known lifetimes.</para>
    <para>In general, your programs will always be creating new objects based on some criteria that will be known only at the time the program is running. You won�t know until run-time the quantity or even the exact type of the objects you need. To solve the general programming problem, you need to be able to create any number of objects, anytime, anywhere. So you can�t rely on creating a named reference to hold each one of your objects:</para>
    <para>MyObject myReference;</para>
    <para> </para>
    <para>since you�ll never know how many of these you�ll actually need.</para>
    <para>To solve this rather essential problem, Java has several ways to hold objects (or rather, references to objects). The built-in type is the array, which has been discussed before. Also, the Java utilities library has a reasonably complete set of <emphasis role="italic">container</emphasis><emphasis role="italic"> classes</emphasis> (also known as <emphasis role="italic">collection</emphasis><emphasis role="italic">classes</emphasis>, but because the Java 2 libraries use the name <emphasis role="bold">Collection</emphasis> to refer to a particular subset of the library, I shall use the more inclusive term �container�). Containers provide sophisticated ways to hold and even manipulate your objects.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064665"/><anchor xreflabel="Arrays" xml:id="_Toc375545347"/>Arrays</title>
      <para>Most of the necessary introduction to arrays is in the last section of Chapter 4, which showed how you define and initialize an array. Holding objects is the focus of this chapter, and an array is just one way to hold objects. But there are a number of other ways to hold objects, so what makes an array special?</para>
      <para>There are two issues that distinguish arrays from other types of containers: efficiency and type. The array is the most efficient way that Java provides to store and randomly access a sequence of objects (actually, object references). The array is a simple linear sequence, which makes element access fast, but you pay for this speed: when you create an array object, its size is fixed and cannot be changed for the lifetime of that array object. You might suggest creating an array of a particular size and then, if you run out of space, creating a new one and moving all the references from the old one to the new one. This is the behavior of the <emphasis role="bold">ArrayList </emphasis>class, which will be studied later in this chapter. However, because of the overhead of this size flexibility, an <emphasis role="bold">ArrayList</emphasis> is measurably less efficient than an array.</para>
      <para>The <emphasis role="bold">vector</emphasis> container class in C++ <emphasis role="italic">does</emphasis> know the type of objects it holds, but it has a different drawback when compared with arrays in Java: the C++ <emphasis role="bold">vector</emphasis>�s <emphasis role="bold">operator[]</emphasis> doesn�t do bounds checking, so you can run past the end<anchor xreflabel="[44]" xml:id="_ftnref44"/>[44]. In Java, you get bounds checking regardless of whether you�re using an array or a container�you�ll get a <emphasis role="bold">RuntimeException</emphasis> if you exceed the bounds. As you�ll learn in Chapter 10, this type of exception indicates a programmer error, and thus you don�t need to check for it in your code. As an aside, the reason the C++ <emphasis role="bold">vector</emphasis> doesn�t check bounds with every access is speed�in Java you have the constant performance overhead of bounds checking all the time for both arrays and containers.</para>
      <para>The other generic container classes that will be studied in this chapter, <emphasis role="bold">List</emphasis>, <emphasis role="bold">Set</emphasis>, and <emphasis role="bold">Map</emphasis>, all deal with objects as if they had no specific type. That is, they treat them as type <emphasis role="bold">Object</emphasis>, the root class of all classes in Java. This works fine from one standpoint: you need to build only one container, and any Java object will go into that container. (Except for primitives�these can be placed in containers as constants using the Java primitive wrapper classes, or as changeable values by wrapping in your own class.) This is the second place where an array is superior to the generic containers: when you create an array, you create it to hold a specific type. This means that you get compile-time type checking to prevent you from putting the wrong type in, or mistaking the type that you�re extracting. Of course, Java will prevent you from sending an inappropriate message to an object, either at compile-time or at run-time. So it�s not much riskier one way or the other, it�s just nicer if the compiler points it out to you, faster at run-time, and there�s less likelihood that the end user will get surprised by an exception.</para>
      <para>For efficiency and type checking it�s always worth trying to use an array if you can. However, when you�re trying to solve a more general problem arrays can be too restrictive. After looking at arrays, the rest of this chapter will be devoted to the container classes provided by Java.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545348"/><anchor xreflabel="Arrays
are first-class objects" xml:id="_Toc481064666"/>Arrays are first-class objects</title>
        <para>Regardless of what type of array you�re working with, the array identifier is actually a reference to a true object that�s created on the heap. This is the object that holds the references to the other objects, and it can be created either implicitly, as part of the array initialization syntax, or explicitly with a <emphasis role="bold">new</emphasis> expression. Part of the array object (in fact, the only field or method you can access) is the read-only <emphasis role="bold">length</emphasis> member that tells you how many elements can be stored in that array object. The �<emphasis role="bold">[]</emphasis>� syntax is the only other access that you have to the array object.</para>
        <para>The following example shows the various ways that an array can be initialized, and how the array references can be assigned to different array objects. It also shows that arrays of objects and arrays of primitives are almost identical in their use. The only difference is that arrays of objects hold references, while arrays of primitives hold the primitive values directly.</para>
        <para>//: c09:ArraySize.java</para>
        <para>// Initialization &amp; re-assignment of arrays.</para>
        <para> </para>
        <para>class Weeble {} // A small mythical creature</para>
        <para> </para>
        <para>public class ArraySize {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� // Arrays of objects:</para>
        <para>��� Weeble[] a; // Null reference</para>
        <para>��� Weeble[] b = new Weeble[5]; // Null references</para>
        <para>��� Weeble[] c = new Weeble[4];</para>
        <para>��� for(int i = 0; i &lt; c.length; i++)</para>
        <para>����� c[i] = new Weeble();</para>
        <para>��� // Aggregate initialization:</para>
        <para>��� Weeble[] d = { </para>
        <para>����� new Weeble(), new Weeble(), new Weeble()</para>
        <para>��� };</para>
        <para>��� // Dynamic aggregate initialization:</para>
        <para>��� a = new Weeble[] {</para>
        <para>����� new Weeble(), new Weeble()</para>
        <para>��� };</para>
        <para>��� System.out.println(&quot;a.length=&quot; + a.length);</para>
        <para>��� System.out.println(&quot;b.length = &quot; + b.length);</para>
        <para>��� // The references inside the array are </para>
        <para>��� // automatically initialized to null:</para>
        <para>��� for(int i = 0; i &lt; b.length; i++)</para>
        <para>����� System.out.println(&quot;b[&quot; + i + &quot;]=&quot; + b[i]);</para>
        <para>��� System.out.println(&quot;c.length = &quot; + c.length);</para>
        <para>��� System.out.println(&quot;d.length = &quot; + d.length);</para>
        <para>��� a = d;</para>
        <para>�� �System.out.println(&quot;a.length = &quot; + a.length);</para>
        <para> </para>
        <para>��� // Arrays of primitives:</para>
        <para>��� int[] e; // Null reference</para>
        <para>��� int[] f = new int[5];</para>
        <para>��� int[] g = new int[4];</para>
        <para>��� for(int i = 0; i &lt; g.length; i++)</para>
        <para>����� g[i] = i*i;</para>
        <para>��� int[] h = { 11, 47, 93 };</para>
        <para>��� // Compile error: variable e not initialized:</para>
        <para>��� //!System.out.println(&quot;e.length=&quot; + e.length);</para>
        <para>��� System.out.println(&quot;f.length = &quot; + f.length);</para>
        <para>��� // The primitives inside the array are</para>
        <para>��� // automatically initialized to zero:</para>
        <para>��� for(int i = 0; i &lt; f.length; i++)</para>
        <para>����� System.out.println(&quot;f[&quot; + i + &quot;]=&quot; + f[i]);</para>
        <para>��� System.out.println(&quot;g.length = &quot; + g.length);</para>
        <para>��� System.out.println(&quot;h.length = &quot; + h.length);</para>
        <para>��� e = h;</para>
        <para>��� System.out.println(&quot;e.length = &quot; + e.length);</para>
        <para>��� e = new int[] { 1, 2 };</para>
        <para>��� System.out.println(&quot;e.length = &quot; + e.length);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Here�s the output from the program:</para>
        <para>b.length = 5</para>
        <para>b[0]=null</para>
        <para>b[1]=null</para>
        <para>b[2]=null</para>
        <para>b[3]=null</para>
        <para>b[4]=null</para>
        <para>c.length = 4</para>
        <para>d.length = 3</para>
        <para>a.length = 3</para>
        <para>a.length = 2</para>
        <para>f.length = 5</para>
        <para>f[0]=0</para>
        <para>f[1]=0</para>
        <para>f[2]=0</para>
        <para>f[3]=0</para>
        <para>f[4]=0</para>
        <para>g.length = 4</para>
        <para>h.length = 3</para>
        <para>e.length = 3</para>
        <para>e.length = 2</para>
        <para> </para>
        <para>The array <emphasis role="bold">a</emphasis> is initially just a <emphasis role="bold">null </emphasis>reference, and the compiler prevents you from doing anything with this reference until you�ve properly initialized it. The array <emphasis role="bold">b</emphasis> is initialized to point to an array of <emphasis role="bold">Weeble</emphasis> references, but no actual <emphasis role="bold">Weeble</emphasis> objects are ever placed in that array. However, you can still ask what the size of the array is, since <emphasis role="bold">b</emphasis> is pointing to a legitimate object. This brings up a slight drawback: you can�t find out how many elements are actually <emphasis role="italic">in</emphasis> the array, since <emphasis role="bold">length</emphasis> tells you only how many elements <emphasis role="italic">can</emphasis> be placed in the array; that is, the size of the array object, not the number of elements it actually holds. However, when an array object is created its references are automatically initialized to <emphasis role="bold">null</emphasis>, so you can see whether a particular array slot has an object in it by checking to see whether it�s <emphasis role="bold">null</emphasis>. Similarly, an array of primitives is automatically initialized to zero for numeric types, <emphasis role="bold">(char)0 </emphasis>for <emphasis role="bold">char</emphasis>, and<emphasis role="bold"> false</emphasis> for <emphasis role="bold">boolean</emphasis>.</para>
        <para>Array <emphasis role="bold">c</emphasis> shows the creation of the array object followed by the assignment of <emphasis role="bold">Weeble</emphasis> objects to all the slots in the array. Array <emphasis role="bold">d</emphasis> shows the �aggregate initialization� syntax that causes the array object to be created (implicitly with <emphasis role="bold">new</emphasis> on the heap, just like for array <emphasis role="bold">c</emphasis>) <emphasis role="italic">and</emphasis> initialized with <emphasis role="bold">Weeble</emphasis> objects, all in one statement.</para>
        <para>The next array initialization could be thought of as a �dynamic aggregate initialization.� The aggregate initialization used by <emphasis role="bold">d</emphasis> must be used at the point of <emphasis role="bold">d</emphasis>�s definition, but with the second syntax you can create and initialize an array object anywhere. For example, suppose <emphasis role="bold">hide( )</emphasis> is a method that takes an array of <emphasis role="bold">Weeble</emphasis> objects. You could call it by saying:</para>
        <para>hide(d);</para>
        <para> </para>
        <para>but you can also dynamically create the array you want to pass as the argument:</para>
        <para>hide(new Weeble[] { new Weeble(), new Weeble() });</para>
        <para> </para>
        <para>In some situations this new syntax provides a more convenient way to write code.</para>
        <para>The expression</para>
        <para>a = d;</para>
        <para> </para>
        <para>shows how you can take a reference that�s attached to one array object and assign it to another array object, just as you can do with any other type of object reference. Now both <emphasis role="bold">a</emphasis> and <emphasis role="bold">d</emphasis> are pointing to the same array object on the heap.</para>
        <para>The second part of <emphasis role="bold">ArraySize.java</emphasis> shows that primitive arrays work just like object arrays <emphasis role="italic">except</emphasis> that primitive arrays hold the primitive values directly.</para>
        <section>
          <title><anchor xreflabel="Containers of primitives" xml:id="_Toc375545349"/>Containers of primitives</title>
          <para>Container classes can hold only references to objects. An array, however, can be created to hold primitives directly, as well as references to objects. It <emphasis role="italic">is</emphasis> possible to use the �wrapper� classes such as <emphasis role="bold">Integer</emphasis>, <emphasis role="bold">Double,</emphasis> etc. to place primitive values inside a container, but the wrapper classes for primitives can be awkward to use. In addition, it�s much more efficient to create and access an array of primitives than a container of wrapped primitives.</para>
          <para>Of course, if you�re using a primitive type and you need the flexibility of a container that automatically expands when more space is needed, the array won�t work and you�re forced to use a container of wrapped primitives. You might think that there should be a specialized type of <emphasis role="bold">ArrayList</emphasis> for each of the primitive data types, but Java doesn�t provide this for you. Some sort of templatizing mechanism might someday provide a better way for Java to handle this problem.<anchor xreflabel="[45]" xml:id="_ftnref45"/>[45]</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Returning an array" xml:id="_Toc481064667"/>Returning an array</title>
        <para>Suppose you�re writing a method and you don�t just want to return just one thing, but a whole bunch of things. Languages like C and C++ make this difficult because you can�t just return an array, only a pointer to an array. This introduces problems because it becomes messy to control the lifetime of the array, which easily leads to memory leaks.</para>
        <para>Java takes a similar approach, but you just �return an array.� Actually, of course, you�re returning a reference to an array, but with Java you never worry about responsibility for that array�it will be around as long as you need it, and the garbage collector will clean it up when you�re done.</para>
        <para>As an example, consider returning an array of <emphasis role="bold">String</emphasis>:</para>
        <para>//: c09:IceCream.java</para>
        <para>// Returning arrays from methods.</para>
        <para> </para>
        <para>public class IceCream {</para>
        <para>� static String[] flav = {</para>
        <para>��� &quot;Chocolate&quot;, &quot;Strawberry&quot;,</para>
        <para>��� &quot;Vanilla Fudge Swirl&quot;, &quot;Mint Chip&quot;,</para>
        <para>��� &quot;Mocha Almond Fudge&quot;, &quot;Rum Raisin&quot;,</para>
        <para>��� &quot;Praline Cream&quot;, &quot;Mud Pie&quot; </para>
        <para>� };</para>
        <para>� static String[] flavorSet(int n) {</para>
        <para>��� // Force it to be positive &amp; within bounds:</para>
        <para>��� n = Math.abs(n) % (flav.length + 1);</para>
        <para>��� String[] results = new String[n];</para>
        <para>��� boolean[] picked = </para>
        <para>����� new boolean[flav.length];</para>
        <para>��� for (int i = 0; i &lt; n; i++) {</para>
        <para>����� int t;</para>
        <para>����� do </para>
        <para>������� t = (int)(Math.random() * flav.length);</para>
        <para>����� while (picked[t]);</para>
        <para>����� results[i] = flav[t];</para>
        <para>����� picked[t] = true;</para>
        <para>��� }</para>
        <para>��� return results;</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� for(int i = 0; i &lt; 20; i++) {</para>
        <para>����� System.out.println(</para>
        <para>������� &quot;flavorSet(&quot; + i + &quot;) = &quot;);</para>
        <para>����� String[] fl = flavorSet(flav.length);</para>
        <para>����� for(int j = 0; j &lt; fl.length; j++)</para>
        <para>������� System.out.println(&quot;\t&quot; + fl[j]);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The method <emphasis role="bold">flavorSet( )</emphasis> creates an array of <emphasis role="bold">String</emphasis> called <emphasis role="bold">results</emphasis>. The size of this array is <emphasis role="bold">n</emphasis>, determined by the argument you pass into the method. Then it proceeds to choose flavors randomly from the array <emphasis role="bold">flav</emphasis> and place them into <emphasis role="bold">results</emphasis>, which it finally returns. Returning an array is just like returning any other object�it�s a reference. It�s not important that the array was created within <emphasis role="bold">flavorSet( )</emphasis>, or that the array was created anyplace else, for that matter. The garbage collector takes care of cleaning up the array when you�re done with it, and the array will persist for as long as you need it.</para>
        <para>As an aside, notice that when <emphasis role="bold">flavorSet( )</emphasis> chooses flavors randomly, it ensures that a random choice hasn�t been picked before. This is performed in a <emphasis role="bold">do</emphasis> loop that keeps making random choices until it finds one that�s not already in the <emphasis role="bold">picked</emphasis> array. (Of course, a <emphasis role="bold">String</emphasis> comparison could also have been performed to see if the random choice was already in the <emphasis role="bold">results</emphasis> array, but <emphasis role="bold">String</emphasis> comparisons are inefficient.) If it�s successful, it adds the entry and finds the next one (<emphasis role="bold">i </emphasis>gets incremented). </para>
        <para><emphasis role="bold">main( )</emphasis> prints out 20 full sets of flavors, so you can see that <emphasis role="bold">flavorSet( )</emphasis> chooses the flavors in a random order each time. It�s easiest to see this if you redirect the output into a file. And while you�re looking at the file, remember, you just <emphasis role="italic">want</emphasis> the ice cream, you don�t <emphasis role="italic">need</emphasis> it.</para>
      </section>
      <section>
        <title><anchor xreflabel="The Arrays class" xml:id="_Toc481064668"/>The <emphasis role="bold">Arrays</emphasis> class</title>
        <para>In <emphasis role="bold">java.util</emphasis>, you�ll find the <emphasis role="bold">Arrays</emphasis> class, which holds a set of <emphasis role="bold">static</emphasis> methods that perform utility functions for arrays. There are four basic functions: <emphasis role="bold">equals( )</emphasis>, to compare two arrays for equality; <emphasis role="bold">fill( )</emphasis>, to fill an array with a value; <emphasis role="bold">sort( )</emphasis>, to sort the array; and <emphasis role="bold">binarySearch( )</emphasis>, to find an element in a sorted array. All of these methods are overloaded for all the primitive types and <emphasis role="bold">Object</emphasis>s. In addition, there�s a single <emphasis role="bold">asList( )</emphasis> method that takes any array and turns it into a <emphasis role="bold">List</emphasis> container�which you�ll learn about later in this chapter.</para>
        <para>While useful, the <emphasis role="bold">Arrays</emphasis> class stops short of being fully functional. For example, it would be nice to be able to easily print the elements of an array without having to code a <emphasis role="bold">for</emphasis> loop by hand every time. And as you�ll see, the <emphasis role="bold">fill( )</emphasis> method only takes a single value and places it in the array, so if you wanted�for example�to fill an array with randomly generated numbers, <emphasis role="bold">fill( )</emphasis> is no help.</para>
        <para>Thus it makes sense to supplement the <emphasis role="bold">Arrays</emphasis> class with some additional utilities, which will be placed in the <emphasis role="bold">package</emphasis><emphasis role="bold">com.bruceeckel.util</emphasis> for convenience. These will print an array of any type, and fill an array with values or objects that are created by an object called a <emphasis role="italic">generator</emphasis> that you can define.</para>
        <para>Because code needs to be created for each primitive type as well as <emphasis role="bold">Object</emphasis>, there�s a lot of nearly duplicated code<anchor xreflabel="[46]" xml:id="_ftnref46"/>[46]. For example, a �generator� interface is required for each type because the return type of <emphasis role="bold">next( )</emphasis> must be different in each case:</para>
        <para>//: com:bruceeckel:util:Generator.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public interface Generator { </para>
        <para>� Object next(); </para>
        <para>} ///:~</para>
        <para> </para>
        <para>//: com:bruceeckel:util:BooleanGenerator.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public interface BooleanGenerator {</para>
        <para>� boolean next();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>//: com:bruceeckel:util:ByteGenerator.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public interface ByteGenerator {</para>
        <para>� byte next();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>//: com:bruceeckel:util:CharGenerator.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public interface CharGenerator {</para>
        <para>� char next();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>//: com:bruceeckel:util:ShortGenerator.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public interface ShortGenerator {</para>
        <para>� short next();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>//: com:bruceeckel:util:IntGenerator.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public interface IntGenerator {</para>
        <para>� int next();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>//: com:bruceeckel:util:LongGenerator.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public interface LongGenerator {</para>
        <para>� long next();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>//: com:bruceeckel:util:FloatGenerator.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public interface FloatGenerator {</para>
        <para>� float next();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>//: com:bruceeckel:util:DoubleGenerator.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public interface DoubleGenerator {</para>
        <para>� double next();</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">Arrays2</emphasis> contains a variety of <emphasis role="bold">print( )</emphasis> functions, overloaded for each type. You can simply print an array, you can add a message before the array is printed, or you can print a range of elements within an array. The <emphasis role="bold">print( )</emphasis> code is self-explanatory:</para>
        <para>//: com:bruceeckel:util:Arrays2.java</para>
        <para>// A supplement to java.util.Arrays, to provide</para>
        <para>// additional useful functionality when working</para>
        <para>// with arrays. Allows any array to be printed,</para>
        <para>// and to be filled via a user-defined </para>
        <para>// &quot;generator&quot; object.</para>
        <para>package com.bruceeckel.util;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class Arrays2 {</para>
        <para>� private static void</para>
        <para>� start(int from, int to, int length) {</para>
        <para>��� if(from != 0 || to != length)</para>
        <para>����� System.out.print(&quot;[&quot;+ from +&quot;:&quot;+ to +&quot;] &quot;);</para>
        <para>��� System.out.print(&quot;(&quot;);</para>
        <para>� }</para>
        <para>� private static void end() {</para>
        <para>��� System.out.println(&quot;)&quot;);</para>
        <para>� }</para>
        <para>� public static void print(Object[] a) {</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(String msg, Object[] a) {</para>
        <para>��� System.out.print(msg + &quot; &quot;);</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(Object[] a, int from, int to){</para>
        <para>��� start(from, to, a.length);</para>
        <para>��� for(int i = from; i &lt; to; i++) {</para>
        <para>����� System.out.print(a[i]);</para>
        <para>����� if(i &lt; to -1)</para>
        <para>������� System.out.print(&quot;, &quot;);</para>
        <para>��� }</para>
        <para>��� end();</para>
        <para>� }</para>
        <para>� public static void print(boolean[] a) {</para>
        <para>����� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(String msg, boolean[] a) {</para>
        <para>��� System.out.print(msg + &quot; &quot;);</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(boolean[] a, int from, int to) {</para>
        <para>��� start(from, to, a.length);</para>
        <para>��� for(int i = from; i &lt; to; i++) {</para>
        <para>����� System.out.print(a[i]);</para>
        <para>����� if(i &lt; to -1)</para>
        <para>������� System.out.print(&quot;, &quot;);</para>
        <para>��� }</para>
        <para>��� end();</para>
        <para>� }</para>
        <para>� public static void print(byte[] a) {</para>
        <para>����� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(String msg, byte[] a) {</para>
        <para>��� System.out.print(msg + &quot; &quot;);</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(byte[] a, int from, int to) {</para>
        <para>��� start(from, to, a.length);</para>
        <para>��� for(int i = from; i &lt; to; i++) {</para>
        <para>����� System.out.print(a[i]);</para>
        <para>����� if(i &lt; to -1)</para>
        <para>������� System.out.print(&quot;, &quot;);</para>
        <para>��� }</para>
        <para>��� end();</para>
        <para>� }</para>
        <para>� public static void print(char[] a) {</para>
        <para>����� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(String msg, char[] a) {</para>
        <para>��� System.out.print(msg + &quot; &quot;);</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(char[] a, int from, int to) {</para>
        <para>��� start(from, to, a.length);</para>
        <para>��� for(int i = from; i &lt; to; i++) {</para>
        <para>����� System.out.print(a[i]);</para>
        <para>����� if(i &lt; to -1)</para>
        <para>������� System.out.print(&quot;, &quot;);</para>
        <para>��� }</para>
        <para>��� end();</para>
        <para>� }</para>
        <para>� public static void print(short[] a) {</para>
        <para>����� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(String msg, short[] a) {</para>
        <para>��� System.out.print(msg + &quot; &quot;);</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(short[] a, int from, int to) {</para>
        <para>��� start(from, to, a.length);</para>
        <para>��� for(int i = from; i &lt; to; i++) {</para>
        <para>����� System.out.print(a[i]);</para>
        <para>����� if(i &lt; to - 1)</para>
        <para>������� System.out.print(&quot;, &quot;);</para>
        <para>��� }</para>
        <para>��� end();</para>
        <para>� }</para>
        <para>� public static void print(int[] a) {</para>
        <para>����� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(String msg, int[] a) {</para>
        <para>��� System.out.print(msg + &quot; &quot;);</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(int[] a, int from, int to) {</para>
        <para>��� start(from, to, a.length);</para>
        <para>��� for(int i = from; i &lt; to; i++) {</para>
        <para>����� System.out.print(a[i]);</para>
        <para>����� if(i &lt; to - 1)</para>
        <para>������� System.out.print(&quot;, &quot;);</para>
        <para>��� }</para>
        <para>��� end();</para>
        <para>� }</para>
        <para>� public static void print(long[] a) {</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(String msg, long[] a) {</para>
        <para>��� System.out.print(msg + &quot; &quot;);</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(long[] a, int from, int to) {</para>
        <para>��� start(from, to, a.length);</para>
        <para>��� for(int i = from; i &lt; to; i++) {</para>
        <para>����� System.out.print(a[i]);</para>
        <para>����� if(i &lt; to - 1)</para>
        <para>������� System.out.print(&quot;, &quot;);</para>
        <para>��� }</para>
        <para>��� end();</para>
        <para>� }</para>
        <para>� public static void print(float[] a) {</para>
        <para>����� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(String msg, float[] a) {</para>
        <para>��� System.out.print(msg + &quot; &quot;);</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(float[] a, int from, int to) {</para>
        <para>��� start(from, to, a.length);</para>
        <para>��� for(int i = from; i &lt; to; i++) {</para>
        <para>����� System.out.print(a[i]);</para>
        <para>����� if(i &lt; to - 1)</para>
        <para>������� System.out.print(&quot;, &quot;);</para>
        <para>��� }</para>
        <para>��� end();</para>
        <para>� }</para>
        <para>� public static void print(double[] a) {</para>
        <para>����� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(String msg, double[] a) {</para>
        <para>��� System.out.print(msg + &quot; &quot;);</para>
        <para>��� print(a, 0, a.length);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� print(double[] a, int from, int to){</para>
        <para>��� start(from, to, a.length);</para>
        <para>��� for(int i = from; i &lt; to; i++) {</para>
        <para>����� System.out.print(a[i]);</para>
        <para>����� if(i &lt; to - 1)</para>
        <para>������� System.out.print(&quot;, &quot;);</para>
        <para>��� }</para>
        <para>��� end();</para>
        <para>� }</para>
        <para>� // Fill an array using a generator:</para>
        <para>� public static void </para>
        <para>� fill(Object[] a, Generator gen) {</para>
        <para>����� fill(a, 0, a.length, gen);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(Object[] a, int from, int to, </para>
        <para>������ Generator gen){</para>
        <para>��� for(int i = from; i &lt; to; i++)</para>
        <para>����� a[i] = gen.next();</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(boolean[] a, BooleanGenerator gen) {</para>
        <para>����� fill(a, 0, a.length, gen);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(boolean[] a, int from, int to,</para>
        <para>������ BooleanGenerator gen) {</para>
        <para>��� for(int i = from; i &lt; to; i++)</para>
        <para>����� a[i] = gen.next();</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(byte[] a, ByteGenerator gen) {</para>
        <para>����� fill(a, 0, a.length, gen);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(byte[] a, int from, int to, </para>
        <para>������ ByteGenerator gen) {</para>
        <para>��� for(int i = from; i &lt; to; i++)</para>
        <para>����� a[i] = gen.next();</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(char[] a, CharGenerator gen) {</para>
        <para>����� fill(a, 0, a.length, gen);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(char[] a, int from, int to, </para>
        <para>������ CharGenerator gen) {</para>
        <para>��� for(int i = from; i &lt; to; i++)</para>
        <para>����� a[i] = gen.next();</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(short[] a, ShortGenerator gen) {</para>
        <para>����� fill(a, 0, a.length, gen);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(short[] a, int from, int to, </para>
        <para>������ ShortGenerator gen) {</para>
        <para>��� for(int i = from; i &lt; to; i++)</para>
        <para>����� a[i] = gen.next();</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(int[] a, IntGenerator gen) {</para>
        <para>����� fill(a, 0, a.length, gen);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(int[] a, int from, int to, </para>
        <para>������ IntGenerator gen) {</para>
        <para>��� for(int i = from; i &lt; to; i++)</para>
        <para>����� a[i] = gen.next();</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(long[] a, LongGenerator gen) {</para>
        <para>����� fill(a, 0, a.length, gen);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(long[] a, int from, int to, </para>
        <para>������ LongGenerator gen) {</para>
        <para>��� for(int i = from; i &lt; to; i++)</para>
        <para>����� a[i] = gen.next();</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(float[] a, FloatGenerator gen) {</para>
        <para>����� fill(a, 0, a.length, gen);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(float[] a, int from, int to, </para>
        <para>������ FloatGenerator gen) {</para>
        <para>��� for(int i = from; i &lt; to; i++)</para>
        <para>����� a[i] = gen.next();</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(double[] a, DoubleGenerator gen) {</para>
        <para>����� fill(a, 0, a.length, gen);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(double[] a, int from, int to,</para>
        <para>������ DoubleGenerator gen){</para>
        <para>��� for(int i = from; i &lt; to; i++)</para>
        <para>����� a[i] = gen.next();</para>
        <para>� }</para>
        <para>� private static Random r = new Random();</para>
        <para>� public static class RandBooleanGenerator </para>
        <para>� implements BooleanGenerator {</para>
        <para>��� public boolean next() { </para>
        <para>����� return r.nextBoolean();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static class RandByteGenerator </para>
        <para>� implements ByteGenerator {</para>
        <para>��� public byte next() { </para>
        <para>����� return (byte)r.nextInt();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� static String ssource = </para>
        <para>��� &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; +</para>
        <para>��� &quot;abcdefghijklmnopqrstuvwxyz&quot;;</para>
        <para>� static char[] src = ssource.toCharArray();</para>
        <para>� public static class RandCharGenerator </para>
        <para>� implements CharGenerator {</para>
        <para>��� public char next() {</para>
        <para>����� int pos = Math.abs(r.nextInt());</para>
        <para>����� return src[pos % src.length];</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static class RandStringGenerator</para>
        <para>� implements Generator {</para>
        <para>��� private int len;</para>
        <para>��� private RandCharGenerator cg = </para>
        <para>����� new RandCharGenerator();</para>
        <para>��� public RandStringGenerator(int length) {</para>
        <para>����� len = length;</para>
        <para>��� }</para>
        <para>��� public Object next() {</para>
        <para>����� char[] buf = new char[len];</para>
        <para>����� for(int i = 0; i &lt; len; i++)</para>
        <para>������� buf[i] = cg.next();</para>
        <para>����� return new String(buf);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static class RandShortGenerator </para>
        <para>� implements ShortGenerator {</para>
        <para>��� public short next() { </para>
        <para>����� return (short)r.nextInt();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static class RandIntGenerator </para>
        <para>� implements IntGenerator {</para>
        <para>��� private int mod = 10000;</para>
        <para>��� public RandIntGenerator() {}</para>
        <para>��� public RandIntGenerator(int modulo) {</para>
        <para>����� mod = modulo;</para>
        <para>��� }</para>
        <para>��� public int next() { </para>
        <para>����� return r.nextInt() % mod; </para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static class RandLongGenerator </para>
        <para>� implements LongGenerator {</para>
        <para>��� public long next() { return r.nextLong(); }</para>
        <para>� }</para>
        <para>� public static class RandFloatGenerator </para>
        <para>� implements FloatGenerator {</para>
        <para>��� public float next() { return r.nextFloat(); }</para>
        <para>� }</para>
        <para>� public static class RandDoubleGenerator </para>
        <para>� implements DoubleGenerator {</para>
        <para>��� public double next() {return r.nextDouble();}</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>To fill an array of elements using a generator, the <emphasis role="bold">fill( )</emphasis> method takes a reference to an appropriate generator <emphasis role="bold">interface</emphasis>, which has a <emphasis role="bold">next( )</emphasis> method that will somehow produce an object of the right type (depending on how the interface is implemented). The <emphasis role="bold">fill( )</emphasis> method simply calls <emphasis role="bold">next( )</emphasis> until the desired range has been filled. Now you can create any generator by implementing the appropriate <emphasis role="bold">interface</emphasis>, and use your generator with <emphasis role="bold">fill( )</emphasis>.</para>
        <para>Random data generators are useful for testing, so a set of inner classes is created to implement all the primitive generator interfaces, as well as a <emphasis role="bold">String</emphasis> generator to represent <emphasis role="bold">Object</emphasis>. You can see that <emphasis role="bold">RandStringGenerator</emphasis> uses <emphasis role="bold">RandCharGenerator</emphasis> to fill an array of characters, which is then turned into a <emphasis role="bold">String</emphasis>. The size of the array is determined by the constructor argument.</para>
        <para>To generate numbers that aren�t too large, <emphasis role="bold">RandIntGenerator</emphasis> defaults to a modulus of 10,000, but the overloaded constructor allows you to choose a smaller value.</para>
        <para>Here�s a program to test the library, and to demonstrate how it is used:</para>
        <para>//: c09:TestArrays2.java</para>
        <para>// Test and demonstrate Arrays2 utilities</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>public class TestArrays2 {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int size = 6;</para>
        <para>��� // Or get the size from the command line:</para>
        <para>��� if(args.length != 0)</para>
        <para>����� size = Integer.parseInt(args[0]);</para>
        <para>��� boolean[] a1 = new boolean[size];</para>
        <para>��� byte[] a2 = new byte[size];</para>
        <para>��� char[] a3 = new char[size];</para>
        <para>��� short[] a4 = new short[size];</para>
        <para>��� int[] a5 = new int[size];</para>
        <para>��� long[] a6 = new long[size];</para>
        <para>��� float[] a7 = new float[size];</para>
        <para>��� double[] a8 = new double[size];</para>
        <para>��� String[] a9 = new String[size];</para>
        <para>��� Arrays2.fill(a1, </para>
        <para>����� new Arrays2.RandBooleanGenerator());</para>
        <para>��� Arrays2.print(a1);</para>
        <para>��� Arrays2.print(&quot;a1 = &quot;, a1);</para>
        <para>��� Arrays2.print(a1, size/3, size/3 + size/3);</para>
        <para>��� Arrays2.fill(a2,</para>
        <para>����� new Arrays2.RandByteGenerator());</para>
        <para>��� Arrays2.print(a2);</para>
        <para>��� Arrays2.print(&quot;a2 = &quot;, a2);</para>
        <para>��� Arrays2.print(a2, size/3, size/3 + size/3);</para>
        <para>��� Arrays2.fill(a3,</para>
        <para>����� new Arrays2.RandCharGenerator());</para>
        <para>��� Arrays2.print(a3);</para>
        <para>��� Arrays2.print(&quot;a3 = &quot;, a3);</para>
        <para>��� Arrays2.print(a3, size/3, size/3 + size/3);</para>
        <para>��� Arrays2.fill(a4,</para>
        <para>����� new Arrays2.RandShortGenerator());</para>
        <para>��� Arrays2.print(a4);</para>
        <para>��� Arrays2.print(&quot;a4 = &quot;, a4);</para>
        <para>��� Arrays2.print(a4, size/3, size/3 + size/3);</para>
        <para>��� Arrays2.fill(a5,</para>
        <para>����� new Arrays2.RandIntGenerator());</para>
        <para>��� Arrays2.print(a5);</para>
        <para>��� Arrays2.print(&quot;a5 = &quot;, a5);</para>
        <para>��� Arrays2.print(a5, size/3, size/3 + size/3);</para>
        <para>��� Arrays2.fill(a6,</para>
        <para>����� new Arrays2.RandLongGenerator());</para>
        <para>��� Arrays2.print(a6);</para>
        <para>��� Arrays2.print(&quot;a6 = &quot;, a6);</para>
        <para>��� Arrays2.print(a6, size/3, size/3 + size/3);</para>
        <para>��� Arrays2.fill(a7,</para>
        <para>����� new Arrays2.RandFloatGenerator());</para>
        <para>��� Arrays2.print(a7);</para>
        <para>��� Arrays2.print(&quot;a7 = &quot;, a7);</para>
        <para>��� Arrays2.print(a7, size/3, size/3 + size/3);</para>
        <para>��� Arrays2.fill(a8,</para>
        <para>����� new Arrays2.RandDoubleGenerator());</para>
        <para>��� Arrays2.print(a8);</para>
        <para>��� Arrays2.print(&quot;a8 = &quot;, a8);</para>
        <para>��� Arrays2.print(a8, size/3, size/3 + size/3);</para>
        <para>��� Arrays2.fill(a9,</para>
        <para>����� new Arrays2.RandStringGenerator(7));</para>
        <para>��� Arrays2.print(a9);</para>
        <para>��� Arrays2.print(&quot;a9 = &quot;, a9);</para>
        <para>��� Arrays2.print(a9, size/3, size/3 + size/3);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">size</emphasis> parameter has a default value, but you can also set it from the command line.</para>
      </section>
      <section>
        <title><anchor xreflabel="Filling an array" xml:id="_Toc481064669"/>Filling an array</title>
        <para>The Java standard library <emphasis role="bold">Arrays</emphasis> also has a <emphasis role="bold">fill( )</emphasis> method, but that is rather trivial�it only duplicates a single value into each location, or in the case of objects, copies the same reference into each location. Using <emphasis role="bold">Arrays2.print( )</emphasis>, the <emphasis role="bold">Arrays.fill( )</emphasis> methods can be easily demonstrated:</para>
        <para>//: c09:FillingArrays.java</para>
        <para>// Using Arrays.fill()</para>
        <para>import com.bruceeckel.util.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class FillingArrays {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int size = 6;</para>
        <para>��� // Or get the size from the command line:</para>
        <para>��� if(args.length != 0)</para>
        <para>����� size = Integer.parseInt(args[0]);</para>
        <para>��� boolean[] a1 = new boolean[size];</para>
        <para>��� byte[] a2 = new byte[size];</para>
        <para>��� char[] a3 = new char[size];</para>
        <para>��� short[] a4 = new short[size];</para>
        <para>��� int[] a5 = new int[size];</para>
        <para>� ��long[] a6 = new long[size];</para>
        <para>��� float[] a7 = new float[size];</para>
        <para>��� double[] a8 = new double[size];</para>
        <para>��� String[] a9 = new String[size];</para>
        <para>��� Arrays.fill(a1, true);</para>
        <para>��� Arrays2.print(&quot;a1 = &quot;, a1);</para>
        <para>��� Arrays.fill(a2, (byte)11);</para>
        <para>��� Arrays2.print(&quot;a2 = &quot;, a2);</para>
        <para>��� Arrays.fill(a3, &apos;x&apos;);</para>
        <para>��� Arrays2.print(&quot;a3 = &quot;, a3);</para>
        <para>��� Arrays.fill(a4, (short)17);</para>
        <para>��� Arrays2.print(&quot;a4 = &quot;, a4);</para>
        <para>��� Arrays.fill(a5, 19);</para>
        <para>��� Arrays2.print(&quot;a5 = &quot;, a5);</para>
        <para>��� Arrays.fill(a6, 23);</para>
        <para>��� Arrays2.print(&quot;a6 = &quot;, a6);</para>
        <para>��� Arrays.fill(a7, 29);</para>
        <para>��� Arrays2.print(&quot;a7 = &quot;, a7);</para>
        <para>��� Arrays.fill(a8, 47);</para>
        <para>��� Arrays2.print(&quot;a8 = &quot;, a8);</para>
        <para>��� Arrays.fill(a9, &quot;Hello&quot;);</para>
        <para>��� Arrays2.print(&quot;a9 = &quot;, a9);</para>
        <para>��� // Manipulating ranges:</para>
        <para>��� Arrays.fill(a9, 3, 5, &quot;World&quot;);</para>
        <para>��� Arrays2.print(&quot;a9 = &quot;, a9);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can either fill the entire array, or�as the last two statements show�a range of elements. But since you can only provide a single value to use for filling using <emphasis role="bold">Arrays.fill( )</emphasis>, the <emphasis role="bold">Arrays2.fill( )</emphasis> methods produce much more interesting results.</para>
      </section>
      <section>
        <title><anchor xreflabel="Copying an array" xml:id="_Toc481064670"/>Copying an array</title>
        <para>The Java standard library provides a <emphasis role="bold">static </emphasis>method, <emphasis role="bold">System.arraycopy( )</emphasis>, which can make much faster copies of an array than if you use a <emphasis role="bold">for</emphasis> loop to perform the copy by hand. <emphasis role="bold">System.arraycopy( ) </emphasis>is overloaded to handle all types. Here�s an example that manipulates arrays of <emphasis role="bold">int</emphasis>:</para>
        <para>//: c09:CopyingArrays.java</para>
        <para>// Using System.arraycopy()</para>
        <para>import com.bruceeckel.util.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class CopyingArrays {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int[] i = new int[25];</para>
        <para>��� int[] j = new int[25];</para>
        <para>��� Arrays.fill(i, 47);</para>
        <para>��� Arrays.fill(j, 99);</para>
        <para>��� Arrays2.print(&quot;i = &quot;, i);</para>
        <para>��� Arrays2.print(&quot;j = &quot;, j);</para>
        <para>��� System.arraycopy(i, 0, j, 0, i.length);</para>
        <para>��� Arrays2.print(&quot;j = &quot;, j);</para>
        <para>��� int[] k = new int[10];</para>
        <para>��� Arrays.fill(k, 103);</para>
        <para>��� System.arraycopy(i, 0, k, 0, k.length);</para>
        <para>��� Arrays2.print(&quot;k = &quot;, k);</para>
        <para>��� Arrays.fill(k, 103);</para>
        <para>��� System.arraycopy(k, 0, i, 0, k.length);</para>
        <para>��� Arrays2.print(&quot;i = &quot;, i);</para>
        <para>��� // Objects:</para>
        <para>��� Integer[] u = new Integer[10];</para>
        <para>��� Integer[] v = new Integer[5];</para>
        <para>��� Arrays.fill(u, new Integer(47));</para>
        <para>��� Arrays.fill(v, new Integer(99));</para>
        <para>��� Arrays2.print(&quot;u = &quot;, u);</para>
        <para>��� Arrays2.print(&quot;v = &quot;, v);</para>
        <para>��� System.arraycopy(v, 0, </para>
        <para>����� u, u.length/2, v.length);</para>
        <para>��� Arrays2.print(&quot;u = &quot;, u);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The arguments to <emphasis role="bold">arraycopy( )</emphasis> are the source array, the offset into the source array from whence to start copying, the destination array, the offset into the destination array where the copying begins, and the number of elements to copy. Naturally, any violation of the array boundaries will cause an exception.</para>
        <para>The example shows that both primitive arrays and object arrays can be copied. However, if you copy arrays of objects then only the references get copied�there�s no duplication of the objects themselves. This is called a <emphasis role="italic">shallow copy</emphasis> (see Appendix A).</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545350"/><anchor xreflabel="Comparing
arrays" xml:id="_Toc481064671"/>Comparing arrays</title>
        <para><emphasis role="bold">Arrays</emphasis> provides the overloaded method <emphasis role="bold">equals( )</emphasis> to compare entire arrays for equality. Again, these are overloaded for all the primitives, and for <emphasis role="bold">Object</emphasis>. To be equal, the arrays must have the same number of elements and each element must be equivalent to each corresponding element in the other array, using the <emphasis role="bold">equals( ) </emphasis>for each element. (For primitives, that primitive�s wrapper class <emphasis role="bold">equals( )</emphasis> is used; for example, <emphasis role="bold">Integer.equals( ) </emphasis>for <emphasis role="bold">int</emphasis>.)<emphasis role="bold"/>Here�s an example:</para>
        <para>//: c09:ComparingArrays.java</para>
        <para>// Using Arrays.equals()</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class ComparingArrays {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int[] a1 = new int[10];</para>
        <para>��� int[] a2 = new int[10];</para>
        <para>��� Arrays.fill(a1, 47);</para>
        <para>��� Arrays.fill(a2, 47);</para>
        <para>��� System.out.println(Arrays.equals(a1, a2));</para>
        <para>��� a2[3] = 11;</para>
        <para>��� System.out.println(Arrays.equals(a1, a2));</para>
        <para>��� String[] s1 = new String[5];</para>
        <para>��� Arrays.fill(s1, &quot;Hi&quot;);</para>
        <para>��� String[] s2 = {&quot;Hi&quot;, &quot;Hi&quot;, &quot;Hi&quot;, &quot;Hi&quot;, &quot;Hi&quot;};</para>
        <para>��� System.out.println(Arrays.equals(s1, s2));</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Originally, <emphasis role="bold">a1</emphasis> and <emphasis role="bold">a2</emphasis> are exactly equal, so the output is �true,� but then one of the elements is changed so the second line of output is �false.� In the last case, all the elements of <emphasis role="bold">s1</emphasis> point to the same object, but <emphasis role="bold">s2</emphasis> has five unique objects. However, array equality is based on contents (via <emphasis role="bold">Object.equals( )</emphasis>) and so the result is �true.�</para>
      </section>
      <section>
        <title><anchor xreflabel="Array element comparisons" xml:id="_Toc481064672"/>Array element comparisons</title>
        <para>One of the missing features in the Java 1.0 and 1.1 libraries is algorithmic operations�even simple sorting. This was a rather confusing situation to someone expecting an adequate standard library. Fortunately, Java 2 remedies the situation, at least for the sorting problem.</para>
        <para>A problem with writing generic sorting code is that sorting must perform comparisons based on the actual type of the object. Of course, one approach is to write a different sorting method for every different type, but you should be able to recognize that this does not produce code that is easily reused for new types.</para>
        <para>A primary goal of programming design is to �separate things that change from things that stay the same,� and here, the code that stays the same is the general sort algorithm, but the thing that changes from one use to the next is the way objects are compared. So instead of hard-wiring the comparison code into many different sort routines, the technique of the <emphasis role="italic">callback</emphasis> is used. With a callback, the part of the code that varies from case to case is encapsulated inside its own class, and the part of the code that�s always the same will call back to the code that changes. That way you can make different objects to express different ways of comparison and feed them to the same sorting code.</para>
        <para>In Java 2, there are two ways to provide comparison functionality. The first is with the <emphasis role="italic">natural comparison method</emphasis> that is imparted to a class by implementing the <emphasis role="bold">java.lang.Comparable</emphasis> interface. This is a very simple interface with a single method, <emphasis role="bold">compareTo( )</emphasis>. This method takes another <emphasis role="bold">Object</emphasis> as an argument, and produces a negative value if the argument is less than the current object, zero if the argument is equal, and a positive value if the argument is greater than the current object.</para>
        <para>Here�s a class that implements <emphasis role="bold">Comparable</emphasis> and demonstrates the comparability by using the Java standard library method <emphasis role="bold">Arrays.sort( )</emphasis>:</para>
        <para>//: c09:CompType.java</para>
        <para>// Implementing Comparable in a class.</para>
        <para>import com.bruceeckel.util.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class CompType implements Comparable {</para>
        <para>� int i;</para>
        <para>� int j;</para>
        <para>� public CompType(int n1, int n2) { </para>
        <para>��� i = n1;</para>
        <para>��� j = n2;</para>
        <para>� }</para>
        <para>� public String toString() { </para>
        <para>��� return &quot;[i = &quot; + i + &quot;, j = &quot; + j + &quot;]&quot;;</para>
        <para>� }</para>
        <para>� public int compareTo(Object rv) {</para>
        <para>��� int rvi = ((CompType)rv).i;</para>
        <para>��� return (i &lt; rvi ? -1 : (i == rvi ? 0 : 1));</para>
        <para>� }</para>
        <para>� private static Random r = new Random();</para>
        <para>� private static int randInt() {</para>
        <para>��� return Math.abs(r.nextInt()) % 100;</para>
        <para>� }</para>
        <para>� public static Generator generator() {</para>
        <para>��� return new Generator() {</para>
        <para>����� public Object next() {</para>
        <para>������� return new CompType(randInt(),randInt());</para>
        <para>����� }</para>
        <para>��� };</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� CompType[] a = new CompType[10];</para>
        <para>��� Arrays2.fill(a, generator());</para>
        <para>��� Arrays2.print(&quot;before sorting, a = &quot;, a);</para>
        <para>��� Arrays.sort(a);</para>
        <para>��� Arrays2.print(&quot;after sorting, a = &quot;, a);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>When you define the comparison function, you are responsible for deciding what it means to compare one of your objects to another. Here, only the <emphasis role="bold">i</emphasis> values are used in the comparison, and the <emphasis role="bold">j</emphasis> values are ignored.</para>
        <para>The <emphasis role="bold">static randInt( )</emphasis> method produces positive values between zero and 100, and the <emphasis role="bold">generator( )</emphasis> method produces an object that implements the <emphasis role="bold">Generator</emphasis> interface, by creating an anonymous inner class (see Chapter 8). This builds <emphasis role="bold">CompType</emphasis> objects by initializing them with random values. In <emphasis role="bold">main( )</emphasis>, the generator is used to fill an array of <emphasis role="bold">CompType</emphasis>, which is then sorted. If <emphasis role="bold">Comparable</emphasis> hadn�t been implemented, then you�d get a compile-time error message when you tried to call <emphasis role="bold">sort( )</emphasis>.</para>
        <para>Now suppose someone hands you a class that doesn�t implement <emphasis role="bold">Comparable</emphasis>, or they hand you this class that <emphasis role="italic">does</emphasis> implement <emphasis role="bold">Comparable</emphasis>, but you decide you don�t like the way it works and would rather have a different comparison function for the type. To do this, you use the second approach for comparing objects, by creating a separate class that implements an interface called <emphasis role="bold">Comparator</emphasis>. This has two methods, <emphasis role="bold">compare( )</emphasis> and <emphasis role="bold">equals( )</emphasis>. However, you don�t have to implement <emphasis role="bold">equals( )</emphasis> except for special performance needs, because anytime you create a class it is implicitly inherited from <emphasis role="bold">Object</emphasis>, which has an <emphasis role="bold">equals( )</emphasis>. So you can just use the default <emphasis role="bold">Object</emphasis><emphasis role="bold">equals( )</emphasis> and satisfy the contract imposed by the interface.</para>
        <para>The <emphasis role="bold">Collections</emphasis> class (which we�ll look at more later) contains a single <emphasis role="bold">Comparator</emphasis> that reverses the natural sorting order. This can easily be applied to the <emphasis role="bold">CompType</emphasis>:</para>
        <para>//: c09:Reverse.java</para>
        <para>// The Collecions.reverseOrder() Comparator.</para>
        <para>import com.bruceeckel.util.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class Reverse {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� CompType[] a = new CompType[10];</para>
        <para>��� Arrays2.fill(a, CompType.generator());</para>
        <para>��� Arrays2.print(&quot;before sorting, a = &quot;, a);</para>
        <para>��� Arrays.sort(a, Collections.reverseOrder());</para>
        <para>��� Arrays2.print(&quot;after sorting, a = &quot;, a);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The call to <emphasis role="bold">Collections.reverseOrder( )</emphasis> produces the reference to the <emphasis role="bold">Comparator</emphasis>.</para>
        <para>As a second example, the following <emphasis role="bold">Comparator</emphasis> compares <emphasis role="bold">CompType</emphasis> objects based on their <emphasis role="bold">j</emphasis> values rather than their <emphasis role="bold">i</emphasis> values:</para>
        <para>//: c09:ComparatorTest.java</para>
        <para>// Implementing a Comparator for a class.</para>
        <para>import com.bruceeckel.util.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class CompTypeComparator implements Comparator {</para>
        <para>� public int compare(Object o1, Object o2) {</para>
        <para>��� int j1 = ((CompType)o1).j;</para>
        <para>��� int j2 = ((CompType)o2).j;</para>
        <para>��� return (j1 &lt; j2 ? -1 : (j1 == j2 ? 0 : 1));</para>
        <para>� }</para>
        <para>}</para>
        <para>���������� </para>
        <para>public class ComparatorTest {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� CompType[] a = new CompType[10];</para>
        <para>��� Arrays2.fill(a, CompType.generator());</para>
        <para>��� Arrays2.print(&quot;before sorting, a = &quot;, a);</para>
        <para>��� Arrays.sort(a, new CompTypeComparator());</para>
        <para>��� Arrays2.print(&quot;after sorting, a = &quot;, a);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">compare( )</emphasis> method must return a negative integer, zero, or a positive integer if the first argument is less than, equal to, or greater than the second, respectively.</para>
      </section>
      <section>
        <title><anchor xreflabel="Sorting an array" xml:id="_Toc481064673"/>Sorting an array</title>
        <para>With the built-in sorting methods, you can sort any array of primitives, and any array of objects that either implements <emphasis role="bold">Comparable</emphasis> or has an associated <emphasis role="bold">Comparator</emphasis>. This fills a big hole in the Java libraries�believe it or not, there was no support in Java 1.0 or 1.1 for sorting <emphasis role="bold">String</emphasis>s! Here�s an example that generates random <emphasis role="bold">String</emphasis> objects and sorts them:</para>
        <para>//: c09:StringSorting.java</para>
        <para>// Sorting an array of Strings.</para>
        <para>import com.bruceeckel.util.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class StringSorting {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� String[] sa = new String[30];</para>
        <para>��� Arrays2.fill(sa,</para>
        <para>����� new Arrays2.RandStringGenerator(5));</para>
        <para>��� Arrays2.print(&quot;Before sorting: &quot;, sa);</para>
        <para>��� Arrays.sort(sa);</para>
        <para>��� Arrays2.print(&quot;After sorting: &quot;, sa);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>One thing you�ll notice about the output in the <emphasis role="bold">String</emphasis> sorting algorithm is that it�s <emphasis role="italic">lexicographic</emphasis>, so it puts all the words starting with uppercase letters first, followed by all the words starting with lowercase letters. (Telephone books are typically sorted this way.) You may also want to group the words together regardless of case, and you can do this by defining a <emphasis role="bold">Comparator </emphasis>class, thereby overriding the default <emphasis role="bold">String Comparable </emphasis>behavior. For reuse, this will be added to the �util� package:</para>
        <para>//: com:bruceeckel:util:AlphabeticComparator.java</para>
        <para>// Keeping upper and lowercase letters together.</para>
        <para>package com.bruceeckel.util;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class AlphabeticComparator </para>
        <para>implements Comparator{</para>
        <para>� public int compare(Object o1, Object o2) {</para>
        <para>��� String s1 = (String)o1;</para>
        <para>��� String s2 = (String)o2;</para>
        <para>��� return s1.toLowerCase().compareTo(</para>
        <para>����� s2.toLowerCase());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Each <emphasis role="bold">String</emphasis> is converted to lowercase before the comparison. <emphasis role="bold">String</emphasis>�s built-in <emphasis role="bold">compareTo( )</emphasis> method provides the desired functionality.</para>
        <para>Here�s a test using <emphasis role="bold">AlphabeticComparator</emphasis>:</para>
        <para>//: c09:AlphabeticSorting.java</para>
        <para>// Keeping upper and lowercase letters together.</para>
        <para>import com.bruceeckel.util.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class AlphabeticSorting {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� String[] sa = new String[30];</para>
        <para>��� Arrays2.fill(sa,</para>
        <para>����� new Arrays2.RandStringGenerator(5));</para>
        <para>��� Arrays2.print(&quot;Before sorting: &quot;, sa);</para>
        <para>��� Arrays.sort(sa, new AlphabeticComparator());</para>
        <para>��� Arrays2.print(&quot;After sorting: &quot;, sa);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The sorting algorithm that�s used in the Java standard library is designed to be optimal for the particular type you�re sorting�a Quicksort for primitives, and a stable merge sort for objects. So you shouldn�t need to spend any time worrying about performance unless your profiling tool points you to the sorting process as a bottleneck.</para>
      </section>
      <section>
        <title><anchor xreflabel="Searching a sorted array" xml:id="_Toc481064674"/>Searching a sorted array</title>
        <para>Once an array is sorted, you can perform a fast search for a particular item using <emphasis role="bold">Arrays.binarySearch( )</emphasis>. However, it�s very important that you do not try to use <emphasis role="bold">binarySearch( )</emphasis> on an unsorted array; the results will be unpredictable. The following example uses a <emphasis role="bold">RandIntGenerator</emphasis> to fill an array, then to produces values to search for:</para>
        <para>//: c09:ArraySearching.java</para>
        <para>// Using Arrays.binarySearch().</para>
        <para>import com.bruceeckel.util.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class ArraySearching {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int[] a = new int[100];</para>
        <para>��� Arrays2.RandIntGenerator gen = </para>
        <para>����� new Arrays2.RandIntGenerator(1000);</para>
        <para>��� Arrays2.fill(a, gen);</para>
        <para>��� Arrays.sort(a);</para>
        <para>��� Arrays2.print(&quot;Sorted array: &quot;, a);</para>
        <para>��� while(true) {</para>
        <para>����� int r = gen.next();</para>
        <para>����� int location = Arrays.binarySearch(a, r);</para>
        <para>����� if(location &gt;= 0) {</para>
        <para>������� System.out.println(&quot;Location of &quot; + r + </para>
        <para>��������� &quot; is &quot; + location + &quot;, a[&quot; + </para>
        <para>��������� location + &quot;] = &quot; + a[location]);</para>
        <para>������� break; // Out of while loop</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In the <emphasis role="bold">while</emphasis> loop, random values are generated as search items, until one of them is found.</para>
        <para><emphasis role="bold">Arrays.binarySearch( )</emphasis> produces a value greater than or equal to zero if the search item is found. Otherwise, it produces a negative value representing the place that the element should be inserted if you are maintaining the sorted array by hand. The value produced is </para>
        <para>-(insertion point) - 1</para>
        <para> </para>
        <para>The insertion point is the index of the first element greater than the key, or <emphasis role="bold">a.size( )</emphasis>, if all elements in the array are less than the specified key.</para>
        <para>If the array contains duplicate elements, there is no guarantee which one will be found. The algorithm is thus not really designed to support duplicate elements, as much as tolerate them. If you need a sorted list of nonduplicated elements, however, use a <emphasis role="bold">TreeSet</emphasis>, which will be introduced later in this chapter. This takes care of all the details for you automatically. Only in cases of performance bottlenecks should you replace the <emphasis role="bold">TreeSet</emphasis> with a hand-maintained array.</para>
        <para>If you have sorted an object array using a <emphasis role="bold">Comparator</emphasis> (primitive arrays do not allow sorting with a <emphasis role="bold">Comparator</emphasis>), you must include that same <emphasis role="bold">Comparator</emphasis> when you perform a <emphasis role="bold">binarySearch( )</emphasis> (using the overloaded version of the function that�s provided). For example, the <emphasis role="bold">AlphabeticSorting.java</emphasis> program can be modified to perform a search:</para>
        <para>//: c09:AlphabeticSearch.java</para>
        <para>// Searching with a Comparator.</para>
        <para>import com.bruceeckel.util.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class AlphabeticSearch {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� String[] sa = new String[30];</para>
        <para>��� Arrays2.fill(sa,</para>
        <para>����� new Arrays2.RandStringGenerator(5));</para>
        <para>��� AlphabeticComparator comp =</para>
        <para>����� new AlphabeticComparator();</para>
        <para>��� Arrays.sort(sa, comp);</para>
        <para>��� int index =</para>
        <para>����� Arrays.binarySearch(sa, sa[10], comp);</para>
        <para>��� System.out.println(&quot;Index = &quot; + index);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">Comparator</emphasis> must be passed to the overloaded <emphasis role="bold">binarySearch( )</emphasis> as the third argument. In the above example, success is guaranteed because the search item is plucked out of the array itself.</para>
      </section>
      <section>
        <title><anchor xreflabel="Array summary" xml:id="_Toc481064675"/>Array summary</title>
        <para>To summarize what you�ve seen so far, your first and most efficient choice to hold a group of objects should be an array, and you�re forced into this choice if you want to hold a group of primitives. In the remainder of this chapter we�ll look at the more general case, when you don�t know at the time you�re writing the program how many objects you�re going to need, or if you need a more sophisticated way to store your objects. Java provides a library of <emphasis role="italic">container classes</emphasis> to solve this problem, the basic types of which are <emphasis role="bold">List</emphasis>, <emphasis role="bold">Set</emphasis>,<emphasis role="bold"/>and <emphasis role="bold">Map</emphasis>. You can solve a surprising number of problems using these tools.</para>
        <para>Among their other characteristics�<emphasis role="bold">Set</emphasis>, for example, holds only one object of each value, and <emphasis role="bold">Map</emphasis> is an <emphasis role="italic">associative array</emphasis> that lets you associate any object with any other object�the Java container classes will automatically resize themselves. So, unlike arrays, you can put in any number of objects and you don�t need to worry about how big to make the container while you�re writing the program.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Introduction to containers" xml:id="_Toc481064676"/>Introduction to containers</title>
      <para>To me, container classes are one of the most powerful tools for raw development because they significantly increase your programming muscle. The Java 2 containers represent a thorough redesign<anchor xreflabel="[47]" xml:id="_ftnref47"/>[47] of the rather poor showings in Java 1.0 and 1.1. Some of the redesign makes things tighter and more sensible. It also fills out the functionality of the containers library, providing the behavior of linked lists, queues, and deques (double-ended queues, pronounced �decks�).</para>
      <para>The design of a containers library is difficult (true of most library design problems). In C++, the container classes covered the bases with many different classes. This was better than what was available prior to the C++ container classes (nothing), but it didn�t translate well into Java. On the other extreme, I�ve seen a containers library that consists of a single class, �container,� which acts like both a linear sequence and an associative array at the same time. The Java 2 container library strikes a balance: the full functionality that you expect from a mature container library, but easier to learn and use than the C++ container classes and other similar container libraries. The result can seem a bit odd in places. Unlike some of the decisions made in the early Java libraries, these oddities were not accidents, but carefully considered decisions based on trade-offs in complexity. It might take you a little while to get comfortable with some aspects of the library, but I think you�ll find yourself rapidly acquiring and using these new tools.</para>
      <para>The Java 2 container library takes the issue of �holding your objects� and divides it into two distinct concepts: </para>
      <para><emphasis role="bold">Collection</emphasis>: a group of individual elements, often with some rule applied to them. A <emphasis role="bold">List</emphasis> must hold the elements in a particular sequence, and a <emphasis role="bold">Set</emphasis> cannot have any duplicate elements. (A <emphasis role="italic">bag</emphasis>, which is not implemented in the Java container library�since <emphasis role="bold">List</emphasis>s provide you with enough of that functionality�has no such rules.)</para>
      <para><emphasis role="bold">54.      </emphasis><emphasis role="bold">Map</emphasis>: a group of key-value object pairs. At first glance, this might seem like it ought to be a <emphasis role="bold">Collection</emphasis> of pairs, but when you try to implement it that way the design gets awkward, so it�s clearer to make it a separate concept. On the other hand, it�s convenient to look at portions of a <emphasis role="bold">Map</emphasis> by creating a <emphasis role="bold">Collection</emphasis> to represent that portion. Thus, a <emphasis role="bold">Map</emphasis> can return a <emphasis role="bold">Set</emphasis> of its keys, a <emphasis role="bold">Collection </emphasis>of its values, or a <emphasis role="bold">Set </emphasis>of its pairs. <emphasis role="bold">Map</emphasis>s, like arrays, can easily be expanded to multiple dimensions without adding new concepts: you simply make a <emphasis role="bold">Map</emphasis> whose values are <emphasis role="bold">Map</emphasis>s (and the values of <emphasis role="italic">those</emphasis><emphasis role="bold">Map</emphasis>s can be <emphasis role="bold">Map</emphasis>s, etc.).</para>
      <para>We will first look at the general features of containers, then go into details, and finally learn why there are different versions of some containers, and how to choose between them.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545351"/><anchor xreflabel="" xml:id="_Ref348399494"/><anchor xreflabel="Printing containers" xml:id="_Toc481064677"/>Printing containers</title>
        <para>Unlike arrays, the containers print nicely without any help. Here�s an example that also introduces you to the basic types of containers:</para>
        <para>//: c09:PrintingContainers.java</para>
        <para>// Containers print themselves automatically.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class PrintingContainers {</para>
        <para>� static Collection fill(Collection c) {</para>
        <para>��� c.add(&quot;dog&quot;);</para>
        <para>��� c.add(&quot;dog&quot;);</para>
        <para>��� c.add(&quot;cat&quot;);</para>
        <para>��� return c;</para>
        <para>� }</para>
        <para>� static Map fill(Map m) {</para>
        <para>��� m.put(&quot;dog&quot;, &quot;Bosco&quot;);</para>
        <para>��� m.put(&quot;dog&quot;, &quot;Spot&quot;);</para>
        <para>��� m.put(&quot;cat&quot;, &quot;Rags&quot;);</para>
        <para>��� return m;</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� System.out.println(fill(new ArrayList()));</para>
        <para>��� System.out.println(fill(new HashSet()));</para>
        <para>��� System.out.println(fill(new HashMap()));</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>As mentioned before, there are two basic categories in the Java container library. The distinction is based on the number of items that are held in each location of the container. The <emphasis role="bold">Collection</emphasis> category only holds one item in each location (the name is a bit misleading since entire container libraries are often called �collections�). It includes the <emphasis role="bold">List</emphasis>, which holds a group of items in a specified sequence, and the <emphasis role="bold">Set</emphasis>, which only allows the addition of one item of each type. The <emphasis role="bold">ArrayList </emphasis>is a type of <emphasis role="bold">List</emphasis>, and <emphasis role="bold">HashSet </emphasis>is a type of <emphasis role="bold">Set</emphasis>. To add items to any <emphasis role="bold">Collection</emphasis>, there�s an <emphasis role="bold">add( )</emphasis> method.</para>
        <para>The <emphasis role="bold">Map</emphasis> holds key-value pairs, rather like a mini database. The above program uses one flavor of <emphasis role="bold">Map</emphasis>,<emphasis role="bold"/>the <emphasis role="bold">HashMap</emphasis>. If you have a <emphasis role="bold">Map</emphasis> that associates states with their capitals and you want to know the capital of Ohio, you look it up�almost as if you were indexing into an array. (Maps are also called <emphasis role="italic">associative arrays</emphasis>.) To add elements to a <emphasis role="bold">Map</emphasis> there�s a <emphasis role="bold">put( )</emphasis> method that takes a key and a value as arguments. The above example only shows adding elements and does not look the elements up after they�re added. That will be shown later.</para>
        <para>The overloaded <emphasis role="bold">fill( )</emphasis> methods fill <emphasis role="bold">Collection</emphasis>s and <emphasis role="bold">Map</emphasis>s, respectively. If you look at the output, you can see that the default printing behavior (provided via the container�s various <emphasis role="bold">toString( )</emphasis> methods) produces quite readable results, so no additional printing support is necessary as it was with arrays:</para>
        <para>[dog, dog, cat]</para>
        <para>[cat, dog]</para>
        <para>{cat=Rags, dog=Spot}</para>
        <para> </para>
        <para>A <emphasis role="bold">Collection</emphasis> is printed surrounded by square braces, with each element separated by a comma. A <emphasis role="bold">Map</emphasis> is surrounded by curly braces, with each key and value associated with an equal sign (keys on the left, values on the right).</para>
        <para>You can also immediately see the basic behavior of the different containers. The <emphasis role="bold">List</emphasis> holds the objects exactly as they are entered, without any reordering or editing. The <emphasis role="bold">Set</emphasis>, however, only accepts one of each object and it uses its own internal ordering method (in general, you are only concerned with whether or not something is a member of the <emphasis role="bold">Set</emphasis>, not the order in which it appears�for that you�d use a <emphasis role="bold">List</emphasis>). And the <emphasis role="bold">Map</emphasis> also only accepts one of each type of item, based on the key, and it also has its own internal ordering and does not care about the order in which you enter the items.</para>
      </section>
      <section>
        <title><anchor xreflabel="Filling containers" xml:id="_Toc481064678"/>Filling containers</title>
        <para>Although the problem of printing the containers is taken care of, filling containers suffers from the same deficiency as <emphasis role="bold">java.util.Arrays</emphasis>. Just like <emphasis role="bold">Arrays</emphasis>, there is a companion class called <emphasis role="bold">Collections</emphasis> containing <emphasis role="bold">static</emphasis> utility methods including one called <emphasis role="bold">fill( )</emphasis>. This <emphasis role="bold">fill( )</emphasis> also just duplicates a single object reference throughout the container, and also only works for <emphasis role="bold">List</emphasis> objects and not <emphasis role="bold">Set</emphasis>s or <emphasis role="bold">Map</emphasis>s:</para>
        <para>//: c09:FillingLists.java</para>
        <para>// The Collections.fill() method.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class FillingLists {</para>
        <para>� public static void main(String[] args) {</para>
        <para>�� �List list = new ArrayList();</para>
        <para>��� for(int i = 0; i &lt; 10; i++)</para>
        <para>����� list.add(&quot;&quot;);</para>
        <para>��� Collections.fill(list, &quot;Hello&quot;);</para>
        <para>��� System.out.println(list);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This method is made even less useful by the fact that it can only replace elements that are already in the <emphasis role="bold">List</emphasis>, and will not add new elements.</para>
        <para>To be able to create interesting examples, here is a complementary <emphasis role="bold">Collections2</emphasis> library (part of <emphasis role="bold">com.bruceeckel.util </emphasis>for convenience) with a <emphasis role="bold">fill( )</emphasis> method that uses a generator to add elements, and allows you to specify the number of elements you want to <emphasis role="bold">add( )</emphasis>. The <emphasis role="bold">Generator interface</emphasis> defined previously will work for <emphasis role="bold">Collection</emphasis>s, but the <emphasis role="bold">Map</emphasis> requires its own generator <emphasis role="bold">interface</emphasis> since a pair of objects (one key and one value) must be produced by each call to <emphasis role="bold">next( )</emphasis>. Here is the <emphasis role="bold">Pair</emphasis> class:</para>
        <para>//: com:bruceeckel:util:Pair.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public class Pair {</para>
        <para>� public Object key, value;</para>
        <para>� Pair(Object k, Object v) {</para>
        <para>��� key = k;</para>
        <para>��� value = v;</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Next, the generator <emphasis role="bold">interface</emphasis> that produces the <emphasis role="bold">Pair</emphasis>:</para>
        <para>//: com:bruceeckel:util:MapGenerator.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public interface MapGenerator {</para>
        <para>� Pair next();</para>
        <para>} ///:~</para>
        <para> </para>
        <para>With these, a set of utilities for working with the container classes can be developed:</para>
        <para>//: com:bruceeckel:util:Collections2.java</para>
        <para>// To fill any type of container </para>
        <para>// using a generator object.</para>
        <para>package com.bruceeckel.util;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class Collections2 {</para>
        <para>� // Fill an array using a generator:</para>
        <para>� public static void </para>
        <para>� fill(Collection c, Generator gen, int count) {</para>
        <para>��� for(int i = 0; i &lt; count; i++)</para>
        <para>����� c.add(gen.next());</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� fill(Map m, MapGenerator gen, int count) {</para>
        <para>��� for(int i = 0; i &lt; count; i++) {</para>
        <para>����� Pair p = gen.next();</para>
        <para>����� m.put(p.key, p.value);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static class RandStringPairGenerator</para>
        <para>� implements MapGenerator {</para>
        <para>��� private Arrays2.RandStringGenerator gen;</para>
        <para>��� public RandStringPairGenerator(int len) {</para>
        <para>����� gen = new Arrays2.RandStringGenerator(len);</para>
        <para>��� }</para>
        <para>��� public Pair next() {</para>
        <para>����� return new Pair(gen.next(), gen.next());</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� // Default object so you don&apos;t have </para>
        <para>� // to create your own:</para>
        <para>� public static RandStringPairGenerator rsp =</para>
        <para>��� new RandStringPairGenerator(10);</para>
        <para>� public static class StringPairGenerator</para>
        <para>� implements MapGenerator {</para>
        <para>��� private int index = -1;</para>
        <para>��� private String[][] d;</para>
        <para>��� public StringPairGenerator(String[][] data) {</para>
        <para>����� d = data;</para>
        <para>��� }</para>
        <para>��� public Pair next() {</para>
        <para>����� // Force the index to wrap:</para>
        <para>����� index = (index + 1) % d.length;</para>
        <para>����� return new Pair(d[index][0], d[index][1]);</para>
        <para>��� }</para>
        <para>��� public StringPairGenerator reset() { </para>
        <para>����� index = -1; </para>
        <para>����� return this;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� // Use a predefined dataset:</para>
        <para>� public static StringPairGenerator geography =</para>
        <para>��� new StringPairGenerator(</para>
        <para>����� CountryCapitals.pairs);</para>
        <para>� // Produce a sequence from a 2D array:</para>
        <para>� public static class StringGenerator</para>
        <para>� implements Generator {</para>
        <para>��� private String[][] d;</para>
        <para>��� private int position;</para>
        <para>��� private int index = -1;</para>
        <para>��� public </para>
        <para>��� StringGenerator(String[][] data, int pos) {</para>
        <para>����� d = data;</para>
        <para>����� position = pos;</para>
        <para>��� }</para>
        <para>��� public Object next() {</para>
        <para>����� // Force the index to wrap:</para>
        <para>����� index = (index + 1) % d.length;</para>
        <para>����� return d[index][position];</para>
        <para>��� }</para>
        <para>��� public StringGenerator reset() { </para>
        <para>����� index = -1;</para>
        <para>����� return this;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� // Use a predefined dataset:</para>
        <para>� public static StringGenerator countries =</para>
        <para>��� new StringGenerator(CountryCapitals.pairs,0);</para>
        <para>� public static StringGenerator capitals =</para>
        <para>��� new StringGenerator(CountryCapitals.pairs,1);</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Both versions of <emphasis role="bold">fill( )</emphasis> take an argument that determines the number of items to add to the container. In addition, there are two generators for the map: <emphasis role="bold">RandStringPairGenerator</emphasis>, which creates any number of pairs of gibberish <emphasis role="bold">String</emphasis>s with length determined by the constructor argument; and <emphasis role="bold">StringPairGenerator</emphasis>, which produces pairs of <emphasis role="bold">String</emphasis>s given a two-dimensional array of <emphasis role="bold">String</emphasis>. The <emphasis role="bold">StringGenerator</emphasis> also takes a two-dimensional array of <emphasis role="bold">String </emphasis>but generates single items rather than <emphasis role="bold">Pair</emphasis>s.<emphasis role="bold"/>The <emphasis role="bold">static rsp</emphasis>, <emphasis role="bold">geography</emphasis>,<emphasis role="bold"> countries</emphasis>, and <emphasis role="bold">capitals</emphasis> objects provide prebuilt generators, the last three using<emphasis role="bold"/>all the countries of the world and their capitals. Note that if you try to create more pairs than are available, the generators will loop around to the beginning, and if you are putting the pairs into a <emphasis role="bold">Map</emphasis>, the duplicates will just be ignored.</para>
        <para>Here is the predefined dataset, which consists of country names and their capitals. It is set in a small font to prevent taking up unnecessary space:</para>
        <para>//: com:bruceeckel:util:CountryCapitals.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>public class CountryCapitals {</para>
        <para>� public static final String[][] pairs = {</para>
        <para>��� // Africa</para>
        <para>��� {&quot;ALGERIA&quot;,&quot;Algiers&quot;}, {&quot;ANGOLA&quot;,&quot;Luanda&quot;},</para>
        <para>��� {&quot;BENIN&quot;,&quot;Porto-Novo&quot;}, {&quot;BOTSWANA&quot;,&quot;Gaberone&quot;},</para>
        <para>��� {&quot;BURKINA FASO&quot;,&quot;Ouagadougou&quot;}, {&quot;BURUNDI&quot;,&quot;Bujumbura&quot;},</para>
        <para>��� {&quot;CAMEROON&quot;,&quot;Yaounde&quot;}, {&quot;CAPE VERDE&quot;,&quot;Praia&quot;},</para>
        <para>��� {&quot;CENTRAL AFRICAN REPUBLIC&quot;,&quot;Bangui&quot;},</para>
        <para>��� {&quot;CHAD&quot;,&quot;N&apos;djamena&quot;},� {&quot;COMOROS&quot;,&quot;Moroni&quot;},</para>
        <para>��� {&quot;CONGO&quot;,&quot;Brazzaville&quot;}, {&quot;DJIBOUTI&quot;,&quot;Dijibouti&quot;},</para>
        <para>��� {&quot;EGYPT&quot;,&quot;Cairo&quot;}, {&quot;EQUATORIAL GUINEA&quot;,&quot;Malabo&quot;},</para>
        <para>��� {&quot;ERITREA&quot;,&quot;Asmara&quot;}, {&quot;ETHIOPIA&quot;,&quot;Addis Ababa&quot;},</para>
        <para>��� {&quot;GABON&quot;,&quot;Libreville&quot;}, {&quot;THE GAMBIA&quot;,&quot;Banjul&quot;},</para>
        <para>��� {&quot;GHANA&quot;,&quot;Accra&quot;}, {&quot;GUINEA&quot;,&quot;Conakry&quot;},</para>
        <para>��� {&quot;GUINEA&quot;,&quot;-&quot;}, {&quot;BISSAU&quot;,&quot;Bissau&quot;},</para>
        <para>��� {&quot;CETE D&apos;IVOIR (IVORY COAST)&quot;,&quot;Yamoussoukro&quot;},</para>
        <para>��� {&quot;KENYA&quot;,&quot;Nairobi&quot;}, {&quot;LESOTHO&quot;,&quot;Maseru&quot;},</para>
        <para>��� {&quot;LIBERIA&quot;,&quot;Monrovia&quot;}, {&quot;LIBYA&quot;,&quot;Tripoli&quot;},</para>
        <para>��� {&quot;MADAGASCAR&quot;,&quot;Antananarivo&quot;}, {&quot;MALAWI&quot;,&quot;Lilongwe&quot;},</para>
        <para>��� {&quot;MALI&quot;,&quot;Bamako&quot;}, {&quot;MAURITANIA&quot;,&quot;Nouakchott&quot;},</para>
        <para>�� �{&quot;MAURITIUS&quot;,&quot;Port Louis&quot;}, {&quot;MOROCCO&quot;,&quot;Rabat&quot;},</para>
        <para>��� {&quot;MOZAMBIQUE&quot;,&quot;Maputo&quot;}, {&quot;NAMIBIA&quot;,&quot;Windhoek&quot;},</para>
        <para>��� {&quot;NIGER&quot;,&quot;Niamey&quot;}, {&quot;NIGERIA&quot;,&quot;Abuja&quot;},</para>
        <para>��� {&quot;RWANDA&quot;,&quot;Kigali&quot;}, {&quot;SAO TOME E PRINCIPE&quot;,&quot;Sao Tome&quot;},</para>
        <para>��� {&quot;SENEGAL&quot;,&quot;Dakar&quot;}, {&quot;SEYCHELLES&quot;,&quot;Victoria&quot;},</para>
        <para>��� {&quot;SIERRA LEONE&quot;,&quot;Freetown&quot;}, {&quot;SOMALIA&quot;,&quot;Mogadishu&quot;},</para>
        <para>��� {&quot;SOUTH AFRICA&quot;,&quot;Pretoria/Cape Town&quot;}, {&quot;SUDAN&quot;,&quot;Khartoum&quot;},</para>
        <para>��� {&quot;SWAZILAND&quot;,&quot;Mbabane&quot;}, {&quot;TANZANIA&quot;,&quot;Dodoma&quot;},</para>
        <para>��� {&quot;TOGO&quot;,&quot;Lome&quot;}, {&quot;TUNISIA&quot;,&quot;Tunis&quot;},</para>
        <para>��� {&quot;UGANDA&quot;,&quot;Kampala&quot;},</para>
        <para>��� {&quot;DEMOCRATIC REPUBLIC OF THE CONGO (ZAIRE)&quot;,&quot;Kinshasa&quot;},</para>
        <para>��� {&quot;ZAMBIA&quot;,&quot;Lusaka&quot;}, {&quot;ZIMBABWE&quot;,&quot;Harare&quot;},</para>
        <para>��� // Asia</para>
        <para>��� {&quot;AFGHANISTAN&quot;,&quot;Kabul&quot;}, {&quot;BAHRAIN&quot;,&quot;Manama&quot;},</para>
        <para>��� {&quot;BANGLADESH&quot;,&quot;Dhaka&quot;}, {&quot;BHUTAN&quot;,&quot;Thimphu&quot;},</para>
        <para>��� {&quot;BRUNEI&quot;,&quot;Bandar Seri Begawan&quot;}, {&quot;CAMBODIA&quot;,&quot;Phnom Penh&quot;},</para>
        <para>��� {&quot;CHINA&quot;,&quot;Beijing&quot;}, {&quot;CYPRUS&quot;,&quot;Nicosia&quot;},</para>
        <para>��� {&quot;INDIA&quot;,&quot;New Delhi&quot;}, {&quot;INDONESIA&quot;,&quot;Jakarta&quot;},</para>
        <para>��� {&quot;IRAN&quot;,&quot;Tehran&quot;}, {&quot;IRAQ&quot;,&quot;Baghdad&quot;},</para>
        <para>��� {&quot;ISRAEL&quot;,&quot;Jerusalem&quot;}, {&quot;JAPAN&quot;,&quot;Tokyo&quot;},</para>
        <para>��� {&quot;JORDAN&quot;,&quot;Amman&quot;}, {&quot;KUWAIT&quot;,&quot;Kuwait City&quot;},</para>
        <para>��� {&quot;LAOS&quot;,&quot;Vientiane&quot;}, {&quot;LEBANON&quot;,&quot;Beirut&quot;},</para>
        <para>��� {&quot;MALAYSIA&quot;,&quot;Kuala Lumpur&quot;}, {&quot;THE MALDIVES&quot;,&quot;Male&quot;},</para>
        <para>��� {&quot;MONGOLIA&quot;,&quot;Ulan Bator&quot;}, {&quot;MYANMAR (BURMA)&quot;,&quot;Rangoon&quot;},</para>
        <para>��� {&quot;NEPAL&quot;,&quot;Katmandu&quot;}, {&quot;NORTH KOREA&quot;,&quot;P&apos;yongyang&quot;},</para>
        <para>��� {&quot;OMAN&quot;,&quot;Muscat&quot;}, {&quot;PAKISTAN&quot;,&quot;Islamabad&quot;},</para>
        <para>��� {&quot;PHILIPPINES&quot;,&quot;Manila&quot;}, {&quot;QATAR&quot;,&quot;Doha&quot;},</para>
        <para>��� {&quot;SAUDI ARABIA&quot;,&quot;Riyadh&quot;}, {&quot;SINGAPORE&quot;,&quot;Singapore&quot;},</para>
        <para>��� {&quot;SOUTH KOREA&quot;,&quot;Seoul&quot;}, {&quot;SRI LANKA&quot;,&quot;Colombo&quot;},</para>
        <para>��� {&quot;SYRIA&quot;,&quot;Damascus&quot;}, {&quot;TAIWAN (REPUBLIC OF CHINA)&quot;,&quot;Taipei&quot;},</para>
        <para>��� {&quot;THAILAND&quot;,&quot;Bangkok&quot;}, {&quot;TURKEY&quot;,&quot;Ankara&quot;},</para>
        <para>��� {&quot;UNITED ARAB EMIRATES&quot;,&quot;Abu Dhabi&quot;}, {&quot;VIETNAM&quot;,&quot;Hanoi&quot;},</para>
        <para>��� {&quot;YEMEN&quot;,&quot;Sana&apos;a&quot;},</para>
        <para>��� // Australia and Oceania</para>
        <para>��� {&quot;AUSTRALIA&quot;,&quot;Canberra&quot;}, {&quot;FIJI&quot;,&quot;Suva&quot;},</para>
        <para>��� {&quot;KIRIBATI&quot;,&quot;Bairiki&quot;},</para>
        <para>��� {&quot;MARSHALL ISLANDS&quot;,&quot;Dalap-Uliga-Darrit&quot;},</para>
        <para>��� {&quot;MICRONESIA&quot;,&quot;Palikir&quot;}, {&quot;NAURU&quot;,&quot;Yaren&quot;},</para>
        <para>��� {&quot;NEW ZEALAND&quot;,&quot;Wellington&quot;}, {&quot;PALAU&quot;,&quot;Koror&quot;},</para>
        <para>��� {&quot;PAPUA NEW GUINEA&quot;,&quot;Port Moresby&quot;},</para>
        <para>��� {&quot;SOLOMON ISLANDS&quot;,&quot;Honaira&quot;}, {&quot;TONGA&quot;,&quot;Nuku&apos;alofa&quot;},</para>
        <para>��� {&quot;TUVALU&quot;,&quot;Fongafale&quot;}, {&quot;VANUATU&quot;,&quot;&lt; Port-Vila&quot;},</para>
        <para>��� {&quot;WESTERN SAMOA&quot;,&quot;Apia&quot;},</para>
        <para>��� // Eastern Europe and former USSR </para>
        <para>��� {&quot;ARMENIA&quot;,&quot;Yerevan&quot;}, {&quot;AZERBAIJAN&quot;,&quot;Baku&quot;},</para>
        <para>��� {&quot;BELARUS (BYELORUSSIA)&quot;,&quot;Minsk&quot;}, {&quot;GEORGIA&quot;,&quot;Tbilisi&quot;},</para>
        <para>��� {&quot;KAZAKSTAN&quot;,&quot;Almaty&quot;}, {&quot;KYRGYZSTAN&quot;,&quot;Alma-Ata&quot;},</para>
        <para>��� {&quot;MOLDOVA&quot;,&quot;Chisinau&quot;}, {&quot;RUSSIA&quot;,&quot;Moscow&quot;},</para>
        <para>��� {&quot;TAJIKISTAN&quot;,&quot;Dushanbe&quot;}, {&quot;TURKMENISTAN&quot;,&quot;Ashkabad&quot;},</para>
        <para>��� {&quot;UKRAINE&quot;,&quot;Kyiv&quot;}, {&quot;UZBEKISTAN&quot;,&quot;Tashkent&quot;},</para>
        <para>��� // Europe </para>
        <para>��� {&quot;ALBANIA&quot;,&quot;Tirana&quot;}, {&quot;ANDORRA&quot;,&quot;Andorra la Vella&quot;},</para>
        <para>��� {&quot;AUSTRIA&quot;,&quot;Vienna&quot;}, {&quot;BELGIUM&quot;,&quot;Brussels&quot;},</para>
        <para>��� {&quot;BOSNIA&quot;,&quot;-&quot;}, {&quot;HERZEGOVINA&quot;,&quot;Sarajevo&quot;},</para>
        <para>��� {&quot;CROATIA&quot;,&quot;Zagreb&quot;}, {&quot;CZECH REPUBLIC&quot;,&quot;Prague&quot;},</para>
        <para>��� {&quot;DENMARK&quot;,&quot;Copenhagen&quot;}, {&quot;ESTONIA&quot;,&quot;Tallinn&quot;},</para>
        <para>��� {&quot;FINLAND&quot;,&quot;Helsinki&quot;}, {&quot;FRANCE&quot;,&quot;Paris&quot;},</para>
        <para>��� {&quot;GERMANY&quot;,&quot;Berlin&quot;}, {&quot;GREECE&quot;,&quot;Athens&quot;},</para>
        <para>��� {&quot;HUNGARY&quot;,&quot;Budapest&quot;}, {&quot;ICELAND&quot;,&quot;Reykjavik&quot;},</para>
        <para>��� {&quot;IRELAND&quot;,&quot;Dublin&quot;}, {&quot;ITALY&quot;,&quot;Rome&quot;},</para>
        <para>��� {&quot;LATVIA&quot;,&quot;Riga&quot;}, {&quot;LIECHTENSTEIN&quot;,&quot;Vaduz&quot;},</para>
        <para>��� {&quot;LITHUANIA&quot;,&quot;Vilnius&quot;}, {&quot;LUXEMBOURG&quot;,&quot;Luxembourg&quot;},</para>
        <para>��� {&quot;MACEDONIA&quot;,&quot;Skopje&quot;}, {&quot;MALTA&quot;,&quot;Valletta&quot;},</para>
        <para>��� {&quot;MONACO&quot;,&quot;Monaco&quot;}, {&quot;MONTENEGRO&quot;,&quot;Podgorica&quot;},</para>
        <para>��� {&quot;THE NETHERLANDS&quot;,&quot;Amsterdam&quot;}, {&quot;NORWAY&quot;,&quot;Oslo&quot;},</para>
        <para>��� {&quot;POLAND&quot;,&quot;Warsaw&quot;}, {&quot;PORTUGAL&quot;,&quot;Lisbon&quot;},</para>
        <para>��� {&quot;ROMANIA&quot;,&quot;Bucharest&quot;}, {&quot;SAN MARINO&quot;,&quot;San Marino&quot;},</para>
        <para>��� {&quot;SERBIA&quot;,&quot;Belgrade&quot;}, {&quot;SLOVAKIA&quot;,&quot;Bratislava&quot;},</para>
        <para>��� {&quot;SLOVENIA&quot;,&quot;Ljujiana&quot;}, {&quot;SPAIN&quot;,&quot;Madrid&quot;},</para>
        <para>��� {&quot;SWEDEN&quot;,&quot;Stockholm&quot;}, {&quot;SWITZERLAND&quot;,&quot;Berne&quot;},</para>
        <para>��� {&quot;UNITED KINGDOM&quot;,&quot;London&quot;}, {&quot;VATICAN CITY&quot;,&quot;---&quot;},</para>
        <para>��� // North and Central America</para>
        <para>��� {&quot;ANTIGUA AND BARBUDA&quot;,&quot;Saint John&apos;s&quot;}, {&quot;BAHAMAS&quot;,&quot;Nassau&quot;},</para>
        <para>��� {&quot;BARBADOS&quot;,&quot;Bridgetown&quot;}, {&quot;BELIZE&quot;,&quot;Belmopan&quot;},</para>
        <para>��� {&quot;CANADA&quot;,&quot;Ottawa&quot;}, {&quot;COSTA RICA&quot;,&quot;San Jose&quot;},</para>
        <para>��� {&quot;CUBA&quot;,&quot;Havana&quot;}, {&quot;DOMINICA&quot;,&quot;Roseau&quot;},</para>
        <para>��� {&quot;DOMINICAN REPUBLIC&quot;,&quot;Santo Domingo&quot;},</para>
        <para>��� {&quot;EL SALVADOR&quot;,&quot;San Salvador&quot;}, {&quot;GRENADA&quot;,&quot;Saint George&apos;s&quot;},</para>
        <para>��� {&quot;GUATEMALA&quot;,&quot;Guatemala City&quot;}, {&quot;HAITI&quot;,&quot;Port-au-Prince&quot;},</para>
        <para>��� {&quot;HONDURAS&quot;,&quot;Tegucigalpa&quot;}, {&quot;JAMAICA&quot;,&quot;Kingston&quot;},</para>
        <para>��� {&quot;MEXICO&quot;,&quot;Mexico City&quot;}, {&quot;NICARAGUA&quot;,&quot;Managua&quot;},</para>
        <para>��� {&quot;PANAMA&quot;,&quot;Panama City&quot;}, {&quot;ST. KITTS&quot;,&quot;-&quot;},</para>
        <para>��� {&quot;NEVIS&quot;,&quot;Basseterre&quot;}, {&quot;ST. LUCIA&quot;,&quot;Castries&quot;},</para>
        <para>��� {&quot;ST. VINCENT AND THE GRENADINES&quot;,&quot;Kingstown&quot;},</para>
        <para>��� {&quot;UNITED STATES OF AMERICA&quot;,&quot;Washington, D.C.&quot;},</para>
        <para>��� // South America</para>
        <para>��� {&quot;ARGENTINA&quot;,&quot;Buenos Aires&quot;},</para>
        <para>��� {&quot;BOLIVIA&quot;,&quot;Sucre (legal)/La Paz(administrative)&quot;},</para>
        <para>��� {&quot;BRAZIL&quot;,&quot;Brasilia&quot;}, {&quot;CHILE&quot;,&quot;Santiago&quot;},</para>
        <para>��� {&quot;COLOMBIA&quot;,&quot;Bogota&quot;}, {&quot;ECUADOR&quot;,&quot;Quito&quot;},</para>
        <para>��� {&quot;GUYANA&quot;,&quot;Georgetown&quot;}, {&quot;PARAGUAY&quot;,&quot;Asuncion&quot;},</para>
        <para>��� {&quot;PERU&quot;,&quot;Lima&quot;}, {&quot;SURINAME&quot;,&quot;Paramaribo&quot;},</para>
        <para>��� {&quot;TRINIDAD AND TOBAGO&quot;,&quot;Port of Spain&quot;},</para>
        <para>��� {&quot;URUGUAY&quot;,&quot;Montevideo&quot;}, {&quot;VENEZUELA&quot;,&quot;Caracas&quot;},</para>
        <para>� };</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This is simply a two-dimensional array of <emphasis role="bold">String</emphasis> data<anchor xreflabel="[48]" xml:id="_ftnref48"/>[48]. Here�s a simple test using the <emphasis role="bold">fill( )</emphasis> methods and generators:</para>
        <para>//: c09:FillTest.java</para>
        <para>import com.bruceeckel.util.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class FillTest {</para>
        <para>� static Generator sg = </para>
        <para>��� new Arrays2.RandStringGenerator(7);</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� List list = new ArrayList();</para>
        <para>��� Collections2.fill(list, sg, 25);</para>
        <para>��� System.out.println(list + &quot;\n&quot;);</para>
        <para>��� List list2 = new ArrayList();</para>
        <para>��� Collections2.fill(list2, </para>
        <para>����� Collections2.capitals, 25);</para>
        <para>��� System.out.println(list2 + &quot;\n&quot;);</para>
        <para>��� Set set = new HashSet();</para>
        <para>��� Collections2.fill(set, sg, 25);</para>
        <para>��� System.out.println(set + &quot;\n&quot;);</para>
        <para>��� Map m = new HashMap();</para>
        <para>��� Collections2.fill(m, Collections2.rsp, 25);</para>
        <para>��� System.out.println(m + &quot;\n&quot;);</para>
        <para>��� Map m2 = new HashMap();</para>
        <para>��� Collections2.fill(m2, </para>
        <para>����� Collections2.geography, 25);</para>
        <para>��� System.out.println(m2);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>With these tools you can easily test the various containers by filling them with interesting data.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Container disadvantage: 
unknown type" xml:id="_Toc481064679"/>Container disadvantage:   unknown type</title>
      <para>The �disadvantage� to using the Java containers is that you lose type information when you put an object into a container. This happens because the programmer of that container class had no idea what specific type you wanted to put in the container, and making the container hold only your type would prevent it from being a general-purpose tool. So instead, the container holds references to <emphasis role="bold">Object</emphasis>, which is the root of all the classes so it holds any type. (Of course, this doesn�t include primitive types, since they aren�t inherited from anything.) This is a great solution, except: </para>
      <para>Since the type information is thrown away when you put an object reference into a container, there�s no restriction on the type of object that can be put into your container, even if you mean it to hold only, say, cats. Someone could just as easily put a dog into the container.</para>
      <para>55.      Since the type information is lost, the only thing the container knows that it holds is a reference to an object. You must perform a cast to the correct type before you use it.</para>
      <para>On the up side, Java won�t let you <emphasis role="italic">misuse</emphasis> the objects that you put into a container. If you throw a dog into a container of cats and then try to treat everything in the container as a cat, you�ll get a run-time exception when you pull the dog reference out of the cat container and try to cast it to a cat.</para>
      <para>Here�s an example using the basic workhorse container, <emphasis role="bold">ArrayList</emphasis>. For starters, you can think of <emphasis role="bold">ArrayList</emphasis> as �an array that automatically expands itself.� Using an <emphasis role="bold">ArrayList</emphasis> is straightforward: create one, put objects in using <emphasis role="bold">add( ),</emphasis> and later get them out with <emphasis role="bold">get( ) </emphasis>using an index�just like you would with an array but without the square brackets<anchor xreflabel="[49]" xml:id="_ftnref49"/>[49]. <emphasis role="bold">ArrayList</emphasis> also has a method <emphasis role="bold">size( )</emphasis> to let you know how many elements have been added so you don�t inadvertently run off the end and cause an exception.</para>
      <para>First, <emphasis role="bold">Cat</emphasis> and <emphasis role="bold">Dog</emphasis> classes are created:</para>
      <para>//: c09:Cat.java</para>
      <para>public class Cat {</para>
      <para>� private int catNumber;</para>
      <para>� Cat(int i) { catNumber = i; }</para>
      <para>� void print() {</para>
      <para>��� System.out.println(&quot;Cat #&quot; + catNumber);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>//: c09:Dog.java</para>
      <para>public class Dog {</para>
      <para>� private int dogNumber;</para>
      <para>� Dog(int i) { dogNumber = i; }</para>
      <para>� void print() {</para>
      <para>��� System.out.println(&quot;Dog #&quot; + dogNumber);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para><emphasis role="bold">Cat</emphasis>s and <emphasis role="bold">Dog</emphasis>s are placed into the container, then pulled out:</para>
      <para>//: c09:CatsAndDogs.java</para>
      <para>// Simple container example.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>public class CatsAndDogs {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� ArrayList cats = new ArrayList();</para>
      <para>��� for(int i = 0; i &lt; 7; i++)</para>
      <para>����� cats.add(new Cat(i));</para>
      <para>��� // Not a problem to add a dog to cats:</para>
      <para>��� cats.add(new Dog(7));</para>
      <para>��� for(int i = 0; i &lt; cats.size(); i++)</para>
      <para>����� ((Cat)cats.get(i)).print();</para>
      <para>��� // Dog is detected only at run-time</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The classes <emphasis role="bold">Cat</emphasis> and <emphasis role="bold">Dog</emphasis> are distinct�they have nothing in common except that they are <emphasis role="bold">Object</emphasis>s. (If you don�t explicitly say what class you�re inheriting from, you automatically inherit from <emphasis role="bold">Object</emphasis>.) Since <emphasis role="bold">ArrayList</emphasis> holds <emphasis role="bold">Object</emphasis>s, you can not only put <emphasis role="bold">Cat</emphasis> objects into this container using the <emphasis role="bold">ArrayList </emphasis>method <emphasis role="bold">add( )</emphasis>, but you can also add <emphasis role="bold">Dog</emphasis> objects without complaint at either compile-time or run-time. When you go to fetch out what you think are <emphasis role="bold">Cat</emphasis> objects using the <emphasis role="bold">ArrayList</emphasis> method <emphasis role="bold">get( )</emphasis>, you get back a reference to an object that you must cast to a <emphasis role="bold">Cat</emphasis>. Then you need to surround the entire expression with parentheses to force the evaluation of the cast before calling the <emphasis role="bold">print( )</emphasis> method for <emphasis role="bold">Cat</emphasis>, otherwise you�ll get a syntax error. Then, at run-time, when you try to cast the <emphasis role="bold">Dog</emphasis> object to a <emphasis role="bold">Cat</emphasis>, you�ll get an exception.</para>
      <para>This is more than just an annoyance. It�s something that can create difficult-to-find bugs. If one part (or several parts) of a program inserts objects into a container, and you discover only in a separate part of the program through an exception that a bad object was placed in the container, then you must find out where the bad insert occurred. On the upside, it�s convenient to start with some standardized container classes for programming, despite the scarcity and awkwardness.</para>
      <section>
        <title><anchor xreflabel="Sometimes it works anyway" xml:id="_Toc481064680"/>Sometimes it works anyway</title>
        <para>It turns out that in some cases things seem to work correctly without casting back to your original type. One case is quite special: the <emphasis role="bold">String</emphasis> class has some extra help from the compiler to make it work smoothly. Whenever the compiler expects a <emphasis role="bold">String</emphasis> object and it hasn�t got one, it will automatically call the <emphasis role="bold">toString( )</emphasis> method that�s defined in <emphasis role="bold">Object</emphasis> and can be overridden by any Java class. This method produces the desired <emphasis role="bold">String</emphasis> object, which is then used wherever it was wanted.</para>
        <para>Thus, all you need to do to make objects of your class print is to override the <emphasis role="bold">toString( )</emphasis> method, as shown in the following example:</para>
        <para>//: c09:Mouse.java</para>
        <para>// Overriding toString().</para>
        <para>public class Mouse {</para>
        <para>� private int mouseNumber;</para>
        <para>� Mouse(int i) { mouseNumber = i; }</para>
        <para>� // Override Object.toString():</para>
        <para>� public String toString() {</para>
        <para>��� return &quot;This is Mouse #&quot; + mouseNumber;</para>
        <para>� }</para>
        <para>� public int getNumber() {</para>
        <para>��� return mouseNumber;</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>//: c09:WorksAnyway.java</para>
        <para>// In special cases, things just </para>
        <para>// seem to work correctly.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class MouseTrap {</para>
        <para>� static void caughtYa(Object m) {</para>
        <para>��� Mouse mouse = (Mouse)m; // Cast from Object</para>
        <para>��� System.out.println(&quot;Mouse: &quot; + </para>
        <para>����� mouse.getNumber());</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class WorksAnyway {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� ArrayList mice = new ArrayList();</para>
        <para>��� for(int i = 0; i &lt; 3; i++)</para>
        <para>����� mice.add(new Mouse(i));</para>
        <para>��� for(int i = 0; i &lt; mice.size(); i++) {</para>
        <para>����� // No cast necessary, automatic </para>
        <para>����� // call to Object.toString():</para>
        <para>����� System.out.println(</para>
        <para>������� &quot;Free mouse: &quot; + mice.get(i));</para>
        <para>����� MouseTrap.caughtYa(mice.get(i));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can see <emphasis role="bold">toString( )</emphasis> overridden in <emphasis role="bold">Mouse</emphasis>. In the second <emphasis role="bold">for</emphasis> loop in <emphasis role="bold">main( )</emphasis> you find the statement:</para>
        <para>System.out.println(&quot;Free mouse: &quot; + mice.get(i));</para>
        <para> </para>
        <para>After the �<emphasis role="bold">+</emphasis>� sign the compiler expects to see a <emphasis role="bold">String</emphasis> object. <emphasis role="bold">get( )</emphasis> produces an <emphasis role="bold">Object</emphasis>, so to get the desired <emphasis role="bold">String</emphasis> the compiler implicitly calls <emphasis role="bold">toString( )</emphasis>. Unfortunately, you can work this kind of magic only with <emphasis role="bold">String</emphasis>; it isn�t available for any other type.</para>
        <para>A second approach to hiding the cast has been placed inside <emphasis role="bold">MouseTrap</emphasis>. The <emphasis role="bold">caughtYa( )</emphasis> method accepts not a <emphasis role="bold">Mouse</emphasis>, but an <emphasis role="bold">Object,</emphasis> which it then casts to a <emphasis role="bold">Mouse</emphasis>. This is quite presumptuous, of course, since by accepting an <emphasis role="bold">Object</emphasis> anything could be passed to the method. However, if the cast is incorrect�if you passed the wrong type�you�ll get an exception at run-time. This is not as good as compile-time checking but it�s still robust. Note that in the use of this method:</para>
        <para>MouseTrap.caughtYa(mice.get(i));</para>
        <para> </para>
        <para>no cast is necessary.</para>
      </section>
      <section>
        <title><anchor xreflabel="Making a type-conscious ArrayList" xml:id="_Toc481064681"/>Making a type-conscious <emphasis role="bold">ArrayList</emphasis></title>
        <para>You might not want to give up on this issue just yet. A more ironclad solution is to create a new class using the <emphasis role="bold">ArrayList</emphasis>, such that it will accept only your type and produce only your type:</para>
        <para>//: c09:MouseList.java</para>
        <para>// A type-conscious ArrayList.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class MouseList {</para>
        <para>� private ArrayList list = new ArrayList();</para>
        <para>� public void add(Mouse m) {</para>
        <para>��� list.add(m);</para>
        <para>� }</para>
        <para>� public Mouse get(int index) {</para>
        <para>��� return (Mouse)list.get(index);</para>
        <para>� }</para>
        <para>� public int size() { return list.size(); }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Here�s a test for the new container:</para>
        <para>//: c09:MouseListTest.java</para>
        <para>public class MouseListTest {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� MouseList mice = new MouseList();</para>
        <para>��� for(int i = 0; i &lt; 3; i++)</para>
        <para>����� mice.add(new Mouse(i));</para>
        <para>��� for(int i = 0; i &lt; mice.size(); i++)</para>
        <para>����� MouseTrap.caughtYa(mice.get(i));</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This is similar to the previous example, except that the new <emphasis role="bold">MouseList</emphasis> class has a <emphasis role="bold">private </emphasis>member of type <emphasis role="bold">ArrayList</emphasis>, and methods just like <emphasis role="bold">ArrayList</emphasis>. However, it doesn�t accept and produce generic <emphasis role="bold">Object</emphasis>s, only <emphasis role="bold">Mouse</emphasis> objects. </para>
        <para>Note that if <emphasis role="bold">MouseList</emphasis> had instead been <emphasis role="italic">inherited</emphasis> from <emphasis role="bold">ArrayList</emphasis>, the <emphasis role="bold">add(</emphasis><emphasis role="bold">Mouse)</emphasis> method would simply overload the existing <emphasis role="bold">add(Object)</emphasis> and there would still be no restriction on what type of objects could be added. Thus, the <emphasis role="bold">MouseList</emphasis> becomes a <emphasis role="italic">surrogate</emphasis> to the <emphasis role="bold">ArrayList</emphasis>, performing some activities before passing on the responsibility (see <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis>).</para>
        <para>Because a <emphasis role="bold">MouseList</emphasis> will accept only a <emphasis role="bold">Mouse</emphasis>, if you say:</para>
        <para>mice.add(new Pigeon());</para>
        <para> </para>
        <para>you will get an error message <emphasis role="italic">at compile-time</emphasis>. This approach, while more tedious from a coding standpoint, will tell you immediately if you�re using a type improperly.</para>
        <para>Note that no cast is necessary when using <emphasis role="bold">get( )</emphasis>�it�s always a <emphasis role="bold">Mouse</emphasis>.</para>
        <section>
          <title>Parameterized types</title>
          <para>This kind of problem isn�t isolated�there are numerous cases in which you need to create new types based on other types, and in which it is useful to have specific type information at compile-time. This is the concept of a <emphasis role="italic">parameterized type</emphasis>. In C++, this is directly supported by the language with <emphasis role="italic">templates</emphasis>. It is likely that a future version of Java will support some variation of parameterized types; the current front-runner automatically creates classes similar to <emphasis role="bold">MouseList</emphasis>.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064682"/><anchor xreflabel="Iterators" xml:id="_Toc375545352"/>Iterators</title>
      <para>In any container class, you must have a way to put things in and a way to get things out. After all, that�s the primary job of a container�to hold things. In the <emphasis role="bold">ArrayList</emphasis>, <emphasis role="bold">add( )</emphasis> is the way that you insert objects, and <emphasis role="bold">get( )</emphasis> is <emphasis role="italic">one</emphasis> way to get things out. <emphasis role="bold">ArrayList</emphasis> is quite flexible�you can select anything at any time, and select multiple elements at once using different indexes.</para>
      <para>If you want to start thinking at a higher level, there�s a drawback: you need to know the exact type of the container in order to use it. This might not seem bad at first, but what if you start out using an <emphasis role="bold">ArrayList</emphasis>, and later on in your program you discover that because of the way you are using the container it would be much more efficient to use a <emphasis role="bold">Linked</emphasis><emphasis role="bold">List</emphasis> instead? Or suppose you�d like to write a piece of generic code that doesn�t know or care what type of container it�s working with, so that it could be used on different types of containers without rewriting that code?</para>
      <para>The concept of an <emphasis role="italic">iterator</emphasis> can be used to achieve this abstraction. An iterator is an object whose job is to move through a sequence of objects and select each object in that sequence without the client programmer knowing or caring about the underlying structure of that sequence. In addition, an iterator is usually what�s called a �light-weight� object: one that�s cheap to create. For that reason, you�ll often find seemingly strange constraints for iterators; for example, some iterators can move in only one direction.</para>
      <para>The Java <emphasis role="bold">Iterator</emphasis> is an example of an iterator with these kinds of constraints. There�s not much you can do with one except:</para>
      <para>Ask a container to hand you an <emphasis role="bold">Iterator</emphasis> using a method called <emphasis role="bold">iterator( )</emphasis>.<emphasis role="bold"/>This <emphasis role="bold">Iterator </emphasis>will be ready to return the first element in the sequence on your first call to its <emphasis role="bold">next( )</emphasis> method.</para>
      <para>56.      Get the next object in the sequence with <emphasis role="bold">next( )</emphasis>.</para>
      <para>57.      See if there <emphasis role="italic">are</emphasis> any more objects in the sequence with <emphasis role="bold">hasNext( )</emphasis>.</para>
      <para>58.      Remove the last element returned by the iterator with <emphasis role="bold">remove( )</emphasis>.</para>
      <para>That�s all. It�s a simple implementation of an iterator, but still powerful (and there�s a more sophisticated <emphasis role="bold">ListIterator</emphasis> for <emphasis role="bold">List</emphasis>s). To see how it works, let�s revisit the <emphasis role="bold">CatsAndDogs.java</emphasis> program from earlier in this chapter. In the original version, the method <emphasis role="bold">get( )</emphasis> was used to select each element, but in the following modified version an Iterator is used:</para>
      <para>//: c09:CatsAndDogs2.java</para>
      <para>// Simple container with Iterator.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>public class CatsAndDogs2 {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� ArrayList cats = new ArrayList();</para>
      <para>��� for(int i = 0; i &lt; 7; i++)</para>
      <para>����� cats.add(new Cat(i));</para>
      <para>��� Iterator e = cats.iterator();</para>
      <para>��� while(e.hasNext())</para>
      <para>����� ((Cat)e.next()).print();</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>You can see that the last few lines now use an <emphasis role="bold">Iterator</emphasis> to step through the sequence instead of a <emphasis role="bold">for</emphasis> loop. With the <emphasis role="bold">Iterator</emphasis>, you don�t need to worry about the number of elements in the container. That�s taken care of for you by <emphasis role="bold">hasNext( )</emphasis> and <emphasis role="bold">next( )</emphasis>.</para>
      <para>As another example, consider the creation of a general-purpose printing method:</para>
      <para>//: c09:HamsterMaze.java</para>
      <para>// Using an Iterator.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>class Hamster {</para>
      <para>� private int hamsterNumber;</para>
      <para>� Hamster(int i) { hamsterNumber = i; }</para>
      <para>� public String toString() {</para>
      <para>��� return &quot;This is Hamster #&quot; + hamsterNumber;</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Printer {</para>
      <para>� static void printAll(Iterator e) {</para>
      <para>��� while(e.hasNext())</para>
      <para>����� System.out.println(e.next());</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class HamsterMaze {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� ArrayList v = new ArrayList();</para>
      <para>��� for(int i = 0; i &lt; 3; i++)</para>
      <para>����� v.add(new Hamster(i));</para>
      <para>��� Printer.printAll(v.iterator());</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Look closely at <emphasis role="bold">printAll( )</emphasis>. Note that there�s no information about the type of sequence. All you have is an <emphasis role="bold">Iterator</emphasis>, and that�s all you need to know about the sequence: that you can get the next object, and that you can know when you�re at the end. This idea of taking a container of objects and passing through it to perform an operation on each one is powerful, and will be seen throughout this book.</para>
      <para>The example is even more generic, since it implicitly uses the <emphasis role="bold">Object.</emphasis><emphasis role="bold">toString( )</emphasis> method. The <emphasis role="bold">println( )</emphasis> method is overloaded for all the primitive types as well as <emphasis role="bold">Object</emphasis>; in each case a <emphasis role="bold">String</emphasis> is automatically produced by calling the appropriate <emphasis role="bold">toString( )</emphasis> method. </para>
      <para>Although it�s unnecessary, you can be more explicit using a cast, which has the effect of calling <emphasis role="bold">toString( )</emphasis>:</para>
      <para>System.out.println((String)e.next());</para>
      <para> </para>
      <para>In general, however, you�ll want to do something more than call <emphasis role="bold">Object</emphasis> methods, so you�ll run up against the type-casting issue again. You must assume you�ve gotten an <emphasis role="bold">Iterator</emphasis> to a sequence of the particular type you�re interested in, and cast the resulting objects to that type (getting a run-time exception if you�re wrong).</para>
      <section>
        <title>Unintended recursion</title>
        <para>Because (like every other class), the Java standard containers are inherited from <emphasis role="bold">Object</emphasis>, they<emphasis role="bold"/>contain a <emphasis role="bold">toString( )</emphasis> method. This has been overridden so that they can produce a <emphasis role="bold">String</emphasis> representation of themselves, including the objects they hold. Inside <emphasis role="bold">ArrayList</emphasis>, for example, the <emphasis role="bold">toString( )</emphasis> steps through the elements of the <emphasis role="bold">ArrayList</emphasis> and calls <emphasis role="bold">toString( )</emphasis> for each one. Suppose you�d like to print the address of your class. It seems to make sense to simply refer to <emphasis role="bold">this </emphasis>(in particular, C++ programmers are prone to this approach):</para>
        <para>//: c09:InfiniteRecursion.java</para>
        <para>// Accidental recursion.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class InfiniteRecursion {</para>
        <para>� public String toString() {</para>
        <para>��� return &quot; InfiniteRecursion address: &quot; </para>
        <para>����� + this + &quot;\n&quot;;</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� ArrayList v = new ArrayList();</para>
        <para>��� for(int i = 0; i &lt; 10; i++)</para>
        <para>����� v.add(new InfiniteRecursion());</para>
        <para>��� System.out.println(v);</para>
        <para>��}</para>
        <para>} ///:~</para>
        <para> </para>
        <para>If you simply create an <emphasis role="bold">InfiniteRecursion</emphasis> object and then print it, you�ll get an endless sequence of exceptions. This is also true if you place the <emphasis role="bold">InfiniteRecursion</emphasis> objects in an <emphasis role="bold">ArrayList</emphasis> and print that <emphasis role="bold">ArrayList</emphasis> as shown here. What�s happening is automatic type conversion for <emphasis role="bold">String</emphasis>s. When you say: </para>
        <para>&quot;InfiniteRecursion address: &quot; + this</para>
        <para> </para>
        <para>The compiler sees a <emphasis role="bold">String</emphasis> followed by a �<emphasis role="bold">+</emphasis>� and<emphasis role="bold"/>something that�s not a <emphasis role="bold">String</emphasis>, so it tries to convert <emphasis role="bold">this</emphasis> to a <emphasis role="bold">String</emphasis>. It does this conversion by calling <emphasis role="bold">toString( )</emphasis>, which produces a recursive call. </para>
        <para>If you really do want to print the address of the object in this case, the solution is to call the <emphasis role="bold">Object</emphasis><emphasis role="bold">toString( )</emphasis> method, which does just that. So instead of saying <emphasis role="bold">this</emphasis>, you�d say <emphasis role="bold">super.toString( )</emphasis>. (This only works if you&apos;re directly inheriting from <emphasis role="bold">Object</emphasis>, or if none of your parent classes have overridden the <emphasis role="bold">toString( )</emphasis> method.)</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545359"/><anchor xreflabel="Container
taxonomy" xml:id="_Toc481064683"/>Container taxonomy</title>
      <para><emphasis role="bold">Collection</emphasis>s and <emphasis role="bold">Map</emphasis>s may be implemented in different ways, according to your programming needs. It�s helpful to look at a diagram of the Java 2 containers:</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="432" contentwidth="478" fileref="./TIJ2_files/image028.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image028.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>This diagram can be a bit overwhelming at first, but you�ll see that there are really only three container components: <emphasis role="bold">Map</emphasis>, <emphasis role="bold">List</emphasis>, and <emphasis role="bold">Set</emphasis>, and only two or three implementations of each one (with, typically, a preferred version). When you see this, the containers are not so daunting.</para>
      <para>The dotted boxes represent <emphasis role="bold">interface</emphasis>s, the dashed boxes represent <emphasis role="bold">abstract</emphasis> classes, and the solid boxes are regular (concrete) classes. The dotted-line arrows indicate that a particular class is implementing an <emphasis role="bold">interface</emphasis> (or in the case of an <emphasis role="bold">abstract</emphasis> class, partially implementing that <emphasis role="bold">interface</emphasis>). The solid arrows show that a class can produce objects of the class the arrow is pointing to. For example, any <emphasis role="bold">Collection</emphasis> can produce an <emphasis role="bold">Iterator</emphasis>, while a <emphasis role="bold">List</emphasis> can produce a <emphasis role="bold">ListIterator</emphasis> (as well as an ordinary <emphasis role="bold">Iterator</emphasis>, since <emphasis role="bold">List</emphasis> is inherited from <emphasis role="bold">Collection</emphasis>).</para>
      <para>The interfaces that are concerned with holding objects are <emphasis role="bold">Collection</emphasis>, <emphasis role="bold">List</emphasis>, <emphasis role="bold">Set</emphasis>, and <emphasis role="bold">Map</emphasis>.<emphasis role="bold"/>Ideally, you�ll write most of your code to talk to these interfaces, and the only place where you�ll specify the precise type you�re using is at the point of creation. So you can create a <emphasis role="bold">List</emphasis> like this:</para>
      <para>List x = new LinkedList();</para>
      <para> </para>
      <para>Of course, you can also decide to make <emphasis role="bold">x </emphasis>a <emphasis role="bold">LinkedList </emphasis>(instead of a generic <emphasis role="bold">List</emphasis>)<emphasis role="bold"/>and carry the precise type information around with <emphasis role="bold">x</emphasis>. The beauty (and the intent) of using the <emphasis role="bold">interface</emphasis> is that if you decide you want to change your implementation, all you need to do is change it at the point of creation, like this:</para>
      <para>List x = new ArrayList();</para>
      <para> </para>
      <para>The rest of your code can remain untouched (some of this genericity can also be achieved with iterators).</para>
      <para>In the class hierarchy, you can see a number of classes whose names begin with �<emphasis role="bold">Abstract</emphasis>,� and these can seem a bit confusing at first. They are simply tools that partially implement a particular interface. If you were making your own <emphasis role="bold">Set</emphasis>, for example, you wouldn�t start with the <emphasis role="bold">Set</emphasis> interface and implement all the methods, instead you�d inherit from <emphasis role="bold">AbstractSet</emphasis> and do the minimal necessary work to make your new class. However, the containers library contains enough functionality to satisfy your needs virtually all the time. So for our purposes, you can ignore any class that begins with �<emphasis role="bold">Abstract</emphasis>.�</para>
      <para>Therefore, when you look at the diagram, you�re really concerned with only those <emphasis role="bold">interface</emphasis>s at the top of the diagram and the concrete classes (those with solid boxes around them). You�ll typically make an object of a concrete class, upcast it to the corresponding <emphasis role="bold">interface</emphasis>, and then use the <emphasis role="bold">interface</emphasis> throughout the rest of your code. In addition, you do not need to consider the legacy elements when writing new code. Therefore, the diagram can be greatly simplified to look like this:</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="256" contentwidth="490" fileref="./TIJ2_files/image029.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image029.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>Now it only includes the interfaces and classes that you will encounter on a regular basis, and also the elements that we will focus on in this chapter.</para>
      <para>Here�s a simple example, which fills a <emphasis role="bold">Collection</emphasis> (represented here with an <emphasis role="bold">ArrayList</emphasis>) with <emphasis role="bold">String</emphasis> objects, and then prints each element in the <emphasis role="bold">Collection</emphasis>:</para>
      <para>//: c09:SimpleCollection.java</para>
      <para>// A simple example using Java 2 Collections.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>public class SimpleCollection {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� // Upcast because we just want to</para>
      <para>��� // work with Collection features</para>
      <para>��� Collection c = new ArrayList();</para>
      <para> </para>
      <para>��� for(int i = 0; i &lt; 10; i++)</para>
      <para>����� c.add(Integer.toString(i));</para>
      <para>��� Iterator it = c.iterator();</para>
      <para>��� while(it.hasNext())</para>
      <para>����� System.out.println(it.next());</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The first line in <emphasis role="bold">main( )</emphasis> creates an <emphasis role="bold">ArrayList</emphasis> object and then upcasts it to a <emphasis role="bold">Collection</emphasis>. Since this example uses only the <emphasis role="bold">Collection </emphasis>methods, any object of a class inherited from <emphasis role="bold">Collection</emphasis> would work, but <emphasis role="bold">ArrayList</emphasis> is the typical workhorse <emphasis role="bold">Collection</emphasis>.</para>
      <para>The <emphasis role="bold">add( )</emphasis> method, as its name suggests, puts a new element in the <emphasis role="bold">Collection</emphasis>. However, the documentation carefully states that <emphasis role="bold">add( )</emphasis> �ensures that this Container contains the specified element.� This is to allow for the meaning of <emphasis role="bold">Set</emphasis>, which adds the element only if it isn�t already there. With an <emphasis role="bold">ArrayList</emphasis>, or any sort of <emphasis role="bold">List</emphasis>, <emphasis role="bold">add( )</emphasis> always means �put it in,� because <emphasis role="bold">List</emphasis>s don�t care if there are duplicates.</para>
      <para>All <emphasis role="bold">Collection</emphasis>s can produce an <emphasis role="bold">Iterator</emphasis> via their <emphasis role="bold">iterator( )</emphasis> method. Here, an <emphasis role="bold">Iterator</emphasis> is created and used to traverse the <emphasis role="bold">Collection</emphasis>, printing each element.</para>
    </section>
    <section>
      <title><anchor xreflabel="Collection functionality" xml:id="_Toc481064684"/><emphasis role="bold">Collection</emphasis> functionality</title>
      <para>The following table shows everything you can do with a <emphasis role="bold">Collection</emphasis> (not including the methods that automatically come through with <emphasis role="bold">Object</emphasis>), and thus, everything you can do with a <emphasis role="bold">Set</emphasis> or a <emphasis role="bold">List</emphasis>. (<emphasis role="bold">List</emphasis> also has additional functionality.) <emphasis role="bold">Map</emphasis>s are not inherited from <emphasis role="bold">Collection</emphasis>, and will be treated separately.</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="19*"/>
          <colspec colname="c2" colwidth="28*"/>
          <tbody>
            <row>
              <entry valign="top"><para> boolean add(Object)</para></entry>
              <entry valign="top"><para> Ensures that the container holds the argument. Returns false if it doesn�t add the argument. (This is an �optional� method, described later in this chapter.)</para></entry>
            </row>
            <row>
              <entry valign="top"><para> boolean </para><para> addAll(Collection)</para></entry>
              <entry valign="top"><para> Adds all the elements in the argument. Returns true if any elements were added. (�Optional.�)</para></entry>
            </row>
            <row>
              <entry valign="top"><para> void clear( )</para></entry>
              <entry valign="top"><para> Removes all the elements in the container. (�Optional.�)</para></entry>
            </row>
            <row>
              <entry valign="top"><para> boolean </para><para> contains(Object)</para></entry>
              <entry valign="top"><para> true if the container holds the argument. </para></entry>
            </row>
            <row>
              <entry valign="top"><para> boolean containsAll(Collection)</para></entry>
              <entry valign="top"><para> true if the container holds all the elements in the argument. </para></entry>
            </row>
            <row>
              <entry valign="top"><para> boolean isEmpty( )</para></entry>
              <entry valign="top"><para> true if the container has no elements. </para></entry>
            </row>
            <row>
              <entry valign="top"><para> Iterator iterator( )</para></entry>
              <entry valign="top"><para> Returns an Iterator that you can use to move through the elements in the container. </para></entry>
            </row>
            <row>
              <entry valign="top"><para> boolean </para><para> remove(Object)</para></entry>
              <entry valign="top"><para> If the argument is in the container, one instance of that element is removed. Returns true if a removal occurred. (�Optional.�)</para></entry>
            </row>
            <row>
              <entry valign="top"><para> boolean removeAll(Collection)</para></entry>
              <entry valign="top"><para> Removes all the elements that are contained in the argument. Returns true if any removals occurred. (�Optional.�)</para></entry>
            </row>
            <row>
              <entry valign="top"><para> boolean retainAll(Collection)</para></entry>
              <entry valign="top"><para> Retains only elements that are contained in the argument (an �intersection� from set theory). Returns true if any changes occurred. (�Optional.�)</para></entry>
            </row>
            <row>
              <entry valign="top"><para> int size( )</para></entry>
              <entry valign="top"><para> Returns the number of elements in the container. </para></entry>
            </row>
            <row>
              <entry valign="top"><para> Object[] toArray( )</para></entry>
              <entry valign="top"><para> Returns an array containing all the elements in the container.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> Object[] </para><para> toArray(Object[] a)</para></entry>
              <entry valign="top"><para> Returns an array containing all the elements in the container, whose type is that of the array a rather than plain Object (you must cast the array to the right type).</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Notice that there�s no <emphasis role="bold">get( )</emphasis> function for random-access element selection. That�s because <emphasis role="bold">Collection</emphasis> also includes <emphasis role="bold">Set</emphasis>, which maintains its own internal ordering (and thus makes random-access lookup meaningless). Thus, if you want to examine all the elements of a <emphasis role="bold">Collection</emphasis> you must use an iterator; that�s the only way to fetch things back.</para>
      <para>The following example demonstrates all of these methods. Again, these work with anything that inherits from <emphasis role="bold">Collection</emphasis>, but an <emphasis role="bold">ArrayList</emphasis> is used as a kind of �least-common denominator�:</para>
      <para>//: c09:Collection1.java</para>
      <para>// Things you can do with all Collections.</para>
      <para>import java.util.*;</para>
      <para>import com.bruceeckel.util.*;</para>
      <para> </para>
      <para>public class Collection1 {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Collection c = new ArrayList();</para>
      <para>��� Collections2.fill(c, </para>
      <para>����� Collections2.countries, 10);��� </para>
      <para>��� c.add(&quot;ten&quot;);</para>
      <para>��� c.add(&quot;eleven&quot;);</para>
      <para>��� System.out.println(c);</para>
      <para>��� // Make an array from the List:</para>
      <para>��� Object[] array = c.toArray(); </para>
      <para>��� // Make a String array from the List:</para>
      <para>��� String[] str = </para>
      <para>����� (String[])c.toArray(new String[1]);</para>
      <para>��� // Find max and min elements; this means</para>
      <para>��� // different things depending on the way</para>
      <para>��� // the Comparable interface is implemented:</para>
      <para>��� System.out.println(&quot;Collections.max(c) = &quot; +</para>
      <para>����� Collections.max(c));</para>
      <para>��� System.out.println(&quot;Collections.min(c) = &quot; +</para>
      <para>����� Collections.min(c));</para>
      <para>��� // Add a Collection to another Collection</para>
      <para>��� Collection c2 = new ArrayList();</para>
      <para>��� Collections2.fill(c2, </para>
      <para>����� Collections2.countries, 10);��� </para>
      <para>��� c.addAll(c2);</para>
      <para>��� System.out.println(c);</para>
      <para>��� c.remove(CountryCapitals.pairs[0][0]);</para>
      <para>��� System.out.println(c);</para>
      <para>��� c.remove(CountryCapitals.pairs[1][0]);</para>
      <para>��� System.out.println(c);</para>
      <para>��� // Remove all components that are in the</para>
      <para>��� // argument collection:</para>
      <para>��� c.removeAll(c2);</para>
      <para>��� System.out.println(c);</para>
      <para>��� c.addAll(c2);</para>
      <para>��� System.out.println(c);</para>
      <para>��� // Is an element in this Collection?</para>
      <para>��� String val = CountryCapitals.pairs[3][0];</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;c.contains(&quot; + val� + &quot;) = &quot; </para>
      <para>����� + c.contains(val));</para>
      <para>��� // Is a Collection in this Collection?</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;c.containsAll(c2) = &quot;+ c.containsAll(c2));</para>
      <para>��� Collection c3 = ((List)c).subList(3, 5);</para>
      <para>��� // Keep all the elements that are in both</para>
      <para>��� // c2 and c3 (an intersection of sets):</para>
      <para>��� c2.retainAll(c3);</para>
      <para>��� System.out.println(c);</para>
      <para>��� // Throw away all the elements </para>
      <para>��� // in c2 that also appear in c3:</para>
      <para>��� c2.removeAll(c3);</para>
      <para>��� System.out.println(&quot;c.isEmpty() = &quot; +</para>
      <para>����� c.isEmpty());</para>
      <para>��� c = new ArrayList();</para>
      <para>��� Collections2.fill(c, </para>
      <para>����� Collections2.countries, 10);��� </para>
      <para>��� System.out.println(c);</para>
      <para>��� c.clear(); // Remove all elements</para>
      <para>��� System.out.println(&quot;after c.clear():&quot;);</para>
      <para>��� System.out.println(c);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para><emphasis role="bold">ArrayList</emphasis>s are created containing different sets of data and upcast to <emphasis role="bold">Collection</emphasis> objects, so it�s clear that nothing other than the <emphasis role="bold">Collection</emphasis> interface is being used. <emphasis role="bold">main( )</emphasis> uses simple exercises to show all of the methods in <emphasis role="bold">Collection</emphasis>.</para>
      <para>The following sections describe the various implementations of <emphasis role="bold">List</emphasis>, <emphasis role="bold">Set,</emphasis> and <emphasis role="bold">Map</emphasis> and indicate in each case (with an asterisk) which one should be your default choice. You�ll notice that the legacy classes <emphasis role="bold">Vector</emphasis>, <emphasis role="bold">Stack</emphasis>, and <emphasis role="bold">Hashtable</emphasis> are <emphasis role="italic">not</emphasis> included because in all cases there are preferred classes within the Java 2 Containers.</para>
    </section>
    <section>
      <title><anchor xreflabel="List functionality" xml:id="_Toc481064685"/><emphasis role="bold">List</emphasis> functionality</title>
      <para>The basic <emphasis role="bold">List</emphasis> is quite simple to use, as you�ve seen so far with <emphasis role="bold">ArrayList</emphasis>. Although most of the time you�ll just use <emphasis role="bold">add( )</emphasis> to insert objects, <emphasis role="bold">get( )</emphasis> to get them out one at a time, and <emphasis role="bold">iterator( )</emphasis> to get an <emphasis role="bold">Iterator</emphasis> to the sequence, there�s also a set of other methods that can be useful. </para>
      <para>In addition, there are actually two types of <emphasis role="bold">List</emphasis>: the basic <emphasis role="bold">ArrayList</emphasis>, which excels at randomly accessing elements, and the much more powerful <emphasis role="bold">LinkedList</emphasis> (which is not designed for fast random access, but has a much more general set of methods).</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="10*"/>
          <colspec colname="c2" colwidth="36*"/>
          <tbody>
            <row>
              <entry valign="top"><para> List (interface)</para></entry>
              <entry valign="top"><para> Order is the most important feature of a List; it promises to maintain elements in a particular sequence. List adds a number of methods to Collection that allow insertion and removal of elements in the middle of a List. (This is recommended only for a LinkedList.) A List will produce a ListIterator, and using this you can traverse the List in both directions, as well as insert and remove elements in the middle of the List.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> ArrayList*</para></entry>
              <entry valign="top"><para> A List implemented with an array. Allows rapid random access to elements, but is slow when inserting and removing elements from the middle of a list. ListIterator should be used only for back-and-forth traversal of an ArrayList, but not for inserting and removing elements, which is expensive compared to LinkedList.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> LinkedList</para></entry>
              <entry valign="top"><para> Provides optimal sequential access, with inexpensive insertions and deletions from the middle of the List. Relatively slow for random access. (Use ArrayList instead.) Also has addFirst( ), addLast( ), getFirst( ), getLast( ), removeFirst( ), and removeLast( ) (which are not defined in any interfaces or base classes) to allow it to be used as a stack, a queue, and a deque.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>The methods in the following example each cover a different group of activities: things that every list can do (<emphasis role="bold">basicTest( )</emphasis>), moving around with an <emphasis role="bold">Iterator</emphasis> (<emphasis role="bold">iterMotion( )</emphasis>)<emphasis role="bold"/>versus changing things with an <emphasis role="bold">Iterator</emphasis> (<emphasis role="bold">iterManipulation( )</emphasis>), seeing the effects of <emphasis role="bold">List</emphasis> manipulation (<emphasis role="bold">testVisual( )</emphasis>), and operations available only to <emphasis role="bold">LinkedList</emphasis>s.</para>
      <para>//: c09:List1.java</para>
      <para>// Things you can do with Lists.</para>
      <para>import java.util.*;</para>
      <para>import com.bruceeckel.util.*;</para>
      <para> </para>
      <para>public class List1 {</para>
      <para>� public static List fill(List a) {</para>
      <para>��� Collections2.countries.reset();</para>
      <para>��� Collections2.fill(a, </para>
      <para>����� Collections2.countries, 10);</para>
      <para>��� return a;</para>
      <para>� }</para>
      <para>� static boolean b;</para>
      <para>� static Object o;</para>
      <para>� static int i;</para>
      <para>� static Iterator it;</para>
      <para>� static ListIterator lit;</para>
      <para>� public static void basicTest(List a) {</para>
      <para>��� a.add(1, &quot;x&quot;); // Add at location 1</para>
      <para>��� a.add(&quot;x&quot;); // Add at end</para>
      <para>��� // Add a collection:</para>
      <para>��� a.addAll(fill(new ArrayList()));</para>
      <para>��� // Add a collection starting at location 3:</para>
      <para>��� a.addAll(3, fill(new ArrayList())); </para>
      <para>��� b = a.contains(&quot;1&quot;); // Is it in there?</para>
      <para>��� // Is the entire collection in there?</para>
      <para>��� b = a.containsAll(fill(new ArrayList()));</para>
      <para>��� // Lists allow random access, which is cheap</para>
      <para>��� // for ArrayList, expensive for LinkedList:</para>
      <para>��� o = a.get(1); // Get object at location 1</para>
      <para>��� i = a.indexOf(&quot;1&quot;); // Tell index of object</para>
      <para>��� b = a.isEmpty(); // Any elements inside?</para>
      <para>��� it = a.iterator(); // Ordinary Iterator</para>
      <para>��� lit = a.listIterator(); // ListIterator</para>
      <para>��� lit = a.listIterator(3); // Start at loc 3</para>
      <para>��� i = a.lastIndexOf(&quot;1&quot;); // Last match </para>
      <para>��� a.remove(1); // Remove location 1</para>
      <para>��� a.remove(&quot;3&quot;); // Remove this object</para>
      <para>��� a.set(1, &quot;y&quot;); // Set location 1 to &quot;y&quot;</para>
      <para>��� // Keep everything that&apos;s in the argument</para>
      <para>��� // (the intersection of the two sets):</para>
      <para>��� a.retainAll(fill(new ArrayList()));</para>
      <para>��� // Remove everything that&apos;s in the argument:</para>
      <para>��� a.removeAll(fill(new ArrayList()));</para>
      <para>��� i = a.size(); // How big is it?</para>
      <para>� ��a.clear(); // Remove all elements</para>
      <para>� }</para>
      <para>� public static void iterMotion(List a) {</para>
      <para>��� ListIterator it = a.listIterator();</para>
      <para>��� b = it.hasNext();</para>
      <para>��� b = it.hasPrevious();</para>
      <para>��� o = it.next();</para>
      <para>��� i = it.nextIndex();</para>
      <para>��� o = it.previous();</para>
      <para>��� i = it.previousIndex();</para>
      <para>� }</para>
      <para>� public static void iterManipulation(List a) {</para>
      <para>��� ListIterator it = a.listIterator();</para>
      <para>��� it.add(&quot;47&quot;);</para>
      <para>��� // Must move to an element after add():</para>
      <para>��� it.next();</para>
      <para>��� // Remove the element that was just produced:</para>
      <para>��� it.remove(); </para>
      <para>��� // Must move to an element after remove():</para>
      <para>��� it.next();</para>
      <para>��� // Change the element that was just produced:</para>
      <para>��� it.set(&quot;47&quot;);</para>
      <para>� }</para>
      <para>� public static void testVisual(List a) {</para>
      <para>��� System.out.println(a);</para>
      <para>��� List b = new ArrayList();</para>
      <para>��� fill(b);</para>
      <para>��� System.out.print(&quot;b = &quot;);</para>
      <para>��� System.out.println(b);</para>
      <para>��� a.addAll(b);</para>
      <para>��� a.addAll(fill(new ArrayList()));</para>
      <para>��� System.out.println(a);</para>
      <para>��� // Insert, remove, and replace elements</para>
      <para>��� // using a ListIterator:</para>
      <para>��� ListIterator x = a.listIterator(a.size()/2);</para>
      <para>��� x.add(&quot;one&quot;); </para>
      <para>��� System.out.println(a);</para>
      <para>��� System.out.println(x.next());</para>
      <para>��� x.remove();</para>
      <para>��� System.out.println(x.next());</para>
      <para>��� x.set(&quot;47&quot;);</para>
      <para>��� System.out.println(a);</para>
      <para>��� // Traverse the list backwards:</para>
      <para>��� x = a.listIterator(a.size());</para>
      <para>��� while(x.hasPrevious())</para>
      <para>� ����System.out.print(x.previous() + &quot; &quot;);</para>
      <para>��� System.out.println();</para>
      <para>��� System.out.println(&quot;testVisual finished&quot;);</para>
      <para>� }</para>
      <para>� // There are some things that only</para>
      <para>� // LinkedLists can do:</para>
      <para>� public static void testLinkedList() {</para>
      <para>��� LinkedList ll = new LinkedList();</para>
      <para>��� fill(ll);</para>
      <para>��� System.out.println(ll);</para>
      <para>��� // Treat it like a stack, pushing:</para>
      <para>��� ll.addFirst(&quot;one&quot;);</para>
      <para>��� ll.addFirst(&quot;two&quot;);</para>
      <para>��� System.out.println(ll);</para>
      <para>��� // Like &quot;peeking&quot; at the top of a stack:</para>
      <para>��� System.out.println(ll.getFirst());</para>
      <para>��� // Like popping a stack:</para>
      <para>��� System.out.println(ll.removeFirst());</para>
      <para>��� System.out.println(ll.removeFirst());</para>
      <para>��� // Treat it like a queue, pulling elements</para>
      <para>��� // off the tail end:</para>
      <para>��� System.out.println(ll.removeLast());</para>
      <para>��� // With the above operations, it&apos;s a dequeue!</para>
      <para>��� System.out.println(ll);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� // Make and fill a new list each time:</para>
      <para>��� basicTest(fill(new LinkedList()));</para>
      <para>��� basicTest(fill(new ArrayList()));</para>
      <para>��� iterMotion(fill(new LinkedList()));</para>
      <para>��� iterMotion(fill(new ArrayList()));</para>
      <para>��� iterManipulation(fill(new LinkedList()));</para>
      <para>��� iterManipulation(fill(new ArrayList()));</para>
      <para>��� testVisual(fill(new LinkedList()));</para>
      <para>��� testLinkedList();</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>In <emphasis role="bold">basicTest( )</emphasis> and <emphasis role="bold">iterMotion( )</emphasis> the calls are simply made to show the proper syntax, and while the return value is captured, it is not used. In some cases, the return value isn�t captured since it isn�t typically used. You should look up the full usage of each of these methods in the online documentation from <emphasis role="italic">java.sun.com</emphasis> before you use them.</para>
      <section>
        <title><anchor xreflabel="Making a stack from a LinkedList" xml:id="_Toc481064686"/>Making a stack from a <emphasis role="bold">LinkedList</emphasis></title>
        <para>A stack is sometimes referred to as a �last-in, first-out� (LIFO) container. That is, whatever you �push� on the stack last is the first item you can �pop� out. Like all of the other containers in Java, what you push and pop are <emphasis role="bold">Object</emphasis>s, so you must cast what you pop, unless you�re just using <emphasis role="bold">Object</emphasis> behavior.</para>
        <para>The <emphasis role="bold">LinkedList</emphasis> has methods that directly implement stack functionality, so you can also just use a <emphasis role="bold">LinkedList</emphasis> rather than making a stack class. However, a stack class can sometimes tell the story better:</para>
        <para>//: c09:StackL.java</para>
        <para>// Making a stack from a LinkedList.</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>public class StackL {</para>
        <para>� private LinkedList list = new LinkedList();</para>
        <para>� public void push(Object v) {</para>
        <para>��� list.addFirst(v);</para>
        <para>� }</para>
        <para>� public Object top() { return list.getFirst(); }</para>
        <para>� public Object pop() { </para>
        <para>��� return list.removeFirst(); </para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� StackL stack = new StackL();</para>
        <para>� ��for(int i = 0; i &lt; 10; i++)</para>
        <para>����� stack.push(Collections2.countries.next());</para>
        <para>��� System.out.println(stack.top());</para>
        <para>��� System.out.println(stack.top());</para>
        <para>��� System.out.println(stack.pop());</para>
        <para>��� System.out.println(stack.pop());</para>
        <para>��� System.out.println(stack.pop());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>If you want only stack behavior, inheritance is inappropriate here because it would produce a class with all the rest of the <emphasis role="bold">LinkedList</emphasis> methods (you�ll see later that this very mistake was made by the Java 1.0 library designers with <emphasis role="bold">Stack</emphasis>).</para>
      </section>
      <section>
        <title><anchor xreflabel="Making a queue from a LinkedList" xml:id="_Toc481064687"/>Making a queue from a <emphasis role="bold">LinkedList</emphasis></title>
        <para>A <emphasis role="italic">queue</emphasis> is a �<emphasis role="italic">first-in, first-out</emphasis>� (FIFO) container. That is, you put things in at one end, and pull them out at the other. So the order in which you put them in will be the same order that they come out. <emphasis role="bold">LinkedList</emphasis> has methods to support queue behavior, so these can be used in a <emphasis role="bold">Queue</emphasis> class:</para>
        <para>//: c09:Queue.java</para>
        <para>// Making a queue from a LinkedList.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class Queue {</para>
        <para>� private LinkedList list = new LinkedList();</para>
        <para>� public void put(Object v) { list.addFirst(v); }</para>
        <para>� public Object get() { </para>
        <para>��� return list.removeLast(); </para>
        <para>� }</para>
        <para>� public boolean isEmpty() { </para>
        <para>��� return list.isEmpty(); </para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Queue queue = new Queue();</para>
        <para>��� for(int i = 0; i &lt; 10; i++)</para>
        <para>����� queue.put(Integer.toString(i));</para>
        <para>��� while(!queue.isEmpty())</para>
        <para>����� System.out.println(queue.get());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can also easily create a <emphasis role="italic">deque</emphasis> (double-ended queue) from a <emphasis role="bold">LinkedList</emphasis>. This is like a queue, but you can add and remove elements from either end.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Set
functionality" xml:id="_Toc481064688"/><emphasis role="bold">Set</emphasis> functionality</title>
      <para><emphasis role="bold">Set</emphasis> has exactly the same interface as <emphasis role="bold">Collection</emphasis>, so there isn�t any extra functionality like there is with the two different <emphasis role="bold">List</emphasis>s. Instead, the <emphasis role="bold">Set</emphasis> is exactly a <emphasis role="bold">Collection</emphasis>, it just has different behavior. (This is the ideal use of inheritance and polymorphism: to express different behavior.) A <emphasis role="bold">Set</emphasis> refuses to hold more than one instance of each object value (what constitutes the �value� of an object is more complex, as you shall see). </para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="10*"/>
          <colspec colname="c2" colwidth="36*"/>
          <tbody>
            <row>
              <entry valign="top"><para> Set (interface)</para></entry>
              <entry valign="top"><para> Each element that you add to the Set must be unique; otherwise the Set doesn�t add the duplicate element. Objects added to a Set must define equals( ) to establish object uniqueness. Set has exactly the same interface as Collection. The Set interface does not guarantee it will maintain its elements in any particular order.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> HashSet*</para></entry>
              <entry valign="top"><para> For Sets where fast lookup time is important. Objects must also define hashCode( ).</para></entry>
            </row>
            <row>
              <entry valign="top"><para> TreeSet</para></entry>
              <entry valign="top"><para> An ordered Set backed by a tree. This way, you can extract an ordered sequence from a Set.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>The following example does <emphasis role="italic">not</emphasis> show everything you can do with a <emphasis role="bold">Set</emphasis>, since the interface is the same as <emphasis role="bold">Collection</emphasis>, and so was exercised in the previous example. Instead, this demonstrates the behavior that makes a <emphasis role="bold">Set</emphasis> unique:</para>
      <para>//: c09:Set1.java</para>
      <para>// Things you can do with Sets.</para>
      <para>import java.util.*;</para>
      <para>import com.bruceeckel.util.*;</para>
      <para> </para>
      <para>public class Set1 {</para>
      <para>� static Collections2.StringGenerator gen = </para>
      <para>��� Collections2.countries;</para>
      <para>� public static void testVisual(Set a) {</para>
      <para>��� Collections2.fill(a, gen.reset(), 10);��� </para>
      <para>��� Collections2.fill(a, gen.reset(), 10);��� </para>
      <para>��� Collections2.fill(a, gen.reset(), 10);��� </para>
      <para>��� System.out.println(a); // No duplicates!</para>
      <para>��� // Add another set to this one:</para>
      <para>�� �a.addAll(a);</para>
      <para>��� a.add(&quot;one&quot;); </para>
      <para>��� a.add(&quot;one&quot;); </para>
      <para>��� a.add(&quot;one&quot;);</para>
      <para>��� System.out.println(a);</para>
      <para>��� // Look something up:</para>
      <para>��� System.out.println(&quot;a.contains(\&quot;one\&quot;): &quot; +</para>
      <para>����� a.contains(&quot;one&quot;));</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� System.out.println(&quot;HashSet&quot;);</para>
      <para>��� testVisual(new HashSet());</para>
      <para>��� System.out.println(&quot;TreeSet&quot;);</para>
      <para>��� testVisual(new TreeSet());</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Duplicate values are added to the <emphasis role="bold">Set</emphasis>, but when it is printed you�ll see the <emphasis role="bold">Set</emphasis> has accepted only one instance of each value.</para>
      <para>When you run this program you�ll notice that the order maintained by the <emphasis role="bold">HashSet</emphasis> is different from <emphasis role="bold">TreeSet</emphasis>, since each has a different way of storing elements so they can be located later. (<emphasis role="bold">TreeSet</emphasis> keeps them sorted, while <emphasis role="bold">HashSet</emphasis> uses a hashing function, which is designed specifically for rapid lookups.) When creating your own types, be aware that a <emphasis role="bold">Set</emphasis> needs a way to maintain a storage order, which means you must implement the <emphasis role="bold">Comparable </emphasis>interface and define the <emphasis role="bold">compareTo( ) </emphasis>method. Here�s an example:</para>
      <para>//: c09:Set2.java</para>
      <para>// Putting your own type in a Set.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>class MyType implements Comparable {</para>
      <para>� private int i;</para>
      <para>� public MyType(int n) { i = n; }</para>
      <para>� public boolean equals(Object o) {</para>
      <para>��� return </para>
      <para>����� (o instanceof MyType) </para>
      <para>����� &amp;&amp; (i == ((MyType)o).i);</para>
      <para>� }</para>
      <para>� public int hashCode() { return i; }</para>
      <para>� public String toString() { return i + &quot; &quot;; }</para>
      <para>� public int compareTo(Object o) {</para>
      <para>��� int i2 = ((MyType)o).i;</para>
      <para>��� return (i2 &lt; i ? -1 : (i2 == i ? 0 : 1));</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class Set2 {</para>
      <para>� public static Set fill(Set a, int size) {</para>
      <para>��� for(int i = 0; i &lt; size; i++)</para>
      <para>����� a.add(new MyType(i));</para>
      <para>��� return a;</para>
      <para>� }</para>
      <para>� public static void test(Set a) {</para>
      <para>��� fill(a, 10);</para>
      <para>��� fill(a, 10); // Try to add duplicates</para>
      <para>��� fill(a, 10);</para>
      <para>��� a.addAll(fill(new TreeSet(), 10));</para>
      <para>��� System.out.println(a);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� test(new HashSet());</para>
      <para>��� test(new TreeSet());</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The form for the definitions for <emphasis role="bold">equals( )</emphasis> and <emphasis role="bold">hashCode( )</emphasis> will be described later in this chapter. You must define an <emphasis role="bold">equals( )</emphasis> in both cases, but the <emphasis role="bold">hashCode( )</emphasis> is absolutely necessary only if the class will be placed in a <emphasis role="bold">HashSet</emphasis> (which is likely, since that should generally be your first choice as a <emphasis role="bold">Set</emphasis> implementation). However, as a programming style you should always override <emphasis role="bold">hashCode( )</emphasis> when you override <emphasis role="bold">equals( )</emphasis>. This process will be fully detailed later in this chapter.</para>
      <para>In the <emphasis role="bold">compareTo( )</emphasis>, note that I did <emphasis role="italic">not</emphasis> use the �simple and obvious� form <emphasis role="bold">return i-i2</emphasis>. Although this is a common programming error, it would only work properly if <emphasis role="bold">i</emphasis> and <emphasis role="bold">i2</emphasis> were �unsigned�<emphasis role="bold"> int</emphasis>s (if Java <emphasis role="italic">had </emphasis>an �unsigned� keyword, which it does not). It breaks for Java�s signed <emphasis role="bold">int</emphasis>, which is not big enough to represent the difference of two signed <emphasis role="bold">int</emphasis>s. If <emphasis role="bold">i</emphasis> is a large positive integer and <emphasis role="bold">j</emphasis> is a large negative integer, <emphasis role="bold">i-j</emphasis> will overflow and return a negative value, which will not work. </para>
      <section>
        <title><anchor xreflabel="SortedSet" xml:id="_Toc481064689"/><emphasis role="bold">SortedSet</emphasis></title>
        <para>If you have a <emphasis role="bold">SortedSet</emphasis> (of which <emphasis role="bold">TreeSet</emphasis> is the only one available), the elements are guaranteed to be in sorted order which allows additional functionality to be provided with these methods in the <emphasis role="bold">SortedSet</emphasis> interface:</para>
        <para><emphasis role="bold">Comparator comparator():</emphasis> Produces the <emphasis role="bold">Comparator</emphasis> used for this <emphasis role="bold">Set</emphasis>, or <emphasis role="bold">null</emphasis> for natural ordering. </para>
        <para><emphasis role="bold">Object first():</emphasis> Produces the lowest element. </para>
        <para><emphasis role="bold">Object last():</emphasis> Produces the highest element. </para>
        <para><emphasis role="bold">SortedSet subSet(fromElement, toElement):</emphasis> Produces a view of this <emphasis role="bold">Set</emphasis> with elements from <emphasis role="bold">fromElement</emphasis>, inclusive, to <emphasis role="bold">toElement</emphasis>, exclusive. </para>
        <para><emphasis role="bold">SortedSet headSet(toElement):</emphasis> Produces a view of this <emphasis role="bold">Set</emphasis> with elements less than <emphasis role="bold">toElement</emphasis>. </para>
        <para><emphasis role="bold">SortedSet tailSet(fromElement):</emphasis> Produces a view of this <emphasis role="bold">Set</emphasis> with elements greater than or equal to <emphasis role="bold">fromElement</emphasis>.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Map
functionality" xml:id="_Toc481064690"/><emphasis role="bold">Map</emphasis> functionality</title>
      <para>An <emphasis role="bold">ArrayList</emphasis> allows you to select from a sequence of objects using a number, so in a sense it associates numbers to objects. But what if you�d like to select from a sequence of objects using some other criterion? A stack is an example: its selection criterion is �the last thing pushed on the stack.� A powerful twist on this idea of �selecting from a sequence� is alternately termed a <emphasis role="italic">map</emphasis>, a <emphasis role="italic">dictionary,</emphasis> or an <emphasis role="italic">associative array</emphasis>. Conceptually, it seems like an <emphasis role="bold">ArrayList</emphasis>, but instead of looking up objects using a number, you look them up using <emphasis role="italic">another object</emphasis>! This is often a key process in a program.</para>
      <para>The concept shows up in Java as the <emphasis role="bold">Map </emphasis>interface. The <emphasis role="bold">put(Object key, Object value)</emphasis> method adds a value (the thing you want), and associates it with a key (the thing you look it up with). <emphasis role="bold">get(Object key)</emphasis> produces the value given the corresponding key. You can also test a <emphasis role="bold">Map</emphasis> to see if it contains a key or a value with <emphasis role="bold">containsKey( )</emphasis> and <emphasis role="bold">containsValue( )</emphasis>. </para>
      <para>The standard Java library contains two different types of <emphasis role="bold">Map</emphasis>s: <emphasis role="bold">HashMap</emphasis> and <emphasis role="bold">TreeMap</emphasis>. Both have the same interface (since they both implement <emphasis role="bold">Map</emphasis>), but they differ in one distinct way: efficiency. If you look at what must be done for a <emphasis role="bold">get( )</emphasis>, it seems pretty slow to search through (for example) an <emphasis role="bold">ArrayList</emphasis> for the key. This is where <emphasis role="bold">HashMap</emphasis> speeds things up. Instead of a slow search for the key, it uses a special value called a <emphasis role="italic">hash code</emphasis>.<emphasis role="italic"/>The hash code is a way to take some information in the object in question and turn it into a �relatively unique� <emphasis role="bold">int</emphasis> for that object. All Java objects can produce a hash code, and <emphasis role="bold">hashCode( )</emphasis> is a method in the root class <emphasis role="bold">Object</emphasis>. A <emphasis role="bold">HashMap </emphasis>takes the <emphasis role="bold">hashCode( )</emphasis> of the object and uses it to quickly hunt for the key. This results in a dramatic performance improvement<anchor xreflabel="[50]" xml:id="_ftnref50"/>[50].</para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="10*"/>
          <colspec colname="c2" colwidth="36*"/>
          <tbody>
            <row>
              <entry valign="top"><para> Map (interface)</para></entry>
              <entry valign="top"><para> Maintains key-value associations (pairs), so you can look up a value using a key.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> HashMap*</para></entry>
              <entry valign="top"><para> Implementation based on a hash table. (Use this instead of Hashtable.) Provides constant-time performance for inserting and locating pairs. Performance can be adjusted via constructors that allow you to set the <emphasis role="italic">capacity</emphasis> and <emphasis role="italic">load factor</emphasis> of the hash table.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> TreeMap</para></entry>
              <entry valign="top"><para> Implementation based on a red-black tree. When you view the keys or the pairs, they will be in sorted order (determined by Comparable or Comparator, discussed later). The point of a TreeMap is that you get the results in sorted order. TreeMap is the only Map with the subMap( ) method, which allows you to return a portion of the tree.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Sometimes you�ll also need to know the details of how hashing works, so we�ll look at that a little later.</para>
      <para>The following example uses the <emphasis role="bold">Collections2.</emphasis><emphasis role="bold">fill( )</emphasis> method and the test data sets that were previously defined:</para>
      <para>//: c09:Map1.java</para>
      <para>// Things you can do with Maps.</para>
      <para>import java.util.*;</para>
      <para>import com.bruceeckel.util.*;</para>
      <para> </para>
      <para>public class Map1 {</para>
      <para>� static Collections2.StringPairGenerator geo = </para>
      <para>��� Collections2.geography;</para>
      <para>� static Collections2.RandStringPairGenerator </para>
      <para>��� rsp = Collections2.rsp;</para>
      <para>� // Producing a Set of the keys:</para>
      <para>� public static void printKeys(Map m) {</para>
      <para>��� System.out.print(&quot;Size = &quot; + m.size() +&quot;, &quot;);</para>
      <para>��� System.out.print(&quot;Keys: &quot;);</para>
      <para>��� System.out.println(m.keySet());</para>
      <para>� }</para>
      <para>� // Producing a Collection of the values:</para>
      <para>� public static void printValues(Map m) {</para>
      <para>��� System.out.print(&quot;Values: &quot;);</para>
      <para>��� System.out.println(m.values());</para>
      <para>� }</para>
      <para>� public static void test(Map m) {</para>
      <para>��� Collections2.fill(m, geo, 25);</para>
      <para>��� // Map has &apos;Set&apos; behavior for keys:</para>
      <para>��� Collections2.fill(m, geo.reset(), 25);</para>
      <para>��� printKeys(m);</para>
      <para>��� printValues(m);</para>
      <para>��� System.out.println(m);</para>
      <para>��� String key = CountryCapitals.pairs[4][0];</para>
      <para>��� String value = CountryCapitals.pairs[4][1];</para>
      <para>��� System.out.println(&quot;m.containsKey(\&quot;&quot; + key +</para>
      <para>����� &quot;\&quot;): &quot; + m.containsKey(key));</para>
      <para>��� System.out.println(&quot;m.get(\&quot;&quot; + key + &quot;\&quot;): &quot;</para>
      <para>����� + m.get(key));</para>
      <para>��� System.out.println(&quot;m.containsValue(\&quot;&quot; </para>
      <para>����� + value + &quot;\&quot;): &quot; + </para>
      <para>����� m.containsValue(value)); </para>
      <para>��� Map m2 = new TreeMap();</para>
      <para>��� Collections2.fill(m2, rsp, 25);</para>
      <para>��� m.putAll(m2);</para>
      <para>��� printKeys(m);</para>
      <para>��� key = m.keySet().iterator().next().toString();</para>
      <para>��� System.out.println(&quot;First key in map: &quot;+key);</para>
      <para>��� m.remove(key);</para>
      <para>��� printKeys(m);</para>
      <para>��� m.clear();</para>
      <para>��� System.out.println(&quot;m.isEmpty(): &quot; </para>
      <para>����� + m.isEmpty());</para>
      <para>��� Collections2.fill(m, geo.reset(), 25);</para>
      <para>��� // Operations on the Set change the Map:</para>
      <para>��� m.keySet().removeAll(m.keySet());</para>
      <para>��� System.out.println(&quot;m.isEmpty(): &quot; </para>
      <para>����� + m.isEmpty());</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� System.out.println(&quot;Testing HashMap&quot;);</para>
      <para>��� test(new HashMap());</para>
      <para>��� System.out.println(&quot;Testing TreeMap&quot;);</para>
      <para>��� test(new TreeMap());</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The <emphasis role="bold">printKeys( )</emphasis> and <emphasis role="bold">printValues( )</emphasis> methods are not only useful utilities, they also demonstrate how to produce <emphasis role="bold">Collection</emphasis> views of a <emphasis role="bold">Map</emphasis>. The <emphasis role="bold">keySet( )</emphasis> method produces a <emphasis role="bold">Set</emphasis> backed by the keys in the <emphasis role="bold">Map</emphasis>. Similar treatment is given to <emphasis role="bold">values( )</emphasis>, which produces a <emphasis role="bold">Collection</emphasis> containing all the values in the <emphasis role="bold">Map.</emphasis> (Note that keys must be unique, while values may contain duplicates.) Since these <emphasis role="bold">Collection</emphasis>s are backed by the <emphasis role="bold">Map</emphasis>, any changes in a <emphasis role="bold">Collection</emphasis> will be reflected in the associated <emphasis role="bold">Map</emphasis>.</para>
      <para>The rest of the program provides simple examples of each <emphasis role="bold">Map</emphasis> operation, and tests each type of <emphasis role="bold">Map</emphasis>.</para>
      <para>As an example of the use of a <emphasis role="bold">HashMap</emphasis>, consider a program to check the randomness of Java�s <emphasis role="bold">Math.random( )</emphasis> method. Ideally, it would produce a perfect distribution of random numbers, but to test this you need to generate a bunch of random numbers and count the ones that fall in the various ranges. A <emphasis role="bold">HashMap</emphasis> is perfect for this, since it associates objects with objects (in this case, the value object contains the number produced by <emphasis role="bold">Math.random( )</emphasis> along with the number of times that number appears):</para>
      <para>//: c09:Statistics.java</para>
      <para>// Simple demonstration of HashMap.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>class Counter { </para>
      <para>� int i = 1; </para>
      <para>� public String toString() { </para>
      <para>��� return Integer.toString(i); </para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Statistics {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� HashMap hm = new HashMap();</para>
      <para>��� for(int i = 0; i &lt; 10000; i++) {</para>
      <para>����� // Produce a number between 0 and 20:</para>
      <para>����� Integer r = </para>
      <para>������� new Integer((int)(Math.random() * 20));</para>
      <para>����� if(hm.containsKey(r))</para>
      <para>������� ((Counter)hm.get(r)).i++;</para>
      <para>����� else</para>
      <para>������� hm.put(r, new Counter());</para>
      <para>��� }</para>
      <para>��� System.out.println(hm);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>In <emphasis role="bold">main( )</emphasis>, each time a random number is generated it is wrapped inside an <emphasis role="bold">Integer</emphasis> object so that reference can be used with the <emphasis role="bold">HashMap</emphasis>. (You can�t use a primitive with a container, only an object reference.) The <emphasis role="bold">containsKey( )</emphasis> method checks to see if this key is already in the container. (That is, has the number been found already?) If so, the <emphasis role="bold">get( )</emphasis> method produces the associated value for the key, which in this case is a <emphasis role="bold">Counter</emphasis> object. The value <emphasis role="bold">i</emphasis> inside the counter is incremented to indicate that one more of this particular random number has been found.</para>
      <para>If the key has not been found yet, the method <emphasis role="bold">put( )</emphasis> will place a new key-value pair into the <emphasis role="bold">HashMap</emphasis>. Since <emphasis role="bold">Counter</emphasis> automatically initializes its variable <emphasis role="bold">i</emphasis> to one when it�s created, it indicates the first occurrence of this particular random number.</para>
      <para>To display the <emphasis role="bold">HashMap</emphasis>, it is simply printed. The <emphasis role="bold">HashMap</emphasis><emphasis role="bold">toString( )</emphasis> method moves through all the key-value pairs and calls the <emphasis role="bold">toString( )</emphasis> for each one. The <emphasis role="bold">Integer.toString( )</emphasis> is predefined, and you can see the <emphasis role="bold">toString( )</emphasis> for <emphasis role="bold">Counter</emphasis>. The output from one run (with some line breaks added) is:</para>
      <para>{19=526, 18=533, 17=460, 16=513, 15=521, 14=495,</para>
      <para>�13=512, 12=483, 11=488, 10=487, 9=514, 8=523,</para>
      <para>�7=497, 6=487, 5=480, 4=489, 3=509, 2=503, 1=475,</para>
      <para>�0=505}</para>
      <para> </para>
      <para>You might wonder at the necessity of the class <emphasis role="bold">Counter,</emphasis> which seems like it doesn�t even have the functionality of the wrapper class <emphasis role="bold">Integer</emphasis>. Why not use <emphasis role="bold">int</emphasis> or <emphasis role="bold">Integer</emphasis>? Well, you can�t use an <emphasis role="bold">int</emphasis> because all of the containers can hold only<emphasis role="bold"> Object </emphasis>references. After seeing containers the wrapper classes might begin to make a little more sense to you, since you can�t put any of the primitive types in containers. However, the only thing you <emphasis role="italic">can</emphasis> do with the Java wrappers is to initialize them to a particular value and read that value. That is, there�s no way to change a value once a wrapper object has been created. This makes the <emphasis role="bold">Integer</emphasis> wrapper immediately useless to solve our problem, so we�re forced to create a new class that does satisfy the need.</para>
      <section>
        <title><anchor xreflabel="SortedMap" xml:id="_Toc481064691"/><emphasis role="bold">SortedMap</emphasis></title>
        <para>If you have a <emphasis role="bold">SortedMap</emphasis> (of which <emphasis role="bold">TreeMap</emphasis> is the only one available), the keys are guaranteed to be in sorted order which allows additional functionality to be provided with these methods in the <emphasis role="bold">SortedMap</emphasis> interface:</para>
        <para><emphasis role="bold">Comparator comparator():</emphasis> Produces the comparator used for this <emphasis role="bold">Map</emphasis>, or <emphasis role="bold">null</emphasis> for natural ordering. </para>
        <para><emphasis role="bold">Object firstKey():</emphasis> Produces the lowest key. </para>
        <para><emphasis role="bold">Object lastKey():</emphasis> Produces the highest key. </para>
        <para><emphasis role="bold">SortedMap subMap(fromKey, toKey):</emphasis> Produces a view of this <emphasis role="bold">Map</emphasis> with keys from <emphasis role="bold">fromKey</emphasis>, inclusive, to <emphasis role="bold">toKey</emphasis>, exclusive. </para>
        <para><emphasis role="bold">SortedMap headMap(toKey):</emphasis> Produces a view of this <emphasis role="bold">Map</emphasis> with keys less than <emphasis role="bold">toKey</emphasis>. </para>
        <para><emphasis role="bold">SortedMap tailMap(fromKey):</emphasis> Produces a view of this <emphasis role="bold">Map</emphasis> with keys greater than or equal to <emphasis role="bold">fromKey</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="Hashing and hash codes" xml:id="_Toc481064692"/>Hashing and hash codes</title>
        <para>In the previous example, a standard library class (<emphasis role="bold">Integer</emphasis>) was used as a key for the <emphasis role="bold">HashMap</emphasis>. It worked fine as a key, because it has all the necessary wiring to make it work correctly as a key. But a common pitfall occurs with <emphasis role="bold">HashMap</emphasis>s when you create your own classes to be used as keys. For example, consider a weather predicting system that matches <emphasis role="bold">Groundhog</emphasis> objects to <emphasis role="bold">Prediction</emphasis> objects. It seems fairly straightforward�you create the two classes, and use <emphasis role="bold">Groundhog</emphasis> as the key and <emphasis role="bold">Prediction</emphasis> as the value:</para>
        <para>//: c09:SpringDetector.java</para>
        <para>// Looks plausible, but doesn&apos;t work.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Groundhog {</para>
        <para>� int ghNumber;</para>
        <para>� Groundhog(int n) { ghNumber = n; }</para>
        <para>}</para>
        <para> </para>
        <para>class Prediction {</para>
        <para>� boolean shadow = Math.random() &gt; 0.5;</para>
        <para>� public String toString() {</para>
        <para>��� if(shadow)</para>
        <para>����� return &quot;Six more weeks of Winter!&quot;;</para>
        <para>��� else</para>
        <para>����� return &quot;Early Spring!&quot;;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class SpringDetector {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� HashMap hm = new HashMap();</para>
        <para>��� for(int i = 0; i &lt; 10; i++)</para>
        <para>����� hm.put(new Groundhog(i), new Prediction());</para>
        <para>��� System.out.println(&quot;hm = &quot; + hm + &quot;\n&quot;);</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;Looking up prediction for Groundhog #3:&quot;);</para>
        <para>��� Groundhog gh = new Groundhog(3);</para>
        <para>��� if(hm.containsKey(gh))</para>
        <para>����� System.out.println((Prediction)hm.get(gh));</para>
        <para>��� else</para>
        <para>����� System.out.println(&quot;Key not found: &quot; + gh);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Each <emphasis role="bold">Groundhog</emphasis> is given an identity number, so you can look up a <emphasis role="bold">Prediction</emphasis> in the <emphasis role="bold">HashMap</emphasis> by saying, �Give me the <emphasis role="bold">Prediction </emphasis>associated with <emphasis role="bold">Groundhog</emphasis> number 3.� The <emphasis role="bold">Prediction</emphasis> class contains a <emphasis role="bold">boolean</emphasis> that is initialized using <emphasis role="bold">Math.random( )</emphasis>, and a <emphasis role="bold">toString( )</emphasis> that interprets the result for you. In <emphasis role="bold">main( )</emphasis>, a <emphasis role="bold">HashMap</emphasis> is filled with <emphasis role="bold">Groundhog</emphasis>s and their associated <emphasis role="bold">Prediction</emphasis>s. The <emphasis role="bold">HashMap </emphasis>is printed so you can see that it has been filled. Then a <emphasis role="bold">Groundhog</emphasis> with an identity number of 3 is used as a key to look up the prediction for <emphasis role="bold">Groundhog</emphasis> #3 (which you can see must be in the <emphasis role="bold">Map</emphasis>).</para>
        <para>It seems simple enough, but it doesn�t work. The problem is that <emphasis role="bold">Groundhog</emphasis> is inherited from the common root class <emphasis role="bold">Object</emphasis> (which is what happens if you don�t specify a base class, thus all classes are ultimately inherited from <emphasis role="bold">Object</emphasis>). It is <emphasis role="bold">Object</emphasis>�s <emphasis role="bold">hashCode( )</emphasis> method that is used to generate the hash code for each object, and by default it just uses the address of its object. Thus, the first instance of <emphasis role="bold">Groundhog(3)</emphasis> does <emphasis role="italic">not</emphasis> produce a hash code equal to the hash code for the second instance of <emphasis role="bold">Groundhog(3)</emphasis> that we tried to use as a lookup.</para>
        <para>You might think that all you need to do is write an appropriate override for <emphasis role="bold">hashCode( )</emphasis>. But it still won�t work until you�ve done one more thing: override the <emphasis role="bold">equals( )</emphasis> that is also part of <emphasis role="bold">Object</emphasis>. This method is used by the <emphasis role="bold">HashMap</emphasis> when trying to determine if your key is equal to any of the keys in the table. Again, the default <emphasis role="bold">Object.equals( )</emphasis> simply compares object addresses, so one <emphasis role="bold">Groundhog(3)</emphasis> is not equal to another <emphasis role="bold">Groundhog(3)</emphasis>.</para>
        <para>Thus, to use your own classes as keys in a <emphasis role="bold">HashMap</emphasis>, you must override both <emphasis role="bold">hashCode( )</emphasis> and <emphasis role="bold">equals( )</emphasis>, as shown in the following solution to the problem above:</para>
        <para>//: c09:SpringDetector2.java</para>
        <para>// A class that&apos;s used as a key in a HashMap </para>
        <para>// must override hashCode() and equals().</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Groundhog2 {</para>
        <para>� int ghNumber;</para>
        <para>� Groundhog2(int n) { ghNumber = n; }</para>
        <para>� public int hashCode() { return ghNumber; }</para>
        <para>� public boolean equals(Object o) {</para>
        <para>��� return (o instanceof Groundhog2)</para>
        <para>����� &amp;&amp; (ghNumber == ((Groundhog2)o).ghNumber);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class SpringDetector2 {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� HashMap hm = new HashMap();</para>
        <para>��� for(int i = 0; i &lt; 10; i++)</para>
        <para>����� hm.put(new Groundhog2(i),new Prediction());</para>
        <para>��� System.out.println(&quot;hm = &quot; + hm + &quot;\n&quot;);</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;Looking up prediction for groundhog #3:&quot;);</para>
        <para>��� Groundhog2 gh = new Groundhog2(3);</para>
        <para>��� if(hm.containsKey(gh))</para>
        <para>����� System.out.println((Prediction)hm.get(gh));</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Note that this uses the <emphasis role="bold">Prediction</emphasis> class from the previous example, so <emphasis role="bold">SpringDetector.java</emphasis> must be compiled first or you�ll get a compile-time error when you try to compile<emphasis role="bold"> SpringDetector2.java</emphasis>.</para>
        <para><emphasis role="bold">Groundhog2.hashCode( )</emphasis> returns the groundhog number as an identifier. In this example, the programmer is responsible for ensuring that no two groundhogs exist with the same ID number. The <emphasis role="bold">hashCode( ) </emphasis>is not required to return a unique identifier (something you�ll understand better later in this chapter), but the <emphasis role="bold">equals( )</emphasis> method must be able to strictly determine whether two objects are equivalent.</para>
        <para>Even though it appears that the <emphasis role="bold">equals( )</emphasis> method is only checking to see whether the argument is an instance of <emphasis role="bold">Groundhog2</emphasis> (using the <emphasis role="bold">instanceof</emphasis> keyword, which is fully explained in Chapter 12), the <emphasis role="bold">instanceof</emphasis> actually quietly does a second sanity check, to see if the object is <emphasis role="bold">null</emphasis>, since <emphasis role="bold">instanceof</emphasis> produces <emphasis role="bold">false</emphasis> if the left-hand argument is <emphasis role="bold">null</emphasis>. Assuming it�s the correct type and not <emphasis role="bold">null</emphasis>, the comparison is based on the actual <emphasis role="bold">ghNumber</emphasis>s. This time, when you run the program, you�ll see it produces the correct output.</para>
        <para>When creating your own class to use in a <emphasis role="bold">HashSet</emphasis>, you must pay attention to the same issues as when it is used as a key in a <emphasis role="bold">HashMap</emphasis>.</para>
        <section>
          <title>Understanding <emphasis role="bold">hashCode( )</emphasis></title>
          <para>The above example is only a start toward solving the problem correctly. It shows that if you do not override <emphasis role="bold">hashCode( )</emphasis> and <emphasis role="bold">equals( )</emphasis> for your key, the hashed data structure (<emphasis role="bold">HashSet</emphasis> or <emphasis role="bold">HashMap</emphasis>) will not be able to deal with your key properly. However, to get a good solution for the problem you need to understand what�s going on inside the hashed data structure.</para>
          <para>First, consider the motivation behind hashing: you want to look up an object using another object. But you can accomplish this with a <emphasis role="bold">TreeSet</emphasis> or <emphasis role="bold">TreeMap</emphasis>, too. It�s also possible to implement your own <emphasis role="bold">Map</emphasis>. To do so, the <emphasis role="bold">Map.entrySet( )</emphasis> method must be supplied to produce a set of <emphasis role="bold">Map.Entry</emphasis> objects. <emphasis role="bold">MPair</emphasis> will be defined as the new type of <emphasis role="bold">Map.Entry</emphasis>. In order for it to be placed in a <emphasis role="bold">TreeSet</emphasis> it must implement <emphasis role="bold">equals( )</emphasis> and be <emphasis role="bold">Comparable</emphasis>:</para>
          <para>//: c09:MPair.java</para>
          <para>// A Map implemented with ArrayLists.</para>
          <para>import java.util.*;</para>
          <para> </para>
          <para>public class MPair </para>
          <para>implements Map.Entry, Comparable {</para>
          <para>� Object key, value;</para>
          <para>� MPair(Object k, Object v) {</para>
          <para>��� key = k;</para>
          <para>��� value = v;</para>
          <para>� }</para>
          <para>� public Object getKey() { return key; }</para>
          <para>� public Object getValue() { return value; }</para>
          <para>� public Object setValue(Object v){</para>
          <para>��� Object result = value;</para>
          <para>��� value = v;</para>
          <para>��� return result;</para>
          <para>� }</para>
          <para>� public boolean equals(Object o) {</para>
          <para>��� return key.equals(((MPair)o).key);</para>
          <para>� }</para>
          <para>� public int compareTo(Object rv) {</para>
          <para>��� return ((Comparable)key).compareTo(</para>
          <para>����� ((MPair)rv).key);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>Notice that the comparisons are only interested in the keys, so duplicate values are perfectly acceptable.</para>
          <para>The following example implements a <emphasis role="bold">Map</emphasis> using a pair of <emphasis role="bold">ArrayLists</emphasis>:</para>
          <para>//: c09:SlowMap.java</para>
          <para>// A Map implemented with ArrayLists.</para>
          <para>import java.util.*;</para>
          <para>import com.bruceeckel.util.*;</para>
          <para> </para>
          <para>public class SlowMap extends AbstractMap {</para>
          <para>� private ArrayList </para>
          <para>��� keys = new ArrayList(),</para>
          <para>��� values = new ArrayList();</para>
          <para>� public Object put(Object key, Object value) {</para>
          <para>��� Object result = get(key);</para>
          <para>��� if(!keys.contains(key)) {</para>
          <para>����� keys.add(key);</para>
          <para>����� values.add(value);</para>
          <para>��� } else</para>
          <para>����� values.set(keys.indexOf(key), value);</para>
          <para>��� return result;</para>
          <para>� }</para>
          <para>� public Object get(Object key) {</para>
          <para>��� if(!keys.contains(key))</para>
          <para>����� return null;</para>
          <para>��� return values.get(keys.indexOf(key));</para>
          <para>� }</para>
          <para>� public Set entrySet() {</para>
          <para>��� Set entries = new HashSet();</para>
          <para>��� Iterator</para>
          <para>����� ki = keys.iterator(),</para>
          <para>����� vi = values.iterator();</para>
          <para>��� while(ki.hasNext())</para>
          <para>����� entries.add(new MPair(ki.next(), vi.next()));</para>
          <para>��� return entries;</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� SlowMap m = new SlowMap();</para>
          <para>��� Collections2.fill(m, </para>
          <para>����� Collections2.geography, 25);</para>
          <para>��� System.out.println(m);��� </para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The <emphasis role="bold">put( )</emphasis> method simply places the keys and values in corresponding <emphasis role="bold">ArrayList</emphasis>s. In <emphasis role="bold">main( )</emphasis>, a <emphasis role="bold">SlowMap</emphasis> is loaded and then printed to show that it works.</para>
          <para>This shows that it�s not that hard to produce a new type of <emphasis role="bold">Map</emphasis>. But as the name suggests, a <emphasis role="bold">SlowMap </emphasis>isn�t very fast, so you probably wouldn�t use it if you had an alternative available. The problem is in the lookup of the key: there is no order so a simple linear search is used, which is the slowest way to look something up.</para>
          <para>The whole point of hashing is speed: hashing allows the lookup to happen quickly. Since the bottleneck is in the speed of the key lookup, one of the solutions to the problem could be by keeping the keys sorted and then using <emphasis role="bold">Collections.binarySearch( )</emphasis> to perform the lookup (an exercise at the end of this chapter will walk you through this process).</para>
          <para>Hashing goes further by saying that all you want to do is to store the key <emphasis role="italic">somewhere</emphasis> so that it can be quickly found. As you�ve seen in this chapter, the fastest structure in which to store a group of elements is an array, so that will be used for representing the key information (note carefully that I said �key information,� and not the key itself). Also seen in this chapter was the fact that an array, once allocated, cannot be resized, so we have a problem: we want to be able to store any number of values in the <emphasis role="bold">Map</emphasis>, but if the number of keys is fixed by the array size, how can this be?</para>
          <para>The answer is that the array will not hold the keys. From the key object, a number will be derived that will index into the array. This number is the <emphasis role="italic">hash code</emphasis>, produced by the <emphasis role="bold">hashCode( )</emphasis> method (in computer science parlance, this is the <emphasis role="italic">hash function</emphasis>) defined in <emphasis role="bold">Object</emphasis> and presumably overridden by your class. To solve the problem of the fixed-size array, more than one key may produce the same index. That is, there may be <emphasis role="italic">collisions</emphasis>. Because of this, it doesn�t matter how big the array is because each key object will land somewhere in that array.</para>
          <para>So the process of looking up a value starts by computing the hash code and using it to index into the array. If you could guarantee that there were no collisions (which could be possible if you have a fixed number of values) then you�d have a <emphasis role="italic">perfect hashing function</emphasis>, but that�s a special case. In all other cases, collisions are handled by <emphasis role="italic">external chaining:</emphasis> the array points not directly to a value, but instead to a list of values. These values are searched in a linear fashion using the <emphasis role="bold">equals( )</emphasis> method. Of course, this aspect of the search is much slower, but if the hash function is good there will only be a few values in each slot, at the most. So instead of searching through the entire list, you quickly jump to a slot where you have to compare a few entries to find the value. This is much faster, which is why the <emphasis role="bold">HashMap</emphasis> is so quick.</para>
          <para>Knowing the basics of hashing, it�s possible to implement a simple hashed <emphasis role="bold">Map</emphasis>:</para>
          <para>//: c09:SimpleHashMap.java</para>
          <para>// A demonstration hashed Map.</para>
          <para>import java.util.*;</para>
          <para>import com.bruceeckel.util.*;</para>
          <para> </para>
          <para>public class SimpleHashMap extends AbstractMap {</para>
          <para>� // Choose a prime number for the hash table</para>
          <para>� // size, to achieve a uniform distribution:</para>
          <para>� private final static int SZ = 997;</para>
          <para>� private LinkedList[] bucket= new LinkedList[SZ];</para>
          <para>� public Object put(Object key, Object value) {</para>
          <para>��� Object result = null;</para>
          <para>��� int index = key.hashCode() % SZ;</para>
          <para>��� if(index &lt; 0) index = -index;</para>
          <para>��� if(bucket[index] == null)</para>
          <para>����� bucket[index] = new LinkedList();</para>
          <para>��� LinkedList pairs = bucket[index];</para>
          <para>��� MPair pair = new MPair(key, value);</para>
          <para>��� ListIterator it = pairs.listIterator();</para>
          <para>��� boolean found = false;</para>
          <para>��� while(it.hasNext()) {</para>
          <para>����� Object iPair = it.next();</para>
          <para>����� if(iPair.equals(pair)) {</para>
          <para>������� result = ((MPair)iPair).getValue();</para>
          <para>������� it.set(pair); // Replace old with new</para>
          <para>��� ����found = true;</para>
          <para>������� break;</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>��� if(!found)</para>
          <para>����� bucket[index].add(pair);</para>
          <para>��� return result;</para>
          <para>� }</para>
          <para>� public Object get(Object key) {</para>
          <para>��� int index = key.hashCode() % SZ;</para>
          <para>��� if(index &lt; 0) index = -index;</para>
          <para>��� if(bucket[index] == null) return null;</para>
          <para>��� LinkedList pairs = bucket[index];</para>
          <para>��� MPair match = new MPair(key, null);</para>
          <para>��� ListIterator it = pairs.listIterator();</para>
          <para>��� while(it.hasNext()) {</para>
          <para>����� Object iPair = it.next();</para>
          <para>����� if(iPair.equals(match))</para>
          <para>������� return ((MPair)iPair).getValue();</para>
          <para>��� }</para>
          <para>��� return null;</para>
          <para>� }</para>
          <para>� public Set entrySet() {</para>
          <para>��� Set entries = new HashSet();</para>
          <para>��� for(int i = 0; i &lt; bucket.length; i++) {</para>
          <para>����� if(bucket[i] == null) continue;</para>
          <para>����� Iterator it = bucket[i].iterator();</para>
          <para>����� while(it.hasNext())</para>
          <para>������� entries.add(it.next());</para>
          <para>��� }</para>
          <para>��� return entries;</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� SimpleHashMap m = new SimpleHashMap();</para>
          <para>��� Collections2.fill(m, </para>
          <para>����� Collections2.geography, 25);</para>
          <para>��� System.out.println(m);��� </para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>Because the �slots� in a hash table are often referred to as <emphasis role="italic">buckets,</emphasis> the array that represents the actual table is called <emphasis role="bold">bucket</emphasis>. To promote even distribution, the number of buckets is typically a prime number. Notice that it is an array of <emphasis role="bold">LinkedList</emphasis>, which automatically provides for collisions�each new item is simply added to the end of the list.</para>
          <para>The return value of <emphasis role="bold">put( )</emphasis> is <emphasis role="bold">null</emphasis> or, if the key was already in the list, the old value associated with that key. The return value is <emphasis role="bold">result</emphasis>, which is initialized to <emphasis role="bold">null</emphasis>, but if a key is discovered in the list then <emphasis role="bold">result</emphasis> is assigned to that key.</para>
          <para>For both <emphasis role="bold">put( )</emphasis> and <emphasis role="bold">get( )</emphasis>, the first thing that happens is that the <emphasis role="bold">hashCode( )</emphasis> is called for the key, and the result is forced to a positive number. Then it is forced to fit into the <emphasis role="bold">bucket</emphasis> array using the modulus operator and the size of the array. If that location is <emphasis role="bold">null</emphasis>, it means there are no elements that hash to that location, so a new <emphasis role="bold">LinkedList</emphasis> is created to hold the object that just did. However, the normal process is to look through the list to see if there are duplicates, and if there are, the old value is put into <emphasis role="bold">result</emphasis> and the new value replaces the old. The <emphasis role="bold">found</emphasis> flag keeps track of whether an old key-value pair was found and, if not, the new pair is appended to the end of the list.</para>
          <para>In <emphasis role="bold">get( )</emphasis>, you�ll see very similar code as that contained in <emphasis role="bold">put( )</emphasis>, but simpler. The index is calculated into the <emphasis role="bold">bucket</emphasis> array, and if a <emphasis role="bold">LinkedList</emphasis> exists it is searched for a match.</para>
          <para><emphasis role="bold">entrySet( )</emphasis> must find and traverse all the lists, adding them to the result <emphasis role="bold">Set</emphasis>. Once this method has been created, the <emphasis role="bold">Map</emphasis> can be tested by filling it with values and then printing them.</para>
        </section>
        <section>
          <title><emphasis role="bold">HashMap</emphasis> performance factors</title>
          <para>To understand the issues, some terminology is necessary:</para>
          <para><emphasis role="bold"><emphasis role="italic">Capacity</emphasis></emphasis><emphasis role="italic">:</emphasis> The number of buckets in the table.</para>
          <para><emphasis role="bold"><emphasis role="italic">Initial capacity</emphasis></emphasis><emphasis role="italic">:</emphasis> The number of buckets when the table is created. <emphasis role="bold">HashMap</emphasis> and <emphasis role="bold">HashSet</emphasis>: have constructors that allow you to specify the initial capacity.</para>
          <para><emphasis role="bold"><emphasis role="italic">Size</emphasis></emphasis><emphasis role="italic">:</emphasis> The number of entries currently in the table.</para>
          <para><emphasis role="bold"><emphasis role="italic">Load factor</emphasis></emphasis><emphasis role="italic">:</emphasis> size/capacity. A load factor of 0 is an empty table, 0.5 is a half-full table, etc. A lightly-loaded table will have few collisions and so is optimal for insertions and lookups (but will slow down the process of traversing with an iterator). <emphasis role="bold">HashMap</emphasis> and <emphasis role="bold">HashSet</emphasis> have constructors that allow you to specify the load factor, which means that when this load factor is reached the container will automatically increase the capacity (the number of buckets) by roughly doubling it, and will redistribute the existing objects into the new set of buckets (this is called <emphasis role="italic">rehashing</emphasis>).</para>
          <para>The default load factor used by <emphasis role="bold">HashMap </emphasis>is 0.75 (it doesn�t rehash until the table is � full). This seems to be a good trade-off between time and space costs. A higher load factor decreases the space required by the table but increases the lookup cost, which is important because lookup is what you do most of the time (including both <emphasis role="bold">get( )</emphasis> and <emphasis role="bold">put( )</emphasis>).</para>
          <para>If you know that you�ll be storing many entries in a <emphasis role="bold">HashMap</emphasis>, creating it with an appropriately large initial capacity will prevent the overhead of automatic rehashing.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Overriding hashCode( )" xml:id="_Toc481064693"/>Overriding <emphasis role="bold">hashCode( )</emphasis></title>
        <para>Now that you understand what�s involved in the function of the <emphasis role="bold">HashMap</emphasis>, the issues involved in writing a <emphasis role="bold">hashCode( )</emphasis> will make more sense.</para>
        <para>First of all, you don�t have control of the creation of the actual value that�s used to index into the array of buckets. That is dependent on the capacity of the particular <emphasis role="bold">HashMap</emphasis> object, and that capacity changes depending on how full the container is, and what the load factor is. The value produced by your <emphasis role="bold">hashCode( )</emphasis> will be further processed in order to create the bucket index (in <emphasis role="bold">SimpleHashMap</emphasis> the calculation is just a modulo by the size of the bucket array). </para>
        <para>The most important factor in creating a <emphasis role="bold">hashCode( )</emphasis> is that, regardless of when <emphasis role="bold">hashCode( )</emphasis> is called, it produces the same value for a particular object every time it is called. If you end up with an object that produces one <emphasis role="bold">hashCode( ) </emphasis>value when it is <emphasis role="bold">put( )</emphasis> into a <emphasis role="bold">HashMap</emphasis>, and another during a <emphasis role="bold">get( )</emphasis>, you won�t be able to retrieve the objects. So if your <emphasis role="bold">hashCode( )</emphasis> depends on mutable data in the object the user must be made aware that changing the data will effectively produce a different key by generating a different <emphasis role="bold">hashCode( )</emphasis>.</para>
        <para>In addition, you will probably <emphasis role="italic">not </emphasis>want to generate a <emphasis role="bold">hashCode( ) </emphasis>that is based on unique object information�in particular, the value of <emphasis role="bold">this</emphasis> makes a bad <emphasis role="bold">hashCode( ) </emphasis>because then you can�t generate a new identical key to the one used to <emphasis role="bold">put( ) </emphasis>the original key-value pair. This was the problem that occurred in <emphasis role="bold">SpringDetector.java</emphasis> because the default implementation of <emphasis role="bold">hashCode( ) </emphasis><emphasis role="italic">does</emphasis> use the object address. So you�ll want to use information in the object that identifies the object in a meaningful way.</para>
        <para>One example is found in the <emphasis role="bold">String</emphasis> class. <emphasis role="bold">String</emphasis>s have the special characteristic that if a program has several <emphasis role="bold">String</emphasis> objects that contain identical character sequences, then those <emphasis role="bold">String</emphasis> objects all map to the same memory (the mechanism for this is described in Appendix A). So it makes sense that the <emphasis role="bold">hashCode( )</emphasis> produced by two separate instances of <emphasis role="bold">new String(�hello�)</emphasis> should be identical. You can see it by running this program:</para>
        <para>//: c09:StringHashCode.java</para>
        <para>public class StringHashCode {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� System.out.println(&quot;Hello&quot;.hashCode());</para>
        <para>��� System.out.println(&quot;Hello&quot;.hashCode());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>For this to work, the <emphasis role="bold">hashCode( )</emphasis> for <emphasis role="bold">String</emphasis> must be based on the contents of the <emphasis role="bold">String</emphasis>.</para>
        <para>So for a <emphasis role="bold">hashCode( )</emphasis> to be effective, it must be fast and it must be meaningful: that is, it must generate a value based on the contents of the object. Remember that this value doesn�t have to be unique�you should lean toward speed rather than uniqueness�but between <emphasis role="bold">hashCode( )</emphasis> and <emphasis role="bold">equals( )</emphasis> the identity of the object must be completely resolved.</para>
        <para>Because the <emphasis role="bold">hashCode( )</emphasis> is further processed before the bucket index is produced, the range of values is not important; it just needs to generate an <emphasis role="bold">int</emphasis>.</para>
        <para>There�s one other factor: a good <emphasis role="bold">hashCode( )</emphasis> should result in an even distribution of values. If the values tend to cluster, then the <emphasis role="bold">HashMap</emphasis> or <emphasis role="bold">HashSet </emphasis>will be more heavily loaded in some areas and will not be as fast as it could be with an evenly distributed hashing function.</para>
        <para>Here�s an example that follows these guidelines:</para>
        <para>//: c09:CountedString.java</para>
        <para>// Creating a good hashCode().</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class CountedString {</para>
        <para>� private String s;</para>
        <para>� private int id = 0;</para>
        <para>� private static ArrayList created = </para>
        <para>��� new ArrayList();</para>
        <para>� public CountedString(String str) {</para>
        <para>��� s = str;</para>
        <para>��� created.add(s);</para>
        <para>��� Iterator it = created.iterator();</para>
        <para>��� // Id is the total number of instances</para>
        <para>��� // of this string in use by CountedString:</para>
        <para>��� while(it.hasNext())</para>
        <para>����� if(it.next().equals(s))</para>
        <para>������� id++;</para>
        <para>� }</para>
        <para>� public String toString() {</para>
        <para>��� return &quot;String: &quot; + s + &quot; id: &quot; + id +</para>
        <para>����� &quot; hashCode(): &quot; + hashCode() + &quot;\n&quot;;</para>
        <para>� }</para>
        <para>� public int hashCode() { </para>
        <para>��� return s.hashCode() * id;</para>
        <para>� }</para>
        <para>� public boolean equals(Object o) {</para>
        <para>��� return (o instanceof CountedString)</para>
        <para>����� &amp;&amp; s.equals(((CountedString)o).s)</para>
        <para>����� &amp;&amp; id == ((CountedString)o).id;</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� HashMap m = new HashMap();</para>
        <para>��� CountedString[] cs = new CountedString[10];</para>
        <para>��� for(int i = 0; i &lt; cs.length; i++) {</para>
        <para>����� cs[i] = new CountedString(&quot;hi&quot;);</para>
        <para>����� m.put(cs[i], new Integer(i));</para>
        <para>��� }</para>
        <para>��� System.out.println(m);</para>
        <para>��� for(int i = 0; i &lt; cs.length; i++) {</para>
        <para>����� System.out.print(&quot;Looking up &quot; + cs[i]);</para>
        <para>����� System.out.println(m.get(cs[i]));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">CountedString</emphasis> includes a <emphasis role="bold">String</emphasis> and an <emphasis role="bold">id</emphasis> that represents the number of <emphasis role="bold">CountedString</emphasis> objects that contain an identical <emphasis role="bold">String</emphasis>. The counting is accomplished in the constructor by iterating through the <emphasis role="bold">static ArrayList</emphasis> where all the <emphasis role="bold">String</emphasis>s are stored.</para>
        <para>Both <emphasis role="bold">hashCode( )</emphasis> and <emphasis role="bold">equals( )</emphasis> produce results based on both fields; if they were just based on the <emphasis role="bold">String</emphasis> alone or the <emphasis role="bold">id</emphasis> alone there would be duplicate matches for distinct values.</para>
        <para>Note how simple the <emphasis role="bold">hashCode( )</emphasis> is: <emphasis role="bold">String</emphasis>�s <emphasis role="bold">hashCode( )</emphasis> is multiplied by the <emphasis role="bold">id</emphasis>. Smaller is generally better (and faster) for <emphasis role="bold">hashCode( )</emphasis>.</para>
        <para>In <emphasis role="bold">main( )</emphasis>, a bunch of <emphasis role="bold">CountedString</emphasis> objects are created, using the same <emphasis role="bold">String</emphasis> to show that the duplicates create unique values because of the count <emphasis role="bold">id</emphasis>. The <emphasis role="bold">HashMap</emphasis> is displayed so that you can see how it is stored internally (no discernible orders) and then each key is looked up individually to demonstrate that the lookup mechanism is working properly.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Holding references" xml:id="_Toc481064694"/>Holding references</title>
      <para>The <emphasis role="bold">java.lang.ref</emphasis> library contains a set of classes that allow greater flexibility in garbage collection, which are especially useful when you have large objects that may cause memory exhaustion. There are three classes inherited from the abstract class <emphasis role="bold">Reference</emphasis>: <emphasis role="bold">SoftReference</emphasis>,<emphasis role="bold"/><emphasis role="bold">WeakReference</emphasis>, and<emphasis role="bold"/><emphasis role="bold">PhantomReference</emphasis>. Each of these provides a different level of indirection for the garbage collector, if the object in question is <emphasis role="italic">only</emphasis> reachable through one of these <emphasis role="bold">Reference</emphasis> objects. </para>
      <para>If an object is <emphasis role="italic">reachable</emphasis> it means that somewhere in your program the object can be found. This could mean that you have an ordinary reference on the stack that goes right to the object, but you might also have a reference to an object that has a reference to the object in question; there could be many intermediate links. If an object is reachable, the garbage collector cannot release it because it�s still in use by your program. If an object isn�t reachable, there�s no way for your program to use it so it�s safe to garbage-collect that object.</para>
      <para>You use <emphasis role="bold">Reference</emphasis> objects when you want to continue to hold onto a reference to that object�you want to be able to reach that object�but you also want to allow the garbage collector to release that object. Thus, you have a way to go on using the object, but if memory exhaustion is imminent you allow that object to be released.</para>
      <para>You accomplish this by using a <emphasis role="bold">Reference</emphasis> object as an intermediary between you and the ordinary reference, <emphasis role="italic">and</emphasis> there must be no ordinary references to the object (ones that are not wrapped inside <emphasis role="bold">Reference</emphasis> objects). If the garbage collector discovers that an object is reachable through an ordinary reference, it will not release that object.</para>
      <para>In the order <emphasis role="bold">SoftReference</emphasis>,<emphasis role="bold"> WeakReference</emphasis>, and<emphasis role="bold"> PhantomReference</emphasis>, each one is �weaker� than the last, and corresponds to a different level of reachability. Soft references are for implementing memory-sensitive caches. Weak references are for implementing �canonicalizing mappings��where instances of objects can be simultaneously used in multiple places in a program, to save storage�that do not prevent their keys (or values) from being reclaimed. Phantom references are for scheduling pre-mortem cleanup actions in a more flexible way than is possible with the Java finalization mechanism.</para>
      <para>With <emphasis role="bold">SoftReference</emphasis>s and<emphasis role="bold"> WeakReference</emphasis>s, you have a choice about whether to place them on a <emphasis role="bold">ReferenceQueue</emphasis> (the device used for premortem cleanup actions), but a <emphasis role="bold">PhantomReference</emphasis> can only be built on a <emphasis role="bold">ReferenceQueue</emphasis>. Here�s a simple demonstration:</para>
      <para>//: c09:References.java</para>
      <para>// Demonstrates Reference objects</para>
      <para>import java.lang.ref.*;</para>
      <para> </para>
      <para>class VeryBig {</para>
      <para>� static final int SZ = 10000;</para>
      <para>� double[] d = new double[SZ];</para>
      <para>� String ident;</para>
      <para>� public VeryBig(String id) { ident = id; }</para>
      <para>��public String toString() { return ident; }</para>
      <para>� public void finalize() {</para>
      <para>��� System.out.println(&quot;Finalizing &quot; + ident);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class References {</para>
      <para>� static ReferenceQueue rq= new ReferenceQueue();</para>
      <para>� public static void checkQueue() {</para>
      <para>��� Object inq = rq.poll();</para>
      <para>��� if(inq != null)</para>
      <para>����� System.out.println(&quot;In queue: &quot; + </para>
      <para>������� (VeryBig)((Reference)inq).get());</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� int size = 10;</para>
      <para>��� // Or, choose size via the command line:</para>
      <para>��� if(args.length &gt; 0)</para>
      <para>����� size = Integer.parseInt(args[0]);��� </para>
      <para>��� SoftReference[] sa =</para>
      <para>����� new SoftReference[size];</para>
      <para>��� for(int i = 0; i &lt; sa.length; i++) {</para>
      <para>����� sa[i] = new SoftReference(</para>
      <para>������� new VeryBig(&quot;Soft &quot; + i), rq);</para>
      <para>����� System.out.println(&quot;Just created: &quot; +</para>
      <para>������� (VeryBig)sa[i].get());</para>
      <para>����� checkQueue();</para>
      <para>��� }</para>
      <para>��� WeakReference[] wa =</para>
      <para>����� new WeakReference[size];</para>
      <para>��� for(int i = 0; i &lt; wa.length; i++) {</para>
      <para>����� wa[i] = new WeakReference(</para>
      <para>������� new VeryBig(&quot;Weak &quot; + i), rq);</para>
      <para>����� System.out.println(&quot;Just created: &quot; +</para>
      <para>������� (VeryBig)wa[i].get());</para>
      <para>����� checkQueue();</para>
      <para>��� }</para>
      <para>��� SoftReference s = new SoftReference(</para>
      <para>����� new VeryBig(&quot;Soft&quot;));</para>
      <para>��� WeakReference w = new WeakReference(</para>
      <para>����� new VeryBig(&quot;Weak&quot;));</para>
      <para>��� System.gc();</para>
      <para>��� PhantomReference[] pa =</para>
      <para>����� new PhantomReference[size];</para>
      <para>��� for(int i = 0; i &lt; pa.length; i++) {</para>
      <para>����� pa[i] = new PhantomReference(</para>
      <para>������� new VeryBig(&quot;Phantom &quot; + i), rq);</para>
      <para>����� System.out.println(&quot;Just created: &quot; +</para>
      <para>������� (VeryBig)pa[i].get());</para>
      <para>����� checkQueue();</para>
      <para>��� }</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>When you run this program (you�ll want to pipe the output through a �more� utility so that you can view the output in pages), you�ll see that the objects are garbage-collected, even though you still have access to them through the <emphasis role="bold">Reference</emphasis> object (to get the actual object reference, you use <emphasis role="bold">get( )</emphasis>). You�ll also see that the <emphasis role="bold">ReferenceQueue</emphasis> always produces a <emphasis role="bold">Reference</emphasis> containing a <emphasis role="bold">null</emphasis> object. To make use of this, you can inherit from the particular <emphasis role="bold">Reference</emphasis> class you�re interested in and add more useful methods to the new type of <emphasis role="bold">Reference</emphasis>.</para>
      <section>
        <title><anchor xreflabel="The WeakHashMap" xml:id="_Toc481064695"/>The <emphasis role="bold">WeakHashMap</emphasis></title>
        <para>The containers library has a special <emphasis role="bold">Map</emphasis> to hold weak references: the <emphasis role="bold">WeakHashMap</emphasis>. This class is designed to make the creation of canonicalized mappings easier. In such a mapping, you are saving storage by making only one instance of a particular value. When the program needs that value, it looks up the existing object in the mapping and uses that (rather than creating one from scratch). The mapping may make the values as part of its initialization, but it�s more likely that the values are made on demand. </para>
        <para>Since this is a storage-saving technique, it�s very convenient that the <emphasis role="bold">WeakHashMap</emphasis> allows the garbage collector to automatically clean up the keys and values. You don�t have to do anything special to the keys and values you want to place in the <emphasis role="bold">WeakHashMap</emphasis>; these are automatically wrapped in <emphasis role="bold">WeakReference</emphasis>s by the map. The trigger to allow cleanup is if the key is no longer in use, as demonstrated here:</para>
        <para>//: c09:CanonicalMapping.java</para>
        <para>// Demonstrates WeakHashMap.</para>
        <para>import java.util.*;</para>
        <para>import java.lang.ref.*;</para>
        <para> </para>
        <para>class Key {</para>
        <para>� String ident;</para>
        <para>� public Key(String id) { ident = id; }</para>
        <para>� public String toString() { return ident; }</para>
        <para>� public int hashCode() { </para>
        <para>��� return ident.hashCode();</para>
        <para>� }</para>
        <para>� public boolean equals(Object r) {</para>
        <para>��� return (r instanceof Key)</para>
        <para>����� &amp;&amp; ident.equals(((Key)r).ident);</para>
        <para>� }</para>
        <para>� public void finalize() {</para>
        <para>��� System.out.println(&quot;Finalizing Key &quot;+ ident);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Value {</para>
        <para>� String ident;</para>
        <para>� public Value(String id) { ident = id; }</para>
        <para>� public String toString() { return ident; }</para>
        <para>� public void finalize() {</para>
        <para>��� System.out.println(&quot;Finalizing Value &quot;+ident);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class CanonicalMapping {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int size = 1000;</para>
        <para>��� // Or, choose size via the command line:</para>
        <para>��� if(args.length &gt; 0)</para>
        <para>����� size = Integer.parseInt(args[0]);��� </para>
        <para>��� Key[] keys = new Key[size];</para>
        <para>��� WeakHashMap whm = new WeakHashMap();</para>
        <para>��� for(int i = 0; i &lt; size; i++) {</para>
        <para>����� Key k = new Key(Integer.toString(i));</para>
        <para>����� Value v = new Value(Integer.toString(i));</para>
        <para>����� if(i % 3 == 0)</para>
        <para>������� keys[i] = k; // Save as &quot;real&quot; references</para>
        <para>����� whm.put(k, v);</para>
        <para>��� }</para>
        <para>��� System.gc();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">Key</emphasis> class must have a <emphasis role="bold">hashCode( )</emphasis> and an <emphasis role="bold">equals( )</emphasis> since it is being used as a key in a hashed data structure, as described previously in this chapter.</para>
        <para>When you run the program you�ll see that the garbage collector will skip every third key, because an ordinary reference to that key has also been placed in the <emphasis role="bold">keys</emphasis> array and thus those objects cannot be garbage-collected.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064696"/><anchor xreflabel="Iterators
revisited" xml:id="_Toc375545358"/>Iterators revisited</title>
      <para>We can now demonstrate the true power of the <emphasis role="bold">Iterator</emphasis>: the ability to separate the operation of traversing a sequence from the underlying structure of that sequence. In the following example, the class <emphasis role="bold">PrintData</emphasis> uses an <emphasis role="bold">Iterator</emphasis> to move through a sequence and call the <emphasis role="bold">toString( )</emphasis> method for every object. Two different types of containers are created�an <emphasis role="bold">ArrayList</emphasis> and a <emphasis role="bold">HashMap</emphasis>�and they are each filled with, respectively, <emphasis role="bold">Mouse </emphasis>and <emphasis role="bold">Hamster </emphasis>objects. (These classes are defined earlier in this chapter.) Because an <emphasis role="bold">Iterator </emphasis>hides the structure of the underlying container, <emphasis role="bold">PrintData</emphasis> doesn�t know or care what kind of container the <emphasis role="bold">Iterator </emphasis>comes from:</para>
      <para>//: c09:Iterators2.java</para>
      <para>// Revisiting Iterators.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>class PrintData {</para>
      <para>� static void print(Iterator e) {</para>
      <para>��� while(e.hasNext())</para>
      <para>����� System.out.println(e.next());</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Iterators2 {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� ArrayList v = new ArrayList();</para>
      <para>��� for(int i = 0; i &lt; 5; i++)</para>
      <para>����� v.add(new Mouse(i));</para>
      <para>��� HashMap m = new HashMap();</para>
      <para>��� for(int i = 0; i &lt; 5; i++)</para>
      <para>����� m.put(new Integer(i), new Hamster(i));</para>
      <para>��� System.out.println(&quot;ArrayList&quot;);</para>
      <para>��� PrintData.print(v.iterator());</para>
      <para>��� System.out.println(&quot;HashMap&quot;);</para>
      <para>��� PrintData.print(m.entrySet().iterator());</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>For the <emphasis role="bold">HashMap</emphasis>, the <emphasis role="bold">entrySet( )</emphasis> method produces a <emphasis role="bold">Set</emphasis> of <emphasis role="bold">Map.entry</emphasis> objects, which contain both the key and the value for each entry, so you see both of them printed.</para>
      <para>Note that <emphasis role="bold">PrintData.print( )</emphasis> takes advantage of the fact that the objects in these containers are of class <emphasis role="bold">Object</emphasis> so the call <emphasis role="bold">toString( )</emphasis> by <emphasis role="bold">System.out.println( ) </emphasis>is automatic. It�s more likely that in your problem, you must make the assumption that your <emphasis role="bold">Iterator</emphasis> is walking through a container of some specific type. For example, you might assume that everything in the container is a <emphasis role="bold">Shape</emphasis> with a <emphasis role="bold">draw( )</emphasis> method. Then you must downcast from the <emphasis role="bold">Object </emphasis>that <emphasis role="bold">Iterator.next( )</emphasis> returns to produce a <emphasis role="bold">Shape</emphasis>.</para>
    </section>
    <section>
      <title><anchor xreflabel="Choosing an implementation" xml:id="_Toc481064697"/>Choosing an implementation</title>
      <para>By now you should understand that there are really only three container components: <emphasis role="bold">Map</emphasis>, <emphasis role="bold">List</emphasis>, and <emphasis role="bold">Set</emphasis>, and only two or three implementations of each interface. If you need to use the functionality offered by a particular <emphasis role="bold">interface</emphasis>, how do you decide which particular implementation to use?</para>
      <para>To understand the answer, you must be aware that each different implementation has its own features, strengths, and weaknesses. For example, you can see in the diagram that the �feature� of <emphasis role="bold">Hashtable</emphasis>, <emphasis role="bold">Vector</emphasis>, and <emphasis role="bold">Stack</emphasis> is that they are legacy classes, so that old code doesn�t break. On the other hand, it�s best if you don�t use those for new (Java 2) code.</para>
      <para>The distinction between the other containers often comes down to what they are �backed by�; that is, the data structures that physically implement your desired <emphasis role="bold">interface</emphasis>. This means that, for example, <emphasis role="bold">ArrayList</emphasis> and<emphasis role="bold"> LinkedList </emphasis>implement the <emphasis role="bold">List</emphasis> interface so your program will produce the same results regardless of the one you use. However, <emphasis role="bold">ArrayList</emphasis> is backed by an array, while the <emphasis role="bold">LinkedList</emphasis> is implemented in the usual way for a doubly linked list, as individual objects each containing data along with references to the previous and next elements in the list. Because of this, if you want to do many insertions and removals in the middle of a list, a <emphasis role="bold">LinkedList</emphasis> is the appropriate choice. (<emphasis role="bold">LinkedList</emphasis> also has additional functionality that is established in <emphasis role="bold">AbstractSequentialList</emphasis>.) If not, an <emphasis role="bold">ArrayList</emphasis> is typically faster.</para>
      <para>As another example, a <emphasis role="bold">Set</emphasis> can be implemented as either a <emphasis role="bold">TreeSet</emphasis> or a <emphasis role="bold">HashSet</emphasis>. A <emphasis role="bold">TreeSet</emphasis> is backed by a <emphasis role="bold">TreeMap</emphasis> and is designed to produce a constantly sorted set. However, if you�re going to have larger quantities in your <emphasis role="bold">Set</emphasis>, the performance of <emphasis role="bold">TreeSet</emphasis> insertions will get slow. When you�re writing a program that needs a <emphasis role="bold">Set</emphasis>, you should choose <emphasis role="bold">HashSet</emphasis> by default, and change to <emphasis role="bold">TreeSet</emphasis> when it&apos;s more important to have a constantly sorted set.</para>
      <section>
        <title><anchor xreflabel="Choosing between Lists" xml:id="_Toc481064698"/>Choosing between <emphasis role="bold">List</emphasis>s</title>
        <para>The most convincing way to see the differences between the implementations of <emphasis role="bold">List</emphasis> is with a performance test. The following code establishes an inner base class to use as a test framework, then creates an array of anonymous inner classes, one for each different test. Each of these inner classes is called by the <emphasis role="bold">test( )</emphasis> method. This approach allows you to easily add and remove new kinds of tests.</para>
        <para>//: c09:ListPerformance.java</para>
        <para>// Demonstrates performance differences in Lists.</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>public class ListPerformance {</para>
        <para>� private abstract static class Tester {</para>
        <para>��� String name;</para>
        <para>��� int size; // Test quantity</para>
        <para>��� Tester(String name, int size) { </para>
        <para>����� this.name = name;</para>
        <para>����� this.size = size;</para>
        <para>��� }</para>
        <para>��� abstract void test(List a, int reps);</para>
        <para>� }</para>
        <para>� private static Tester[] tests = {</para>
        <para>��� new Tester(&quot;get&quot;, 300) { </para>
        <para>����� void test(List a, int reps) {</para>
        <para>������� for(int i = 0; i &lt; reps; i++) {</para>
        <para>��������� for(int j = 0; j &lt; a.size(); j++)</para>
        <para>����������� a.get(j);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� },</para>
        <para>��� new Tester(&quot;iteration&quot;, 300) { </para>
        <para>����� void test(List a, int reps) {</para>
        <para>������� for(int i = 0; i &lt; reps; i++) {</para>
        <para>��������� Iterator it = a.iterator();</para>
        <para>��������� while(it.hasNext())</para>
        <para>����������� it.next();</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� },</para>
        <para>��� new Tester(&quot;insert&quot;, 5000) { </para>
        <para>����� void test(List a, int reps) {</para>
        <para>������� int half = a.size()/2;</para>
        <para>������� String s = &quot;test&quot;;</para>
        <para>������� ListIterator it = a.listIterator(half);</para>
        <para>������� for(int i = 0; i &lt; size * 10; i++)</para>
        <para>��������� it.add(s);</para>
        <para>����� }</para>
        <para>��� },</para>
        <para>��� new Tester(&quot;remove&quot;, 5000) { </para>
        <para>����� void test(List a, int reps) {</para>
        <para>������� ListIterator it = a.listIterator(3);</para>
        <para>������� while(it.hasNext()) {</para>
        <para>��������� it.next();</para>
        <para>��������� it.remove();</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� },</para>
        <para>� };</para>
        <para>� public static void test(List a, int reps) {</para>
        <para>��� // A trick to print out the class name:</para>
        <para>��� System.out.println(&quot;Testing &quot; + </para>
        <para>����� a.getClass().getName());</para>
        <para>��� for(int i = 0; i &lt; tests.length; i++) {</para>
        <para>����� Collections2.fill(a, </para>
        <para>������� Collections2.countries.reset(),</para>
        <para>������� tests[i].size);</para>
        <para>����� System.out.print(tests[i].name);</para>
        <para>����� long t1 = System.currentTimeMillis();</para>
        <para>����� tests[i].test(a, reps);</para>
        <para>����� long t2 = System.currentTimeMillis();</para>
        <para>����� System.out.println(&quot;: &quot; + (t2 - t1));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void testArray(int reps) {</para>
        <para>��� System.out.println(&quot;Testing array as List&quot;);</para>
        <para>��� // Can only do first two tests on an array:</para>
        <para>��� for(int i = 0; i &lt; 2; i++) {</para>
        <para>����� String[] sa = new String[tests[i].size];</para>
        <para>����� Arrays2.fill(sa, </para>
        <para>������� Collections2.countries.reset());</para>
        <para>����� List a = Arrays.asList(sa);</para>
        <para>����� System.out.print(tests[i].name);</para>
        <para>����� long t1 = System.currentTimeMillis();</para>
        <para>����� tests[i].test(a, reps);</para>
        <para>����� long t2 = System.currentTimeMillis();</para>
        <para>����� System.out.println(&quot;: &quot; + (t2 - t1));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int reps = 50000;</para>
        <para>��� // Or, choose the number of repetitions</para>
        <para>��� // via the command line:</para>
        <para>��� if(args.length &gt; 0)</para>
        <para>����� reps = Integer.parseInt(args[0]);</para>
        <para>��� System.out.println(reps + &quot; repetitions&quot;);</para>
        <para>��� testArray(reps);</para>
        <para>��� test(new ArrayList(), reps);</para>
        <para>��� test(new LinkedList(), reps);</para>
        <para>��� test(new Vector(), reps);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The inner class <emphasis role="bold">Tester</emphasis> is <emphasis role="bold">abstract</emphasis>, to provide a base class for the specific tests. It contains a <emphasis role="bold">String</emphasis> to be printed when the test starts, a <emphasis role="bold">size </emphasis>parameter to be used by the test for quantity of elements or repetitions of tests, a constructor to initialize the fields, and an <emphasis role="bold">abstract</emphasis> method <emphasis role="bold">test( )</emphasis> that does the work. All the different types of tests are collected in one place, the array <emphasis role="bold">tests</emphasis>, which is initialized with different anonymous inner classes that inherit from <emphasis role="bold">Tester</emphasis>. To add or remove tests, simply add or remove an inner class definition from the array, and everything else happens automatically.</para>
        <para>To compare array access to container access (primarily against <emphasis role="bold">ArrayList</emphasis>), a special test is created for arrays by wrapping one as a <emphasis role="bold">List</emphasis> using <emphasis role="bold">Arrays.asList( )</emphasis>. Note that only the first two tests can be performed in this case, because you cannot insert or remove elements from an array.</para>
        <para>The <emphasis role="bold">List</emphasis> that�s handed to <emphasis role="bold">test( )</emphasis> is first filled with elements, then each test in the <emphasis role="bold">tests</emphasis> array is timed. The results will vary from machine to machine; they are intended to give only an order of magnitude comparison between the performance of the different containers. Here is a summary of one run:</para>
        <informaltable frame="all">
          <tgroup cols="5">
            <colspec colname="c1" colwidth="10*"/>
            <colspec colname="c2" colwidth="6*"/>
            <colspec colname="c3" colwidth="8*"/>
            <colspec colname="c4" colwidth="6*"/>
            <colspec colname="c5" colwidth="7*"/>
            <tbody>
              <row>
                <entry valign="top"><para> Type</para></entry>
                <entry valign="top"><para> Get</para></entry>
                <entry valign="top"><para> Iteration</para></entry>
                <entry valign="top"><para> Insert</para></entry>
                <entry valign="top"><para> Remove</para></entry>
              </row>
              <row>
                <entry valign="top"><para> array</para></entry>
                <entry valign="top"><para> 1430</para></entry>
                <entry valign="top"><para> 3850</para></entry>
                <entry valign="top"><para> na</para></entry>
                <entry valign="top"><para> na</para></entry>
              </row>
              <row>
                <entry valign="top"><para> ArrayList</para></entry>
                <entry valign="top"><para> 3070</para></entry>
                <entry valign="top"><para> 12200</para></entry>
                <entry valign="top"><para> 500</para></entry>
                <entry valign="top"><para> 46850</para></entry>
              </row>
              <row>
                <entry valign="top"><para> LinkedList</para></entry>
                <entry valign="top"><para> 16320</para></entry>
                <entry valign="top"><para> 9110</para></entry>
                <entry valign="top"><para> 110</para></entry>
                <entry valign="top"><para> 60</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Vector</para></entry>
                <entry valign="top"><para> 4890</para></entry>
                <entry valign="top"><para> 16250</para></entry>
                <entry valign="top"><para> 550</para></entry>
                <entry valign="top"><para> 46850</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>As expected, arrays are faster than any container for random-access lookups and iteration. You can see that random accesses (<emphasis role="bold">get( )</emphasis>) are cheap for <emphasis role="bold">ArrayList</emphasis>s and expensive for <emphasis role="bold">LinkedList</emphasis>s. (Oddly, iteration is <emphasis role="italic">faster</emphasis> for a <emphasis role="bold">LinkedList</emphasis> than an <emphasis role="bold">ArrayList</emphasis>, which is a bit counterintuitive.) On the other hand, insertions and removals from the middle of a list are dramatically cheaper for a <emphasis role="bold">LinkedList</emphasis> than for an <emphasis role="bold">ArrayList</emphasis>�<emphasis role="italic">especially</emphasis> removals. <emphasis role="bold">Vector </emphasis>is generally not as fast as <emphasis role="bold">ArrayList</emphasis>, and it should be avoided; it�s only in the library for legacy code support (the only reason it works in this program is because it was adapted to be a <emphasis role="bold">List</emphasis> in Java 2).<emphasis role="bold"/>The best approach is probably to choose an <emphasis role="bold">ArrayList</emphasis> as your default, and to change to a <emphasis role="bold">LinkedList</emphasis> if you discover performance problems due to many insertions and removals from the middle of the list. And of course, if you are working with a fixed-sized group of elements, use an array.</para>
      </section>
      <section>
        <title><anchor xreflabel="Choosing between Sets" xml:id="_Toc481064699"/>Choosing between <emphasis role="bold">Set</emphasis>s</title>
        <para>You can choose between a <emphasis role="bold">TreeSet </emphasis>and a <emphasis role="bold">HashSet</emphasis>, depending on the size of the <emphasis role="bold">Set</emphasis> (if you need to produce an ordered sequence from a <emphasis role="bold">Set</emphasis>, use <emphasis role="bold">TreeSet</emphasis>).<emphasis role="bold"/>The following test program gives an indication of this trade-off:</para>
        <para>//: c09:SetPerformance.java</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>public class SetPerformance {</para>
        <para>� private abstract static class Tester {</para>
        <para>��� String name;</para>
        <para>��� Tester(String name) { this.name = name; }</para>
        <para>��� abstract void test(Set s, int size, int reps);</para>
        <para>� }</para>
        <para>� private static Tester[] tests = {</para>
        <para>��� new Tester(&quot;add&quot;) { </para>
        <para>����� void test(Set s, int size, int reps) {</para>
        <para>������� for(int i = 0; i &lt; reps; i++) {</para>
        <para>��������� s.clear();</para>
        <para>��������� Collections2.fill(s, </para>
        <para>����������� Collections2.countries.reset(),size);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� },</para>
        <para>��� new Tester(&quot;contains&quot;) { </para>
        <para>����� void test(Set s, int size, int reps) {</para>
        <para>������� for(int i = 0; i &lt; reps; i++)</para>
        <para>��������� for(int j = 0; j &lt; size; j++)</para>
        <para>����������� s.contains(Integer.toString(j));</para>
        <para>����� }</para>
        <para>��� },</para>
        <para>��� new Tester(&quot;iteration&quot;) { </para>
        <para>����� void test(Set s, int size, int reps) {</para>
        <para>������� for(int i = 0; i &lt; reps * 10; i++) {</para>
        <para>��������� Iterator it = s.iterator();</para>
        <para>��������� while(it.hasNext())</para>
        <para>����������� it.next();</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� },</para>
        <para>� };</para>
        <para>� public static void </para>
        <para>� test(Set s, int size, int reps) {</para>
        <para>��� System.out.println(&quot;Testing &quot; + </para>
        <para>����� s.getClass().getName() + &quot; size &quot; + size);</para>
        <para>��� Collections2.fill(s, </para>
        <para>����� Collections2.countries.reset(), size);</para>
        <para>��� for(int i = 0; i &lt; tests.length; i++) {</para>
        <para>����� System.out.print(tests[i].name);</para>
        <para>����� long t1 = System.currentTimeMillis();</para>
        <para>����� tests[i].test(s, size, reps);</para>
        <para>����� long t2 = System.currentTimeMillis();</para>
        <para>����� System.out.println(&quot;: &quot; + </para>
        <para>������� ((double)(t2 - t1)/(double)size));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int reps = 50000;</para>
        <para>��� // Or, choose the number of repetitions</para>
        <para>��� // via the command line:</para>
        <para>��� if(args.length &gt; 0)</para>
        <para>����� reps = Integer.parseInt(args[0]);</para>
        <para>��� // Small:</para>
        <para>��� test(new TreeSet(), 10, reps);</para>
        <para>��� test(new HashSet(), 10, reps);</para>
        <para>��� // Medium:</para>
        <para>��� test(new TreeSet(), 100, reps);</para>
        <para>��� test(new HashSet(), 100, reps);</para>
        <para>��� // Large:</para>
        <para>��� test(new TreeSet(), 1000, reps);</para>
        <para>��� test(new HashSet(), 1000, reps);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The following table shows the results of one run. (Of course, this will be different according to the computer and JVM you are using; you should run the test yourself as well):</para>
        <informaltable frame="all">
          <tgroup cols="5">
            <colspec colname="c1" colwidth="20*"/>
            <colspec colname="c2" colwidth="20*"/>
            <colspec colname="c3" colwidth="20*"/>
            <colspec colname="c4" colwidth="20*"/>
            <colspec colname="c5" colwidth="20*"/>
            <tbody>
              <row>
                <entry valign="top"><para> Type</para></entry>
                <entry valign="top"><para> Test size</para></entry>
                <entry valign="top"><para> Add</para></entry>
                <entry valign="top"><para> Contains</para></entry>
                <entry valign="top"><para> Iteration</para></entry>
              </row>
              <row>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> 10</para></entry>
                <entry valign="top"><para> 138.0</para></entry>
                <entry valign="top"><para> 115.0</para></entry>
                <entry valign="top"><para> 187.0</para></entry>
              </row>
              <row>
                <entry valign="top"><para> TreeSet </para></entry>
                <entry valign="top"><para> 100</para></entry>
                <entry valign="top"><para> 189.5</para></entry>
                <entry valign="top"><para> 151.1</para></entry>
                <entry valign="top"><para> 206.5</para></entry>
              </row>
              <row>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> 1000</para></entry>
                <entry valign="top"><para> 150.6</para></entry>
                <entry valign="top"><para> 177.4</para></entry>
                <entry valign="top"><para> 40.04</para></entry>
              </row>
              <row>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> 10</para></entry>
                <entry valign="top"><para> 55.0</para></entry>
                <entry valign="top"><para> 82.0</para></entry>
                <entry valign="top"><para> 192.0</para></entry>
              </row>
              <row>
                <entry valign="top"><para> HashSet </para></entry>
                <entry valign="top"><para> 100</para></entry>
                <entry valign="top"><para> 45.6</para></entry>
                <entry valign="top"><para> 90.0</para></entry>
                <entry valign="top"><para> 202.2</para></entry>
              </row>
              <row>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> 1000</para></entry>
                <entry valign="top"><para> 36.14</para></entry>
                <entry valign="top"><para> 106.5</para></entry>
                <entry valign="top"><para> 39.39</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>The performance of <emphasis role="bold">HashSet</emphasis> is generally superior to <emphasis role="bold">TreeSet</emphasis> for all operations (but in particular addition and lookup, the two most important operations). The only reason <emphasis role="bold">TreeSet</emphasis> exists is because it maintains its elements in sorted order, so you only use it when you need a sorted <emphasis role="bold">Set</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="Choosing between Maps" xml:id="_Toc481064700"/>Choosing between <emphasis role="bold">Map</emphasis>s</title>
        <para>When choosing between implementations of <emphasis role="bold">Map</emphasis>, the size of the <emphasis role="bold">Map</emphasis> is what most strongly affects performance, and the following test program gives an indication of this trade-off:</para>
        <para>//: c09:MapPerformance.java</para>
        <para>// Demonstrates performance differences in Maps.</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>public class MapPerformance {</para>
        <para>� private abstract static class Tester {</para>
        <para>��� String name;</para>
        <para>��� Tester(String name) { this.name = name; }</para>
        <para>��� abstract void test(Map m, int size, int reps);</para>
        <para>� }</para>
        <para>� private static Tester[] tests = {</para>
        <para>��� new Tester(&quot;put&quot;) { </para>
        <para>����� void test(Map m, int size, int reps) {</para>
        <para>������� for(int i = 0; i &lt; reps; i++) {</para>
        <para>������ ���m.clear();</para>
        <para>��������� Collections2.fill(m, </para>
        <para>����������� Collections2.geography.reset(), size);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� },</para>
        <para>��� new Tester(&quot;get&quot;) { </para>
        <para>����� void test(Map m, int size, int reps) {</para>
        <para>������� for(int i = 0; i &lt; reps; i++)</para>
        <para>��������� for(int j = 0; j &lt; size; j++)</para>
        <para>����������� m.get(Integer.toString(j));</para>
        <para>����� }</para>
        <para>��� },</para>
        <para>��� new Tester(&quot;iteration&quot;) { </para>
        <para>����� void test(Map m, int size, int reps) {</para>
        <para>������� for(int i = 0; i &lt; reps * 10; i++) {</para>
        <para>��������� Iterator it = m.entrySet().iterator();</para>
        <para>��������� while(it.hasNext())</para>
        <para>����������� it.next();</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� },</para>
        <para>� };</para>
        <para>� public static void </para>
        <para>� test(Map m, int size, int reps) {</para>
        <para>��� System.out.println(&quot;Testing &quot; + </para>
        <para>����� m.getClass().getName() + &quot; size &quot; + size);</para>
        <para>��� Collections2.fill(m, </para>
        <para>����� Collections2.geography.reset(), size);</para>
        <para>��� for(int i = 0; i &lt; tests.length; i++) {</para>
        <para>����� System.out.print(tests[i].name);</para>
        <para>����� long t1 = System.currentTimeMillis();</para>
        <para>����� tests[i].test(m, size, reps);</para>
        <para>����� long t2 = System.currentTimeMillis();</para>
        <para>����� System.out.println(&quot;: &quot; + </para>
        <para>������� ((double)(t2 - t1)/(double)size));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� int reps = 50000;</para>
        <para>��� // Or, choose the number of repetitions</para>
        <para>��� // via the command line:</para>
        <para>��� if(args.length &gt; 0)</para>
        <para>����� reps = Integer.parseInt(args[0]);</para>
        <para>��� // Small:</para>
        <para>��� test(new TreeMap(), 10, reps);</para>
        <para>��� test(new HashMap(), 10, reps);</para>
        <para>��� test(new Hashtable(), 10, reps);</para>
        <para>��� // Medium:</para>
        <para>��� test(new TreeMap(), 100, reps);</para>
        <para>��� test(new HashMap(), 100, reps);</para>
        <para>��� test(new Hashtable(), 100, reps);</para>
        <para>� ��// Large:</para>
        <para>��� test(new TreeMap(), 1000, reps);</para>
        <para>��� test(new HashMap(), 1000, reps);</para>
        <para>��� test(new Hashtable(), 1000, reps);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Because the size of the map is the issue, you�ll see that the timing tests divide the time by the size to normalize each measurement. Here is one set of results. (Yours will probably be different.)</para>
        <informaltable frame="all">
          <tgroup cols="5">
            <colspec colname="c1" colwidth="10*"/>
            <colspec colname="c2" colwidth="6*"/>
            <colspec colname="c3" colwidth="6*"/>
            <colspec colname="c4" colwidth="7*"/>
            <colspec colname="c5" colwidth="9*"/>
            <thead>
              <row>
                <entry valign="top"><para> Type </para></entry>
                <entry valign="top"><para> Test size</para></entry>
                <entry valign="top"><para> Put</para></entry>
                <entry valign="top"><para> Get</para></entry>
                <entry valign="top"><para> Iteration</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> 10</para></entry>
                <entry valign="top"><para> 143.0</para></entry>
                <entry valign="top"><para> 110.0</para></entry>
                <entry valign="top"><para> 186.0</para></entry>
              </row>
              <row>
                <entry valign="top"><para> TreeMap </para></entry>
                <entry valign="top"><para> 100</para></entry>
                <entry valign="top"><para> 201.1</para></entry>
                <entry valign="top"><para> 188.4</para></entry>
                <entry valign="top"><para> 280.1</para></entry>
              </row>
              <row>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> 1000</para></entry>
                <entry valign="top"><para> 222.8</para></entry>
                <entry valign="top"><para> 205.2</para></entry>
                <entry valign="top"><para> 40.7</para></entry>
              </row>
              <row>
                <entry valign="top"><para> �</para></entry>
                <entry valign="top"><para> 10</para></entry>
                <entry valign="top"><para> 66.0</para></entry>
                <entry valign="top"><para> 83.0</para></entry>
                <entry valign="top"><para> 197.0</para></entry>
              </row>
              <row>
                <entry valign="top"><para> HashMap</para></entry>
                <entry valign="top"><para> 100</para></entry>
                <entry valign="top"><para> 80.7</para></entry>
                <entry valign="top"><para> 135.7</para></entry>
                <entry valign="top"><para> 278.5</para></entry>
              </row>
              <row>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> 1000</para></entry>
                <entry valign="top"><para> 48.2</para></entry>
                <entry valign="top"><para> 105.7</para></entry>
                <entry valign="top"><para> 41.4</para></entry>
              </row>
              <row>
                <entry valign="top"><para> �</para></entry>
                <entry valign="top"><para> 10</para></entry>
                <entry valign="top"><para> 61.0</para></entry>
                <entry valign="top"><para> 93.0</para></entry>
                <entry valign="top"><para> 302.0</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Hashtable</para></entry>
                <entry valign="top"><para> 100</para></entry>
                <entry valign="top"><para> 90.6</para></entry>
                <entry valign="top"><para> 143.3</para></entry>
                <entry valign="top"><para> 329.0</para></entry>
              </row>
              <row>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> 1000</para></entry>
                <entry valign="top"><para> 54.1</para></entry>
                <entry valign="top"><para> 110.95</para></entry>
                <entry valign="top"><para> 47.3</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>As you might expect, <emphasis role="bold">Hashtable</emphasis> performance is roughly equivalent to <emphasis role="bold">HashMap</emphasis>. (You can also see that <emphasis role="bold">HashMap</emphasis> is generally a bit faster. <emphasis role="bold">HashMap</emphasis> is intended to replace <emphasis role="bold">Hashtable</emphasis>.) The <emphasis role="bold">TreeMap </emphasis>is generally slower than the <emphasis role="bold">HashMap</emphasis>, so why would you use it? So you could use it not as a <emphasis role="bold">Map</emphasis>,<emphasis role="bold"/>but as a way to create an ordered list. The behavior of a tree is such that it�s always in order and doesn�t have to be specially sorted. Once you fill a <emphasis role="bold">TreeMap</emphasis>, you can call <emphasis role="bold">keySet( )</emphasis> to get a <emphasis role="bold">Set</emphasis> view of the keys, then <emphasis role="bold">toArray( )</emphasis> to produce an array of those keys. You can then use the <emphasis role="bold">static </emphasis>method <emphasis role="bold">Arrays.binarySearch( )</emphasis> (discussed later) to rapidly find objects in your sorted array. Of course, you would probably only do this if, for some reason, the behavior of a <emphasis role="bold">HashMap</emphasis> was unacceptable, since <emphasis role="bold">HashMap </emphasis>is designed to rapidly find things. Also, you can easily create a <emphasis role="bold">HashMap </emphasis>from a <emphasis role="bold">TreeMap </emphasis>with a single object creation In the end, when you�re using a <emphasis role="bold">Map </emphasis>your first choice should be <emphasis role="bold">HashMap</emphasis>, and only if you need a constantly sorted <emphasis role="bold">Map</emphasis> will you need <emphasis role="bold">TreeMap</emphasis>.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Sorting and searching Lists" xml:id="_Toc481064701"/>Sorting and searching <emphasis role="bold">List</emphasis>s</title>
      <para>Utilities to perform sorting and searching for <emphasis role="bold">List</emphasis>s have the same names and signatures as those for sorting arrays of objects, but are <emphasis role="bold">static </emphasis>methods of <emphasis role="bold">Collections</emphasis> instead of <emphasis role="bold">Arrays</emphasis>. Here�s an example, modified from <emphasis role="bold">ArraySearching.java</emphasis>:</para>
      <para>//: c09:ListSortSearch.java</para>
      <para>// Sorting and searching Lists with &apos;Collections.&apos;</para>
      <para>import com.bruceeckel.util.*;</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>public class ListSortSearch {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� List list = new ArrayList();</para>
      <para>��� Collections2.fill(list, </para>
      <para>����� Collections2.capitals, 25);</para>
      <para>��� System.out.println(list + &quot;\n&quot;);</para>
      <para>��� Collections.shuffle(list);</para>
      <para>��� System.out.println(&quot;After shuffling: &quot;+list);</para>
      <para>�� �Collections.sort(list);</para>
      <para>��� System.out.println(list + &quot;\n&quot;);</para>
      <para>��� Object key = list.get(12);</para>
      <para>��� int index = </para>
      <para>����� Collections.binarySearch(list, key);</para>
      <para>��� System.out.println(&quot;Location of &quot; + key + </para>
      <para>����� &quot; is &quot; + index + &quot;, list.get(&quot; + </para>
      <para>����� index + &quot;) = &quot; + list.get(index));</para>
      <para>��� AlphabeticComparator comp =</para>
      <para>����� new AlphabeticComparator();</para>
      <para>��� Collections.sort(list, comp);</para>
      <para>��� System.out.println(list + &quot;\n&quot;);</para>
      <para>��� key = list.get(12);</para>
      <para>��� index = </para>
      <para>����� Collections.binarySearch(list, key, comp);</para>
      <para>��� System.out.println(&quot;Location of &quot; + key + </para>
      <para>����� &quot; is &quot; + index + &quot;, list.get(&quot; + </para>
      <para>����� index + &quot;) = &quot; + list.get(index));</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The use of these methods is identical to the ones in <emphasis role="bold">Arrays</emphasis>, but you�re using a <emphasis role="bold">List</emphasis> instead of an array. Just like searching and sorting with arrays, if you sort using a <emphasis role="bold">Comparator</emphasis> you must <emphasis role="bold">binarySearch( )</emphasis> using the same <emphasis role="bold">Comparator</emphasis>.</para>
      <para>This program also demonstrates the <emphasis role="bold">shuffle( )</emphasis> method in <emphasis role="bold">Collections</emphasis>, which randomizes the order of a <emphasis role="bold">List</emphasis>.</para>
    </section>
    <section>
      <title><anchor xreflabel="Utilities" xml:id="_Toc481064702"/>Utilities</title>
      <para>There are a number of other useful utilities in the <emphasis role="bold">Collections</emphasis> class: </para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="24*"/>
          <colspec colname="c2" colwidth="24*"/>
          <tbody>
            <row>
              <entry valign="top"><para> enumeration(Collection) </para></entry>
              <entry valign="top"><para> Produces an old-style Enumeration for the argument.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> max(Collection) </para><para>min(Collection)</para></entry>
              <entry valign="top"><para> Produces the maximum or minimum element in the argument using the natural comparison method of the objects in the Collection.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> max(Collection, Comparator) </para><para>min(Collection, Comparator)</para></entry>
              <entry valign="top"><para> Produces the maximum or minimum element in the Collection using the Comparator. </para></entry>
            </row>
            <row>
              <entry valign="top"><para> reverse( )</para></entry>
              <entry valign="top"><para> Reverses all the elements in place.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> copy(List dest, List src)</para></entry>
              <entry valign="top"><para> Copies elements from src to dest.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> fill(List list, Object o)</para></entry>
              <entry valign="top"><para> Replaces all the elements of list with o.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> nCopies(int n, Object o) </para></entry>
              <entry valign="top"><para> Returns an immutable List of size n whose references all point to o. </para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Note that <emphasis role="bold">min( )</emphasis> and <emphasis role="bold">max( )</emphasis> work with <emphasis role="bold">Collection</emphasis> objects, not with <emphasis role="bold">List</emphasis>s, so you don�t need to worry about whether the <emphasis role="bold">Collection</emphasis> should be sorted or not. (As mentioned earlier, you <emphasis role="italic">do</emphasis> need to <emphasis role="bold">sort( )</emphasis> a <emphasis role="bold">List</emphasis> or an array before performing a <emphasis role="bold">binarySearch( )</emphasis>.)</para>
      <section>
        <title><anchor xreflabel="Making a Collection or Map
unmodifiable" xml:id="_Toc481064703"/>Making a <emphasis role="bold">Collection</emphasis> or <emphasis role="bold">Map</emphasis> unmodifiable</title>
        <para>Often it is convenient to create a read-only version of a <emphasis role="bold">Collection</emphasis> or <emphasis role="bold">Map</emphasis>. The <emphasis role="bold">Collections</emphasis> class allows you to do this by passing the original container into a method that hands back a read-only version. There are four variations on this method, one each for <emphasis role="bold">Collection</emphasis> (if you don�t want to treat a <emphasis role="bold">Collection </emphasis>as a more specific type), <emphasis role="bold">List</emphasis>, <emphasis role="bold">Set,</emphasis> and <emphasis role="bold">Map</emphasis>. This example shows the proper way to build read-only versions of each:</para>
        <para>//: c09:ReadOnly.java</para>
        <para>// Using the Collections.unmodifiable methods.</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>public class ReadOnly {</para>
        <para>� static Collections2.StringGenerator gen = </para>
        <para>��� Collections2.countries;</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Collection c = new ArrayList();</para>
        <para>��� Collections2.fill(c, gen, 25); // Insert data</para>
        <para>��� c = Collections.unmodifiableCollection(c);</para>
        <para>��� System.out.println(c); // Reading is OK</para>
        <para>��� c.add(&quot;one&quot;); // Can&apos;t change it</para>
        <para>��� </para>
        <para>��� List a = new ArrayList();</para>
        <para>��� Collections2.fill(a, gen.reset(), 25);</para>
        <para>��� a = Collections.unmodifiableList(a);</para>
        <para>��� ListIterator lit = a.listIterator();</para>
        <para>��� System.out.println(lit.next()); // Reading OK</para>
        <para>��� lit.add(&quot;one&quot;); // Can&apos;t change it</para>
        <para> </para>
        <para>��� Set s = new HashSet();</para>
        <para>��� Collections2.fill(s, gen.reset(), 25);</para>
        <para>��� s = Collections.unmodifiableSet(s);</para>
        <para>��� System.out.println(s); // Reading OK</para>
        <para>��� //! s.add(&quot;one&quot;); // Can&apos;t change it</para>
        <para>��� </para>
        <para>��� Map m = new HashMap();</para>
        <para>��� Collections2.fill(m,</para>
        <para>����� Collections2.geography, 25);</para>
        <para>��� m = Collections.unmodifiableMap(m);</para>
        <para>��� System.out.println(m); // Reading OK</para>
        <para>��� //! m.put(&quot;Ralph&quot;, &quot;Howdy!&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In each case, you must fill the container with meaningful data <emphasis role="italic">before</emphasis> you make it read-only. Once it is loaded, the best approach is to replace the existing reference with the reference that is produced by the �unmodifiable� call. That way, you don�t run the risk of accidentally changing the contents once you�ve made it unmodifiable. On the other hand, this tool also allows you to keep a modifiable container as <emphasis role="bold">private</emphasis> within a class and to return a read-only reference to that container from a method call. So you can change it from within the class, but everyone else can only read it.</para>
        <para>Calling the �unmodifiable� method for a particular type does not cause compile-time checking, but once the transformation has occurred, any calls to methods that modify the contents of a particular container will produce an <emphasis role="bold">UnsupportedOperationException</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="Synchronizing a Collection
or Map" xml:id="_Toc481064704"/>Synchronizing a <emphasis role="bold">Collection</emphasis> or <emphasis role="bold">Map</emphasis></title>
        <para>The <emphasis role="bold">synchronized</emphasis> keyword is an important part of the subject of <emphasis role="italic">multithreading</emphasis>, a more complicated topic that will not be introduced until Chapter 14. Here, I shall note only that the <emphasis role="bold">Collections</emphasis> class contains a way to automatically synchronize an entire container. The syntax is similar to the �unmodifiable� methods:</para>
        <para>//: c09:Synchronization.java</para>
        <para>// Using the Collections.synchronized methods.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class Synchronization {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Collection c = </para>
        <para>����� Collections.synchronizedCollection(</para>
        <para>������� new ArrayList());</para>
        <para>��� List list = Collections.synchronizedList(</para>
        <para>����� new ArrayList());</para>
        <para>��� Set s = Collections.synchronizedSet(</para>
        <para>����� new HashSet());</para>
        <para>��� Map m = Collections.synchronizedMap(</para>
        <para>����� new HashMap());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In this case, you immediately pass the new container through the appropriate �synchronized� method; that way there�s no chance of accidentally exposing the unsynchronized version.</para>
        <section>
          <title>Fail fast</title>
          <para>The Java containers also have a mechanism to prevent more than one process from modifying the contents of a container. The problem occurs if you�re iterating through a container and some other process steps in and inserts, removes, or changes an object in that container. Maybe you�ve already passed that object, maybe it�s ahead of you, maybe the size of the container shrinks after you call <emphasis role="bold">size( )</emphasis>�there are many scenarios for disaster. The Java containers library incorporates a <emphasis role="italic">fail-fast</emphasis> mechanism that looks for any changes to the container other than the ones your process is personally responsible for. If it detects that someone else is modifying the container, it immediately produces a <emphasis role="bold">ConcurrentModificationException</emphasis>. This is the �fail-fast� aspect�it doesn�t try to detect a problem later on using a more complex algorithm.</para>
          <para>It�s quite easy to see the fail-fast mechanism in operation�all you have to do is create an iterator and then add something to the collection that the iterator is pointing to, like this:</para>
          <para>//: c09:FailFast.java</para>
          <para>// Demonstrates the &quot;fail fast&quot; behavior.</para>
          <para>import java.util.*;</para>
          <para> </para>
          <para>public class FailFast {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Collection c = new ArrayList();</para>
          <para>��� Iterator it = c.iterator();</para>
          <para>��� c.add(&quot;An object&quot;);</para>
          <para>��� // Causes an exception:</para>
          <para>��� String s = (String)it.next();</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The exception happens because something is placed in the container <emphasis role="italic">after</emphasis> the iterator is acquired from the container. The possibility that two parts of the program could be modifying the same container produces an uncertain state, so the exception notifies you that you should change your code�in this case, acquire the iterator <emphasis role="italic">after</emphasis> you have added all the elements to the container.</para>
          <para>Note that you cannot benefit from this kind of monitoring when you�re accessing the elements of a <emphasis role="bold">List</emphasis> using <emphasis role="bold">get( )</emphasis>.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Unsupported operations" xml:id="_Toc481064705"/>Unsupported operations</title>
      <para>It�s possible to turn an array into a <emphasis role="bold">List</emphasis> with the <emphasis role="bold">Arrays.asList( )</emphasis> method:</para>
      <para>//: c09:Unsupported.java</para>
      <para>// Sometimes methods defined in the</para>
      <para>// Collection interfaces don&apos;t work!</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>public class Unsupported {</para>
      <para>� private static String[] s = {</para>
      <para>��� &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;,</para>
      <para>��� &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;ten&quot;,</para>
      <para>� };</para>
      <para>� static List a = Arrays.asList(s);</para>
      <para>� static List a2 = a.subList(3, 6);</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� System.out.println(a);</para>
      <para>��� System.out.println(a2);</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;a.contains(&quot; + s[0] + &quot;) = &quot; + </para>
      <para>����� a.contains(s[0]));</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;a.containsAll(a2) = &quot; + </para>
      <para>����� a.containsAll(a2));</para>
      <para>��� System.out.println(&quot;a.isEmpty() = &quot; +</para>
      <para>����� a.isEmpty());</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;a.indexOf(&quot; + s[5] + &quot;) = &quot; + </para>
      <para>����� a.indexOf(s[5]));</para>
      <para>��� // Traverse backwards:</para>
      <para>��� ListIterator lit = a.listIterator(a.size());</para>
      <para>��� while(lit.hasPrevious())</para>
      <para>����� System.out.print(lit.previous() + &quot; &quot;);</para>
      <para>��� System.out.println();</para>
      <para>��� // Set the elements to different values:</para>
      <para>��� for(int i = 0; i &lt; a.size(); i++)</para>
      <para>����� a.set(i, &quot;47&quot;);</para>
      <para>��� System.out.println(a);</para>
      <para>��� // Compiles, but won&apos;t run:</para>
      <para>��� lit.add(&quot;X&quot;); // Unsupported operation</para>
      <para>��� a.clear(); // Unsupported</para>
      <para>��� a.add(&quot;eleven&quot;); // Unsupported</para>
      <para>��� a.addAll(a2); // Unsupported</para>
      <para>��� a.retainAll(a2); // Unsupported</para>
      <para>��� a.remove(s[0]); // Unsupported</para>
      <para>��� a.removeAll(a2); // Unsupported</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>You�ll discover that only a portion of the <emphasis role="bold">Collection</emphasis> and <emphasis role="bold">List </emphasis>interfaces are actually implemented. The rest of the methods cause the unwelcome appearance of something called an <emphasis role="bold">UnsupportedOperationException</emphasis>. You�ll learn all about exceptions in the next chapter, but the short story is that the <emphasis role="bold">Collection</emphasis><emphasis role="bold">interface</emphasis>�as well as some of the other <emphasis role="bold">interface</emphasis>s in the Java containers library�contain �optional� methods, which might or might not be �supported� in the concrete class that <emphasis role="bold">implements</emphasis> that <emphasis role="bold">interface</emphasis>. Calling an unsupported method causes an <emphasis role="bold">UnsupportedOperationException</emphasis> to indicate a programming error.</para>
      <para>�What?!?� you say, incredulous. �The whole point of <emphasis role="bold">interface</emphasis>s and base classes is that they promise these methods will do something meaningful! This breaks that promise�it says that not only will calling some methods <emphasis role="italic">not</emphasis> perform a meaningful behavior, they will stop the program! Type safety was just thrown out the window!� </para>
      <para>It�s not quite that bad. With a <emphasis role="bold">Collection</emphasis>, <emphasis role="bold">List</emphasis>, <emphasis role="bold">Set</emphasis>, or <emphasis role="bold">Map</emphasis>, the compiler still restricts you to calling only the methods in that <emphasis role="bold">interface</emphasis>, so it�s not like Smalltalk (in which you can call any method for any object, and find out only when you run the program whether your call does anything). In addition, most methods that take a <emphasis role="bold">Collection</emphasis> as an argument only read from that <emphasis role="bold">Collection</emphasis>�all the �read� methods of <emphasis role="bold">Collection </emphasis>are <emphasis role="italic">not</emphasis> optional.</para>
      <para>This approach prevents an explosion of interfaces in the design. Other designs for container libraries always seem to end up with a confusing plethora of interfaces to describe each of the variations on the main theme and are thus difficult to learn. It�s not even possible to capture all of the special cases in <emphasis role="bold">interface</emphasis>s, because someone can always invent a new <emphasis role="bold">interface</emphasis>. The �unsupported operation� approach achieves an important goal of the Java containers library: the containers are simple to learn and use; unsupported operations are a special case that can be learned later. For this approach to work, however:</para>
      <para>The <emphasis role="bold">UnsupportedOperationException</emphasis> must be a rare event. That is, for most classes all operations should work, and only in special cases should an operation be unsupported. This is true in the Java containers library, since the classes you�ll use 99 percent of the time�<emphasis role="bold">ArrayList</emphasis>, <emphasis role="bold">LinkedList</emphasis>, <emphasis role="bold">HashSet</emphasis>, and <emphasis role="bold">HashMap</emphasis>, as well as the other concrete implementations�support all of the operations. The design does provide a �back door� if you want to create a new <emphasis role="bold">Collection</emphasis> without providing meaningful definitions for all the methods in the <emphasis role="bold">Collection</emphasis><emphasis role="bold">interface</emphasis>, and yet still fit it into the existing library.</para>
      <para>59.      When an operation <emphasis role="italic">is</emphasis> unsupported, there should be reasonable likelihood that an <emphasis role="bold">UnsupportedOperationException</emphasis> will appear at implementation time, rather than after you�ve shipped the product to the customer. After all, it indicates a programming error: you�ve used an implementation incorrectly. This point is less certain, and is where the experimental nature of this design comes into play. Only over time will we find out how well it works.</para>
      <para>In the example above, <emphasis role="bold">Arrays.asList( )</emphasis> produces a <emphasis role="bold">List</emphasis> that is backed by a fixed-size array. Therefore it makes sense that the only supported operations are the ones that don�t change the size of the array. If, on the other hand, a new <emphasis role="bold">interface</emphasis> were required to express this different kind of behavior (called, perhaps, �<emphasis role="bold">FixedSizeList</emphasis>�), it would throw open the door to complexity and soon you wouldn�t know where to start when trying to use the library.</para>
      <para>The documentation for a method that takes a <emphasis role="bold">Collection</emphasis>, <emphasis role="bold">List</emphasis>, <emphasis role="bold">Set</emphasis>, or <emphasis role="bold">Map</emphasis> as an argument should specify which of the optional methods must be implemented. For example, sorting requires the <emphasis role="bold">set( )</emphasis> and <emphasis role="bold">Iterator.set( ) </emphasis>methods, but not <emphasis role="bold">add( )</emphasis> and <emphasis role="bold">remove( )</emphasis>. </para>
    </section>
    <section>
      <title><anchor xreflabel="Java 1.0/1.1 containers" xml:id="_Toc481064706"/>Java 1.0/1.1 containers</title>
      <para>Unfortunately, a lot of code was written using the Java 1.0/1.1 containers, and even new code is sometimes written using these classes. So although you should never use the old containers when writing new code, you�ll still need to be aware of them. However, the old containers were quite limited, so there�s not that much to say about them. (Since they are in the past, I will try to refrain from overemphasizing some of the hideous design decisions.)</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545355"/><anchor xreflabel="Vector
&amp; Enumeration" xml:id="_Toc481064707"/>Vector &amp; Enumeration</title>
        <para>The only self-expanding sequence in Java 1.0/1.1 was the <emphasis role="bold">Vector</emphasis>, and so it saw a lot of use. Its flaws are too numerous to describe here (see the first edition of this book, available on this book�s CD ROM and as a free download from <emphasis role="italic">www.BruceEckel.com</emphasis>). Basically, you can think of it as an <emphasis role="bold">ArrayList</emphasis> with long, awkward method names. In the Java 2 container library, <emphasis role="bold">Vector</emphasis> was adapted so that it could fit as a <emphasis role="bold">Collection </emphasis>and a <emphasis role="bold">List</emphasis>, so in the following example the <emphasis role="bold">Collections2.fill( )</emphasis> method is successfully used. This turns out to be a bit perverse, as it may confuse some people into thinking that <emphasis role="bold">Vector</emphasis> has gotten better, when it is actually included only to support pre-Java 2 code.</para>
        <para>The Java 1.0/1.1 version of the iterator chose to invent a new name, �enumeration,� instead of using a term that everyone was already familiar with. The <emphasis role="bold">Enumeration</emphasis> interface is smaller than <emphasis role="bold">Iterator</emphasis>, with only two methods, and it uses longer method names: <emphasis role="bold">boolean</emphasis><emphasis role="bold">hasMoreElements( )</emphasis> produces <emphasis role="bold">true</emphasis> if this enumeration contains more elements, and <emphasis role="bold">Object nextElement( ) </emphasis>returns the next element of this enumeration if there are any more (otherwise it throws an exception).</para>
        <para><emphasis role="bold">Enumeration</emphasis> is only an interface, not an implementation, and even new libraries sometimes still use the old <emphasis role="bold">Enumeration</emphasis>�which is unfortunate but generally harmless. Even though you should always use <emphasis role="bold">Iterator</emphasis> when you can in your own code, you must be prepared for libraries that want to hand you an <emphasis role="bold">Enumeration</emphasis>.</para>
        <para>In addition, you can produce an <emphasis role="bold">Enumeration</emphasis> for any <emphasis role="bold">Collection</emphasis> by using the <emphasis role="bold">Collections.enumeration( )</emphasis> method, as seen in this example:</para>
        <para>//: c09:Enumerations.java</para>
        <para>// Java 1.0/1.1 Vector and Enumeration.</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>class Enumerations {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Vector v = new Vector();</para>
        <para>��� Collections2.fill(</para>
        <para>����� v, Collections2.countries, 100);</para>
        <para>��� Enumeration e = v.elements();</para>
        <para>��� while(e.hasMoreElements())</para>
        <para>����� System.out.println(e.nextElement());</para>
        <para>��� // Produce an Enumeration from a Collection:</para>
        <para>��� e = Collections.enumeration(new ArrayList());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The Java 1.0/1.1 <emphasis role="bold">Vector</emphasis> has only an <emphasis role="bold">addElement( )</emphasis> method, but <emphasis role="bold">fill( )</emphasis> uses the <emphasis role="bold">add( )</emphasis> method that was pasted on as <emphasis role="bold">Vector</emphasis> was turned into a <emphasis role="bold">List</emphasis>. To produce an <emphasis role="bold">Enumeration</emphasis>, you call <emphasis role="bold">elements( )</emphasis>, then you can use it to perform a forward iteration.</para>
        <para>The last line creates an <emphasis role="bold">ArrayList</emphasis> and uses <emphasis role="bold">enumeration( )</emphasis> to adapt an <emphasis role="bold">Enumeration</emphasis> from the <emphasis role="bold">ArrayList</emphasis><emphasis role="bold">Iterator</emphasis>. Thus, if you have old code that wants an <emphasis role="bold">Enumeration</emphasis>, you can still use the new containers.</para>
      </section>
      <section>
        <title><anchor xreflabel="Hashtable" xml:id="_Toc481064708"/>Hashtable</title>
        <para>As you�ve seen in the performance comparison in this chapter, the basic <emphasis role="bold">Hashtable</emphasis> is very similar to the <emphasis role="bold">HashMap</emphasis>, even down to the method names. There�s no reason to use <emphasis role="bold">Hashtable</emphasis> instead of <emphasis role="bold">HashMap</emphasis> in new code.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064709"/><anchor xreflabel="Stack" xml:id="_Toc375545356"/>Stack</title>
        <para>The concept of the stack was introduced earlier, with the <emphasis role="bold">LinkedList</emphasis>.<emphasis role="bold"/>What�s rather odd about the Java 1.0/1.1 <emphasis role="bold">Stack </emphasis>is that instead of using a <emphasis role="bold">Vector</emphasis> as a building block, <emphasis role="bold">Stack </emphasis>is <emphasis role="italic">inherited</emphasis> from <emphasis role="bold">Vector</emphasis>. So it has all of the characteristics and behaviors of a <emphasis role="bold">Vector</emphasis> plus some extra <emphasis role="bold">Stack</emphasis> behaviors. It�s difficult to know whether the designers explicitly decided that this was an especially useful way of doing things, or whether it was just a naive design.</para>
        <para>Here�s a simple demonstration of <emphasis role="bold">Stack</emphasis> that pushes each line from a <emphasis role="bold">String</emphasis> array:</para>
        <para>//: c09:Stacks.java</para>
        <para>// Demonstration of Stack Class.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class Stacks {</para>
        <para>� static String[] months = { </para>
        <para>��� &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;,</para>
        <para>��� &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;,</para>
        <para>��� &quot;October&quot;, &quot;November&quot;, &quot;December&quot; };</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Stack stk = new Stack();</para>
        <para>��� for(int i = 0; i &lt; months.length; i++)</para>
        <para>����� stk.push(months[i] + &quot; &quot;);</para>
        <para>��� System.out.println(&quot;stk = &quot; + stk);</para>
        <para>��� // Treating a stack as a Vector:</para>
        <para>��� stk.addElement(&quot;The last line&quot;);</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;element 5 = &quot; + stk.elementAt(5));</para>
        <para>��� System.out.println(&quot;popping elements:&quot;);</para>
        <para>��� while(!stk.empty())</para>
        <para>����� System.out.println(stk.pop());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Each line in the <emphasis role="bold">months </emphasis>array is inserted into the <emphasis role="bold">Stack</emphasis> with <emphasis role="bold">push( )</emphasis>, and later fetched from the top of the stack with a <emphasis role="bold">pop( )</emphasis>. To make a point, <emphasis role="bold">Vector </emphasis>operations are also performed on the <emphasis role="bold">Stack</emphasis> object. This is possible because, by virtue of inheritance, a <emphasis role="bold">Stack</emphasis><emphasis role="italic">is</emphasis> a <emphasis role="bold">Vector</emphasis>. Thus, all operations that can be performed on a <emphasis role="bold">Vector</emphasis> can also be performed on a <emphasis role="bold">Stack</emphasis>, such as <emphasis role="bold">elementAt( )</emphasis>.</para>
        <para>As mentioned earlier, you should use a <emphasis role="bold">LinkedList</emphasis> when you want stack behavior.</para>
      </section>
      <section>
        <title><anchor xreflabel="BitSet" xml:id="_Toc481064710"/>BitSet</title>
        <para>A <emphasis role="bold">BitSet</emphasis> is used if you want to efficiently store a lot of on-off information. It�s efficient only from the standpoint of size; if you�re looking for efficient access, it is slightly slower than using an array of some native type.</para>
        <para>In addition, the minimum size of the <emphasis role="bold">BitSet</emphasis> is that of a <emphasis role="bold">long</emphasis>: 64 bits. This implies that if you�re storing anything smaller, like 8 bits, a <emphasis role="bold">BitSet</emphasis> will be wasteful; you�re better off creating your own class, or just an array, to hold your flags if size is an issue.</para>
        <para>A normal container expands as you add more elements, and the <emphasis role="bold">BitSet</emphasis> does this as well. The following example shows how the <emphasis role="bold">BitSet </emphasis>works:</para>
        <para>//: c09:Bits.java</para>
        <para>// Demonstration of BitSet.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class Bits {</para>
        <para>� static void printBitSet(BitSet b) {</para>
        <para>��� System.out.println(&quot;bits: &quot; + b);</para>
        <para>��� String bbits = new String();</para>
        <para>��� for(int j = 0; j &lt; b.size() ; j++)</para>
        <para>����� bbits += (b.get(j) ? &quot;1&quot; : &quot;0&quot;);</para>
        <para>��� System.out.println(&quot;bit pattern: &quot; + bbits);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Random rand = new Random();</para>
        <para>��� // Take the LSB of nextInt():</para>
        <para>��� byte bt = (byte)rand.nextInt();</para>
        <para>��� BitSet bb = new BitSet();</para>
        <para>��� for(int i = 7; i &gt;=0; i--)</para>
        <para>����� if(((1 &lt;&lt; i) &amp;� bt) != 0)</para>
        <para>������� bb.set(i);</para>
        <para>����� else</para>
        <para>������� bb.clear(i);</para>
        <para>��� System.out.println(&quot;byte value: &quot; + bt);</para>
        <para>��� printBitSet(bb);</para>
        <para> </para>
        <para>��� short st = (short)rand.nextInt();</para>
        <para>��� BitSet bs = new BitSet();</para>
        <para>��� for(int i = 15; i &gt;=0; i--)</para>
        <para>����� if(((1 &lt;&lt; i) &amp;� st) != 0)</para>
        <para>������� bs.set(i);</para>
        <para>����� else</para>
        <para>������� bs.clear(i);</para>
        <para>��� System.out.println(&quot;short value: &quot; + st);</para>
        <para>��� printBitSet(bs);</para>
        <para> </para>
        <para>��� int it = rand.nextInt();</para>
        <para>��� BitSet bi = new BitSet();</para>
        <para>��� for(int i = 31; i &gt;=0; i--)</para>
        <para>����� if(((1 &lt;&lt; i) &amp;� it) != 0)</para>
        <para>������� bi.set(i);</para>
        <para>����� else</para>
        <para>������� bi.clear(i);</para>
        <para>��� System.out.println(&quot;int value: &quot; + it);</para>
        <para>��� printBitSet(bi);</para>
        <para> </para>
        <para>��� // Test bitsets &gt;= 64 bits:</para>
        <para>��� BitSet b127 = new BitSet();</para>
        <para>��� b127.set(127);</para>
        <para>��� System.out.println(&quot;set bit 127: &quot; + b127);</para>
        <para>��� BitSet b255 = new BitSet(65);</para>
        <para>��� b255.set(255);</para>
        <para>��� System.out.println(&quot;set bit 255: &quot; + b255);</para>
        <para>��� BitSet b1023 = new BitSet(512);</para>
        <para>��� b1023.set(1023);</para>
        <para>��� b1023.set(1024);</para>
        <para>��� System.out.println(&quot;set bit 1023: &quot; + b1023);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The random number generator is used to create a random <emphasis role="bold">byte</emphasis>, <emphasis role="bold">short</emphasis>, and <emphasis role="bold">int</emphasis>, and each one is transformed into a corresponding bit pattern in a <emphasis role="bold">BitSet</emphasis>. This works fine because a <emphasis role="bold">BitSet</emphasis> is 64 bits, so none of these cause it to increase in size. Then a <emphasis role="bold">BitSet</emphasis> of 512 bits is created. The constructor allocates storage for twice that number of bits. However, you can still set bit 1024 or greater.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Summary" xml:id="_Toc481064711"/>Summary</title>
      <para>To review the containers provided in the standard Java library:</para>
      <para>An array associates numerical indices to objects. It holds objects of a known type so that you don�t have to cast the result when you�re looking up an object. It can be multidimensional, and it can hold primitives. However, its size cannot be changed once you create it.</para>
      <para>60.      A <emphasis role="bold">Collection</emphasis> holds single elements, while a <emphasis role="bold">Map</emphasis> holds associated pairs.</para>
      <para>61.      Like an array, a <emphasis role="bold">List</emphasis> also associates numerical indices to objects�you can think of arrays and <emphasis role="bold">List</emphasis>s as ordered containers. The <emphasis role="bold">List</emphasis> automatically resizes itself as you add more elements. But a <emphasis role="bold">List</emphasis> can hold only <emphasis role="bold">Object reference</emphasis>s, so it won�t hold primitives and you must always cast the result when you pull an <emphasis role="bold">Object </emphasis>reference out of a container.</para>
      <para>62.      Use an <emphasis role="bold">ArrayList</emphasis> if you�re doing a lot of random accesses, and a <emphasis role="bold">LinkedList</emphasis> if you will be doing a lot of insertions and removals in the middle of the list.</para>
      <para>63.      The behavior of queues, deques, and stacks is provided via the <emphasis role="bold">LinkedList</emphasis>.</para>
      <para>64.      A <emphasis role="bold">Map</emphasis> is a way to associate not numbers, but <emphasis role="italic">objects</emphasis> with other objects. The design of a <emphasis role="bold">HashMap</emphasis> is focused on rapid access, while a <emphasis role="bold">TreeMap</emphasis> keeps its keys in sorted order, and thus is not as fast as a <emphasis role="bold">HashMap</emphasis>.</para>
      <para>65.      A <emphasis role="bold">Set</emphasis> only accepts one of each type of object. <emphasis role="bold">HashSet</emphasis>s provide maximally fast lookups, while <emphasis role="bold">TreeSet</emphasis>s keep the elements in sorted order.</para>
      <para>66.      There�s no need to use the legacy classes <emphasis role="bold">Vector</emphasis>, <emphasis role="bold">Hashtable</emphasis> and <emphasis role="bold">Stack</emphasis> in new code.</para>
      <para>The containers are tools that you can use on a day-to-day basis to make your programs simpler, more powerful, and more effective.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064712"/><anchor xreflabel="Exercises" xml:id="_Toc375545360"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Create an array of <emphasis role="bold">double</emphasis> and <emphasis role="bold">fill( )</emphasis> it using <emphasis role="bold">RandDoubleGenerator</emphasis>. Print the results.</para>
      <para>  118.         Create a new class called <emphasis role="bold">Gerbil</emphasis> with an <emphasis role="bold">int gerbilNumber </emphasis>that�s initialized in the constructor (similar to the <emphasis role="bold">Mouse </emphasis>example in this chapter). Give it a method called <emphasis role="bold">hop( )</emphasis> that prints out which gerbil number this is, and that it�s hopping. Create an <emphasis role="bold">ArrayList</emphasis> and add a bunch of <emphasis role="bold">Gerbil</emphasis> objects to the <emphasis role="bold">List</emphasis>. Now use the <emphasis role="bold">get( )</emphasis> method to move through the <emphasis role="bold">List</emphasis> and call <emphasis role="bold">hop( )</emphasis> for each <emphasis role="bold">Gerbil</emphasis>.</para>
      <para>  119.         Modify Exercise 2 so you use an <emphasis role="bold">Iterator</emphasis> to move through the <emphasis role="bold">List</emphasis> while calling <emphasis role="bold">hop( )</emphasis>.</para>
      <para>  120.         Take the <emphasis role="bold">Gerbil</emphasis> class in Exercise 2 and put it into a <emphasis role="bold">Map</emphasis> instead, associating the name of the <emphasis role="bold">Gerbil</emphasis> as a <emphasis role="bold">String</emphasis> (the key) for each <emphasis role="bold">Gerbil </emphasis>(the value) you put in the table. Get an <emphasis role="bold">Iterator</emphasis> for the <emphasis role="bold">keySet( )</emphasis> and use it to move through the <emphasis role="bold">Map</emphasis>, looking up the <emphasis role="bold">Gerbil</emphasis> for each key and printing out the key and telling the <emphasis role="bold">gerbil</emphasis> to <emphasis role="bold">hop( )</emphasis>.</para>
      <para>  121.         Create a <emphasis role="bold">List</emphasis> (try both <emphasis role="bold">ArrayList </emphasis>and <emphasis role="bold">LinkedList</emphasis>)<emphasis role="bold"/>and fill it using <emphasis role="bold">Collections2.countries</emphasis>. Sort the list and print it, then apply <emphasis role="bold">Collections.shuffle( )</emphasis> to the list repeatedly, printing it each time so that you can see how the <emphasis role="bold">shuffle( )</emphasis> method randomizes the list differently each time.</para>
      <para>  122.         Demonstrate that you can�t add anything but a <emphasis role="bold">Mouse</emphasis> to a <emphasis role="bold">MouseList</emphasis>.</para>
      <para>  123.         Modify <emphasis role="bold">MouseList.java</emphasis> so that it inherits from <emphasis role="bold">ArrayList</emphasis> instead of using composition. Demonstrate the problem with this approach.</para>
      <para>  124.         Repair <emphasis role="bold">CatsAndDogs.java</emphasis> by creating a <emphasis role="bold">Cats</emphasis> container (utilizing <emphasis role="bold">ArrayList</emphasis>)<emphasis role="bold"/>that will only accept and retrieve <emphasis role="bold">Cat</emphasis> objects.</para>
      <para>  125.         Create a container that encapsulates an array of <emphasis role="bold">String</emphasis>, and that only adds <emphasis role="bold">String</emphasis>s and gets <emphasis role="bold">String</emphasis>s, so that there are no casting issues during use. If the internal array isn�t big enough for the next add, your container should automatically resize it. In <emphasis role="bold">main( )</emphasis>, compare the performance of your container with an <emphasis role="bold">ArrayList</emphasis> holding <emphasis role="bold">String</emphasis>s.</para>
      <para>  126.         Repeat Exercise 9 for a container of <emphasis role="bold">int</emphasis>, and compare the performance to an <emphasis role="bold">ArrayList</emphasis> holding <emphasis role="bold">Integer</emphasis> objects. In your performance comparison, include the process of incrementing each object in the container.</para>
      <para>  127.         Using the utilities in <emphasis role="bold">com.bruceeckel.util</emphasis>, create an array of each primitive type and of <emphasis role="bold">String</emphasis>, then fill each array using an appropriate generator, and print each array using the appropriate <emphasis role="bold">print( )</emphasis> method.</para>
      <para>  128.         Create a generator that produces character names from your favorite movies (you can use <emphasis role="italic">Snow White</emphasis> or <emphasis role="italic">Star Wars </emphasis>as a fallback), and loops around to the beginning when it runs out of names. Use the utilities in <emphasis role="bold">com.bruceeckel.util</emphasis> to fill an array, an <emphasis role="bold">ArrayList</emphasis>, a <emphasis role="bold">LinkedList</emphasis> and both types of <emphasis role="bold">Set</emphasis>, then print each container.</para>
      <para>  129.         Create a class containing two <emphasis role="bold">String</emphasis> objects, and make it <emphasis role="bold">Comparable</emphasis> so that the comparison only cares about the first <emphasis role="bold">String</emphasis>. Fill an array and an <emphasis role="bold">ArrayList </emphasis>with objects of your class, using the <emphasis role="bold">geography </emphasis>generator. Demonstrate that sorting works properly. Now make a <emphasis role="bold">Comparator</emphasis> that only cares about the second <emphasis role="bold">String</emphasis> and demonstrate that sorting works properly; also perform a binary search using your <emphasis role="bold">Comparator</emphasis>.</para>
      <para>  130.         Modify Exercise 13 so that an alphabetic sort is used.</para>
      <para>  131.         Use <emphasis role="bold">Arrays2.RandStringGenerator</emphasis> to fill a <emphasis role="bold">TreeSet</emphasis> but using alphabetic ordering. Print the <emphasis role="bold">TreeSet</emphasis> to verify the sort order.</para>
      <para>  132.         Create both an <emphasis role="bold">ArrayList</emphasis> and a <emphasis role="bold">LinkedList</emphasis>, and fill each using the <emphasis role="bold">Collections2.capitals</emphasis> generator. Print each list using an ordinary <emphasis role="bold">Iterator</emphasis>, then insert one list into the other using a <emphasis role="bold">ListIterator</emphasis>, inserting at every other location. Now perform the insertion starting at the end of the first list and moving backward.</para>
      <para>  133.         Write a method that uses an <emphasis role="bold">Iterator</emphasis> to step through a <emphasis role="bold">Collection</emphasis> and print the <emphasis role="bold">hashCode( )</emphasis> of each object in the container. Fill all the different types of <emphasis role="bold">Collection</emphasis>s with objects and apply your method to each container.</para>
      <para>  134.         Repair the problem in <emphasis role="bold">InfiniteRecursion.java</emphasis>.</para>
      <para>  135.         Create a class, then make an initialized array of objects of your class. Fill a <emphasis role="bold">List</emphasis> from your array. Create a subset of your <emphasis role="bold">List</emphasis> using <emphasis role="bold">subList( )</emphasis>, and then remove this subset from your <emphasis role="bold">List</emphasis> using <emphasis role="bold">removeAll( )</emphasis>.</para>
      <para><anchor xreflabel="" xml:id="B"/>  136.         Change Exercise 6 in Chapter 7 to use an <emphasis role="bold">ArrayList</emphasis> to hold the <emphasis role="bold">Rodent</emphasis>s and an <emphasis role="bold">Iterator</emphasis> to move through the sequence of <emphasis role="bold">Rodent</emphasis>s. Remember that an <emphasis role="bold">ArrayList</emphasis> holds only <emphasis role="bold">Object</emphasis>s so you must use a cast when accessing individual <emphasis role="bold">Rodent</emphasis>s.</para>
      <para>  137.         Following the <emphasis role="bold">Queue.java</emphasis> example, create a <emphasis role="bold">Deque</emphasis> class and test it.</para>
      <para>  138.         Use a <emphasis role="bold">TreeMap</emphasis> in <emphasis role="bold">Statistics.java</emphasis>. Now add code that tests the performance difference between <emphasis role="bold">HashMap</emphasis> and <emphasis role="bold">TreeMap</emphasis> in that program.</para>
      <para>  139.         Produce a <emphasis role="bold">Map</emphasis> and a <emphasis role="bold">Set </emphasis>containing all the countries that begin with �A.�</para>
      <para>  140.         Using <emphasis role="bold">Collections2.countries</emphasis>, fill a <emphasis role="bold">Set</emphasis> multiple times with the same data and verify that the <emphasis role="bold">Set</emphasis> ends up with only one of each instance. Try this with both kinds of <emphasis role="bold">Set</emphasis>.</para>
      <para>  141.         Starting with <emphasis role="bold">Statistics.java</emphasis>, create a program that runs the test repeatedly and looks to see if any one number tends to appear more than the others in the results.</para>
      <para>  142.         Rewrite <emphasis role="bold">Statistics.java</emphasis> using a <emphasis role="bold">HashSet</emphasis> of <emphasis role="bold">Counter</emphasis> objects (you�ll have to modify <emphasis role="bold">Counter</emphasis> so that it will work in the <emphasis role="bold">HashSet</emphasis>). Which approach seems better?</para>
      <para>  143.         Modify the class in Exercise 13 so that it will work with <emphasis role="bold">HashSet</emphasis>s and as a key in <emphasis role="bold">HashMap</emphasis>s.</para>
      <para>  144.         Using <emphasis role="bold">SlowMap.java</emphasis> for inspiration, create a <emphasis role="bold">SlowSet</emphasis>.</para>
      <para>  145.         Apply the tests in <emphasis role="bold">Map1.java</emphasis> to <emphasis role="bold">SlowMap</emphasis> to verify that it works. Fix anything in <emphasis role="bold">SlowMap </emphasis>that doesn�t work correctly.</para>
      <para>  146.         Implement the rest of the <emphasis role="bold">Map</emphasis> interface for <emphasis role="bold">SlowMap</emphasis>.</para>
      <para>  147.         Modify <emphasis role="bold">MapPerformance.java</emphasis> to include tests of <emphasis role="bold">SlowMap</emphasis>.</para>
      <para>  148.         Modify <emphasis role="bold">SlowMap</emphasis> so that instead of two <emphasis role="bold">ArrayList</emphasis>s, it holds a single <emphasis role="bold">ArrayList</emphasis> of <emphasis role="bold">MPair</emphasis> objects. Verify that the modified version works correctly. Using <emphasis role="bold">MapPerformance.java</emphasis>, test the speed of your new <emphasis role="bold">Map</emphasis>. Now change the <emphasis role="bold">put( )</emphasis> method so that it performs a <emphasis role="bold">sort( )</emphasis> after each pair is entered, and modify <emphasis role="bold">get( )</emphasis> to use <emphasis role="bold">Collections.binarySearch( )</emphasis> to look up the key. Compare the performance of the new version with the old ones.</para>
      <para>  149.         Add a <emphasis role="bold">char</emphasis> field to <emphasis role="bold">CountedString</emphasis> that is also initialized in the constructor, and modify the <emphasis role="bold">hashCode( )</emphasis> and <emphasis role="bold">equals( )</emphasis> methods to include the value of this <emphasis role="bold">char</emphasis>.</para>
      <para>  150.         Modify <emphasis role="bold">SimpleHashMap</emphasis> so that it reports collisions, and test this by adding the same data set twice so that you see collisions.</para>
      <para>  151.         Modify <emphasis role="bold">SimpleHashMap</emphasis> so that it reports the number of �probes� necessary when collisions occur. That is, how many calls to <emphasis role="bold">next( )</emphasis> must be made on the <emphasis role="bold">Iterator</emphasis>s that walk the <emphasis role="bold">LinkedList</emphasis>s looking for matches?</para>
      <para>  152.         Implement the <emphasis role="bold">clear( )</emphasis> and <emphasis role="bold">remove( )</emphasis> methods for <emphasis role="bold">SimpleHashMap</emphasis>.</para>
      <para>  153.         Implement the rest of the <emphasis role="bold">Map</emphasis> interface for <emphasis role="bold">SimpleHashMap</emphasis>.</para>
      <para>  154.         Add a <emphasis role="bold">private</emphasis><emphasis role="bold">rehash( )</emphasis> method to <emphasis role="bold">SimpleHashMap</emphasis> that is invoked when the load factor exceeds 0.75. During rehashing, double the number of buckets, then search for the first prime number greater than that to determine the new number of buckets.</para>
      <para>  155.         Following the example in <emphasis role="bold">SimpleHashMap.java</emphasis>, create and test a <emphasis role="bold">SimpleHashSet</emphasis>.</para>
      <para>  156.         Modify <emphasis role="bold">SimpleHashMap</emphasis> to use <emphasis role="bold">ArrayList</emphasis>s instead of <emphasis role="bold">LinkedList</emphasis>s. Modify <emphasis role="bold">MapPerformance.java</emphasis> to compare the performance of the two implementations.</para>
      <para>  157.         Using the HTML documentation for the JDK (downloadable from <emphasis role="italic">java.sun.com</emphasis>), look up the <emphasis role="bold">HashMap</emphasis> class. Create a <emphasis role="bold">HashMap</emphasis>, fill it with elements, and determine the load factor. Test the lookup speed with this map, then attempt to increase the speed by making a new <emphasis role="bold">HashMap</emphasis> with a larger initial capacity and copying the old map into the new one, running your lookup speed test again on the new map.</para>
      <para>  158.         In Chapter 8, locate the <emphasis role="bold">GreenhouseControls.java</emphasis> example, which consists of three files. In <emphasis role="bold">Controller.java</emphasis>, the class <emphasis role="bold">EventSet</emphasis> is just a container. Change the code to use a <emphasis role="bold">LinkedList</emphasis> instead of an <emphasis role="bold">EventSet</emphasis>. This will require more than just replacing <emphasis role="bold">EventSet</emphasis> with <emphasis role="bold">LinkedList</emphasis>; you�ll also need to use an <emphasis role="bold">Iterator</emphasis> to cycle through the set of events.</para>
      <para>  159.         (Challenging). Write your own hashed map class, customized for a particular key type: <emphasis role="bold">String </emphasis>for this example. Do not inherit it from <emphasis role="bold">Map</emphasis>. Instead, duplicate the methods so that the <emphasis role="bold">put( )</emphasis> and <emphasis role="bold">get( )</emphasis> methods specifically take <emphasis role="bold">String</emphasis> objects, not <emphasis role="bold">Object</emphasis>s, as keys. Everything that involves keys should not use generic types, but instead work with <emphasis role="bold">String</emphasis>s, to avoid the cost of upcasting and downcasting. Your goal is to make the fastest possible custom implementation. Modify <emphasis role="bold">MapPerformance.java</emphasis> to test your implementation vs. a <emphasis role="bold">HashMap</emphasis>.</para>
      <para>  160.         (Challenging). Find the source code for <emphasis role="bold">List</emphasis> in the Java source code library that comes with all Java distributions. Copy this code and make a special version called <emphasis role="bold">intList</emphasis> that holds only <emphasis role="bold">int</emphasis>s. Consider what it would take to make a special version of <emphasis role="bold">List</emphasis> for all the primitive types. Now consider what happens if you want to make a linked list class that works with all the primitive types. If parameterized types are ever implemented in Java, they will provide a way to do this work for you automatically (as well as many other benefits).</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc375545361"/><anchor xreflabel="" xml:id="Chapter_9"/><anchor xreflabel="" xml:id="_Toc481064713"/><anchor xreflabel="10: Error Handling 
with Exceptions" xml:id="_Toc477690730"/>10: Error Handling   with Exceptions</title>
    <para><anchor xreflabel="The basic philosophy of
Java is that �badly formed code will not be run.�" xml:id="OLE_LINK1"/>The basic philosophy of Java is that �badly formed code will not be run.�</para>
    <para>The ideal time to catch an error is at compile-time, before you even try to run the program. However, not all errors can be detected at compile-time. The rest of the problems must be handled at run-time, through some formality that allows the originator of the error to pass appropriate information to a recipient who will know how to handle the difficulty properly.</para>
    <para>In C and other earlier languages, there could be several of these formalities, and they were generally established by convention and not as part of the programming language. Typically, you returned a special value or set a flag, and the recipient was supposed to look at the value or the flag and determine that something was amiss. However, as the years passed, it was discovered that programmers who use a library tend to think of themselves as invincible�as in, �Yes, errors might happen to others, but not in <emphasis role="italic">my</emphasis> code.� So, not too surprisingly, they wouldn�t check for the error conditions (and sometimes the error conditions were too silly to check for<anchor xreflabel="[51]" xml:id="_ftnref51"/>[51]). If you <emphasis role="italic">were</emphasis> thorough enough to check for an error every time you called a method, your code could turn into an unreadable nightmare. Because programmers could still coax systems out of these languages they were resistant to admitting the truth: This approach to handling errors was a major limitation to creating large, robust, maintainable programs.</para>
    <para>The solution is to take the casual nature out of error handling and to enforce formality. This actually has a long history, since implementations of <emphasis role="italic">exception handling</emphasis> go back to operating systems in the 1960s, and even to BASIC�s �<emphasis role="bold">on error goto</emphasis>.� But C++ exception handling was based on Ada, and Java�s is based primarily on C++ (although it looks even more like Object Pascal).</para>
    <para>The word �exception� is meant in the sense of �I take exception to that.� At the point where the problem occurs you might not know what to do with it, but you do know that you can�t just continue on merrily; you must stop and somebody, somewhere, must figure out what to do. But you don�t have enough information in the current context to fix the problem. So you hand the problem out to a higher context where someone is qualified to make the proper decision (much like a chain of command).</para>
    <para>The other rather significant benefit of exceptions is that they clean up error handling code. Instead of checking for a particular error and dealing with it at multiple places in your program, you no longer need to check at the point of the method call (since the exception will guarantee that someone catches it). And, you need to handle the problem in only one place, the so-called <emphasis role="italic">exception handler</emphasis>. This saves you code, and it separates the code that describes what you want to do from the code that is executed when things go awry. In general, reading, writing, and debugging code becomes much clearer with exceptions than when using the old way of error handling.</para>
    <para>Because exception handling is enforced by the Java compiler, there are only so many examples that can be written in this book without learning about exception handling. This chapter introduces you to the code you need to write to properly handle exceptions, and the way you can generate your own exceptions if one of your methods gets into trouble.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064714"/><anchor xreflabel="Basic
exceptions" xml:id="_Toc375545362"/>Basic exceptions</title>
      <para>An <emphasis role="italic">exceptional condition</emphasis> is a problem that prevents the continuation of the method or scope that you�re in. It�s important to distinguish an exceptional condition from a normal problem, in which you have enough information in the current context to somehow cope with the difficulty. With an exceptional condition, you cannot continue processing because you don�t have the information necessary to deal with the problem <emphasis role="italic">in the current context</emphasis>. All you can do is jump out of the current context and relegate that problem to a higher context. This is what happens when you throw an exception.</para>
      <para>A simple example is a divide. If you�re about to divide by zero, it�s worth checking to make sure you don�t go ahead and perform the divide. But what does it mean that the denominator is zero? Maybe you know, in the context of the problem you�re trying to solve in that particular method, how to deal with a zero denominator. But if it�s an unexpected value, you can�t deal with it and so must throw an exception rather than continuing along that path.</para>
      <para>When you throw an exception, several things happen. First, the exception object is created in the same way that any Java object is created: on the heap, with <emphasis role="bold">new</emphasis>. Then the current path of execution (the one you couldn�t continue) is stopped and the reference for the exception object is ejected from the current context. At this point the exception handling mechanism takes over and begins to look for an appropriate place to continue executing the program. This appropriate place is the <emphasis role="italic">exception handler,</emphasis> whose job is to recover from the problem so the program can either try another tack or just continue.</para>
      <para>As a simple example of throwing an exception, consider an object reference called <emphasis role="bold">t</emphasis>. It�s possible that you might be passed a reference that hasn�t been initialized, so you might want to check before trying to call a method using that object reference. You can send information about the error into a larger context by creating an object representing your information and �throwing� it out of your current context. This is called <emphasis role="italic">throwing an exception.</emphasis> Here�s what it looks like:</para>
      <para>if(t == null)</para>
      <para>� throw new NullPointerException();</para>
      <para> </para>
      <para>This throws the exception, which allows you�in the current context�to abdicate responsibility for thinking about the issue further. It�s just magically handled somewhere else. Precisely <emphasis role="italic">where </emphasis>will be shown shortly.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064715"/><anchor xreflabel="Exception
arguments" xml:id="_Toc375545363"/>Exception arguments</title>
        <para>Like any object in Java, you always create exceptions on the heap using <emphasis role="bold">new</emphasis>, which allocates storage and calls a constructor. There are two constructors in all standard exceptions: the first is the default constructor, and the second takes a string argument so you can place pertinent information in the exception:</para>
        <para>if(t == null)</para>
        <para>� throw new NullPointerException(&quot;t = null&quot;);</para>
        <para> </para>
        <para>This string can later be extracted using various methods, as will be shown shortly.</para>
        <para>The keyword <emphasis role="bold">throw</emphasis> causes a number of relatively magical things to happen. Typically, you�ll first use <emphasis role="bold">new</emphasis> to create<emphasis role="bold"/>an object that represents the error condition. You give the resulting reference to <emphasis role="bold">throw</emphasis>. The object is, in effect, �returned� from the method, even though that object type isn�t normally what the method is designed to return. A simplistic way to think about exception handling is as an alternate return mechanism, although you get into trouble if you take that analogy too far. You can also exit from ordinary scopes by throwing an exception. But a value is returned, and the method or scope exits.</para>
        <para>Any similarity to an ordinary return from a method ends here, because <emphasis role="italic">where</emphasis> you return is someplace completely different from where you return for a normal method call. (You end up in an appropriate exception handler that might be miles away�many levels lower on the call stack�from where the exception was thrown.)</para>
        <para>In addition, you can throw any type of <emphasis role="bold">Throwable</emphasis> object that you want. Typically, you�ll throw a different class of exception for each different type of error. The information about the error is represented both inside the exception object and implicitly in the type of exception object chosen, so someone in the bigger context can figure out what to do with your exception. (Often, the only information is the type of exception object, and nothing meaningful is stored within the exception object.)</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064716"/><anchor xreflabel="" xml:id="_Toc375545364"/><anchor xreflabel="" xml:id="_Toc312374113"/><anchor xreflabel="" xml:id="_Toc305628770"/><anchor xreflabel="Catching an exception" xml:id="_Toc305593298"/>Catching an exception</title>
      <para>If a method throws an exception, it must assume that exception is �caught� and dealt with. One of the advantages of Java exception handling is that it allows you to concentrate on the problem you�re trying to solve in one place, and then deal with the errors from that code in another place.</para>
      <para>To see how an exception is caught, you must first understand the concept of a <emphasis role="italic">guarded region,</emphasis> which is a section of code that might produce exceptions, and which is followed by the code to handle those exceptions.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064717"/><anchor xreflabel="" xml:id="_Toc375545365"/><anchor xreflabel="The try block" xml:id="_Toc312374114"/>The <emphasis role="bold">try</emphasis> block</title>
        <para>If you�re inside a method and you throw an exception (or another method you call within this method throws an exception), that method will exit in the process of throwing. If you don�t want a <emphasis role="bold">throw </emphasis>to exit the method, you can set up a special block within that method to capture the exception. This is called the <emphasis role="italic">try</emphasis><emphasis role="italic">block</emphasis>�because you �try� your various method calls there. The try block is an ordinary scope, preceded by the keyword <emphasis role="bold">try</emphasis>:</para>
        <para>try {</para>
        <para>� // Code that might generate exceptions</para>
        <para>}</para>
        <para> </para>
        <para>If you were checking for errors carefully in a programming language that didn�t support exception handling, you�d have to surround every method call with setup and error testing code, even if you call the same method several times. With exception handling, you put everything in a try block and capture all the exceptions in one place. This means your code is a lot easier to write and easier to read because the goal of the code is not confused with the error checking.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064718"/><anchor xreflabel="" xml:id="_Toc375545366"/><anchor xreflabel="Exception handlers" xml:id="_Toc312374115"/>Exception handlers</title>
        <para>Of course, the thrown exception must end up someplace. This �place� is the <emphasis role="italic">exception handler</emphasis><emphasis role="italic">,</emphasis> and there�s one for every exception type you want to catch. Exception handlers immediately follow the try block and are denoted by the keyword <emphasis role="bold">catch</emphasis>:</para>
        <para>try {</para>
        <para>� // Code that might generate exceptions</para>
        <para>} catch(Type1 id1) {</para>
        <para>� // Handle exceptions of Type1</para>
        <para>} catch(Type2 id2) {</para>
        <para>� // Handle exceptions of Type2</para>
        <para>} catch(Type3 id3) {</para>
        <para>� // Handle exceptions of Type3</para>
        <para>}</para>
        <para> </para>
        <para>// etc...</para>
        <para> </para>
        <para>Each catch clause (exception handler) is like a little method that takes one and only one argument of a particular type. The identifier (<emphasis role="bold">id1</emphasis>, <emphasis role="bold">id2</emphasis>, and so on) can be used inside the handler, just like a method argument. Sometimes you never use the identifier because the type of the exception gives you enough information to deal with the exception, but the identifier must still be there.</para>
        <para>The handlers must appear directly after the try block. If an exception is thrown, the exception handling mechanism goes hunting for the first handler with an argument that matches the type of the exception. Then it enters that catch clause, and the exception is considered handled. The search for handlers stops once the catch clause is finished. Only the matching catch clause executes; it�s not like a <emphasis role="bold">switch</emphasis> statement in which you need a <emphasis role="bold">break</emphasis> after each <emphasis role="bold">case</emphasis> to prevent the remaining ones from executing.</para>
        <para>Note that, within the try block, a number of different method calls might generate the same exception, but you need only one handler.</para>
        <section>
          <title>Termination vs. resumption</title>
          <para>There are two basic models in exception handling theory. In <emphasis role="italic">termination</emphasis> (which is what Java and C++ support), you assume the error is so critical that there�s no way to get back to where the exception occurred. Whoever threw the exception decided that there was no way to salvage the situation, and they don�t <emphasis role="italic">want</emphasis> to come back.</para>
          <para>The alternative is called <emphasis role="italic">resumption</emphasis>. It means that the exception handler is expected to do something to rectify the situation, and then the faulting method is retried, presuming success the second time. If you want resumption, it means you still hope to continue execution after the exception is handled. In this case, your exception is more like a method call�which is how you should set up situations in Java in which you want resumption-like behavior. (That is, don�t throw an exception; call a method that fixes the problem.) Alternatively, place your <emphasis role="bold">try</emphasis> block inside a <emphasis role="bold">while</emphasis> loop that keeps reentering the <emphasis role="bold">try</emphasis> block until the result is satisfactory.</para>
          <para>Historically, programmers using operating systems that supported resumptive exception handling eventually ended up using termination-like code and skipping resumption. So although resumption sounds attractive at first, it isn�t quite so useful in practice. The dominant reason is probably the <emphasis role="italic">coupling </emphasis>that results: your handler must often be aware of where the exception is thrown from and contain nongeneric code specific to the throwing location. This makes the code difficult to write and maintain, especially for large systems where the exception can be generated from many points.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064719"/><anchor xreflabel="Creating
your own exceptions" xml:id="_Toc375545373"/>Creating your own exceptions</title>
      <para>You�re not stuck using the existing Java exceptions. This is important because you�ll often need to create your own exceptions to denote a special error that your library is capable of creating, but which was not foreseen when the Java exception hierarchy was created.</para>
      <para>To create your own exception class, you�re forced to inherit from an existing type of exception, preferably one that is close in meaning to your new exception (this is often not possible, however). The most trivial way to create a new type of exception is just to let the compiler create the default constructor for you, so it requires almost no code at all:</para>
      <para>//: c10:SimpleExceptionDemo.java</para>
      <para>// Inheriting your own exceptions.</para>
      <para>class SimpleException extends Exception {} </para>
      <para> </para>
      <para>public class SimpleExceptionDemo {</para>
      <para>� public void f() throws SimpleException {</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;Throwing SimpleException from f()&quot;);</para>
      <para>��� throw new SimpleException ();</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� SimpleExceptionDemo sed = </para>
      <para>����� new SimpleExceptionDemo();</para>
      <para>��� try {</para>
      <para>����� sed.f();</para>
      <para>��� } catch(SimpleException e) {</para>
      <para>����� System.err.println(&quot;Caught it!&quot;);</para>
      <para>��� }</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>When the compiler creates the default constructor, it which automatically (and invisibly) calls the base-class default constructor. Of course, in this case you don�t get a <emphasis role="bold">SimpleException(String)</emphasis> constructor, but in practice that isn�t used much. As you�ll see, the most important thing about an exception is the class name, so most of the time an exception like the one shown above is satisfactory.</para>
      <para>Here, the result is printed to the console <emphasis role="italic">standard error</emphasis> stream by writing to <emphasis role="bold">System.err</emphasis>. This is usually a better place to send error information than <emphasis role="bold">System.out</emphasis>, which may be redirected. If you send output to <emphasis role="bold">System.err</emphasis> it will not be redirected along with <emphasis role="bold">System.out</emphasis> so the user is more likely to notice it.</para>
      <para>Creating an exception class that also has a constructor that takes a <emphasis role="bold">String</emphasis> is also quite simple:</para>
      <para>//: c10:FullConstructors.java</para>
      <para>// Inheriting your own exceptions.</para>
      <para> </para>
      <para>class MyException extends Exception {</para>
      <para>� public MyException() {}</para>
      <para>� public MyException(String msg) {</para>
      <para>��� super(msg);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class FullConstructors {</para>
      <para>� public static void f() throws MyException {</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;Throwing MyException from f()&quot;);</para>
      <para>��� throw new MyException();</para>
      <para>� }</para>
      <para>� public static void g() throws MyException {</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;Throwing MyException from g()&quot;);</para>
      <para>��� throw new MyException(&quot;Originated in g()&quot;);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� try {</para>
      <para>����� f();</para>
      <para>��� } catch(MyException e) {</para>
      <para>����� e.printStackTrace(System.err);</para>
      <para>��� }</para>
      <para>��� try {</para>
      <para>����� g();</para>
      <para>��� } catch(MyException e) {</para>
      <para>����� e.printStackTrace(System.err);</para>
      <para>��� }</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The added code is small�the addition of two constructors that define the way <emphasis role="bold">MyException</emphasis> is created. In the second constructor, the base-class constructor with a <emphasis role="bold">String</emphasis> argument is explicitly invoked by using the <emphasis role="bold">super</emphasis> keyword.</para>
      <para>The stack trace information is sent to <emphasis role="bold">System.err</emphasis> so that it�s more likely it will be noticed in the event that <emphasis role="bold">System.out</emphasis> has been redirected.</para>
      <para>The output of the program is:</para>
      <para>Throwing MyException from f()</para>
      <para>MyException</para>
      <para>������� at FullConstructors.f(FullConstructors.java:16)</para>
      <para>������� at FullConstructors.main(FullConstructors.java:24)</para>
      <para>Throwing MyException from g()</para>
      <para>MyException: Originated in g()</para>
      <para>������� at FullConstructors.g(FullConstructors.java:20)</para>
      <para>������� at FullConstructors.main(FullConstructors.java:29)</para>
      <para> </para>
      <para>You can see the absence of the detail message in the <emphasis role="bold">MyException</emphasis> thrown from <emphasis role="bold">f( )</emphasis>.</para>
      <para>The process of creating your own exceptions can be taken further. You can add extra constructors and members:</para>
      <para>//: c10:ExtraFeatures.java</para>
      <para>// Further embellishment of exception classes.</para>
      <para> </para>
      <para>class MyException2 extends Exception {</para>
      <para>� public MyException2() {}</para>
      <para>� public MyException2(String msg) {</para>
      <para>��� super(msg);</para>
      <para>� }</para>
      <para>� public MyException2(String msg, int x) {</para>
      <para>��� super(msg);</para>
      <para>��� i = x;</para>
      <para>� }</para>
      <para>� public int val() { return i; }</para>
      <para>� private int i;</para>
      <para>}</para>
      <para> </para>
      <para>public class ExtraFeatures {</para>
      <para>� public static void f() throws MyException2 {</para>
      <para>�� �System.out.println(</para>
      <para>����� &quot;Throwing MyException2 from f()&quot;);</para>
      <para>��� throw new MyException2();</para>
      <para>� }</para>
      <para>� public static void g() throws MyException2 {</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;Throwing MyException2 from g()&quot;);</para>
      <para>��� throw new MyException2(&quot;Originated in g()&quot;);</para>
      <para>� }</para>
      <para>� public static void h() throws MyException2 {</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;Throwing MyException2 from h()&quot;);</para>
      <para>��� throw new MyException2(</para>
      <para>����� &quot;Originated in h()&quot;, 47);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� try {</para>
      <para>����� f();</para>
      <para>��� } catch(MyException2 e) {</para>
      <para>����� e.printStackTrace(System.err);</para>
      <para>��� }</para>
      <para>��� try {</para>
      <para>����� g();</para>
      <para>��� } catch(MyException2 e) {</para>
      <para>����� e.printStackTrace(System.err);</para>
      <para>��� }</para>
      <para>��� try {</para>
      <para>����� h();</para>
      <para>��� } catch(MyException2 e) {</para>
      <para>����� e.printStackTrace(System.err);</para>
      <para>����� System.err.println(&quot;e.val() = &quot; + e.val());</para>
      <para>��� }</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>A data member <emphasis role="bold">i</emphasis> has been added, along with a method that reads that value and an additional constructor that sets it. The output is:</para>
      <para>Throwing MyException2 from f()</para>
      <para>MyException2</para>
      <para>������� at ExtraFeatures.f(ExtraFeatures.java:22)</para>
      <para>������� at ExtraFeatures.main(ExtraFeatures.java:34)</para>
      <para>Throwing MyException2 from g()</para>
      <para>MyException2: Originated in g()</para>
      <para>������� at ExtraFeatures.g(ExtraFeatures.java:26)</para>
      <para>������� at ExtraFeatures.main(ExtraFeatures.java:39)</para>
      <para>Throwing MyException2 from h()</para>
      <para>MyException2: Originated in h()</para>
      <para>������� at ExtraFeatures.h(ExtraFeatures.java:30)</para>
      <para>������� at ExtraFeatures.main(ExtraFeatures.java:44)</para>
      <para>e.val() = 47</para>
      <para> </para>
      <para>Since an exception is just another kind of object, you can continue this process of embellishing the power of your exception classes. Keep in mind, however, that all this dressing-up might be lost on the client programmers using your packages, since they might simply look for the exception to be thrown and nothing more. (That�s the way most of the Java library exceptions are used.) </para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064720"/><anchor xreflabel="" xml:id="_Toc375545367"/><anchor xreflabel="The exception specification" xml:id="_Toc312374116"/>The exception specification</title>
      <para>In Java, you�re required to inform the client programmer, who calls your method, of the exceptions that might be thrown from your method. This is civilized, because the caller can know exactly what code to write to catch all potential exceptions. Of course, if source code is available, the client programmer could hunt through and look for <emphasis role="bold">throw</emphasis> statements, but often a library doesn�t come with sources. To prevent this from being a problem, Java provides syntax (and <emphasis role="italic">forces </emphasis>you to use that syntax) to allow you to politely tell the client programmer what exceptions this method throws, so the client programmer can handle them. This is the <emphasis role="italic">exception specification,</emphasis> and it�s part of the method declaration, appearing after the argument list.</para>
      <para>The exception specification uses an additional keyword, <emphasis role="bold">throws</emphasis>, followed by a list of all the potential exception types. So your method definition might look like this:</para>
      <para>void f() throws TooBig, TooSmall, DivZero { //... </para>
      <para> </para>
      <para>If you say</para>
      <para>void f() { // ...</para>
      <para> </para>
      <para>it means that no exceptions are thrown from the method. (<emphasis role="italic">Except </emphasis>for the exceptions of type <emphasis role="bold">RuntimeException</emphasis>, which can reasonably be thrown anywhere�this will be described later.)</para>
      <para>You can�t lie about an exception specification�if your method causes exceptions and doesn�t handle them, the compiler will detect this and tell you that you must either handle the exception or indicate with an exception specification that it may be thrown from your method. By enforcing exception specifications from top to bottom, Java guarantees that exception correctness can be ensured <emphasis role="italic">at compile-time</emphasis><anchor xreflabel="[52]" xml:id="_ftnref52"/>[52].</para>
      <para>There is one place you can lie: you can claim to throw an exception that you really don�t. The compiler takes your word for it, and forces the users of your method to treat it as if it really does throw that exception. This has the beneficial effect of being a placeholder for that exception, so you can actually start throwing the exception later without requiring changes to existing code. It�s also important for creating <emphasis role="bold">abstract</emphasis> base classes and <emphasis role="bold">interface</emphasis>s whose derived classes or implementations may need to throw exceptions.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064721"/><anchor xreflabel="" xml:id="_Toc375545368"/><anchor xreflabel="Catching any exception" xml:id="_Toc312374118"/>Catching any exception</title>
        <para>It is possible to create a handler that catches any type of exception. You do this by catching the base-class exception type <emphasis role="bold">Exception</emphasis> (there are other types of base exceptions, but <emphasis role="bold">Exception</emphasis> is the base that�s pertinent to virtually all programming activities):</para>
        <para>catch(Exception e) {</para>
        <para>� System.err.println(&quot;Caught an exception&quot;);</para>
        <para>}</para>
        <para> </para>
        <para>This will catch any exception, so if you use it you�ll want to put it at the <emphasis role="italic">end</emphasis> of your list of handlers to avoid preempting any exception handlers that might otherwise follow it.</para>
        <para>Since the <emphasis role="bold">Exception</emphasis> class is the base of all the exception classes that are important to the programmer, you don�t get much specific information about the exception, but you can call the methods that come from <emphasis role="italic">its</emphasis> base type <emphasis role="bold">Throwable</emphasis>:</para>
        <para><emphasis role="bold">String getMessage( )  String </emphasis><link xl:href="../../../../My%20Documents/ProgToolsjdk1.3docsapijavalangThrowable.html#getLocalizedMessage()"><emphasis role="bold">getLocalizedMessage</emphasis></link><emphasis role="bold">( )</emphasis><emphasis role="bold"> </emphasis>Gets the detail message, or a message adjusted for this particular locale.</para>
        <para><emphasis role="bold">String toString( ) </emphasis>Returns a short description of the Throwable, including the detail message if there is one.</para>
        <para><emphasis role="bold">void </emphasis><emphasis role="bold">printStackTrace( )   void printStackTrace(PrintStream)  void </emphasis><link xl:href="../../../../My%20Documents/ProgToolsjdk1.3docsapijavalangThrowable.html#printStackTrace(java.io.PrintWriter)"><emphasis role="bold">printStackTrace</emphasis></link><emphasis role="bold">(</emphasis><link xl:href="../../../../My%20Documents/ProgToolsjdk1.3docsapijavaioPrintWriter.html"><emphasis role="bold">PrintWriter</emphasis></link><emphasis role="bold">)  </emphasis>Prints the Throwable and the Throwable�s call stack trace. The call stack shows the sequence of method calls that brought you to the point at which the exception was thrown. The first version prints to standard error, the second and third prints to a stream of your choice (in Chapter 11, you�ll understand why there are two types of streams).</para>
        <para><emphasis role="bold">Throwable </emphasis><link xl:href="../../../../My%20Documents/ProgToolsjdk1.3docsapijavalangThrowable.html#fillInStackTrace()"><emphasis role="bold">fillInStackTrace</emphasis></link><emphasis role="bold">( )</emphasis></para>
        <para> Records information within this <emphasis role="bold">Throwable </emphasis>object about the current state of the stack frames. Useful when an application is rethrowing an error or exception (more about this shortly).</para>
        <para>In addition, you get some other methods from <emphasis role="bold">Throwable</emphasis>�s base type <emphasis role="bold">Object</emphasis> (everybody�s base type). The one that might come in handy for exceptions is <emphasis role="bold">getClass( )</emphasis>, which returns an object representing the class of this object. You can in turn query this <emphasis role="bold">Class</emphasis> object for its name with <emphasis role="bold">getName( )</emphasis> or <emphasis role="bold">toString( )</emphasis>. You can also do more sophisticated things with <emphasis role="bold">Class</emphasis> objects that aren�t necessary in exception handling. <emphasis role="bold">Class</emphasis> objects will be studied later in this book.</para>
        <para>Here�s an example that shows the use of the basic <emphasis role="bold">Exception</emphasis> methods:</para>
        <para>//: c10:ExceptionMethods.java</para>
        <para>// Demonstrating the Exception Methods.</para>
        <para> </para>
        <para>public class ExceptionMethods {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� try {</para>
        <para>����� throw new Exception(&quot;Here&apos;s my Exception&quot;);</para>
        <para>��� } catch(Exception e) {</para>
        <para>����� System.err.println(&quot;Caught Exception&quot;);</para>
        <para>����� System.err.println(</para>
        <para>������� &quot;e.getMessage(): &quot; + e.getMessage());</para>
        <para>����� System.err.println(</para>
        <para>������� &quot;e.getLocalizedMessage(): &quot; +</para>
        <para>�������� e.getLocalizedMessage());</para>
        <para>����� System.err.println(&quot;e.toString(): &quot; + e);</para>
        <para>����� System.err.println(&quot;e.printStackTrace():&quot;);</para>
        <para>����� e.printStackTrace(System.err);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The output for this program is:</para>
        <para>Caught Exception</para>
        <para>e.getMessage(): Here&apos;s my Exception</para>
        <para>e.getLocalizedMessage(): Here&apos;s my Exception</para>
        <para>e.toString(): java.lang.Exception: </para>
        <para>�� Here&apos;s my Exception</para>
        <para>e.printStackTrace():</para>
        <para>java.lang.Exception: Here&apos;s my Exception</para>
        <para>�at ExceptionMethods.main(ExceptionMethods.java:7)</para>
        <para>java.lang.Exception: </para>
        <para>�� Here&apos;s my Exception</para>
        <para>�at ExceptionMethods.main(ExceptionMethods.java:7)</para>
        <para> </para>
        <para>You can see that the methods provide successively more information�each is effectively a superset of the previous one.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064722"/><anchor xreflabel="" xml:id="_Toc375545369"/><anchor xreflabel="Rethrowing an exception" xml:id="_Toc312374119"/>Rethrowing an exception</title>
        <para>Sometimes you�ll want to rethrow the exception that you just caught, particularly when you use <emphasis role="bold">Exception</emphasis> to catch any exception. Since you already have the reference to the current exception, you can simply rethrow that reference:</para>
        <para>catch(Exception e) {</para>
        <para>� System.err.println(&quot;An exception was thrown&quot;);</para>
        <para>� throw e;</para>
        <para>}</para>
        <para> </para>
        <para>Rethrowing an exception causes the exception to go to the exception handlers in the next-higher context. Any further <emphasis role="bold">catch</emphasis> clauses for the same <emphasis role="bold">try</emphasis> block are still ignored. In addition, everything about the exception object is preserved, so the handler at the higher context that catches the specific exception type can extract all the information from that object.</para>
        <para>If you simply rethrow the current exception, the information that you print about that exception in <emphasis role="bold">printStackTrace( ) </emphasis>will pertain to the exception�s origin, not the place where you rethrow it. If you want to install new stack trace information, you can do so by calling <emphasis role="bold">fillInStackTrace( )</emphasis>, which returns an exception object that it creates by stuffing the current stack information into the old exception object. Here�s what it looks like:</para>
        <para>//: c10:Rethrowing.java</para>
        <para>// Demonstrating fillInStackTrace()</para>
        <para> </para>
        <para>public class Rethrowing {</para>
        <para>� public static void f() throws Exception {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;originating the exception in f()&quot;);</para>
        <para>��� throw new Exception(&quot;thrown from f()&quot;);</para>
        <para>� }</para>
        <para>� public static void g() throws Throwable {</para>
        <para>��� try {</para>
        <para>����� f();</para>
        <para>��� } catch(Exception e) {</para>
        <para>����� System.err.println(</para>
        <para>������� &quot;Inside g(), e.printStackTrace()&quot;);</para>
        <para>����� e.printStackTrace(System.err);</para>
        <para>����� throw e; // 17</para>
        <para>����� // throw e.fillInStackTrace(); // 18</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void</para>
        <para>� main(String[] args) throws Throwable {</para>
        <para>��� try {</para>
        <para>����� g();</para>
        <para>��� } catch(Exception e) {</para>
        <para>����� System.err.println(</para>
        <para>�� �����&quot;Caught in main, e.printStackTrace()&quot;);</para>
        <para>����� e.printStackTrace(System.err);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The important line numbers are marked as comments. With line 17 uncommented (as shown), the output is:</para>
        <para>originating the exception in f()</para>
        <para>Inside g(), e.printStackTrace()</para>
        <para>java.lang.Exception: thrown from f()</para>
        <para>������� at Rethrowing.f(Rethrowing.java:8)</para>
        <para>������� at Rethrowing.g(Rethrowing.java:12)</para>
        <para>������� at Rethrowing.main(Rethrowing.java:24)</para>
        <para>Caught in main, e.printStackTrace()</para>
        <para>java.lang.Exception: thrown from f()</para>
        <para>������� at Rethrowing.f(Rethrowing.java:8)</para>
        <para>������� at Rethrowing.g(Rethrowing.java:12)</para>
        <para>������� at Rethrowing.main(Rethrowing.java:24)</para>
        <para> </para>
        <para>So the exception stack trace always remembers its true point of origin, no matter how many times it gets rethrown.</para>
        <para>With line 17 commented and line 18 uncommented, <emphasis role="bold">fillInStackTrace( )</emphasis> is used instead, and the result is:</para>
        <para>originating the exception in f()</para>
        <para>Inside g(), e.printStackTrace()</para>
        <para>java.lang.Exception: thrown from f()</para>
        <para>������� at Rethrowing.f(Rethrowing.java:8)</para>
        <para>������� at Rethrowing.g(Rethrowing.java:12)</para>
        <para>������� at Rethrowing.main(Rethrowing.java:24)</para>
        <para>Caught in main, e.printStackTrace()</para>
        <para>java.lang.Exception: thrown from f()</para>
        <para>������� at Rethrowing.g(Rethrowing.java:18)</para>
        <para>������� at Rethrowing.main(Rethrowing.java:24)</para>
        <para> </para>
        <para>Because of <emphasis role="bold">fillInStackTrace( )</emphasis>, line 18 becomes the new point of origin of the exception.</para>
        <para>The class <emphasis role="bold">Throwable</emphasis> must appear in the exception specification for <emphasis role="bold">g( )</emphasis> and <emphasis role="bold">main( )</emphasis> because <emphasis role="bold">fillInStackTrace( )</emphasis> produces a reference to a <emphasis role="bold">Throwable</emphasis> object. Since <emphasis role="bold">Throwable</emphasis> is a base class of <emphasis role="bold">Exception</emphasis>, it�s possible to get an object that�s a <emphasis role="bold">Throwable</emphasis> but <emphasis role="italic">not</emphasis> an <emphasis role="bold">Exception</emphasis>, so the handler for <emphasis role="bold">Exception</emphasis> in <emphasis role="bold">main( ) </emphasis>might miss it. To make sure everything is in order, the compiler forces an exception specification for <emphasis role="bold">Throwable</emphasis>. For example, the exception in the following program is <emphasis role="italic">not</emphasis> caught in <emphasis role="bold">main( )</emphasis>:</para>
        <para>//: c10:ThrowOut.java</para>
        <para>public class ThrowOut {</para>
        <para>� public static void</para>
        <para>� main(String[] args) throws Throwable {</para>
        <para>��� try {</para>
        <para>����� throw new Throwable(); </para>
        <para>��� } catch(Exception e) {</para>
        <para>����� System.err.println(&quot;Caught in main()&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>It�s also possible to rethrow a different exception from the one you caught. If you do this, you get a similar effect as when you use <emphasis role="bold">fillInStackTrace( )</emphasis>�the information about the original site of the exception is lost, and what you�re left with is the information pertaining to the new <emphasis role="bold">throw</emphasis>:</para>
        <para>//: c10:RethrowNew.java</para>
        <para>// Rethrow a different object </para>
        <para>// from the one that was caught.</para>
        <para> </para>
        <para>class OneException extends Exception {</para>
        <para>� public OneException(String s) { super(s); }</para>
        <para>}</para>
        <para> </para>
        <para>class TwoException extends Exception {</para>
        <para>� public TwoException(String s) { super(s); }</para>
        <para>}</para>
        <para> </para>
        <para>public class RethrowNew {</para>
        <para>� public static void f() throws OneException {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;originating the exception in f()&quot;);</para>
        <para>��� throw new OneException(&quot;thrown from f()&quot;);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws TwoException {</para>
        <para>��� try {</para>
        <para>����� f();</para>
        <para>��� } catch(OneException e) {</para>
        <para>����� System.err.println(</para>
        <para>������� &quot;Caught in main, e.printStackTrace()&quot;);</para>
        <para>����� e.printStackTrace(System.err);</para>
        <para>����� throw new TwoException(&quot;from main()&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The output is:</para>
        <para>originating the exception in f()</para>
        <para>Caught in main, e.printStackTrace()</para>
        <para>OneException: thrown from f()</para>
        <para>������� at RethrowNew.f(RethrowNew.java:17)</para>
        <para>������� at RethrowNew.main(RethrowNew.java:22)</para>
        <para>Exception in thread &quot;main&quot; TwoException: from main()</para>
        <para>������� at RethrowNew.main(RethrowNew.java:27)</para>
        <para> </para>
        <para>The final exception knows only that it came from <emphasis role="bold">main( )</emphasis>, and not from <emphasis role="bold">f( )</emphasis>. </para>
        <para>You never have to worry about cleaning up the previous exception, or any exceptions for that matter. They�re all heap-based objects created with <emphasis role="bold">new</emphasis>, so the garbage collector automatically cleans them all up.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064723"/><anchor xreflabel="Standard
Java exceptions" xml:id="_Toc375545370"/>Standard Java exceptions</title>
      <para>The Java class <emphasis role="bold">Throwable</emphasis> describes anything that can be thrown as an exception. There are two general types of <emphasis role="bold">Throwable</emphasis> objects (�types of� = �inherited from�). <emphasis role="bold">Error</emphasis> represents compile-time and system errors that you don�t worry about catching (except in special cases). <emphasis role="bold">Exception</emphasis> is the basic type that can be thrown from any of the standard Java library class methods and from your methods and run-time accidents. So the Java programmer�s base type of interest is <emphasis role="bold">Exception</emphasis>.</para>
      <para>The best way to get an overview of the exceptions is to browse the HTML Java documentation that you can download from <emphasis role="italic">java.sun.com.</emphasis> It�s worth doing this once just to get a feel for the various exceptions, but you�ll soon see that there isn�t anything special between one exception and the next except for the name. Also, the number of exceptions in Java keeps expanding; basically it�s pointless to print them in a book. Any new library you get from a third-party vendor will probably have its own exceptions as well. The important thing to understand is the concept and what you should do with the exceptions.</para>
      <para>The basic idea is that the name of the exception represents the problem that occurred, and the exception name is intended to be relatively self-explanatory. The exceptions are not all defined in <emphasis role="bold">java.lang</emphasis>; some are created to support other libraries such as <emphasis role="bold">util</emphasis>, <emphasis role="bold">net,</emphasis> and <emphasis role="bold">io</emphasis>, which you can see from their full class names or what they are inherited from. For example, all I/O exceptions are inherited from <emphasis role="bold">java.io.IOException</emphasis>.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064724"/><anchor xreflabel="The
special case of RuntimeException" xml:id="_Toc375545372"/>The special case of <emphasis role="bold">RuntimeException</emphasis></title>
        <para>The first example in this chapter was</para>
        <para>if(t == null)</para>
        <para>� throw new NullPointerException();</para>
        <para> </para>
        <para>It can be a bit horrifying to think that you must check for <emphasis role="bold">null</emphasis> on every reference that is passed into a method (since you can�t know if the caller has passed you a valid reference). Fortunately, you don�t�this is part of the standard run-time checking that Java performs for you, and if any call is made to a <emphasis role="bold">null</emphasis> reference, Java will automatically throw a <emphasis role="bold">NullPointerException</emphasis>. So the above bit of code is always superfluous. </para>
        <para>There�s a whole group of exception types that are in this category. They�re always thrown automatically by Java and you don�t need to include them in your exception specifications. Conveniently enough, they�re all grouped together by putting them under a single base class called <emphasis role="bold">RuntimeException</emphasis>, which is a perfect example of inheritance: it establishes a family of types that have some characteristics and behaviors in common. Also, you never need to write an exception specification saying that a method might throw a <emphasis role="bold">RuntimeException</emphasis>, since that�s just assumed. Because they indicate bugs, you virtually never catch a <emphasis role="bold">RuntimeException</emphasis>�it�s dealt with automatically. If you were forced to check for <emphasis role="bold">RuntimeException</emphasis>s your code could get messy. Even though you don�t typically catch <emphasis role="bold">RuntimeExceptions</emphasis>,<emphasis role="bold"/>in your own packages you might choose to throw some of the <emphasis role="bold">RuntimeException</emphasis>s. </para>
        <para>What happens when you don�t catch such exceptions? Since the compiler doesn�t enforce exception specifications for these, it�s quite plausible that a <emphasis role="bold">RuntimeException</emphasis> could percolate all the way out to your <emphasis role="bold">main( ) </emphasis>method without being caught. To see what happens in this case, try the following example:</para>
        <para>//: c10:NeverCaught.java</para>
        <para>// Ignoring RuntimeExceptions.</para>
        <para> </para>
        <para>public class NeverCaught {</para>
        <para>� static void f() {</para>
        <para>��� throw new RuntimeException(&quot;From f()&quot;);</para>
        <para>� }</para>
        <para>� static void g() {</para>
        <para>��� f();</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� g();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can already see that a <emphasis role="bold">RuntimeException </emphasis>(or anything inherited from it) is a special case, since the compiler doesn�t require an exception specification for these types.</para>
        <para>The output is:</para>
        <para>Exception in thread &quot;main&quot;</para>
        <para>java.lang.RuntimeException: From f()</para>
        <para>������� at NeverCaught.f(NeverCaught.java:9)</para>
        <para>������� at NeverCaught.g(NeverCaught.java:12)</para>
        <para>������� at NeverCaught.main(NeverCaught.java:15)</para>
        <para> </para>
        <para>So the answer is: If a <emphasis role="bold">RuntimeException</emphasis> gets all the way out to <emphasis role="bold">main( )</emphasis> without being caught, <emphasis role="bold">printStackTrace( )</emphasis> is called for that exception as the program exits.</para>
        <para>Keep in mind that you can only ignore <emphasis role="bold">RuntimeException</emphasis>s in your coding, since all other handling is carefully enforced by the compiler. The reasoning is that a <emphasis role="bold">RuntimeException</emphasis> represents a programming error:</para>
        <para>An error you cannot catch (receiving a <emphasis role="bold">null</emphasis> reference handed to your method by a client programmer, for example) .</para>
        <para>67.      An error that you, as a programmer, should have checked for in your code (such as <emphasis role="bold">ArrayIndexOutOfBoundsException</emphasis> where you should have paid attention to the size of the array). </para>
        <para>You can see what a tremendous benefit it is to have exceptions in this case, since they help in the debugging process.</para>
        <para>It�s interesting to notice that you cannot classify Java exception handling as a single-purpose tool. Yes, it is designed to handle those pesky run-time errors that will occur because of forces outside your code�s control, but it�s also essential for certain types of programming bugs that the compiler cannot detect.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Performing cleanup 
with finally" xml:id="_Toc481064725"/>Performing cleanup   with finally</title>
      <para>There�s often some piece of code that you want to execute whether or not an exception is thrown within a <emphasis role="bold">try</emphasis> block. This usually pertains to some operation other than memory recovery (since that�s taken care of by the garbage collector). To achieve this effect, you use a <emphasis role="bold">finally</emphasis> clause<anchor xreflabel="[53]" xml:id="_ftnref53"/>[53] at the end of all the exception handlers. The full picture of an exception handling section is thus:</para>
      <para><emphasis role="bold">try</emphasis> {</para>
      <para>� // The guarded region: Dangerous activities</para>
      <para>� // that might throw A, B, or C </para>
      <para>} <emphasis role="bold">catch</emphasis>(A a1) {</para>
      <para>� // Handler for situation A</para>
      <para>} <emphasis role="bold">catch</emphasis>(B b1) {</para>
      <para>� // Handler for situation B</para>
      <para>} <emphasis role="bold">catch</emphasis>(C c1) {</para>
      <para>� // Handler for situation C</para>
      <para>} <emphasis role="bold">finally</emphasis> {</para>
      <para>� // Activities that happen every time</para>
      <para>}</para>
      <para> </para>
      <para>To demonstrate that the <emphasis role="bold">finally</emphasis> clause always runs, try this program:</para>
      <para>//: c10:FinallyWorks.java</para>
      <para>// The finally clause is always executed.</para>
      <para> </para>
      <para>class ThreeException extends Exception {}</para>
      <para> </para>
      <para>public class FinallyWorks {</para>
      <para>� static int count = 0;</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� while(true) {</para>
      <para>����� try {</para>
      <para>������� // Post-increment is zero first time:</para>
      <para>������� if(count++ == 0)</para>
      <para>��������� throw new ThreeException();</para>
      <para>������� System.out.println(&quot;No exception&quot;);</para>
      <para>����� } catch(ThreeException e) {</para>
      <para>������� System.err.println(&quot;ThreeException&quot;);</para>
      <para>����� } finally {</para>
      <para>������� System.err.println(&quot;In finally clause&quot;);</para>
      <para>������� if(count == 2) break; // out of &quot;while&quot;</para>
      <para>����� }</para>
      <para>��� }</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>This program also gives a hint for how you can deal with the fact that exceptions in Java (like exceptions in C++) do not allow you to resume back to where the exception was thrown, as discussed earlier. If you place your <emphasis role="bold">try</emphasis> block in a loop, you can establish a condition that must be met before you continue the program. You can also add a <emphasis role="bold">static</emphasis> counter or some other device to allow the loop to try several different approaches before giving up. This way you can build a greater level of robustness into your programs.</para>
      <para>The output is:</para>
      <para>ThreeException</para>
      <para>In finally clause</para>
      <para>No exception</para>
      <para>In finally clause</para>
      <para> </para>
      <para>Whether an exception is thrown or not, the <emphasis role="bold">finally</emphasis> clause is always executed.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064726"/><anchor xreflabel="What�s finally for?" xml:id="_Toc375545375"/>What�s <emphasis role="bold">finally</emphasis> for?</title>
        <para>In a language without garbage collection <emphasis role="italic">and</emphasis> without automatic destructor calls<anchor xreflabel="[54]" xml:id="_ftnref54"/>[54], <emphasis role="bold">finally</emphasis> is important because it allows the programmer to guarantee the release of memory regardless of what happens in the <emphasis role="bold">try</emphasis> block. But Java has garbage collection, so releasing memory is virtually never a problem. Also, it has no destructors to call. So when do you need to use <emphasis role="bold">finally</emphasis> in Java?</para>
        <para><emphasis role="bold">finally</emphasis> is necessary when you need to set something <emphasis role="italic">other</emphasis> than memory back to its original state. This is some kind of cleanup like an open file or network connection, something you�ve drawn on the screen, or even a switch in the outside world, as modeled in the following example:</para>
        <para>//: c10:OnOffSwitch.java </para>
        <para>// Why use finally?</para>
        <para> </para>
        <para>class Switch {</para>
        <para>� boolean state = false;</para>
        <para>� boolean read() { return state; }</para>
        <para>� void on() { state = true; }</para>
        <para>� void off() { state = false; }</para>
        <para>} </para>
        <para>class OnOffException1 extends Exception {}</para>
        <para>class OnOffException2 extends Exception {}</para>
        <para> </para>
        <para>public class OnOffSwitch {</para>
        <para>� static Switch sw = new Switch();</para>
        <para>� static void f() throws </para>
        <para>��� OnOffException1, OnOffException2 {}</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� try {</para>
        <para>����� sw.on();</para>
        <para>����� // Code that can throw exceptions...</para>
        <para>����� f();</para>
        <para>����� sw.off();</para>
        <para>��� } catch(OnOffException1 e) {</para>
        <para>����� System.err.println(&quot;OnOffException1&quot;);</para>
        <para>����� sw.off();</para>
        <para>��� } catch(OnOffException2 e) {</para>
        <para>����� System.err.println(&quot;OnOffException2&quot;);</para>
        <para>����� sw.off();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The goal here is to make sure that the switch is off when <emphasis role="bold">main( )</emphasis> is completed, so <emphasis role="bold">sw.off( )</emphasis> is placed at the end of the try block and at the end of each exception handler. But it�s possible that an exception could be thrown that isn�t caught here, so <emphasis role="bold">sw.off( ) </emphasis>would be missed. However, with <emphasis role="bold">finally</emphasis> you can place the cleanup code from a try block in just one place:</para>
        <para>//: c10:WithFinally.java</para>
        <para>// Finally Guarantees cleanup.</para>
        <para> </para>
        <para>public class WithFinally {</para>
        <para>� static Switch sw = new Switch();</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� try {</para>
        <para>����� sw.on();</para>
        <para>����� // Code that can throw exceptions...</para>
        <para>����� OnOffSwitch.f();</para>
        <para>��� } catch(OnOffException1 e) {</para>
        <para>����� System.err.println(&quot;OnOffException1&quot;);</para>
        <para>��� } catch(OnOffException2 e) {</para>
        <para>����� System.err.println(&quot;OnOffException2&quot;);</para>
        <para>��� } finally {</para>
        <para>����� sw.off();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Here the <emphasis role="bold">sw.off( )</emphasis> has been moved to just one place, where it�s guaranteed to run no matter what happens.</para>
        <para>Even in cases in which the exception is not caught in the current set of <emphasis role="bold">catch</emphasis> clauses, <emphasis role="bold">finally</emphasis> will be executed before the exception handling mechanism continues its search for a handler at the next higher level:</para>
        <para>//: c10:AlwaysFinally.java</para>
        <para>// Finally is always executed.</para>
        <para> </para>
        <para>class FourException extends Exception {}</para>
        <para> </para>
        <para>public class AlwaysFinally {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;Entering first try block&quot;);</para>
        <para>��� try {</para>
        <para>����� System.out.println(</para>
        <para>������� &quot;Entering second try block&quot;);</para>
        <para>����� try {</para>
        <para>������� throw new FourException();</para>
        <para>����� } finally {</para>
        <para>������� System.out.println(</para>
        <para>��������� &quot;finally in 2nd try block&quot;);</para>
        <para>����� }</para>
        <para>��� } catch(FourException e) {</para>
        <para>����� System.err.println(</para>
        <para>����� ��&quot;Caught FourException in 1st try block&quot;);</para>
        <para>��� } finally {</para>
        <para>����� System.err.println(</para>
        <para>������� &quot;finally in 1st try block&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The output for this program shows you what happens:</para>
        <para>Entering first try block</para>
        <para>Entering second try block</para>
        <para>finally in 2nd try block</para>
        <para>Caught FourException in 1st try block</para>
        <para>finally in 1st try block</para>
        <para> </para>
        <para>The <emphasis role="bold">finally</emphasis> statement will also be executed in situations in which <emphasis role="bold">break</emphasis> and <emphasis role="bold">continue</emphasis> statements are involved. Note that, along with the labeled <emphasis role="bold">break</emphasis> and labeled <emphasis role="bold">continue</emphasis>, <emphasis role="bold">finally</emphasis> eliminates the need for a <emphasis role="bold">goto </emphasis>statement in Java.</para>
      </section>
      <section>
        <title><anchor xreflabel="Pitfall: the lost exception" xml:id="_Toc481064727"/>Pitfall: the lost exception</title>
        <para>In general, Java�s exception implementation is quite outstanding, but unfortunately there�s a flaw. Although exceptions are an indication of a crisis in your program and should never be ignored, it�s possible for an exception to simply be lost. This happens with a particular configuration using a <emphasis role="bold">finally</emphasis> clause:</para>
        <para>//: c10:LostMessage.java</para>
        <para>// How an exception can be lost.</para>
        <para> </para>
        <para>class VeryImportantException extends Exception {</para>
        <para>� public String toString() {</para>
        <para>��� return &quot;A very important exception!&quot;;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class HoHumException extends Exception {</para>
        <para>� public String toString() {</para>
        <para>��� return &quot;A trivial exception&quot;;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class LostMessage {</para>
        <para>� void f() throws VeryImportantException {</para>
        <para>��� throw new VeryImportantException();</para>
        <para>� }</para>
        <para>� void dispose() throws HoHumException {</para>
        <para>��� throw new HoHumException();</para>
        <para>� }</para>
        <para>� public static void main(String[] args) </para>
        <para>����� throws Exception {</para>
        <para>��� LostMessage lm = new LostMessage();</para>
        <para>��� try {</para>
        <para>����� lm.f();</para>
        <para>��� } finally {</para>
        <para>����� lm.dispose();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The output is:</para>
        <para>Exception in thread &quot;main&quot; A trivial exception</para>
        <para>��� at LostMessage.dispose(LostMessage.java:21)</para>
        <para>��� at LostMessage.main(LostMessage.java:29)</para>
        <para> </para>
        <para>You can see that there�s no evidence of the <emphasis role="bold">VeryImportantException</emphasis>, which is simply replaced by the <emphasis role="bold">HoHumException</emphasis> in the <emphasis role="bold">finally</emphasis> clause. This is a rather serious pitfall, since it means that an exception can be completely lost, and in a far more subtle and difficult-to-detect fashion than the example above. In contrast, C++ treats the situation in which a second exception is thrown before the first one is handled as a dire programming error. Perhaps a future version of Java will repair this problem (on the other hand, you will typically wrap any method that throws an exception, such as <emphasis role="bold">dispose( )</emphasis>, inside a <emphasis role="bold">try-catch</emphasis> clause).</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545374"/><anchor xreflabel="Exception
restrictions" xml:id="_Toc481064728"/>Exception restrictions</title>
      <para>When you override a method, you can throw only the exceptions that have been specified in the base-class version of the method. This is a useful restriction, since it means that code that works with the base class will automatically work with any object derived from the base class (a fundamental OOP concept, of course), including exceptions.</para>
      <para>This example demonstrates the kinds of restrictions imposed (at compile-time) for exceptions:</para>
      <para>//: c10:StormyInning.java</para>
      <para>// Overridden methods may throw only the </para>
      <para>// exceptions specified in their base-class </para>
      <para>// versions, or exceptions derived from the </para>
      <para>// base-class exceptions.</para>
      <para> </para>
      <para>class BaseballException extends Exception {}</para>
      <para>class Foul extends BaseballException {}</para>
      <para>class Strike extends BaseballException {}</para>
      <para> </para>
      <para>abstract class Inning {</para>
      <para>� Inning() throws BaseballException {}</para>
      <para>� void event () throws BaseballException {</para>
      <para>�� // Doesn&apos;t actually have to throw anything</para>
      <para>� }</para>
      <para>� abstract void atBat() throws Strike, Foul;</para>
      <para>� void walk() {} // Throws nothing</para>
      <para>}</para>
      <para> </para>
      <para>class StormException extends Exception {}</para>
      <para>class RainedOut extends StormException {}</para>
      <para>class PopFoul extends Foul {}</para>
      <para> </para>
      <para>interface Storm {</para>
      <para>� void event() throws RainedOut;</para>
      <para>� void rainHard() throws RainedOut;</para>
      <para>}</para>
      <para> </para>
      <para>public class StormyInning extends Inning </para>
      <para>��� implements Storm {</para>
      <para>� // OK to add new exceptions for </para>
      <para>� // constructors, but you must deal </para>
      <para>� // with the base constructor exceptions:</para>
      <para>� StormyInning() throws RainedOut, </para>
      <para>��� BaseballException {}</para>
      <para>� StormyInning(String s) throws Foul, </para>
      <para>��� BaseballException {}</para>
      <para>� // Regular methods must conform to base class:</para>
      <para>//! void walk() throws PopFoul {} //Compile error</para>
      <para>� // Interface CANNOT add exceptions to existing</para>
      <para>� // methods from the base class:</para>
      <para>//! public void event() throws RainedOut {}</para>
      <para>� // If the method doesn&apos;t already exist in the</para>
      <para>� // base class, the exception is OK:</para>
      <para>� public void rainHard() throws RainedOut {}</para>
      <para>� // You can choose to not throw any exceptions,</para>
      <para>� // even if base version does:</para>
      <para>� public void event() {}</para>
      <para>� // Overridden methods can throw </para>
      <para>� // inherited exceptions:</para>
      <para>� void atBat() throws PopFoul {}</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� try {</para>
      <para>����� StormyInning si = new StormyInning();</para>
      <para>����� si.atBat();</para>
      <para>��� } catch(PopFoul e) {</para>
      <para>����� System.err.println(&quot;Pop foul&quot;);</para>
      <para>��� } catch(RainedOut e) {</para>
      <para>����� System.err.println(&quot;Rained out&quot;);</para>
      <para>��� } catch(BaseballException e) {</para>
      <para>����� System.err.println(&quot;Generic error&quot;);</para>
      <para>��� }</para>
      <para>��� // Strike not thrown in derived version.</para>
      <para>��� try {</para>
      <para>����� // What happens if you upcast?</para>
      <para>����� Inning i = new StormyInning();</para>
      <para>����� i.atBat();</para>
      <para>����� // You must catch the exceptions from the</para>
      <para>��� ��// base-class version of the method:</para>
      <para>��� } catch(Strike e) {</para>
      <para>����� System.err.println(&quot;Strike&quot;);</para>
      <para>��� } catch(Foul e) {</para>
      <para>����� System.err.println(&quot;Foul&quot;);</para>
      <para>��� } catch(RainedOut e) {</para>
      <para>����� System.err.println(&quot;Rained out&quot;);</para>
      <para>��� } catch(BaseballException e) {</para>
      <para>����� System.err.println(</para>
      <para>������� &quot;Generic baseball exception&quot;);</para>
      <para>��� }</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>In <emphasis role="bold">Inning</emphasis>, you can see that both the constructor and the <emphasis role="bold">event( )</emphasis> method say they will throw an exception, but they never do. This is legal because it allows you to force the user to catch any exceptions that might be added in overridden versions of <emphasis role="bold">event( )</emphasis>. The same idea holds for <emphasis role="bold">abstract</emphasis> methods, as seen in <emphasis role="bold">atBat( )</emphasis>.</para>
      <para>The <emphasis role="bold">interface Storm</emphasis> is interesting because it contains one method (<emphasis role="bold">event( )</emphasis>) that is defined in <emphasis role="bold">Inning</emphasis>, and one method that isn�t. Both methods throw a new type of exception, <emphasis role="bold">RainedOut</emphasis>. When <emphasis role="bold">StormyInning</emphasis><emphasis role="bold">extends Inning</emphasis> and <emphasis role="bold">implements Storm</emphasis>, you�ll see that the <emphasis role="bold">event( )</emphasis> method in <emphasis role="bold">Storm</emphasis><emphasis role="italic">cannot</emphasis> change the exception interface of <emphasis role="bold">event( )</emphasis> in <emphasis role="bold">Inning</emphasis>. Again, this makes sense because otherwise you�d never know if you were catching the correct thing when working with the base class. Of course, if a method described in an <emphasis role="bold">interface</emphasis> is not in the base class, such as <emphasis role="bold">rainHard( )</emphasis>,<emphasis role="bold"/>then there�s no problem if it throws exceptions.</para>
      <para>The restriction on exceptions does not apply to constructors. You can see in <emphasis role="bold">StormyInning </emphasis>that a constructor can throw anything it wants, regardless of what the base-class constructor throws. However, since a base-class constructor must always be called one way or another (here, the default constructor is called automatically), the derived-class constructor must declare any base-class constructor exceptions in its exception specification. Note that a derived-class constructor cannot catch exceptions thrown by its base-class constructor.</para>
      <para>The reason <emphasis role="bold">StormyInning.walk( )</emphasis> will not compile is that it throws an exception, while <emphasis role="bold">Inning.walk( )</emphasis> does not. If this was allowed, then you could write code that called <emphasis role="bold">Inning.walk( )</emphasis> and that didn�t have to handle any exceptions, but then when you substituted an object of a class derived from <emphasis role="bold">Inning</emphasis>, exceptions would be thrown so your code would break. By forcing the derived-class methods to conform to the exception specifications of the base-class methods, substitutability of objects is maintained.</para>
      <para>The overridden <emphasis role="bold">event( )</emphasis> method shows that a derived-class version of a method may choose not to throw any exceptions, even if the base-class version does. Again, this is fine since it doesn�t break any code that is written�assuming the base-class version throws exceptions. Similar logic applies to <emphasis role="bold">atBat( )</emphasis>, which throws <emphasis role="bold">PopFoul</emphasis>, an exception that is derived from <emphasis role="bold">Foul</emphasis> thrown by the base-class version of <emphasis role="bold">atBat( )</emphasis>. This way, if someone writes code that works with <emphasis role="bold">Inning</emphasis> and calls <emphasis role="bold">atBat( )</emphasis>, they must catch the <emphasis role="bold">Foul</emphasis> exception. Since <emphasis role="bold">PopFoul</emphasis> is derived from <emphasis role="bold">Foul</emphasis>, the exception handler will also catch <emphasis role="bold">PopFoul</emphasis>. </para>
      <para>The last point of interest is in <emphasis role="bold">main( )</emphasis>. Here you can see that if you�re dealing with exactly a <emphasis role="bold">StormyInning</emphasis> object, the compiler forces you to catch only the exceptions that are specific to that class, but if you upcast to the base type then the compiler (correctly) forces you to catch the exceptions for the base type. All these constraints produce much more robust exception-handling code<anchor xreflabel="[55]" xml:id="_ftnref55"/>[55].</para>
      <para>It�s useful to realize that although exception specifications are enforced by the compiler during inheritance, the exception specifications are not part of the type of a method, which is comprised of only the method name and argument types. Therefore, you cannot overload methods based on exception specifications. In addition, just because an exception specification exists in a base-class version of a method doesn�t mean that it must exist in the derived-class version of the method. This is quite different from inheritance rules, where a method in the base class must also exist in the derived class. Put another way, the �exception specification interface� for a particular method may narrow during inheritance and overriding, but it may not widen�this is precisely the opposite of the rule for the class interface during inheritance.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064729"/><anchor xreflabel="" xml:id="_Toc375545376"/><anchor xreflabel="" xml:id="_Toc312374122"/><anchor xreflabel="" xml:id="_Toc305628772"/><anchor xreflabel="Constructors" xml:id="_Toc305593300"/>Constructors</title>
      <para>When writing code with exceptions, it�s particularly important that you always ask, �If an exception occurs, will this be properly cleaned up?� Most of the time you�re fairly safe, but in constructors there�s a problem. The constructor puts the object into a safe starting state, but it might perform some operation�such as opening a file�that doesn�t get cleaned up until the user is finished with the object and calls a special cleanup method. If you throw an exception from inside a constructor, these cleanup behaviors might not occur properly. This means that you must be especially diligent while you write your constructor.</para>
      <para>Since you�ve just learned about <emphasis role="bold">finally</emphasis>, you might think that it is the correct solution. But it�s not quite that simple, because <emphasis role="bold">finally </emphasis>performs the cleanup code <emphasis role="italic">every time,</emphasis> even in the situations in which you don�t want the cleanup code executed until the cleanup method runs. Thus, if you do perform cleanup in <emphasis role="bold">finally</emphasis>, you must set some kind of flag when the constructor finishes normally so that you don�t do anything in the <emphasis role="bold">finally</emphasis> block if the flag is set. Because this isn�t particularly elegant (you are coupling your code from one place to another), it�s best if you try to avoid performing this kind of cleanup in <emphasis role="bold">finally</emphasis> unless you are forced to.</para>
      <para>In the following example, a class called <emphasis role="bold">InputFile</emphasis> is created that opens a file and allows you to read it one line (converted into a <emphasis role="bold">String</emphasis>) at a time. It uses the classes <emphasis role="bold">FileReader</emphasis> and <emphasis role="bold">BufferedReader</emphasis> from the Java standard I/O library that will be discussed in Chapter 11, but which are simple enough that you probably won�t have any trouble understanding their basic use:</para>
      <para>//: c10:Cleanup.java</para>
      <para>// Paying attention to exceptions</para>
      <para>// in constructors.</para>
      <para>import java.io.*;</para>
      <para> </para>
      <para>class InputFile {</para>
      <para>� private BufferedReader in;</para>
      <para>� InputFile(String fname) throws Exception {</para>
      <para>��� try {</para>
      <para>����� in = </para>
      <para>������� new BufferedReader(</para>
      <para>��������� new FileReader(fname));</para>
      <para>����� // Other code that might throw exceptions</para>
      <para>��� } catch(FileNotFoundException e) {</para>
      <para>����� System.err.println(</para>
      <para>������� &quot;Could not open &quot; + fname);</para>
      <para>����� // Wasn&apos;t open, so don&apos;t close it</para>
      <para>����� throw e;</para>
      <para>��� } catch(Exception e) {</para>
      <para>����� // All other exceptions must close it</para>
      <para>����� try {</para>
      <para>������� in.close();</para>
      <para>����� } catch(IOException e2) {</para>
      <para>������� System.err.println(</para>
      <para>��������� &quot;in.close() unsuccessful&quot;);</para>
      <para>����� }</para>
      <para>����� throw e; // Rethrow</para>
      <para>��� } finally {</para>
      <para>����� // Don&apos;t close it here!!!</para>
      <para>��� }</para>
      <para>� }</para>
      <para>� String getLine() {</para>
      <para>��� String s;</para>
      <para>��� try {</para>
      <para>����� s = in.readLine();</para>
      <para>��� } catch(IOException e) {</para>
      <para>����� System.err.println(</para>
      <para>������� &quot;readLine() unsuccessful&quot;);</para>
      <para>����� s = &quot;failed&quot;;</para>
      <para>��� }</para>
      <para>��� return s;</para>
      <para>� }</para>
      <para>� void cleanup() {</para>
      <para>��� try {</para>
      <para>����� in.close();</para>
      <para>��� } catch(IOException e2) {</para>
      <para>����� System.err.println(</para>
      <para>������� &quot;in.close() unsuccessful&quot;);</para>
      <para>��� }</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class Cleanup {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� try {</para>
      <para>����� InputFile in = </para>
      <para>������� new InputFile(&quot;Cleanup.java&quot;);</para>
      <para>����� String s;</para>
      <para>����� int i = 1;</para>
      <para>����� while((s = in.getLine()) != null)</para>
      <para>������� System.out.println(&quot;&quot;+ i++ + &quot;: &quot; + s);</para>
      <para>����� in.cleanup();</para>
      <para>��� } catch(Exception e) {</para>
      <para>����� System.err.println(</para>
      <para>������� &quot;Caught in main, e.printStackTrace()&quot;);</para>
      <para>����� e.printStackTrace(System.err);</para>
      <para>��� }</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The constructor for <emphasis role="bold">InputFile</emphasis> takes a <emphasis role="bold">String</emphasis> argument, which is the name of the file you want to open. Inside a <emphasis role="bold">try</emphasis> block, it creates a <emphasis role="bold">FileReader</emphasis> using the file name. A <emphasis role="bold">FileReader</emphasis> isn�t particularly useful until you turn around and use it to create a <emphasis role="bold">BufferedReader</emphasis> that you can actually talk to�notice that one of the benefits of <emphasis role="bold">InputFile</emphasis> is that it combines these two actions.</para>
      <para>If the <emphasis role="bold">FileReader</emphasis> constructor is unsuccessful, it throws a <emphasis role="bold">FileNotFoundException</emphasis>, which must be caught separately because that�s the one case in which you don�t want to close the file since it wasn�t successfully opened. Any <emphasis role="italic">other</emphasis> catch clauses must close the file because it <emphasis role="italic">was</emphasis> opened by the time those catch clauses are entered. (Of course, this is trickier if more than one method can throw a <emphasis role="bold">FileNotFoundException</emphasis>. In that case, you might want to break things into several <emphasis role="bold">try </emphasis>blocks.) The <emphasis role="bold">close( )</emphasis> method might throw an exception so it is tried and caught even though it�s within the block of another <emphasis role="bold">catch</emphasis> clause�it�s just another pair of curly braces to the Java compiler. After performing local operations, the exception is rethrown, which is appropriate because this constructor failed, and you wouldn�t want the calling method to assume that the object had been properly created and was valid.</para>
      <para>In this example, which doesn�t use the aforementioned flagging technique, the <emphasis role="bold">finally</emphasis> clause is definitely <emphasis role="italic">not</emphasis> the place to <emphasis role="bold">close( )</emphasis> the file, since that would close it every time the constructor completed. Since we want the file to be open for the useful lifetime of the <emphasis role="bold">InputFile</emphasis> object this would not be appropriate.</para>
      <para>The <emphasis role="bold">getLine( )</emphasis> method returns a <emphasis role="bold">String</emphasis> containing the next line in the file. It calls <emphasis role="bold">readLine( ),</emphasis> which can throw an exception, but that exception is caught so <emphasis role="bold">getLine( )</emphasis> doesn�t throw any exceptions. One of the design issues with exceptions is whether to handle an exception completely at this level, to handle it partially and pass the same exception (or a different one) on, or whether to simply pass it on. Passing it on, when appropriate, can certainly simplify coding. The <emphasis role="bold">getLine( )</emphasis> method becomes:</para>
      <para>String getLine() throws IOException {</para>
      <para>� return in.readLine();</para>
      <para>}</para>
      <para> </para>
      <para>But of course, the caller is now responsible for handling any <emphasis role="bold">IOException</emphasis> that might arise.</para>
      <para>The <emphasis role="bold">cleanup( )</emphasis> method must be called by the user when finished using the <emphasis role="bold">InputFile</emphasis> object. This will release the system resources (such as file handles) that are used by the <emphasis role="bold">BufferedReader</emphasis> and/or <emphasis role="bold">FileReader</emphasis> objects<anchor xreflabel="[56]" xml:id="_ftnref56"/>[56]. You don�t want to do this until you�re finished with the <emphasis role="bold">InputFile</emphasis> object, at the point you�re going to let it go. You might think of putting such functionality into a <emphasis role="bold">finalize( )</emphasis> method, but as mentioned in Chapter 4 you can�t always be sure that <emphasis role="bold">finalize( )</emphasis> will be called (even if you <emphasis role="italic">can</emphasis> be sure that it will be called, you don�t know <emphasis role="italic">when</emphasis>). This is one of the downsides to Java: all cleanup�other than memory cleanup�doesn�t happen automatically, so you must inform the client programmer that they are responsible, and possibly guarantee that cleanup occurs using <emphasis role="bold">finalize( )</emphasis>.</para>
      <para>In <emphasis role="bold">Cleanup.java</emphasis> an <emphasis role="bold">InputFile</emphasis> is created to open the same source file that creates the program, the file is read in a line at a time, and line numbers are added. All exceptions are caught generically in <emphasis role="bold">main( )</emphasis>, although you could choose greater granularity.</para>
      <para>One of the benefits of this example is to show you why exceptions are introduced at this point in the book�you can�t do basic I/O without using exceptions. Exceptions are so integral to programming in Java, especially because the compiler enforces them, that you can accomplish only so much without knowing how to work with them.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064730"/><anchor xreflabel="" xml:id="_Toc375545377"/><anchor xreflabel="" xml:id="_Toc312374124"/><anchor xreflabel="" xml:id="_Toc305628773"/><anchor xreflabel="Exception matching" xml:id="_Toc305593301"/>Exception matching</title>
      <para>When an exception is thrown, the exception handling system looks through the �nearest� handlers in the order they are written. When it finds a match, the exception is considered handled, and no further searching occurs. </para>
      <para>Matching an exception doesn�t require a perfect match between the exception and its handler. A derived-class object will match a handler for the base class, as shown in this example:</para>
      <para>//: c10:Human.java</para>
      <para>// Catching exception hierarchies.</para>
      <para> </para>
      <para>class Annoyance extends Exception {}</para>
      <para>class Sneeze extends Annoyance {}</para>
      <para> </para>
      <para>public class Human {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� try {</para>
      <para>����� throw new Sneeze();</para>
      <para>��� } catch(Sneeze s) {</para>
      <para>����� System.err.println(&quot;Caught Sneeze&quot;);</para>
      <para>��� } catch(Annoyance a) {</para>
      <para>����� System.err.println(&quot;Caught Annoyance&quot;);</para>
      <para>��� }</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The <emphasis role="bold">Sneeze</emphasis> exception will be caught by the first <emphasis role="bold">catch</emphasis> clause that it matches�which is the first one, of course. However, if you remove the first catch clause, leaving only:</para>
      <para>��� try {</para>
      <para>����� throw new Sneeze();</para>
      <para>��� } catch(Annoyance a) {</para>
      <para>����� System.err.println(&quot;Caught Annoyance&quot;);</para>
      <para>��� }</para>
      <para> </para>
      <para>The code will still work because it�s catching the base class of <emphasis role="bold">Sneeze</emphasis>. Put another way, <emphasis role="bold">catch(Annoyance e)</emphasis> will catch an <emphasis role="bold">Annoyance</emphasis><emphasis role="italic">or any class derived from it</emphasis>. This is useful because if you decide to add more� derived exceptions to a method, then the client programmer�s code will not need changing as long as the client catches the base class exceptions.</para>
      <para>If you try to �mask� the derived-class exceptions by putting the base-class catch clause first, like this:</para>
      <para>��� try {</para>
      <para>����� throw new Sneeze();</para>
      <para>��� } catch(Annoyance a) {</para>
      <para>����� System.err.println(&quot;Caught Annoyance&quot;);</para>
      <para>��� } catch(Sneeze s) {</para>
      <para>����� System.err.println(&quot;Caught Sneeze&quot;);</para>
      <para>��� }</para>
      <para> </para>
      <para>the compiler will give you an error message, since it sees that the <emphasis role="bold">Sneeze</emphasis> catch-clause can never be reached.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064731"/><anchor xreflabel="" xml:id="_Toc375545378"/><anchor xreflabel="Exception" xml:id="_Toc312374128"/>Exception guidelines</title>
        <para>Use exceptions to:</para>
        <para>Fix the problem and call the method that caused the exception again.</para>
        <para>68.      Patch things up and continue without retrying the method.</para>
        <para>69.      Calculate some alternative result instead of what the method was supposed to produce.</para>
        <para>70.      Do whatever you can in the current context and rethrow the <emphasis role="italic">same</emphasis> exception to a higher context.</para>
        <para>71.      Do whatever you can in the current context and throw a <emphasis role="italic">different</emphasis> exception to a higher context.</para>
        <para>72.      Terminate the program.</para>
        <para>73.      Simplify. (If your exception scheme makes things more complicated, then it is painful and annoying to use.)</para>
        <para>74.      Make your library and program safer. (This is a short-term investment for debugging, and a long-term investment (for application robustness.)</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064732"/><anchor xreflabel="Summary" xml:id="_Toc375545379"/>Summary</title>
      <para>Improved error recovery�is one of the most powerful ways that you can increase the robustness of your code. Error recovery is a fundamental concern for every program you write, but it�s especially important in Java, where one of the primary goals is to create program components for others to use. <emphasis role="italic">To create a robust system, each component must be robust.</emphasis></para>
      <para>The goals for exception handling in Java are to simplify the creation of large, reliable programs using less code than currently possible, and with more confidence that your application doesn�t have an unhandled error.</para>
      <para>Exceptions are not terribly difficult to learn, and are one of those features that provide immediate and significant benefits to your project. Fortunately, Java enforces all aspects of exceptions so it�s guaranteed that they will be used consistently by both library designers and client programmers.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064733"/><anchor xreflabel="Exercises" xml:id="_Toc375545380"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Create a class with a <emphasis role="bold">main( )</emphasis> that throws an object of class <emphasis role="bold">Exception</emphasis> inside a <emphasis role="bold">try</emphasis> block. Give the constructor for <emphasis role="bold">Exception</emphasis> a <emphasis role="bold">String</emphasis> argument. Catch the exception inside a <emphasis role="bold">catch</emphasis> clause and print the <emphasis role="bold">String</emphasis> argument. Add a <emphasis role="bold">finally</emphasis> clause and print a message to prove you were there.</para>
      <para>  161.         Create your own exception class using the <emphasis role="bold">extends</emphasis> keyword. Write a constructor for this class that takes a <emphasis role="bold">String</emphasis> argument and stores it inside the object with a <emphasis role="bold">String</emphasis> reference. Write a method that prints out the stored <emphasis role="bold">String</emphasis>. Create a <emphasis role="bold">try-catch</emphasis> clause to exercise your new exception.</para>
      <para>  162.         Write a class with a method that throws an exception of the type created in Exercise 2. Try compiling it without an exception specification to see what the compiler says. Add the appropriate exception specification. Try out your class and its exception inside a try-catch clause.</para>
      <para>  163.         Define an object reference and initialize it to <emphasis role="bold">null</emphasis>. Try to call a method through this reference. Now wrap the code in a <emphasis role="bold">try-catch</emphasis> clause to catch the exception.</para>
      <para>  164.         Create a class with two methods, <emphasis role="bold">f( )</emphasis> and <emphasis role="bold">g( )</emphasis>. In <emphasis role="bold">g( )</emphasis>, throw an exception of a new type that you define. In <emphasis role="bold">f( )</emphasis>, call <emphasis role="bold">g( )</emphasis>, catch its exception and, in the <emphasis role="bold">catch</emphasis> clause, throw a different exception (of a second type that you define). Test your code in <emphasis role="bold">main( )</emphasis>.</para>
      <para>  165.         Create three new types of exceptions. Write a class with a method that throws all three. In <emphasis role="bold">main( )</emphasis>, call the method but only use a single <emphasis role="bold">catch</emphasis> clause that will catch all three types of exceptions.</para>
      <para>  166.         Write code to generate and catch an <emphasis role="bold">ArrayIndexOutOfBoundsException</emphasis>.</para>
      <para>  167.         Create your own resumption-like behavior using a <emphasis role="bold">while</emphasis> loop that repeats until an exception is no longer thrown.</para>
      <para>  168.         Create a three-level hierarchy of exceptions. Now create a base-class <emphasis role="bold">A </emphasis>with a method that throws an exception at the base of your hierarchy. Inherit <emphasis role="bold">B</emphasis> from <emphasis role="bold">A</emphasis> and override the method so it throws an exception at level two of your hierarchy. Repeat by inheriting class <emphasis role="bold">C</emphasis> from <emphasis role="bold">B</emphasis>. In <emphasis role="bold">main( )</emphasis>, create a <emphasis role="bold">C</emphasis> and upcast it to <emphasis role="bold">A</emphasis>, then call the method.</para>
      <para>  169.         Demonstrate that a derived-class constructor cannot catch exceptions thrown by its base-class constructor.</para>
      <para>  170.         Show that <emphasis role="bold">OnOffSwitch.java</emphasis> can fail by throwing a <emphasis role="bold">RuntimeException</emphasis> inside the <emphasis role="bold">try</emphasis> block.</para>
      <para>  171.         Show that <emphasis role="bold">WithFinally.java</emphasis> doesn�t fail by throwing a <emphasis role="bold">RuntimeException</emphasis> inside the <emphasis role="bold">try</emphasis> block.</para>
      <para>  172.         Modify Exercise 6 by adding a <emphasis role="bold">finally</emphasis> clause. Verify your <emphasis role="bold">finally</emphasis> clause is executed, even if a <emphasis role="bold">NullPointerException</emphasis> is thrown.</para>
      <para>  173.         Create an example where you use a flag to control whether cleanup code is called, as described in the second paragraph after the heading �Constructors.�</para>
      <para>  174.         Modify <emphasis role="bold">StormyInning.java</emphasis> by adding an <emphasis role="bold">UmpireArgument</emphasis> exception type, and methods that throw this exception. Test the modified hierarchy.</para>
      <para>  175.         Remove the first catch clause in <emphasis role="bold">Human.java</emphasis> and verify that the code still compiles and runs properly.</para>
      <para>  176.         Add a second level of exception loss to <emphasis role="bold">LostMessage.java</emphasis> so that the <emphasis role="bold">HoHumException</emphasis> is itself replaced by a third exception.</para>
      <para>  177.         In Chapter 5, find the two programs called <emphasis role="bold">Assert.java</emphasis> and modify these to throw their own type of exception instead of printing to <emphasis role="bold">System.err</emphasis>. This exception should be an inner class that extends <emphasis role="bold">RuntimeException</emphasis>.</para>
      <para>  178.         Add an appropriate set of exceptions to <emphasis role="bold">c08:GreenhouseControls.java</emphasis>.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064734"/><anchor xreflabel="" xml:id="_Toc477690731"/><anchor xreflabel="" xml:id="_Toc375545381"/><anchor xreflabel="" xml:id="Chapter_10"/>11: The Java   I/O System</title>
    <para>Creating a good input/output (I/O) system is one of the more difficult tasks for the language designer.</para>
    <para>This is evidenced by the number of different approaches. The challenge seems to be in covering all eventualities. Not only are there different sources and sinks of I/O that you want to communicate with (files, the console, network connections), but you need to talk to them in a wide variety of ways (sequential, random-access, buffered, binary, character, by lines, by words, etc.).</para>
    <para>The Java library designers attacked this problem by creating lots of classes. In fact, there are so many classes for Java�s I/O system that it can be intimidating at first (ironically, the Java I/O design actually prevents an explosion of classes). There was also a significant change in the I/O library after Java 1.0, when the original <emphasis role="bold">byte</emphasis>-oriented library was supplemented with <emphasis role="bold">char</emphasis>-oriented, Unicode-based I/O classes. As a result there are a fair number of classes to learn before you understand enough of Java�s I/O picture that you can use it properly. In addition, it�s rather important to understand the evolution history of the I/O library, even if your first reaction is �don�t bother me with history, just show me how to use it!� The problem is that without the historical perspective you will rapidly become confused with some of the classes and when you should and shouldn�t use them.</para>
    <para>This chapter will give you an introduction to the variety of I/O classes in the standard Java library and how to use them. </para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545382"/><anchor xreflabel="" xml:id="_Toc481064735"/><anchor xreflabel="The File class" xml:id="_Toc375545390"/>The <emphasis role="bold">File</emphasis> class</title>
      <para>Before getting into the classes that actually read and write data to streams, we�ll look a utility provided with the library to assist you in handling file directory issues.</para>
      <para>The <emphasis role="bold">File </emphasis>class has a deceiving name�you might think it refers to a file, but it doesn�t. It can represent either the <emphasis role="italic">name</emphasis> of a particular file or the <emphasis role="italic">names</emphasis> of a set of files in a directory. If it�s a set of files, you can ask for the set with the <emphasis role="bold">list( )</emphasis> method, and this returns an array of <emphasis role="bold">String</emphasis>. It makes sense to return an array rather than one of the flexible container classes because the number of elements is fixed, and if you want a different directory listing you just create a different <emphasis role="bold">File</emphasis> object. In fact, �FilePath� would have been a better name for the class. This section shows an example of the use of this class, including the associated <emphasis role="bold">FilenameFilter</emphasis><emphasis role="bold">interface</emphasis>.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064736"/><anchor xreflabel="A
directory lister" xml:id="_Toc375545391"/>A directory lister</title>
        <para>Suppose you�d like to see a directory listing. The <emphasis role="bold">File</emphasis> object can be listed in two ways. If you call <emphasis role="bold">list( )</emphasis> with no arguments, you�ll get the full list that the <emphasis role="bold">File</emphasis> object contains. However, if you want a restricted list�for example, if you want all of the files with an extension of <emphasis role="bold">.java</emphasis>�then you use a �directory filter,� which is a class that tells how to select the <emphasis role="bold">File</emphasis> objects for display.</para>
        <para>Here�s the code for the example. Note that the result has been effortlessly sorted (alphabetically) using the <emphasis role="bold">java.utils.Array.sort( )</emphasis> method and the <emphasis role="bold">AlphabeticComparator</emphasis> defined in Chapter 9:</para>
        <para>//: c11:DirList.java</para>
        <para>// Displays directory listing.</para>
        <para>import java.io.*;</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>public class DirList {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� File path = new File(&quot;.&quot;);</para>
        <para>��� String[] list;</para>
        <para>��� if(args.length == 0)</para>
        <para>����� list = path.list();</para>
        <para>��� else </para>
        <para>����� list = path.list(new DirFilter(args[0]));</para>
        <para>��� Arrays.sort(list,</para>
        <para>����� new AlphabeticComparator());</para>
        <para>��� for(int i = 0; i &lt; list.length; i++)</para>
        <para>����� System.out.println(list[i]);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class DirFilter implements FilenameFilter {</para>
        <para>� String afn;</para>
        <para>� DirFilter(String afn) { this.afn = afn; }</para>
        <para>� public boolean accept(File dir, String name) {</para>
        <para>��� // Strip path information:</para>
        <para>��� String f = new File(name).getName();</para>
        <para>��� return f.indexOf(afn) != -1;</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">DirFilter</emphasis> class �implements� the <emphasis role="bold">interface</emphasis><emphasis role="bold">FilenameFilter</emphasis>. It�s useful to see how simple the <emphasis role="bold">FilenameFilter</emphasis><emphasis role="bold">interface</emphasis> is:</para>
        <para>public interface FilenameFilter {</para>
        <para>� boolean accept(File dir, String name);</para>
        <para>}</para>
        <para> </para>
        <para>It says all that this type of object does is provide a method called <emphasis role="bold">accept( )</emphasis>. The whole reason behind the creation of this class is to provide the <emphasis role="bold">accept( )</emphasis> method to the <emphasis role="bold">list( )</emphasis> method so that <emphasis role="bold">list( )</emphasis> can �call back� <emphasis role="bold">accept( )</emphasis> to determine which file names should be included in the list. Thus, this technique is often referred to as a <emphasis role="italic">callback</emphasis> or sometimes a <emphasis role="italic">functor</emphasis> (that is, <emphasis role="bold">DirFilter</emphasis> is a functor because its only job is to hold a method) or the <emphasis role="italic">Command</emphasis><emphasis role="italic">Pattern</emphasis>. Because <emphasis role="bold">list( )</emphasis> takes a <emphasis role="bold">FilenameFilter</emphasis> object as its argument, it means that you can pass an object of any class that implements <emphasis role="bold">FilenameFilter</emphasis> to choose (even at run-time) how the <emphasis role="bold">list( )</emphasis> method will behave. The purpose of a callback is to provide flexibility in the behavior of code.</para>
        <para><emphasis role="bold">DirFilter</emphasis> shows that just because an <emphasis role="bold">interface</emphasis> contains only a set of methods, you�re not restricted to writing only those methods. (You must at least provide definitions for all the methods in an interface, however.) In this case, the <emphasis role="bold">DirFilter</emphasis> constructor is also created.</para>
        <para>The <emphasis role="bold">accept( )</emphasis> method must accept a <emphasis role="bold">File</emphasis> object representing the directory that a particular file is found in, and a <emphasis role="bold">String</emphasis> containing the name of that file. You might choose to use or ignore either of these arguments, but you will probably at least use the file name. Remember that the <emphasis role="bold">list( )</emphasis> method is calling <emphasis role="bold">accept( )</emphasis> for each of the file names in the directory object to see which one should be included�this is indicated by the <emphasis role="bold">boolean</emphasis> result returned by <emphasis role="bold">accept( )</emphasis>.</para>
        <para>To make sure the element you�re working with is only the file name and contains no path information, all you have to do is take the <emphasis role="bold">String</emphasis> object and create a <emphasis role="bold">File</emphasis> object out of it, then call <emphasis role="bold">getName( )</emphasis>, which strips away all the path information (in a platform-independent way). Then <emphasis role="bold">accept( )</emphasis> uses the <emphasis role="bold">String </emphasis>class <emphasis role="bold">indexOf( )</emphasis> method to see if the search string <emphasis role="bold">afn</emphasis> appears anywhere in the name of the file. If <emphasis role="bold">afn</emphasis> is found within the string, the return value is the starting index of <emphasis role="bold">afn</emphasis>, but if it�s not found the return value is -1. Keep in mind that this is a simple string search and does not have �glob� expression wildcard matching�such as �fo?.b?r*��which is much more difficult to implement.</para>
        <para>The <emphasis role="bold">list( )</emphasis> method returns an array. You can query this array for its length and then move through it selecting the array elements. This ability to easily pass an array in and out of a method is a tremendous improvement over the behavior of C and C++.</para>
        <section>
          <title>Anonymous inner classes</title>
          <para>This example is ideal for rewriting using an anonymous inner class (described in Chapter 8). As a first cut, a method <emphasis role="bold">filter( ) </emphasis>is created that returns a reference to a <emphasis role="bold">FilenameFilter</emphasis>:</para>
          <para>//: c11:DirList2.java</para>
          <para>// Uses anonymous inner classes.</para>
          <para>import java.io.*;</para>
          <para>import java.util.*;</para>
          <para>import com.bruceeckel.util.*;</para>
          <para> </para>
          <para>public class DirList2 {</para>
          <para>� public static FilenameFilter </para>
          <para>� filter(final String afn) {</para>
          <para>��� // Creation of anonymous inner class:</para>
          <para>��� return new FilenameFilter() {</para>
          <para>����� String fn = afn;</para>
          <para>����� public boolean accept(File dir, String n) {</para>
          <para>������� // Strip path information:</para>
          <para>������� String f = new File(n).getName();</para>
          <para>������� return f.indexOf(fn) != -1;</para>
          <para>����� }</para>
          <para>��� }; // End of anonymous inner class</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� File path = new File(&quot;.&quot;);</para>
          <para>��� String[] list;</para>
          <para>��� if(args.length == 0)</para>
          <para>����� list = path.list();</para>
          <para>��� else </para>
          <para>����� list = path.list(filter(args[0]));</para>
          <para>��� Arrays.sort(list,</para>
          <para>����� new AlphabeticComparator());</para>
          <para>��� for(int i = 0; i &lt; list.length; i++)</para>
          <para>����� System.out.println(list[i]);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>Note that the argument to <emphasis role="bold">filter( )</emphasis> must be <emphasis role="bold">final</emphasis>. This is required by the anonymous inner class so that it can use an object from outside its scope.</para>
          <para>This design is an improvement because the <emphasis role="bold">FilenameFilter</emphasis> class is now tightly bound to <emphasis role="bold">DirList2</emphasis>. However, you can take this approach one step further and define the anonymous inner class as an argument to <emphasis role="bold">list( )</emphasis>, in which case it�s even smaller:</para>
          <para>//: c11:DirList3.java</para>
          <para>// Building the anonymous inner class &quot;in-place.&quot;</para>
          <para>import java.io.*;</para>
          <para>import java.util.*;</para>
          <para>import com.bruceeckel.util.*;</para>
          <para> </para>
          <para>public class DirList3 {</para>
          <para>� public static void main(final String[] args) {</para>
          <para>��� File path = new File(&quot;.&quot;);</para>
          <para>��� String[] list;</para>
          <para>��� if(args.length == 0)</para>
          <para>����� list = path.list();</para>
          <para>��� else </para>
          <para>����� list = path.list(new FilenameFilter() {</para>
          <para>������� public boolean </para>
          <para>������� accept(File dir, String n) {</para>
          <para>��������� String f = new File(n).getName();</para>
          <para>��������� return f.indexOf(args[0]) != -1;</para>
          <para>������� }</para>
          <para>����� });</para>
          <para>��� Arrays.sort(list,</para>
          <para>����� new AlphabeticComparator());</para>
          <para>��� for(int i = 0; i &lt; list.length; i++)</para>
          <para>����� System.out.println(list[i]);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The argument to <emphasis role="bold">main( )</emphasis> is now <emphasis role="bold">final</emphasis>, since the anonymous inner class uses <emphasis role="bold">args[0]</emphasis> directly.</para>
          <para>This shows you how anonymous inner classes allow the creation of quick-and-dirty classes to solve problems. Since everything in Java revolves around classes, this can be a useful coding technique. One benefit is that it keeps the code that solves a particular problem isolated together in one spot. On the other hand, it is not always as easy to read, so you must use it judiciously.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064737"/><anchor xreflabel="Checking
for and creating directories" xml:id="_Toc375545392"/>Checking for and creating directories</title>
        <para>The <emphasis role="bold">File</emphasis> class is more than just a representation for an existing file or directory. You can also use a <emphasis role="bold">File</emphasis> object to create a new directory or an entire directory path if it doesn�t exist. You can also look at the characteristics of files (size, last modification date, read/write), see whether a <emphasis role="bold">File</emphasis> object represents a file or a directory, and delete a file. This program shows some of the other methods available with the <emphasis role="bold">File</emphasis> class (see the HTML documentation from <emphasis role="italic">java.sun.com </emphasis>for the full set):</para>
        <para>//: c11:MakeDirectories.java</para>
        <para>// Demonstrates the use of the File class to</para>
        <para>// create directories and manipulate files.</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>public class MakeDirectories {</para>
        <para>� private final static String usage =</para>
        <para>��� &quot;Usage:MakeDirectories path1 ...\n&quot; +</para>
        <para>��� &quot;Creates each path\n&quot; +</para>
        <para>��� &quot;Usage:MakeDirectories -d path1 ...\n&quot; +</para>
        <para>��� &quot;Deletes each path\n&quot; +</para>
        <para>��� &quot;Usage:MakeDirectories -r path1 path2\n&quot; +</para>
        <para>��� &quot;Renames from path1 to path2\n&quot;;</para>
        <para>� private static void usage() {</para>
        <para>��� System.err.println(usage);</para>
        <para>��� System.exit(1);</para>
        <para>� }</para>
        <para>� private static void fileData(File f) {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;Absolute path: &quot; + f.getAbsolutePath() +</para>
        <para>����� &quot;\n Can read: &quot; + f.canRead() +</para>
        <para>����� &quot;\n Can write: &quot; + f.canWrite() +</para>
        <para>����� &quot;\n getName: &quot; + f.getName() +</para>
        <para>����� &quot;\n getParent: &quot; + f.getParent() +</para>
        <para>����� &quot;\n getPath: &quot; + f.getPath() +</para>
        <para>����� &quot;\n length: &quot; + f.length() +</para>
        <para>����� &quot;\n lastModified: &quot; + f.lastModified());</para>
        <para>��� if(f.isFile())</para>
        <para>����� System.out.println(&quot;it&apos;s a file&quot;);</para>
        <para>��� else if(f.isDirectory())</para>
        <para>����� System.out.println(&quot;it&apos;s a directory&quot;);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� if(args.length &lt; 1) usage();</para>
        <para>��� if(args[0].equals(&quot;-r&quot;)) {</para>
        <para>����� if(args.length != 3) usage();</para>
        <para>����� File </para>
        <para>������� old = new File(args[1]),</para>
        <para>������� rname = new File(args[2]);</para>
        <para>����� old.renameTo(rname);</para>
        <para>����� fileData(old);</para>
        <para>����� fileData(rname);</para>
        <para>����� return; // Exit main</para>
        <para>��� }</para>
        <para>��� int count = 0;</para>
        <para>��� boolean del = false;</para>
        <para>��� if(args[0].equals(&quot;-d&quot;)) {</para>
        <para>����� count++;</para>
        <para>����� del = true;</para>
        <para>�� �}</para>
        <para>��� for( ; count &lt; args.length; count++) {</para>
        <para>����� File f = new File(args[count]);</para>
        <para>����� if(f.exists()) {</para>
        <para>������� System.out.println(f + &quot; exists&quot;);</para>
        <para>������� if(del) {</para>
        <para>��������� System.out.println(&quot;deleting...&quot; + f);</para>
        <para>��������� f.delete();</para>
        <para>������� }</para>
        <para>����� } </para>
        <para>����� else { // Doesn&apos;t exist</para>
        <para>������� if(!del) {</para>
        <para>��������� f.mkdirs();</para>
        <para>��������� System.out.println(&quot;created &quot; + f);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>����� fileData(f);</para>
        <para>��� }� </para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In <emphasis role="bold">fileData( )</emphasis> you can see various file investigation methods used to display information about the file or directory path.</para>
        <para>The first method that�s exercised by <emphasis role="bold">main( )</emphasis> is <emphasis role="bold">renameTo( )</emphasis>, which allows you to rename (or move) a file to an entirely new path represented by the argument, which is another <emphasis role="bold">File</emphasis> object. This also works with directories of any length.</para>
        <para>If you experiment with the above program, you�ll find that you can make a directory path of any complexity because <emphasis role="bold">mkdirs( )</emphasis> will do all the work for you.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Input and output" xml:id="_Toc481064738"/>Input and output</title>
      <para>I/O libraries often use the abstraction of a <emphasis role="italic">stream</emphasis>, which represents any data source or sink as an object capable of producing or receiving pieces of data. The stream hides the details of what happens to the data inside the actual I/O device.</para>
      <para>The Java library classes for I/O are divided by input and output, as you can see by looking at the online Java class hierarchy with your Web browser. By inheritance, everything derived from the <emphasis role="bold">InputStream</emphasis> or <emphasis role="bold">Reader </emphasis>classes have basic methods called <emphasis role="bold">read( ) </emphasis>for reading a single byte or array of bytes. Likewise, everything derived from <emphasis role="bold">OutputStream </emphasis>or <emphasis role="bold">Writer </emphasis>classes have basic methods called <emphasis role="bold">write( ) </emphasis>for writing a single byte or array of bytes. However, you won�t generally use these methods; they exist so that other classes can use them�these other classes provide a more useful interface. Thus, you�ll rarely create your stream object by using a single class, but instead will layer multiple objects together to provide your desired functionality. The fact that you create more than one object to create a single resulting stream is the primary reason that Java�s stream library is confusing.</para>
      <para>It�s helpful to categorize the classes by their functionality. In Java 1.0, the library designers started by deciding that all classes that had anything to do with input would be inherited from <emphasis role="bold">InputStream</emphasis> and all classes that were associated with output would be inherited from <emphasis role="bold">OutputStream</emphasis>. </para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064739"/><anchor xreflabel="Types
of InputStream" xml:id="_Toc375545383"/>Types of <emphasis role="bold">InputStream</emphasis></title>
        <para><emphasis role="bold">InputStream</emphasis>�s job is to represent classes that produce input from different sources. These sources can be: </para>
        <para>An array of bytes.</para>
        <para>75.      A <emphasis role="bold">String</emphasis> object.</para>
        <para>76.      A file.</para>
        <para>77.      A �pipe,� which works like a physical pipe: you put things in one end and they come out the other.</para>
        <para>78.      A sequence of other streams, so you can collect them together into a single stream.</para>
        <para>79.      Other sources, such as an Internet connection. (This will be discussed in a later chapter.)</para>
        <para>Each of these has an associated subclass of <emphasis role="bold">InputStream</emphasis>. In addition, the <emphasis role="bold">FilterInputStream</emphasis> is also a type of <emphasis role="bold">InputStream</emphasis>, to provide a base class for &quot;decorator&quot; classes that attach attributes or useful interfaces to input streams. This is discussed later.</para>
        <para><emphasis role="bold">Table 11-1. Types of InputStream</emphasis></para>
        <informaltable frame="all">
          <tgroup cols="3">
            <colspec colname="c1" colwidth="20*"/>
            <colspec colname="c2" colwidth="14*"/>
            <colspec colname="c3" colwidth="20*"/>
            <thead>
              <row>
                <entry morerows="1" valign="top"><para> Class</para></entry>
                <entry morerows="1" valign="top"><para> Function</para></entry>
                <entry valign="top"><para> Constructor Arguments</para></entry>
              </row>
              <row>
                <entry valign="top"><para> How to use it</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry morerows="1" valign="top"><para> ByteArray-InputStream</para></entry>
                <entry morerows="1" valign="top"><para> Allows a buffer in memory to be used as an InputStream</para></entry>
                <entry valign="top"><para> The buffer from which to extract the bytes.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> As a source of data. Connect it to a FilterInputStream object to provide a useful interface.</para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> StringBuffer-InputStream</para></entry>
                <entry morerows="1" valign="top"><para> Converts a String into an InputStream</para></entry>
                <entry valign="top"><para> A String. The underlying implementation actually uses a StringBuffer.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> As a source of data. Connect it to a FilterInputStream object to provide a useful interface.</para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> File-InputStream</para></entry>
                <entry morerows="1" valign="top"><para> For reading information from a file</para></entry>
                <entry valign="top"><para> A String representing the file name, or a File or FileDescriptor object.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> As a source of data. Connect it to a FilterInputStream object to provide a useful interface.</para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> Piped-InputStream</para></entry>
                <entry morerows="1" valign="top"><para> Produces the data that�s being written to the associated PipedOutput-Stream. Implements the �piping� concept.</para></entry>
                <entry valign="top"><para> PipedOutputStream</para></entry>
              </row>
              <row>
                <entry valign="top"><para> As a source of data in multithreading. Connect it to a FilterInputStream object to provide a useful interface.</para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> Sequence-InputStream</para></entry>
                <entry morerows="1" valign="top"><para> Converts two or more InputStream objects into a single InputStream.</para></entry>
                <entry valign="top"><para> Two InputStream objects or an Enumeration for a container of InputStream objects.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> As a source of data. Connect it to a FilterInputStream object to provide a useful interface.</para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> Filter-InputStream</para></entry>
                <entry morerows="1" valign="top"><para> Abstract class which is an interface for decorators that provide useful functionality to the other InputStream classes. See Table 11-3.</para></entry>
                <entry valign="top"><para> See Table 11-3.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> See Table 11-3.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064740"/><anchor xreflabel="Types
of OutputStream" xml:id="_Toc375545385"/>Types of <emphasis role="bold">OutputStream</emphasis></title>
        <para>This category includes the classes that decide where your output will go: an array of bytes (no <emphasis role="bold">String</emphasis>, however; presumably you can create one using the array of bytes), a file, or a �pipe.�</para>
        <para>In addition, the <emphasis role="bold">FilterOutputStream</emphasis> provides a base class for &quot;decorator&quot; classes that attach attributes or useful interfaces to output streams. This is discussed later.</para>
        <para><emphasis role="bold">Table 11-2. Types of OutputStream</emphasis></para>
        <informaltable frame="all">
          <tgroup cols="3">
            <colspec colname="c1" colwidth="20*"/>
            <colspec colname="c2" colwidth="15*"/>
            <colspec colname="c3" colwidth="20*"/>
            <thead>
              <row>
                <entry morerows="1" valign="top"><para> Class</para></entry>
                <entry morerows="1" valign="top"><para> Function</para></entry>
                <entry valign="top"><para> Constructor Arguments</para></entry>
              </row>
              <row>
                <entry valign="top"><para> How to use it</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry morerows="1" valign="top"><para> ByteArray-OutputStream</para></entry>
                <entry morerows="1" valign="top"><para> Creates a buffer in memory. All the data that you send to the stream is placed in this buffer.</para></entry>
                <entry valign="top"><para> Optional initial size of the buffer.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> To designate the destination of your data. Connect it to a FilterOutputStream object to provide a useful interface.</para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> File-OutputStream</para></entry>
                <entry morerows="1" valign="top"><para> For sending information to a file.</para></entry>
                <entry valign="top"><para> A String representing the file name, or a File or FileDescriptor object.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> To designate the destination of your data. Connect it to a FilterOutputStream object to provide a useful interface.</para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> Piped-OutputStream</para></entry>
                <entry morerows="1" valign="top"><para> Any information you write to this automatically ends up as input for the associated PipedInput-Stream. Implements the �piping� concept.</para></entry>
                <entry valign="top"><para> PipedInputStream</para></entry>
              </row>
              <row>
                <entry valign="top"><para> To designate the destination of your data for multithreading. Connect it to a FilterOutputStream object to provide a useful interface.</para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> Filter-OutputStream</para></entry>
                <entry morerows="1" valign="top"><para> Abstract class which is an interface for decorators that provide useful functionality to the other OutputStream classes. See Table 11-4.</para></entry>
                <entry valign="top"><para> See Table 11-4.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> See Table 11-4.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064741"/><anchor xreflabel="Adding
attributes 
and useful interfaces" xml:id="_Toc375545386"/>Adding attributes   and useful interfaces</title>
      <para>The use of layered objects to dynamically and transparently add responsibilities to individual objects is referred to as the <emphasis role="italic">Decorator</emphasis> pattern. (Patterns<anchor xreflabel="[57]" xml:id="_ftnref57"/>[57] are the subject of <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis>.) The decorator pattern specifies that all objects that wrap around your initial object have the same interface. This makes the basic use of the decorators transparent�you send the same message to an object whether it�s been decorated or not. This is the reason for the existence of the �filter� classes in the Java I/O library: the abstract �filter� class is the base class for all the decorators. (A decorator must have the same interface as the object it decorates, but the decorator can also extend the interface, which occurs in several of the �filter� classes).</para>
      <para>Decorators are often used when simple subclassing results in a large number of subclasses in order to satisfy every possible combination that is needed�so many subclasses that it becomes impractical. The Java I/O library requires many different combinations of features, which is why the decorator pattern is used. There is a drawback to the decorator pattern, however. Decorators give you much more flexibility while you�re writing a program (since you can easily mix and match attributes), but they add complexity to your code. The reason that the Java I/O library is awkward to use is that you must create many classes�the �core� I/O type plus all the decorators�in order to get the single I/O object that you want. </para>
      <para>The classes that provide the decorator interface to control a particular <emphasis role="bold">InputStream</emphasis> or <emphasis role="bold">OutputStream</emphasis> are the <emphasis role="bold">FilterInputStream</emphasis> and <emphasis role="bold">FilterOutputStream</emphasis>�which don�t have very intuitive names. <emphasis role="bold">FilterInputStream</emphasis> and <emphasis role="bold">FilterOutputStream</emphasis> are abstract classes that are derived from the base classes of the I/O library, <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis>, which is the key requirement of the decorator (so that it provides the common interface to all the objects that are being decorated).</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064742"/><anchor xreflabel="Reading
from an InputStream with FilterInputStream" xml:id="_Toc375545387"/>Reading from an <emphasis role="bold">InputStream  </emphasis>with<emphasis role="bold"> FilterInputStream</emphasis></title>
        <para>The <emphasis role="bold">FilterInputStream</emphasis> classes accomplish two significantly different things. <emphasis role="bold">DataInputStream</emphasis> allows you to read different types of primitive data as well as <emphasis role="bold">String</emphasis> objects. (All the methods start with �read,� such as <emphasis role="bold">readByte( )</emphasis>, <emphasis role="bold">readFloat( )</emphasis>, etc.) This, along with its companion <emphasis role="bold">DataOutputStream</emphasis>, allows you to move primitive data from one place to another via a stream. These �places� are determined by the classes in Table 11-1. </para>
        <para>The remaining classes modify the way an <emphasis role="bold">InputStream</emphasis> behaves internally: whether it�s buffered or unbuffered, if it keeps track of the lines it�s reading (allowing you to ask for line numbers or set the line number), and whether you can push back a single character. The last two classes look a lot like support for building a compiler (that is, they were added to support the construction of the Java compiler), so you probably won�t use them in general programming. </para>
        <para>You�ll probably need to buffer your input almost every time, regardless of the I/O device you�re connecting to, so it would have made more sense for the I/O library to make a special case (or simply a method call) for unbuffered input rather than buffered input.</para>
        <para><emphasis role="bold">Table 11-3. Types of FilterInputStream</emphasis></para>
        <informaltable frame="all">
          <tgroup cols="5">
            <colspec colname="c1" colwidth="17*"/>
            <colspec colname="c2" colwidth="18*"/>
            <colspec colname="c3" colwidth="17*"/>
            <colspec colname="c4" colwidth="17*"/>
            <colspec colname="c5" colwidth="1"/>
            <tbody>
              <row>
                <entry morerows="1" valign="top"><para> Class</para></entry>
                <entry morerows="1" nameend="c3" namest="c2" valign="top"><para> Function</para></entry>
                <entry valign="top"><para> Constructor Arguments</para></entry>
                <entry><para>  </para></entry>
              </row>
              <row>
                <entry valign="top"><para> How to use it</para></entry>
                <entry><para>  </para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> Data-InputStream</para></entry>
                <entry morerows="1" nameend="c3" namest="c2" valign="top"><para> Used in concert with DataOutputStream, so you can read primitives (int, char, long, etc.) from a stream in a portable fashion.</para></entry>
                <entry valign="top"><para> InputStream</para></entry>
                <entry><para>  </para></entry>
              </row>
              <row>
                <entry valign="top"><para> Contains a full interface to allow you to read primitive types.</para></entry>
                <entry><para>  </para></entry>
              </row>
              <row>
                <entry morerows="1" nameend="c2" namest="c1" valign="top"><para> Buffered-InputStream</para></entry>
                <entry morerows="1" valign="top"><para> Use this to prevent a physical read every time you want more data. You�re saying �Use a buffer.�</para></entry>
                <entry nameend="c5" namest="c4" valign="top"><para> InputStream, with optional buffer size.</para></entry>
              </row>
              <row>
                <entry nameend="c2" namest="c1" valign="top"><para> This doesn�t provide an interface <emphasis role="italic">per se</emphasis>, just a requirement that a buffer be used. Attach an interface object.</para></entry>
              </row>
              <row>
                <entry morerows="1" nameend="c2" namest="c1" valign="top"><para> LineNumber-InputStream</para></entry>
                <entry morerows="1" valign="top"><para> Keeps track of line numbers in the input stream; you can call getLineNumber( ) and setLineNumber(.</para><para> int)</para></entry>
                <entry nameend="c5" namest="c4" valign="top"><para> InputStream</para></entry>
              </row>
              <row>
                <entry nameend="c2" namest="c1" valign="top"><para> This just adds line numbering, so you�ll probably attach an interface object.</para></entry>
              </row>
              <row>
                <entry morerows="1" nameend="c2" namest="c1" valign="top"><para> Pushback-InputStream</para></entry>
                <entry morerows="1" valign="top"><para> Has a one byte push-back buffer so that you can push back the last character read.</para></entry>
                <entry nameend="c5" namest="c4" valign="top"><para> InputStream</para></entry>
              </row>
              <row>
                <entry nameend="c2" namest="c1" valign="top"><para> Generally used in the scanner for a compiler and probably included because the Java compiler needed it. You probably won�t use this.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064743"/><anchor xreflabel="Writing to an OutputStreamwith FilterOutputStream" xml:id="_Toc375545388"/>Writing to an <emphasis role="bold">OutputStream<emphasis role="italic"> </emphasis></emphasis>with<emphasis role="bold"> FilterOutputStream</emphasis></title>
        <para>The complement to <emphasis role="bold">DataInputStream</emphasis> is <emphasis role="bold">DataOutputStream</emphasis>, which formats each of the primitive types and <emphasis role="bold">String</emphasis> objects onto a stream in such a way that any <emphasis role="bold">DataInputStream</emphasis>, on any machine, can read them. All the methods start with �write,� such as <emphasis role="bold">writeByte( )</emphasis>, <emphasis role="bold">writeFloat( )</emphasis>, etc.</para>
        <para>The original intent of <emphasis role="bold">PrintStream</emphasis> was to print all of the primitive data types and <emphasis role="bold">String</emphasis> objects in a viewable format. This is different from <emphasis role="bold">DataOutputStream</emphasis>, whose goal is to put data elements on a stream in a way that <emphasis role="bold">DataInputStream</emphasis> can portably reconstruct them. </para>
        <para>The two important methods in <emphasis role="bold">PrintStream</emphasis> are <emphasis role="bold">print( )</emphasis> and <emphasis role="bold">println( )</emphasis>, which are overloaded to print all the various types. The difference between <emphasis role="bold">print( )</emphasis> and <emphasis role="bold">println( )</emphasis> is that the latter adds a newline when it�s done.</para>
        <para><emphasis role="bold">PrintStream</emphasis> can be problematic because it traps all <emphasis role="bold">IOException</emphasis>s (You must explicitly test the error status with <emphasis role="bold">checkError( )</emphasis>, which returns <emphasis role="bold">true</emphasis> if an error has occurred). Also, <emphasis role="bold">PrintStream</emphasis> doesn�t internationalize properly and doesn�t handle line breaks in a platform independent way (these problems are solved with <emphasis role="bold">PrintWriter</emphasis>).</para>
        <para><emphasis role="bold">BufferedOutputStream</emphasis> is a modifier and tells the stream to use buffering so you don�t get a physical write every time you write to the stream. You�ll probably always want to use this with files, and possibly console I/O.</para>
        <para><emphasis role="bold">Table 11-4. Types of FilterOutputStream</emphasis></para>
        <informaltable frame="all">
          <tgroup cols="3">
            <colspec colname="c1" colwidth="16*"/>
            <colspec colname="c2" colwidth="17*"/>
            <colspec colname="c3" colwidth="16*"/>
            <thead>
              <row>
                <entry morerows="1" valign="top"><para> Class</para></entry>
                <entry morerows="1" valign="top"><para> Function</para></entry>
                <entry valign="top"><para> Constructor Arguments </para></entry>
              </row>
              <row>
                <entry valign="top"><para> How to use it</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry morerows="1" valign="top"><para> Data-OutputStream</para></entry>
                <entry morerows="1" valign="top"><para> Used in concert with DataInputStream so you can write primitives (int, char, long, etc.) to a stream in a portable fashion.</para></entry>
                <entry valign="top"><para> OutputStream</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Contains full interface to allow you to write primitive types.</para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> PrintStream</para></entry>
                <entry morerows="1" valign="top"><para> For producing formatted output. While DataOutputStream handles the <emphasis role="italic">storage</emphasis> of data, PrintStream handles <emphasis role="italic">display</emphasis>.</para></entry>
                <entry valign="top"><para> OutputStream, with optional boolean indicating that the buffer is flushed with every newline.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Should be the �final� wrapping for your OutputStream object. You�ll probably use this a lot.</para></entry>
              </row>
              <row>
                <entry morerows="1" valign="top"><para> Buffered-OutputStream</para></entry>
                <entry morerows="1" valign="top"><para> Use this to prevent a physical write every time you send a piece of data. You�re saying �Use a buffer.� You can call flush( ) to flush the buffer.</para></entry>
                <entry valign="top"><para> OutputStream, with optional buffer size.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> This doesn�t provide an interface <emphasis role="italic">per se</emphasis>, just a requirement that a buffer is used. Attach an interface object.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545389"/><anchor xreflabel="Readers &amp; Writers" xml:id="_Toc481064744"/><emphasis role="bold">Reader</emphasis>s &amp; <emphasis role="bold">Writer</emphasis>s</title>
      <para>Java 1.1 made some significant modifications to the fundamental I/O stream library (Java 2, however, did not make fundamental modifications). When you see the <emphasis role="bold">Reader</emphasis> and <emphasis role="bold">Writer</emphasis> classes your first thought (like mine) might be that these were meant to replace the <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis> classes. But that�s not the case. Although some aspects of the original streams library are deprecated (if you use them you will receive a warning from the compiler), the <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis> classes still provide valuable functionality in the form of <emphasis role="bold">byte</emphasis>-oriented I/O, while the <emphasis role="bold">Reader </emphasis>and <emphasis role="bold">Writer </emphasis>classes provide Unicode-compliant, character-based I/O. In addition: </para>
      <para>Java 1.1 added new classes into the <emphasis role="bold">InputStream </emphasis>and <emphasis role="bold">OutputStream </emphasis>hierarchy, so it�s obvious those classes weren�t being replaced.</para>
      <para>80.      There are times when you must use classes from the �byte� hierarchy <emphasis role="italic">in combination</emphasis> with classes in the �character� hierarchy. To accomplish this there are �bridge� classes: <emphasis role="bold">InputStreamReader</emphasis> converts an <emphasis role="bold">InputStream </emphasis>to a <emphasis role="bold">Reader </emphasis>and <emphasis role="bold">OutputStreamWriter</emphasis> converts an <emphasis role="bold">OutputStream</emphasis> to a <emphasis role="bold">Writer</emphasis>.</para>
      <para>The most important reason for the <emphasis role="bold">Reader</emphasis> and <emphasis role="bold">Writer</emphasis> hierarchies is for internationalization. The old I/O stream hierarchy supports only 8-bit byte streams and doesn�t handle the 16-bit Unicode characters well. Since Unicode is used for internationalization (and Java�s native <emphasis role="bold">char </emphasis>is 16-bit Unicode), the <emphasis role="bold">Reader</emphasis> and <emphasis role="bold">Writer</emphasis> hierarchies were added to support Unicode in all I/O operations. In addition, the new libraries are designed for faster operations than the old.</para>
      <para>As is the practice in this book, I will attempt to provide an overview of the classes, but assume that you will use online documentation to determine all the details, such as the exhaustive list of methods.</para>
      <section>
        <title><anchor xreflabel="Sources and sinks of data" xml:id="_Toc481064745"/>Sources and sinks of data</title>
        <para>Almost all of the original Java I/O stream classes have corresponding <emphasis role="bold">Reader</emphasis> and <emphasis role="bold">Writer</emphasis> classes to provide native Unicode manipulation. However, there are some places where the <emphasis role="bold">byte</emphasis>-oriented <emphasis role="bold">InputStream</emphasis>s and <emphasis role="bold">OutputStream</emphasis>s are the correct solution;<emphasis role="bold"/>in particular, the <emphasis role="bold">java.util.zip</emphasis> libraries are <emphasis role="bold">byte</emphasis>-oriented rather than <emphasis role="bold">char</emphasis>-oriented. So the most sensible approach to take is to <emphasis role="italic">try</emphasis> to use the <emphasis role="bold">Reader</emphasis> and <emphasis role="bold">Writer</emphasis> classes whenever you can, and you�ll discover the situations when you have to use the <emphasis role="bold">byte</emphasis>-oriented libraries because your code won�t compile.</para>
        <para>Here is a table that shows the correspondence between the sources and sinks of information (that is, where the data physically comes from or goes to) in the two hierarchies. </para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="21*"/>
            <colspec colname="c2" colwidth="24*"/>
            <tbody>
              <row>
                <entry valign="top"><para> Sources &amp; Sinks:</para><para> Java 1.0 class</para></entry>
                <entry valign="top"><para> Corresponding Java 1.1 class</para></entry>
              </row>
              <row>
                <entry valign="top"><para> InputStream</para></entry>
                <entry valign="top"><para> Reader converter: InputStreamReader</para></entry>
              </row>
              <row>
                <entry valign="top"><para> OutputStream</para></entry>
                <entry valign="top"><para> Writer converter: OutputStreamWriter</para></entry>
              </row>
              <row>
                <entry valign="top"><para> FileInputStream</para></entry>
                <entry valign="top"><para> FileReader</para></entry>
              </row>
              <row>
                <entry valign="top"><para> FileOutputStream</para></entry>
                <entry valign="top"><para> FileWriter</para></entry>
              </row>
              <row>
                <entry valign="top"><para> StringBufferInputStream</para></entry>
                <entry valign="top"><para> StringReader</para></entry>
              </row>
              <row>
                <entry valign="top"><para> (no corresponding class)</para></entry>
                <entry valign="top"><para> StringWriter</para></entry>
              </row>
              <row>
                <entry valign="top"><para> ByteArrayInputStream</para></entry>
                <entry valign="top"><para> CharArrayReader</para></entry>
              </row>
              <row>
                <entry valign="top"><para> ByteArrayOutputStream</para></entry>
                <entry valign="top"><para> CharArrayWriter</para></entry>
              </row>
              <row>
                <entry valign="top"><para> PipedInputStream</para></entry>
                <entry valign="top"><para> PipedReader</para></entry>
              </row>
              <row>
                <entry valign="top"><para> PipedOutputStream</para></entry>
                <entry valign="top"><para> PipedWriter</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>In general, you�ll find that the interfaces for the two different hierarchies are similar if not identical.</para>
      </section>
      <section>
        <title><anchor xreflabel="Modifying stream behavior" xml:id="_Toc481064746"/>Modifying stream behavior</title>
        <para>For <emphasis role="bold">InputStream</emphasis>s and <emphasis role="bold">OutputStream</emphasis>s, streams were adapted for particular needs using �decorator� subclasses of <emphasis role="bold">FilterInputStream</emphasis> and <emphasis role="bold">FilterOutputStream.</emphasis> The <emphasis role="bold">Reader</emphasis> and <emphasis role="bold">Writer</emphasis> class hierarchies continue the use of this idea�but not exactly.</para>
        <para>In the following table, the correspondence is a rougher approximation than in the previous table. The difference is because of the class organization: while <emphasis role="bold">BufferedOutputStream</emphasis> is a subclass of <emphasis role="bold">FilterOutputStream</emphasis>, <emphasis role="bold">BufferedWriter</emphasis> is <emphasis role="italic">not</emphasis> a subclass of <emphasis role="bold">FilterWriter</emphasis> (which, even though it is <emphasis role="bold">abstract</emphasis>, has no subclasses and so appears to have been put in either as a placeholder or simply so you wouldn�t wonder where it was). However, the interfaces to the classes are quite a close match. </para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="21*"/>
            <colspec colname="c2" colwidth="25*"/>
            <thead>
              <row>
                <entry valign="top"><para> Filters:</para><para> Java 1.0 class</para></entry>
                <entry valign="top"><para> Corresponding Java 1.1 class</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry valign="top"><para> FilterInputStream</para></entry>
                <entry valign="top"><para> FilterReader</para></entry>
              </row>
              <row>
                <entry valign="top"><para> FilterOutputStream</para></entry>
                <entry valign="top"><para> FilterWriter (abstract class with no subclasses)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> BufferedInputStream</para></entry>
                <entry valign="top"><para> BufferedReader(also has readLine( ))</para></entry>
              </row>
              <row>
                <entry valign="top"><para> BufferedOutputStream</para></entry>
                <entry valign="top"><para> BufferedWriter</para></entry>
              </row>
              <row>
                <entry valign="top"><para> DataInputStream</para></entry>
                <entry valign="top"><para> Use DataInputStream(Except when you need to use readLine( ),when you should use a BufferedReader)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> PrintStream</para></entry>
                <entry valign="top"><para> PrintWriter</para></entry>
              </row>
              <row>
                <entry valign="top"><para> LineNumberInputStream</para></entry>
                <entry valign="top"><para> LineNumberReader</para></entry>
              </row>
              <row>
                <entry valign="top"><para> StreamTokenizer</para></entry>
                <entry valign="top"><para> StreamTokenizer(use constructor that takes a Reader instead)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> PushBackInputStream</para></entry>
                <entry valign="top"><para> PushBackReader</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>There�s one direction that�s quite clear: Whenever you want to use <emphasis role="bold">readLine( )</emphasis>, you shouldn�t do it with a <emphasis role="bold">DataInputStream</emphasis> any more (this is met with a deprecation message at compile-time), but instead use a <emphasis role="bold">BufferedReader</emphasis>. Other than this, <emphasis role="bold">DataInputStream</emphasis> is still a �preferred� member of the I/O library.</para>
        <para>To make the transition to using a <emphasis role="bold">PrintWriter</emphasis> easier, it has constructors that take any <emphasis role="bold">OutputStream</emphasis> object, as well as <emphasis role="bold">Writer</emphasis> objects. However, <emphasis role="bold">PrintWriter</emphasis> has no more support for formatting than <emphasis role="bold">PrintStream</emphasis> does; the interfaces are virtually the same.</para>
        <para>The <emphasis role="bold">PrintWriter</emphasis> constructor also has an option to perform automatic flushing, which happens after every <emphasis role="bold">println( )</emphasis> if the constructor flag is set.</para>
      </section>
      <section>
        <title><anchor xreflabel="Unchanged Classes" xml:id="_Toc481064747"/>Unchanged Classes</title>
        <para>Some classes were left unchanged between Java 1.0 and Java 1.1: </para>
        <informaltable frame="all">
          <tgroup cols="1">
            <colspec colname="c1" colwidth="22*"/>
            <thead>
              <row>
                <entry valign="top"><para> Java 1.0 classes without corresponding Java 1.1 classes</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry valign="top"><para> DataOutputStream</para></entry>
              </row>
              <row>
                <entry valign="top"><para> File</para></entry>
              </row>
              <row>
                <entry valign="top"><para> RandomAccessFile</para></entry>
              </row>
              <row>
                <entry valign="top"><para> SequenceInputStream</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para><emphasis role="bold">DataOutputStream</emphasis>, in particular, is used without change, so for storing and retrieving data in a transportable format you use the <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis> hierarchies.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Off by itself: 
RandomAccessFile" xml:id="_Toc481064748"/>Off by itself:   RandomAccessFile</title>
      <para><emphasis role="bold">RandomAccessFile</emphasis> is used for files containing records of known size so that you can move from one record to another using <emphasis role="bold">seek( )</emphasis>, then read or change the records. The records don�t have to be the same size; you just have to be able to determine how big they are and where they are placed in the file.</para>
      <para>At first it�s a little bit hard to believe that <emphasis role="bold">RandomAccessFile</emphasis> is not part of the <emphasis role="bold">InputStream</emphasis> or <emphasis role="bold">OutputStream</emphasis> hierarchy. However, it has no association with those hierarchies other than that it happens to implement the <emphasis role="bold">DataInput</emphasis> and <emphasis role="bold">DataOutput</emphasis> interfaces (which are also implemented by <emphasis role="bold">DataInputStream</emphasis> and <emphasis role="bold">DataOutputStream</emphasis>). It doesn�t even use any of the functionality of the existing <emphasis role="bold">InputStream</emphasis> or <emphasis role="bold">OutputStream</emphasis> classes�it�s a completely separate class, written from scratch, with all of its own (mostly native) methods. The reason for this may be that <emphasis role="bold">RandomAccessFile</emphasis> has essentially different behavior than the other I/O types, since you can move forward and backward within a file. In any event, it stands alone, as a direct descendant of <emphasis role="bold">Object</emphasis>.</para>
      <para>Essentially, a <emphasis role="bold">RandomAccessFile</emphasis> works like a <emphasis role="bold">DataInputStream</emphasis> pasted together with a <emphasis role="bold">DataOutputStream</emphasis>, along with the methods <emphasis role="bold">getFilePointer( )</emphasis> to find out where you are in the file, <emphasis role="bold">seek( )</emphasis> to move to a new point in the file, and <emphasis role="bold">length( )</emphasis> to determine the maximum size of the file. In addition, the constructors require a second argument (identical to <emphasis role="bold">fopen( ) </emphasis>in C) indicating whether you are just randomly reading (<emphasis role="bold">�r�</emphasis>) or reading and writing (<emphasis role="bold">�rw�</emphasis>). There�s no support for write-only files, which could suggest that <emphasis role="bold">RandomAccessFile</emphasis> might have worked well if it were inherited from <emphasis role="bold">DataInputStream</emphasis>.</para>
      <para>The seeking methods are available only in <emphasis role="bold">RandomAccessFile</emphasis>, which works for files only. <emphasis role="bold">BufferedInputStream</emphasis> does allow you to <emphasis role="bold">mark( )</emphasis> a position (whose value is held in a single internal variable) and <emphasis role="bold">reset( )</emphasis> to that position, but this is limited and not very useful.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064749"/><anchor xreflabel="Typical
uses of I/O streams" xml:id="_Toc375545393"/>Typical uses of I/O streams</title>
      <para>Although you can combine the I/O stream classes in many different ways, you�ll probably just use a few combinations. The following example can be used as a basic reference; it shows the creation and use of typical I/O configurations. Note that each configuration begins with a commented number and title that corresponds to the heading for the appropriate explanation that follows in the text.</para>
      <para>//: c11:IOStreamDemo.java</para>
      <para>// Typical I/O stream configurations.</para>
      <para>import java.io.*;</para>
      <para> </para>
      <para>public class IOStreamDemo {</para>
      <para>� // Throw exceptions to console:</para>
      <para>� public static void main(String[] args) </para>
      <para>� throws IOException {</para>
      <para>��� // 1. Reading input by lines:</para>
      <para>��� BufferedReader in =</para>
      <para>����� new BufferedReader(</para>
      <para>������� new FileReader(&quot;IOStreamDemo.java&quot;));</para>
      <para>��� String s, s2 = new String();</para>
      <para>��� while((s = in.readLine())!= null)</para>
      <para>����� s2 += s + &quot;\n&quot;;</para>
      <para>��� in.close();</para>
      <para> </para>
      <para>��� // 1b. Reading standard input:</para>
      <para>��� BufferedReader stdin =</para>
      <para>����� new BufferedReader(</para>
      <para>������� new InputStreamReader(System.in));����� </para>
      <para>��� System.out.print(&quot;Enter a line:&quot;);</para>
      <para>��� System.out.println(stdin.readLine());</para>
      <para> </para>
      <para>��� // 2. Input from memory</para>
      <para>��� StringReader in2 = new StringReader(s2);</para>
      <para>��� int c;</para>
      <para>��� while((c = in2.read()) != -1)</para>
      <para>����� System.out.print((char)c);</para>
      <para> </para>
      <para>��� // 3. Formatted memory input</para>
      <para>��� try {</para>
      <para>����� DataInputStream in3 =</para>
      <para>������� new DataInputStream(</para>
      <para>��������� new ByteArrayInputStream(s2.getBytes()));</para>
      <para>����� while(true)</para>
      <para>������� System.out.print((char)in3.readByte());</para>
      <para>��� } catch(EOFException e) {</para>
      <para>����� System.err.println(&quot;End of stream&quot;);</para>
      <para>��� }</para>
      <para> </para>
      <para>��� // 4. File output</para>
      <para>��� try {</para>
      <para>����� BufferedReader in4 =</para>
      <para>������� new BufferedReader(</para>
      <para>��������� new StringReader(s2));</para>
      <para>����� PrintWriter out1 =</para>
      <para>������� new PrintWriter(</para>
      <para>��������� new BufferedWriter(</para>
      <para>����������� new FileWriter(&quot;IODemo.out&quot;)));</para>
      <para>����� int lineCount = 1;</para>
      <para>����� while((s = in4.readLine()) != null )</para>
      <para>������� out1.println(lineCount++ + &quot;: &quot; + s);</para>
      <para>����� out1.close();</para>
      <para>��� } catch(EOFException e) {</para>
      <para>����� System.err.println(&quot;End of stream&quot;);</para>
      <para>��� }</para>
      <para> </para>
      <para>��� // 5. Storing &amp; recovering data</para>
      <para>��� try {</para>
      <para>����� DataOutputStream out2 =</para>
      <para>������� new DataOutputStream(</para>
      <para>��������� new BufferedOutputStream(</para>
      <para>����������� new FileOutputStream(&quot;Data.txt&quot;)));</para>
      <para>����� out2.writeDouble(3.14159);</para>
      <para>����� out2.writeChars(&quot;That was pi\n&quot;);</para>
      <para>����� out2.writeBytes(&quot;That was pi\n&quot;);</para>
      <para>����� out2.close();</para>
      <para>����� DataInputStream in5 =</para>
      <para>������� new DataInputStream(</para>
      <para>��������� new BufferedInputStream(</para>
      <para>����������� new FileInputStream(&quot;Data.txt&quot;)));</para>
      <para>����� BufferedReader in5br =</para>
      <para>������� new BufferedReader(</para>
      <para>��������� new InputStreamReader(in5));</para>
      <para>����� // Must use DataInputStream for data:</para>
      <para>����� System.out.println(in5.readDouble());</para>
      <para>����� // Can now use the &quot;proper&quot; readLine():</para>
      <para>����� System.out.println(in5br.readLine());</para>
      <para>����� // But the line comes out funny.</para>
      <para>����� // The one created with writeBytes is OK:</para>
      <para>����� System.out.println(in5br.readLine());</para>
      <para>��� } catch(EOFException e) {</para>
      <para>����� System.err.println(&quot;End of stream&quot;);</para>
      <para>��� }</para>
      <para> </para>
      <para>��� // 6. Reading/writing random access files</para>
      <para>��� RandomAccessFile rf =</para>
      <para>����� new RandomAccessFile(&quot;rtest.dat&quot;, &quot;rw&quot;);</para>
      <para>��� for(int i = 0; i &lt; 10; i++)</para>
      <para>����� rf.writeDouble(i*1.414);</para>
      <para>��� rf.close();</para>
      <para> </para>
      <para>��� rf =</para>
      <para>����� new RandomAccessFile(&quot;rtest.dat&quot;, &quot;rw&quot;);</para>
      <para>��� rf.seek(5*8);</para>
      <para>��� rf.writeDouble(47.0001);</para>
      <para>��� rf.close();</para>
      <para> </para>
      <para>��� rf =</para>
      <para>����� new RandomAccessFile(&quot;rtest.dat&quot;, &quot;r&quot;);</para>
      <para>��� for(int i = 0; i &lt; 10; i++)</para>
      <para>����� System.out.println(</para>
      <para>������� &quot;Value &quot; + i + &quot;: &quot; +</para>
      <para>������� rf.readDouble());</para>
      <para>��� rf.close();</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Here are the descriptions for the numbered sections of the program:</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064750"/><anchor xreflabel="Input
streams" xml:id="_Toc375545394"/>Input streams</title>
        <para>Parts 1 through 4 demonstrate the creation and use of input streams. Part 4 also shows the simple use of an output stream.</para>
        <section>
          <title>1. Buffered input file</title>
          <para>To open a file for character input, you use a <emphasis role="bold">FileInputReader</emphasis> with a <emphasis role="bold">String</emphasis> or a <emphasis role="bold">File</emphasis> object as the file name. For speed, you�ll want that file to be buffered so you give the resulting reference to the constructor for a <emphasis role="bold">BufferedReader</emphasis>. Since <emphasis role="bold">BufferedReader</emphasis> also provides the <emphasis role="bold">readLine( )</emphasis> method, this is your final object and the interface you read from. When you reach the end of the file, <emphasis role="bold">readLine( )</emphasis> returns <emphasis role="bold">null</emphasis> so that is used to break out of the <emphasis role="bold">while</emphasis> loop.</para>
          <para>The <emphasis role="bold">String s2</emphasis> is used to accumulate the entire contents of the file (including newlines that must be added since <emphasis role="bold">readLine( )</emphasis> strips them off). <emphasis role="bold">s2 </emphasis>is then used in the later portions of this program. Finally, <emphasis role="bold">close( )</emphasis> is called to close the file. Technically, <emphasis role="bold">close( )</emphasis> will be called when <emphasis role="bold">finalize( )</emphasis> runs, and this is supposed to happen (whether or not garbage collection occurs) as the program exits. However, this has been inconsistently implemented, so the only safe approach is to explicitly call <emphasis role="bold">close( )</emphasis> for files.</para>
          <para>Section 1b shows how you can wrap <emphasis role="bold">System.in</emphasis> for reading console input. <emphasis role="bold">System.in</emphasis> is a <emphasis role="bold">DataInputStream</emphasis> and <emphasis role="bold">BufferedReader</emphasis> needs a <emphasis role="bold">Reader</emphasis> argument, so <emphasis role="bold">InputStreamReader</emphasis> is brought in to perform the translation.</para>
        </section>
        <section>
          <title>2. Input from memory</title>
          <para>This section takes the <emphasis role="bold">String s2</emphasis> that now contains the entire contents of the file and uses it to create a <emphasis role="bold">StringReader</emphasis>. Then <emphasis role="bold">read( )</emphasis> is used to read each character one at a time and send it out to the console. Note that <emphasis role="bold">read( )</emphasis> returns the next byte as an <emphasis role="bold">int</emphasis> and thus it must be cast to a <emphasis role="bold">char</emphasis> to print properly.</para>
        </section>
        <section>
          <title>3. Formatted memory input</title>
          <para>To read �formatted� data, you use a <emphasis role="bold">DataInputStream</emphasis>, which is a <emphasis role="bold">byte</emphasis>-oriented I/O class (rather than <emphasis role="bold">char</emphasis> oriented). Thus you must use all <emphasis role="bold">InputStream</emphasis> classes rather than <emphasis role="bold">Reader</emphasis> classes. Of course, you can read anything (such as a file) as bytes using <emphasis role="bold">InputStream</emphasis> classes, but here a <emphasis role="bold">String</emphasis> is used. To convert the <emphasis role="bold">String</emphasis> to an array of bytes, which is what is appropriate for a <emphasis role="bold">ByteArrayInputStream</emphasis>, <emphasis role="bold">String</emphasis> has a <emphasis role="bold">getBytes( )</emphasis> method to do the job. At that point, you have an appropriate <emphasis role="bold">InputStream</emphasis> to hand to <emphasis role="bold">DataInputStream</emphasis>.</para>
          <para>If you read the characters from a <emphasis role="bold">DataInputStream </emphasis>one byte at a time using <emphasis role="bold">readByte( )</emphasis>, any byte value is a legitimate result so the return value cannot be used to detect the end of input. Instead, you can use the <emphasis role="bold">available( ) </emphasis>method to find out how many more characters are available. Here�s an example that shows how to read a file one byte at a time:</para>
          <para>//: c11:TestEOF.java</para>
          <para>// Testing for the end of file </para>
          <para>// while reading a byte at a time.</para>
          <para>import java.io.*;</para>
          <para> </para>
          <para>public class TestEOF {</para>
          <para>� // Throw exceptions to console:</para>
          <para>� public static void main(String[] args) </para>
          <para>� throws IOException {</para>
          <para>��� DataInputStream in = </para>
          <para>����� new DataInputStream(</para>
          <para>������ new BufferedInputStream(</para>
          <para>������� new FileInputStream(&quot;TestEof.java&quot;)));</para>
          <para>��� while(in.available() != 0)</para>
          <para>����� System.out.print((char)in.readByte());</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>Note that <emphasis role="bold">available( )</emphasis> works differently depending on what sort of medium you�re reading from; it�s literally �the number of bytes that can be read <emphasis role="italic">without blocking</emphasis>.��With a file this means the whole file, but with a different kind of stream this might not be true, so use it thoughtfully.</para>
          <para>You could also detect the end of input in cases like these by catching an exception. However, the use of exceptions for control flow is considered a misuse of that feature.</para>
        </section>
        <section>
          <title>4. File output</title>
          <para>This example also shows how to write data to a file. First, a <emphasis role="bold">FileWriter</emphasis> is created to connect to the file. You�ll virtually always want to buffer the output by wrapping it in a <emphasis role="bold">BufferedWriter</emphasis> (try removing this wrapping to see the impact on the performance�buffering tends to dramatically increase performance of I/O operations). Then for the formatting it�s turned into a <emphasis role="bold">PrintWriter</emphasis>. The data file created this way is readable as an ordinary text file.</para>
          <para>As the lines are written to the file, line numbers are added. Note that <emphasis role="bold">LineNumberInputStream</emphasis> is <emphasis role="italic">not</emphasis> used, because it�s a silly class and you don�t need it. As shown here, it�s trivial to keep track of your own line numbers.</para>
          <para>When the input stream is exhausted, <emphasis role="bold">readLine( )</emphasis> returns <emphasis role="bold">null</emphasis>. You�ll see an explicit <emphasis role="bold">close( )</emphasis> for <emphasis role="bold">out1</emphasis>, because if you don�t call <emphasis role="bold">close( )</emphasis> for all your output files, you might discover that the buffers don�t get flushed so they�re incomplete.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064751"/><anchor xreflabel="Output
streams" xml:id="_Toc375545395"/>Output streams</title>
        <para>The two primary kinds of output streams are separated by the way they write data: one writes it for human consumption, and the other writes it to be reacquired by a <emphasis role="bold">DataInputStream</emphasis>. The <emphasis role="bold">RandomAccessFile</emphasis> stands alone, although its data format is compatible with the <emphasis role="bold">DataInputStream</emphasis> and <emphasis role="bold">DataOutputStream</emphasis>.</para>
        <section>
          <title>5. Storing and recovering data</title>
          <para>A <emphasis role="bold">PrintWriter</emphasis> formats data so it�s readable by a human. However, to output data so that it can be recovered by another stream, you use a <emphasis role="bold">DataOutputStream</emphasis> to write the data and a <emphasis role="bold">DataInputStream</emphasis> to recover the data. Of course, these streams could be anything, but here a file is used, buffered for both reading and writing. <emphasis role="bold">DataOutputStream</emphasis> and <emphasis role="bold">DataInputStream</emphasis> are <emphasis role="bold">byte</emphasis>-oriented and thus require the <emphasis role="bold">InputStream</emphasis>s and <emphasis role="bold">OutputStream</emphasis>s.</para>
          <para>If you use a <emphasis role="bold">DataOutputStream</emphasis> to write the data, then Java guarantees that you can accurately recover the data using a <emphasis role="bold">DataInputStream</emphasis>�regardless of what different platforms write and read the data. This is incredibly valuable, as anyone knows who has spent time worrying about platform-specific data issues. That problem vanishes if you have Java on both platforms<anchor xreflabel="[58]" xml:id="_ftnref58"/>[58].</para>
          <para>Note that the character string is written using both <emphasis role="bold">writeChars( ) </emphasis>and <emphasis role="bold">writeBytes( )</emphasis>. When you run the program, you�ll discover that <emphasis role="bold">writeChars( )</emphasis> outputs 16-bit Unicode characters. When you read the line using <emphasis role="bold">readLine( )</emphasis>, you�ll see that there is a space between each character, because of the extra byte inserted by Unicode. Since there is no complementary �readChars� method in <emphasis role="bold">DataInputStream</emphasis>, you�re stuck pulling these characters off one at a time with <emphasis role="bold">readChar( )</emphasis>. So for ASCII, it�s easier to write the characters as bytes followed by a newline; then use <emphasis role="bold">readLine( )</emphasis> to read back the bytes as a regular ASCII line.</para>
          <para>The <emphasis role="bold">writeDouble( )</emphasis> stores the <emphasis role="bold">double</emphasis> number to the stream and the complementary <emphasis role="bold">readDouble( )</emphasis> recovers it (there are similar methods for reading and writing the other types). But for any of the reading methods to work correctly, you must know the exact placement of the data item in the stream, since it would be equally possible to read the stored <emphasis role="bold">double</emphasis> as a simple sequence of bytes, or as a <emphasis role="bold">char</emphasis>, etc. So you must either have a fixed format for the data in the file or extra information must be stored in the file that you parse to determine where the data is located.</para>
        </section>
        <section>
          <title>6. Reading and writing random access files</title>
          <para>As previously noted, the <emphasis role="bold">RandomAccessFile</emphasis> is almost totally isolated from the rest of the I/O hierarchy, save for the fact that it implements the <emphasis role="bold">DataInput</emphasis> and <emphasis role="bold">DataOutput</emphasis> interfaces. So you cannot combine it with any of the aspects of the <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis> subclasses. Even though it might make sense to treat a <emphasis role="bold">ByteArrayInputStream</emphasis> as a random access element, you can use <emphasis role="bold">RandomAccessFile</emphasis> to only open a file. You must assume a <emphasis role="bold">RandomAccessFile</emphasis> is properly buffered since you cannot add that.</para>
          <para>The one option you have is in the second constructor argument: you can open a <emphasis role="bold">RandomAccessFile</emphasis> to read (<emphasis role="bold">�r�</emphasis>) or read and write (<emphasis role="bold">�rw�</emphasis>).</para>
          <para>Using a <emphasis role="bold">RandomAccessFile</emphasis> is like using a combined <emphasis role="bold">DataInputStream</emphasis> and <emphasis role="bold">DataOutputStream</emphasis> (because it implements the equivalent interfaces). In addition, you can see that <emphasis role="bold">seek( )</emphasis> is used to move about in the file and change one of the values.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="A bug?" xml:id="_Toc481064752"/>A bug?</title>
        <para>If you look at section 5, you�ll see that the data is written <emphasis role="italic">before</emphasis> the text. That�s because a problem was introduced in Java 1.1 (and persists in Java 2) that sure seems like a bug to me, but I reported it and the bug people at JavaSoft said that this is the way it is supposed to work (however, the problem did <emphasis role="italic">not</emphasis> occur in Java 1.0, which makes me suspicious). The problem is shown in the following code:</para>
        <para>//: c11:IOProblem.java</para>
        <para>// Java 1.1 and higher I/O Problem.</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>public class IOProblem {</para>
        <para>� // Throw exceptions to console:</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws IOException {</para>
        <para>��� DataOutputStream out =</para>
        <para>����� new DataOutputStream(</para>
        <para>������� new BufferedOutputStream(</para>
        <para>��������� new FileOutputStream(&quot;Data.txt&quot;)));</para>
        <para>��� out.writeDouble(3.14159);</para>
        <para>��� out.writeBytes(&quot;That was the value of pi\n&quot;);</para>
        <para>��� out.writeBytes(&quot;This is pi/2:\n&quot;);</para>
        <para>��� out.writeDouble(3.14159/2);</para>
        <para>��� out.close();</para>
        <para> </para>
        <para>��� DataInputStream in =</para>
        <para>����� new DataInputStream(</para>
        <para>������� new BufferedInputStream(</para>
        <para>��������� new FileInputStream(&quot;Data.txt&quot;)));</para>
        <para>��� BufferedReader inbr =</para>
        <para>����� new BufferedReader(</para>
        <para>������� new InputStreamReader(in));</para>
        <para>��� // The doubles written BEFORE the line of text</para>
        <para>��� // read back correctly:</para>
        <para>��� System.out.println(in.readDouble());</para>
        <para>��� // Read the lines of text:</para>
        <para>��� System.out.println(inbr.readLine());</para>
        <para>��� System.out.println(inbr.readLine());</para>
        <para>��� // Trying to read the doubles after the line</para>
        <para>��� // produces an end-of-file exception:</para>
        <para>��� System.out.println(in.readDouble());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>It appears that anything you write after a call to <emphasis role="bold">writeBytes( )</emphasis> is not recoverable. The answer is apparently the same as the answer to the old vaudeville joke: �Doc, it hurts when I do this!� �Don�t do that!�</para>
      </section>
      <section>
        <title><anchor xreflabel="Piped streams" xml:id="_Toc481064753"/>Piped streams</title>
        <para>The <emphasis role="bold">PipedInputStream</emphasis>, <emphasis role="bold">PipedOutputStream</emphasis>, <emphasis role="bold">PipedReader</emphasis> and <emphasis role="bold">PipedWriter</emphasis> have been mentioned only briefly in this chapter. This is not to suggest that they aren�t useful, but their value is not apparent until you begin to understand multithreading, since the piped streams are used to communicate between threads. This is covered along with an example in Chapter 14.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Standard I/O" xml:id="_Toc481064754"/>Standard I/O</title>
      <para>The term <emphasis role="italic">standard I/O</emphasis> refers to the Unix concept (which is reproduced in some form in Windows and many other operating systems) of a single stream of information that is used by a program. All the program�s input can come from <emphasis role="italic">standard input</emphasis>, all its output can go to <emphasis role="italic">standard output</emphasis>, and all of its error messages can be sent to <emphasis role="italic">standard error</emphasis>. The value of standard I/O is that programs can easily be chained together and one program�s standard output can become the standard input for another program. This is a powerful tool.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545397"/><anchor xreflabel="Reading
from standard input" xml:id="_Toc481064755"/>Reading from standard input</title>
        <para>Following the standard I/O model, Java has <emphasis role="bold">System.in</emphasis>, <emphasis role="bold">System.out,</emphasis> and <emphasis role="bold">System.err</emphasis>. Throughout this book you�ve seen how to write to standard output using <emphasis role="bold">System.out,</emphasis> which is already prewrapped as a <emphasis role="bold">PrintStream</emphasis> object. <emphasis role="bold">System.err</emphasis> is likewise a <emphasis role="bold">PrintStream</emphasis>, but <emphasis role="bold">System.in</emphasis> is a raw <emphasis role="bold">InputStream</emphasis>, with no wrapping. This means that while you can use <emphasis role="bold">System.out</emphasis> and <emphasis role="bold">System.err</emphasis> right away, <emphasis role="bold">System.in</emphasis> must be wrapped before you can read from it.</para>
        <para>Typically, you�ll want to read input a line at a time using <emphasis role="bold">readLine( )</emphasis>, so you�ll want to wrap <emphasis role="bold">System.in</emphasis> in a <emphasis role="bold">BufferedReader</emphasis>. To do this, you must convert <emphasis role="bold">System.in </emphasis>to a <emphasis role="bold">Reader</emphasis> using <emphasis role="bold">InputStreamReader</emphasis>. Here�s an example that simply echoes each line that you type in:</para>
        <para>//: c11:Echo.java</para>
        <para>// How to read from standard input.</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>public class Echo {</para>
        <para>� public static void main(String[] args)</para>
        <para>� throws IOException {</para>
        <para>��� BufferedReader in =</para>
        <para>��� ����new BufferedReader(</para>
        <para>��������� new InputStreamReader(System.in));</para>
        <para>��� String s;</para>
        <para>��� while((s = in.readLine()).length() != 0)</para>
        <para>����� System.out.println(s);</para>
        <para>��� // An empty line terminates the program</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The reason for the exception specification is that <emphasis role="bold">readLine( )</emphasis> can throw an <emphasis role="bold">IOException</emphasis>. Note that <emphasis role="bold">System.in</emphasis> should usually be buffered, as with most streams.</para>
      </section>
      <section>
        <title><anchor xreflabel="Changing System.out to a PrintWriter" xml:id="_Toc481064756"/>Changing <emphasis role="bold">System.out</emphasis> to a <emphasis role="bold">PrintWriter</emphasis></title>
        <para><emphasis role="bold">System.out</emphasis> is a <emphasis role="bold">PrintStream</emphasis>, which is an <emphasis role="bold">OutputStream</emphasis>.<emphasis role="bold"> PrintWriter</emphasis> has a constructor that takes an <emphasis role="bold">OutputStream</emphasis> as an argument. Thus, if you want you can convert <emphasis role="bold">System.out</emphasis> into a <emphasis role="bold">PrintWriter</emphasis> using that constructor:</para>
        <para>//: c11:ChangeSystemOut.java</para>
        <para>// Turn System.out into a PrintWriter.</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>public class ChangeSystemOut {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� PrintWriter out = </para>
        <para>����� new PrintWriter(System.out, true);</para>
        <para>��� out.println(&quot;Hello, world&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>It�s important to use the two-argument version of the <emphasis role="bold">PrintWriter</emphasis> constructor and to set the second argument to <emphasis role="bold">true</emphasis> in order to enable automatic flushing, otherwise you may not see the output.</para>
      </section>
      <section>
        <title><anchor xreflabel="Redirecting standard I/O" xml:id="_Toc481064757"/>Redirecting standard I/O</title>
        <para>The Java <emphasis role="bold">System</emphasis> class allows you to redirect the standard input, output, and error I/O streams using simple static method calls:</para>
        <para><emphasis role="bold">setIn(InputStream)  </emphasis><emphasis role="bold">setOut(PrintStream) </emphasis><emphasis role="bold">setErr(PrintStream) </emphasis></para>
        <para>Redirecting output is especially useful if you suddenly start creating a large amount of output on your screen and it�s scrolling past faster than you can read it.<anchor xreflabel="[59]" xml:id="_ftnref59"/>[59] Redirecting input is valuable for a command-line program in which you want to test a particular user-input sequence repeatedly. Here�s a simple example that shows the use of these methods:</para>
        <para>//: c11:Redirecting.java</para>
        <para>// Demonstrates standard I/O redirection.</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>class Redirecting {</para>
        <para>� // Throw exceptions to console:</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws IOException {</para>
        <para>��� BufferedInputStream in = </para>
        <para>����� new BufferedInputStream(</para>
        <para>������� new FileInputStream(</para>
        <para>��������� &quot;Redirecting.java&quot;));</para>
        <para>��� PrintStream out =</para>
        <para>����� new PrintStream(</para>
        <para>������� new BufferedOutputStream(</para>
        <para>��������� new FileOutputStream(&quot;test.out&quot;)));</para>
        <para>��� System.setIn(in);</para>
        <para>��� System.setOut(out);</para>
        <para>��� System.setErr(out);</para>
        <para> </para>
        <para>��� BufferedReader br = </para>
        <para>����� new BufferedReader(</para>
        <para>������� new InputStreamReader(System.in));</para>
        <para>��� String s;</para>
        <para>��� while((s = br.readLine()) != null)</para>
        <para>����� System.out.println(s);</para>
        <para>��� out.close(); // Remember this!</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This program attaches standard input to a file, and redirects standard output and standard error to another file.</para>
        <para>I/O redirection manipulates streams of bytes, not streams of characters, thus <emphasis role="bold">InputStream</emphasis>s and <emphasis role="bold">OutputStream</emphasis>s are used rather than <emphasis role="bold">Reader</emphasis>s and <emphasis role="bold">Writer</emphasis>s.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545400"/><anchor xreflabel="Compression" xml:id="_Toc481064758"/>Compression</title>
      <para>The Java I/O library contains classes to support reading and writing streams in a compressed format. These are wrapped around existing I/O classes to provide compression functionality.</para>
      <para>These classes are not derived from the <emphasis role="bold">Reader</emphasis> and <emphasis role="bold">Writer</emphasis> classes, but instead are part of the <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis> hierarchies. This is because the compression library works with bytes, not characters. However, you might sometimes be forced to mix the two types of streams. (Remember that you can use <emphasis role="bold">InputStreamReader</emphasis> and <emphasis role="bold">OutputStreamWriter</emphasis> to provide easy conversion between one type and another.) </para>
      <informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="19*"/>
          <colspec colname="c2" colwidth="28*"/>
          <thead>
            <row>
              <entry valign="top"><para> Compression class</para></entry>
              <entry valign="top"><para> Function</para></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry valign="top"><para> CheckedInputStream</para></entry>
              <entry valign="top"><para> GetCheckSum( ) produces checksum for any InputStream (not just decompression).</para></entry>
            </row>
            <row>
              <entry valign="top"><para> CheckedOutputStream</para></entry>
              <entry valign="top"><para> GetCheckSum( ) produces checksum for any OutputStream (not just compression).</para></entry>
            </row>
            <row>
              <entry valign="top"><para> DeflaterOutputStream</para></entry>
              <entry valign="top"><para> Base class for compression classes.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> ZipOutputStream</para></entry>
              <entry valign="top"><para> A DeflaterOutputStream that compresses data into the Zip file format.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> GZIPOutputStream</para></entry>
              <entry valign="top"><para> A DeflaterOutputStream that compresses data into the GZIP file format.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> InflaterInputStream</para></entry>
              <entry valign="top"><para> Base class for decompression classes.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> ZipInputStream</para></entry>
              <entry valign="top"><para> An InflaterInputStream that decompresses data that has been stored in the Zip file format.</para></entry>
            </row>
            <row>
              <entry valign="top"><para> GZIPInputStream</para></entry>
              <entry valign="top"><para> An InflaterInputStream that decompresses data that has been stored in the GZIP file format.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Although there are many compression algorithms, Zip and GZIP are possibly the most commonly used. Thus you can easily manipulate your compressed data with the many tools available for reading and writing these formats.</para>
      <section>
        <title><anchor xreflabel="Simple compression with GZIP" xml:id="_Toc481064759"/>Simple compression with GZIP</title>
        <para>The GZIP interface is simple and thus is probably more appropriate when you have a single stream of data that you want to compress (rather than a container of dissimilar pieces of data). Here�s an example that compresses a single file:</para>
        <para>//: c11:GZIPcompress.java</para>
        <para>// Uses GZIP compression to compress a file </para>
        <para>// whose name is passed on the command line.</para>
        <para>import java.io.*;</para>
        <para>import java.util.zip.*;</para>
        <para> </para>
        <para>public class GZIPcompress {</para>
        <para>� // Throw exceptions to console:</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws IOException {</para>
        <para>��� BufferedReader in =</para>
        <para>����� new BufferedReader(</para>
        <para>������� new FileReader(args[0]));</para>
        <para>��� BufferedOutputStream out =</para>
        <para>����� new BufferedOutputStream(</para>
        <para>������� new GZIPOutputStream(</para>
        <para>��������� new FileOutputStream(&quot;test.gz&quot;)));</para>
        <para>��� System.out.println(&quot;Writing file&quot;);</para>
        <para>��� int c;</para>
        <para>��� while((c = in.read()) != -1)</para>
        <para>����� out.write(c);</para>
        <para>��� in.close();</para>
        <para>��� out.close();</para>
        <para>��� System.out.println(&quot;Reading file&quot;);</para>
        <para>��� BufferedReader in2 =</para>
        <para>����� new BufferedReader(</para>
        <para>������� new InputStreamReader(</para>
        <para>��������� new GZIPInputStream(</para>
        <para>����������� new FileInputStream(&quot;test.gz&quot;))));</para>
        <para>��� String s;</para>
        <para>��� while((s = in2.readLine()) != null)</para>
        <para>����� System.out.println(s);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The use of the compression classes is straightforward�you simply wrap your output stream in a <emphasis role="bold">GZIPOutputStream</emphasis> or <emphasis role="bold">ZipOutputStream</emphasis> and your input stream in a <emphasis role="bold">GZIPInputStream</emphasis> or <emphasis role="bold">ZipInputStream</emphasis>. All else is ordinary I/O reading and writing. This is an example of mixing the <emphasis role="bold">char</emphasis>-oriented streams with the <emphasis role="bold">byte</emphasis>-oriented streams: <emphasis role="bold">in</emphasis> uses the <emphasis role="bold">Reader</emphasis> classes, whereas <emphasis role="bold">GZIPOutputStream</emphasis>�s constructor can accept only an <emphasis role="bold">OutputStream</emphasis> object, not a <emphasis role="bold">Writer</emphasis> object. When the file is opened, the <emphasis role="bold">GZIPInputStream</emphasis> is converted to a <emphasis role="bold">Reader</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="Multifile storage with Zip" xml:id="_Toc481064760"/>Multifile storage with Zip</title>
        <para>The library that supports the Zip format is much more extensive. With it you can easily store multiple files, and there�s even a separate class to make the process of reading a Zip file easy. The library uses the standard Zip format so that it works seamlessly with all the tools currently downloadable on the Internet. The following example has the same form as the previous example, but it handles as many command-line arguments as you want. In addition, it shows the use of the <emphasis role="bold">Checksum</emphasis> classes to calculate and verify the checksum for the file. There are two <emphasis role="bold">Checksum</emphasis> types: <emphasis role="bold">Adler32</emphasis> (which is faster) and <emphasis role="bold">CRC32</emphasis> (which is slower but slightly more accurate).</para>
        <para>//: c11:ZipCompress.java</para>
        <para>// Uses Zip compression to compress any </para>
        <para>// number of files given on the command line.</para>
        <para>import java.io.*;</para>
        <para>import java.util.*;</para>
        <para>import java.util.zip.*;</para>
        <para> </para>
        <para>public class ZipCompress {</para>
        <para>� // Throw exceptions to console:</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws IOException {</para>
        <para>��� FileOutputStream f =</para>
        <para>����� new FileOutputStream(&quot;test.zip&quot;);</para>
        <para>��� CheckedOutputStream csum =</para>
        <para>����� new CheckedOutputStream(</para>
        <para>������� f, new Adler32());</para>
        <para>��� ZipOutputStream out =</para>
        <para>����� new ZipOutputStream(</para>
        <para>������� new BufferedOutputStream(csum));</para>
        <para>��� out.setComment(&quot;A test of Java Zipping&quot;);</para>
        <para>��� // No corresponding getComment(), though.</para>
        <para>��� for(int i = 0; i &lt; args.length; i++) {</para>
        <para>����� System.out.println(</para>
        <para>������� &quot;Writing file &quot; + args[i]);</para>
        <para>����� BufferedReader in =</para>
        <para>������� new BufferedReader(</para>
        <para>��������� new FileReader(args[i]));</para>
        <para>����� out.putNextEntry(new ZipEntry(args[i]));</para>
        <para>����� int c;</para>
        <para>����� while((c = in.read()) != -1)</para>
        <para>������� out.write(c);</para>
        <para>����� in.close();</para>
        <para>��� }</para>
        <para>��� out.close();</para>
        <para>��� // Checksum valid only after the file</para>
        <para>��� // has been closed!</para>
        <para>��� System.out.println(&quot;Checksum: &quot; +</para>
        <para>����� csum.getChecksum().getValue());</para>
        <para>��� // Now extract the files:</para>
        <para>��� System.out.println(&quot;Reading file&quot;);</para>
        <para>��� FileInputStream fi =</para>
        <para>������ new FileInputStream(&quot;test.zip&quot;);</para>
        <para>��� CheckedInputStream csumi =</para>
        <para>����� new CheckedInputStream(</para>
        <para>������� fi, new Adler32());</para>
        <para>��� ZipInputStream in2 =</para>
        <para>����� new ZipInputStream(</para>
        <para>������� new BufferedInputStream(csumi));</para>
        <para>��� ZipEntry ze;</para>
        <para>��� while((ze = in2.getNextEntry()) != null) {</para>
        <para>����� System.out.println(&quot;Reading file &quot; + ze);</para>
        <para>����� int x;</para>
        <para>����� while((x = in2.read()) != -1)</para>
        <para>������� System.out.write(x);</para>
        <para>��� }</para>
        <para>��� System.out.println(&quot;Checksum: &quot; +</para>
        <para>����� csumi.getChecksum().getValue());</para>
        <para>��� in2.close();</para>
        <para>��� // Alternative way to open and read</para>
        <para>��� // zip files:</para>
        <para>��� ZipFile zf = new ZipFile(&quot;test.zip&quot;);</para>
        <para>��� Enumeration e = zf.entries();</para>
        <para>��� while(e.hasMoreElements()) {</para>
        <para>����� ZipEntry ze2 = (ZipEntry)e.nextElement();</para>
        <para>����� System.out.println(&quot;File: &quot; + ze2);</para>
        <para>����� // ... and extract the data as before</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>For each file to add to the archive, you must call <emphasis role="bold">putNextEntry( ) </emphasis>and pass it a <emphasis role="bold">ZipEntry </emphasis>object. The <emphasis role="bold">ZipEntry</emphasis> object contains an extensive interface that allows you to get and set all the data available on that particular entry in your Zip file: name, compressed and uncompressed sizes, date, CRC checksum, extra field data, comment, compression method, and whether it�s a directory entry. However, even though the Zip format has a way to set a password, this is not supported in Java�s Zip library. And although <emphasis role="bold">CheckedInputStream</emphasis> and <emphasis role="bold">CheckedOutputStream</emphasis> support both <emphasis role="bold">Adler32</emphasis> and <emphasis role="bold">CRC32</emphasis> checksums, the <emphasis role="bold">ZipEntry</emphasis> class supports only an interface for CRC. This is a restriction of the underlying Zip format, but it might limit you from using the faster <emphasis role="bold">Adler32</emphasis>.</para>
        <para>To extract files, <emphasis role="bold">ZipInputStream</emphasis> has a <emphasis role="bold">getNextEntry( )</emphasis> method that returns the next <emphasis role="bold">ZipEntry</emphasis> if there is one. As a more succinct alternative, you can read the file using a <emphasis role="bold">ZipFile</emphasis> object, which has a method <emphasis role="bold">entries( ) </emphasis>to return an <emphasis role="bold">Enumeration</emphasis> to the <emphasis role="bold">ZipEntries</emphasis>.</para>
        <para>In order to read the checksum you must somehow have access to the associated <emphasis role="bold">Checksum</emphasis> object. Here, a reference to the <emphasis role="bold">CheckedOutputStream</emphasis> and <emphasis role="bold">CheckedInputStream</emphasis> objects is retained, but you could also just hold onto a reference to the <emphasis role="bold">Checksum</emphasis> object.</para>
        <para>A baffling method in Zip streams is <emphasis role="bold">setComment( )</emphasis>. As shown above, you can set a comment when you�re writing a file, but there�s no way to recover the comment in the <emphasis role="bold">ZipInputStream</emphasis>. Comments appear to be supported fully on an entry-by-entry basis only via <emphasis role="bold">ZipEntry</emphasis>.</para>
        <para>Of course, you are not limited to files when using the <emphasis role="bold">GZIP</emphasis> or <emphasis role="bold">Zip</emphasis> libraries�you can compress anything, including data to be sent through a network connection.</para>
      </section>
      <section>
        <title><anchor xreflabel="Java ARchives (JARs)" xml:id="_Toc481064761"/>Java ARchives (JARs)</title>
        <para>The Zip format is also used in the JAR (Java ARchive) file format, which is a way to collect a group of files into a single compressed file, just like Zip. However, like everything else in Java, JAR files are cross-platform so you don�t need to worry about platform issues. You can also include audio and image files as well as class files. </para>
        <para>JAR files are particularly helpful when you deal with the Internet. Before JAR files, your Web browser would have to make repeated requests of a Web server in order to download all of the files that make up an applet. In addition, each of these files was uncompressed. By combining all of the files for a particular applet into a single JAR file, only one server request is necessary and the transfer is faster because of compression. And each entry in a JAR file can be digitally signed for security (refer to the Java documentation for details).</para>
        <para>A JAR file consists of a single file containing a collection of zipped files along with a �manifest� that describes them. (You can create your own manifest file; otherwise the <emphasis role="bold">jar </emphasis>program will do it for you.) You can find out more about JAR manifests in the JDK HTML documentation.</para>
        <para>The <emphasis role="bold">jar</emphasis> utility that comes with Sun�s JDK automatically compresses the files of your choice. You invoke it on the command line:</para>
        <para>jar [options] destination [manifest] inputfile(s)</para>
        <para> </para>
        <para>The options are simply a collection of letters (no hyphen or any other indicator is necessary). Unix/Linux users will note the similarity to the <emphasis role="bold">tar </emphasis>options. These are:</para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="6*"/>
            <colspec colname="c2" colwidth="38*"/>
            <tbody>
              <row>
                <entry valign="top"><para> c </para></entry>
                <entry valign="top"><para> Creates a new or empty archive. </para></entry>
              </row>
              <row>
                <entry valign="top"><para> t </para></entry>
                <entry valign="top"><para> Lists the table of contents. </para></entry>
              </row>
              <row>
                <entry valign="top"><para> x</para></entry>
                <entry valign="top"><para> Extracts all files.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> x file</para></entry>
                <entry valign="top"><para> Extracts the named file.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> f</para></entry>
                <entry valign="top"><para> Says: �I�m going to give you the name of the file.� If you don�t use this, jar assumes that its input will come from standard input, or, if it is creating a file, its output will go to standard output.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> m</para></entry>
                <entry valign="top"><para> Says that the first argument will be the name of the user-created manifest file.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> v</para></entry>
                <entry valign="top"><para> Generates verbose output describing what jar is doing.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> 0</para></entry>
                <entry valign="top"><para> Only store the files; doesn�t compress the files (use to create a JAR file that you can put in your classpath).</para></entry>
              </row>
              <row>
                <entry valign="top"><para> M</para></entry>
                <entry valign="top"><para> Don�t automatically create a manifest file.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>If a subdirectory is included in the files to be put into the JAR file, that subdirectory is automatically added, including all of its subdirectories, etc. Path information is also preserved.</para>
        <para>Here are some typical ways to invoke <emphasis role="bold">jar</emphasis>:</para>
        <para>jar cf myJarFile.jar *.class</para>
        <para> </para>
        <para>This creates a JAR file called <emphasis role="bold">myJarFile.jar</emphasis> that contains all of the class files in the current directory, along with an automatically generated manifest file.</para>
        <para>jar cmf myJarFile.jar myManifestFile.mf *.class</para>
        <para> </para>
        <para>Like the previous example, but adding a user-created manifest file called <emphasis role="bold">myManifestFile.mf</emphasis>.</para>
        <para>jar tf myJarFile.jar</para>
        <para> </para>
        <para>Produces a table of contents of the files in <emphasis role="bold">myJarFile.jar</emphasis>.</para>
        <para>jar tvf myJarFile.jar</para>
        <para> </para>
        <para>Adds the �verbose� flag to give more detailed information about the files in <emphasis role="bold">myJarFile.jar</emphasis>.</para>
        <para>jar cvf myApp.jar audio classes image</para>
        <para> </para>
        <para>Assuming <emphasis role="bold">audio</emphasis>, <emphasis role="bold">classes,</emphasis> and <emphasis role="bold">image</emphasis> are subdirectories, this combines all of the subdirectories into the file <emphasis role="bold">myApp.jar</emphasis>. The �verbose� flag is also included to give extra feedback while the <emphasis role="bold">jar</emphasis> program is working.</para>
        <para>If you create a JAR file using the <emphasis role="bold">0</emphasis> option, that file can be placed in your CLASSPATH:</para>
        <para>CLASSPATH=&quot;lib1.jar;lib2.jar;&quot;</para>
        <para> </para>
        <para>Then Java can search <emphasis role="bold">lib1.jar</emphasis> and <emphasis role="bold">lib2.jar</emphasis> for class files.</para>
        <para>The <emphasis role="bold">jar</emphasis> tool isn�t as useful as a <emphasis role="bold">zip</emphasis> utility. For example, you can�t add or update files to an existing JAR file; you can create JAR files only from scratch. Also, you can�t move files into a JAR file, erasing them as they are moved. However, a JAR file created on one platform will be transparently readable by the <emphasis role="bold">jar</emphasis> tool on any other platform (a problem that sometimes plagues <emphasis role="bold">zip</emphasis> utilities).</para>
        <para>As you will see in Chapter 13, JAR files are also used to package JavaBeans.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Object serialization" xml:id="_Toc481064762"/>Object serialization</title>
      <para>Java�s <emphasis role="italic">object serialization</emphasis> allows you to take any object that implements the <emphasis role="bold">Serializable</emphasis> interface and turn it into a sequence of bytes that can later be fully restored to regenerate the original object. This is even true across a network, which means that the serialization mechanism automatically compensates for differences in operating systems. That is, you can create an object on a Windows machine, serialize it, and send it across the network to a Unix machine where it will be correctly reconstructed. You don�t have to worry about the data representations on the different machines, the byte ordering, or any other details.</para>
      <para>By itself, object serialization is interesting because it allows you to implement <emphasis role="italic">lightweight persistence</emphasis>. Remember that persistence means an object�s lifetime is not determined by whether a program is executing�the object lives <emphasis role="italic">in</emphasis><emphasis role="italic">between</emphasis> invocations of the program. By taking a serializable object and writing it to disk, then restoring that object when the program is reinvoked, you�re able to produce the effect of persistence. The reason it�s called �lightweight� is that you can�t simply define an object using some kind of �persistent� keyword and let the system take care of the details (although this might happen in the future). Instead, you must explicitly serialize and deserialize the objects in your program.</para>
      <para>Object serialization was added to the language to support two major features. Java�s <emphasis role="italic">remote method invocation</emphasis> (RMI) allows objects that live on other machines to behave as if they live on your machine. When sending messages to remote objects, object serialization is necessary to transport the arguments and return values. RMI is discussed in Chapter 15.</para>
      <para>Object serialization is also necessary for JavaBeans, described in Chapter 13. When a Bean is used, its state information is generally configured at design-time. This state information must be stored and later recovered when the program is started; object serialization performs this task.</para>
      <para>Serializing an object is quite simple, as long as the object implements the <emphasis role="bold">Serializable</emphasis> interface (this interface is just a flag and has no methods). When serialization was added to the language, many standard library classes were changed to make them serializable, including all of the wrappers for the primitive types, all of the container classes, and many others. Even <emphasis role="bold">Class</emphasis> objects can be serialized. (See Chapter 12 for the implications of this.)</para>
      <para>To serialize an object, you create some sort of <emphasis role="bold">OutputStream</emphasis> object and then wrap it inside an <emphasis role="bold">ObjectOutputStream</emphasis> object. At this point you need only call <emphasis role="bold">writeObject( )</emphasis> and your object is serialized and sent to the <emphasis role="bold">OutputStream</emphasis>. To reverse the process, you wrap an <emphasis role="bold">InputStream</emphasis> inside an <emphasis role="bold">ObjectInputStream</emphasis> and call <emphasis role="bold">readObject( )</emphasis>. What comes back is, as usual, a reference to an upcast <emphasis role="bold">Object</emphasis>, so you must downcast to set things straight.</para>
      <para>A particularly clever aspect of object serialization is that it not only saves an image of your object but it also follows all the references contained in your object and saves <emphasis role="italic">those </emphasis>objects, and follows all the references in each of those objects, etc. This is sometimes referred to as the �web of objects� that a single object can be connected to, and it includes arrays of references to objects as well as member objects. If you had to maintain your own object serialization scheme, maintaining the code to follow all these links would be a bit mind-boggling. However, Java object serialization seems to pull it off flawlessly, no doubt using an optimized algorithm that traverses the web of objects. The following example tests the serialization mechanism by making a �worm� of linked objects, each of which has a link to the next segment in the worm as well as an array of references to objects of a different class, <emphasis role="bold">Data</emphasis>:</para>
      <para>//: c11:Worm.java</para>
      <para>// Demonstrates object serialization.</para>
      <para>import java.io.*;</para>
      <para> </para>
      <para>class Data implements Serializable {</para>
      <para>� private int i;</para>
      <para>� Data(int x) { i = x; }</para>
      <para>� public String toString() {</para>
      <para>��� return Integer.toString(i);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class Worm implements Serializable {</para>
      <para>� // Generate a random int value:</para>
      <para>� private static int r() {</para>
      <para>��� return (int)(Math.random() * 10);</para>
      <para>� }</para>
      <para>� private Data[] d = {</para>
      <para>��� new Data(r()), new Data(r()), new Data(r())</para>
      <para>� };</para>
      <para>� private Worm next;</para>
      <para>� private char c;</para>
      <para>� // Value of i == number of segments</para>
      <para>� Worm(int i, char x) {</para>
      <para>��� System.out.println(&quot; Worm constructor: &quot; + i);</para>
      <para>��� c = x;</para>
      <para>��� if(--i &gt; 0)</para>
      <para>����� next = new Worm(i, (char)(x + 1));</para>
      <para>� }</para>
      <para>� Worm() {</para>
      <para>��� System.out.println(&quot;Default constructor&quot;);</para>
      <para>� }</para>
      <para>� public String toString() {</para>
      <para>��� String s = &quot;:&quot; + c + &quot;(&quot;;</para>
      <para>��� for(int i = 0; i &lt; d.length; i++)</para>
      <para>����� s += d[i].toString();</para>
      <para>��� s += &quot;)&quot;;</para>
      <para>��� if(next != null)</para>
      <para>����� s += next.toString();</para>
      <para>��� return s;</para>
      <para>� }</para>
      <para>� // Throw exceptions to console:</para>
      <para>� public static void main(String[] args) </para>
      <para>� throws ClassNotFoundException, IOException {</para>
      <para>��� Worm w = new Worm(6, &apos;a&apos;);</para>
      <para>��� System.out.println(&quot;w = &quot; + w);</para>
      <para>��� ObjectOutputStream out =</para>
      <para>����� new ObjectOutputStream(</para>
      <para>������� new FileOutputStream(&quot;worm.out&quot;));</para>
      <para>��� out.writeObject(&quot;Worm storage&quot;);</para>
      <para>��� out.writeObject(w);</para>
      <para>��� out.close(); // Also flushes output</para>
      <para>��� ObjectInputStream in =</para>
      <para>����� new ObjectInputStream(</para>
      <para>������� new FileInputStream(&quot;worm.out&quot;));</para>
      <para>��� String s = (String)in.readObject();</para>
      <para>��� Worm w2 = (Worm)in.readObject();</para>
      <para>��� System.out.println(s + &quot;, w2 = &quot; + w2);</para>
      <para>��� ByteArrayOutputStream bout =</para>
      <para>����� new ByteArrayOutputStream();</para>
      <para>��� ObjectOutputStream out2 =</para>
      <para>����� new ObjectOutputStream(bout);</para>
      <para>��� out2.writeObject(&quot;Worm storage&quot;);</para>
      <para>��� out2.writeObject(w);</para>
      <para>��� out2.flush();</para>
      <para>��� ObjectInputStream in2 =</para>
      <para>����� new ObjectInputStream(</para>
      <para>������� new ByteArrayInputStream(</para>
      <para>��������� bout.toByteArray()));</para>
      <para>��� s = (String)in2.readObject();</para>
      <para>��� Worm w3 = (Worm)in2.readObject();</para>
      <para>��� System.out.println(s + &quot;, w3 = &quot; + w3);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>To make things interesting, the array of <emphasis role="bold">Data</emphasis> objects inside <emphasis role="bold">Worm</emphasis> are initialized with random numbers. (This way you don�t suspect the compiler of keeping some kind of meta-information.) Each <emphasis role="bold">Worm</emphasis> segment is labeled with a <emphasis role="bold">char</emphasis> that�s automatically generated in the process of recursively generating the linked list of <emphasis role="bold">Worm</emphasis>s. When you create a <emphasis role="bold">Worm</emphasis>, you tell the constructor how long you want it to be. To make the <emphasis role="bold">next</emphasis> reference it calls the <emphasis role="bold">Worm</emphasis> constructor with a length of one less, etc. The final <emphasis role="bold">next</emphasis> reference is left as <emphasis role="bold">null</emphasis>, indicating the end of the <emphasis role="bold">Worm</emphasis>.</para>
      <para>The point of all this was to make something reasonably complex that couldn�t easily be serialized. The act of serializing, however, is quite simple. Once the <emphasis role="bold">ObjectOutputStream</emphasis> is created from some other stream, <emphasis role="bold">writeObject( )</emphasis> serializes the object. Notice the call to <emphasis role="bold">writeObject( )</emphasis> for a <emphasis role="bold">String</emphasis>, as well. You can also write all the primitive data types using the same methods as <emphasis role="bold">DataOutputStream</emphasis> (they share the same interface).</para>
      <para>There are two separate code sections that look similar. The first writes and reads a file and the second, for variety, writes and reads a <emphasis role="bold">ByteArray</emphasis>. You can read and write an object using serialization to any <emphasis role="bold">DataInputStream</emphasis> or <emphasis role="bold">DataOutputStream</emphasis> including, as you will see in the Chapter 15, a network. The output from one run was:</para>
      <para>Worm constructor: 6</para>
      <para>Worm constructor: 5</para>
      <para>Worm constructor: 4</para>
      <para>Worm constructor: 3</para>
      <para>Worm constructor: 2</para>
      <para>Worm constructor: 1</para>
      <para>w = :a(262):b(100):c(396):d(480):e(316):f(398)</para>
      <para>Worm storage, w2 = :a(262):b(100):c(396):d(480):e(316):f(398)</para>
      <para>Worm storage, w3 = :a(262):b(100):c(396):d(480):e(316):f(398)</para>
      <para> </para>
      <para>You can see that the deserialized object really does contain all of the links that were in the original object.</para>
      <para>Note that no constructor, not even the default constructor, is called in the process of deserializing a <emphasis role="bold">Serializable</emphasis> object. The entire object is restored by recovering data from the <emphasis role="bold">InputStream</emphasis>.</para>
      <para>Object serialization is <emphasis role="bold">byte</emphasis>-oriented, and thus uses the <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis> hierarchies.</para>
      <section>
        <title><anchor xreflabel="Finding the class" xml:id="_Toc481064763"/>Finding the class</title>
        <para>You might wonder what�s necessary for an object to be recovered from its serialized state. For example, suppose you serialize an object and send it as a file or through a network to another machine. Could a program on the other machine reconstruct the object using only the contents of the file?</para>
        <para>The best way to answer this question is (as usual) by performing an experiment. The following file goes in the subdirectory for this chapter:</para>
        <para>//: c11:Alien.java</para>
        <para>// A serializable class.</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>public class Alien implements Serializable {</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The file that creates and serializes an <emphasis role="bold">Alien </emphasis>object goes in the same directory:</para>
        <para>//: c11:FreezeAlien.java</para>
        <para>// Create a serialized output file.</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>public class FreezeAlien {</para>
        <para>� // Throw exceptions to console:</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws IOException {</para>
        <para>��� ObjectOutput out = </para>
        <para>����� new ObjectOutputStream(</para>
        <para>������� new FileOutputStream(&quot;X.file&quot;));</para>
        <para>��� Alien zorcon = new Alien();</para>
        <para>��� out.writeObject(zorcon); </para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Rather than catching and handling exceptions, this program takes the quick and dirty approach of passing the exceptions out of <emphasis role="bold">main( )</emphasis>, so they�ll be reported on the command line.</para>
        <para>Once the program is compiled and run, copy the resulting <emphasis role="bold">X.file</emphasis> to a subdirectory called <emphasis role="bold">xfiles</emphasis>, where the following code goes:</para>
        <para>//: c11:xfiles:ThawAlien.java</para>
        <para>// Try to recover a serialized file without the </para>
        <para>// class of object that&apos;s stored in that file.</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>public class ThawAlien {</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws IOException, ClassNotFoundException {</para>
        <para>��� ObjectInputStream in =</para>
        <para>����� new ObjectInputStream(</para>
        <para>������� new FileInputStream(&quot;X.file&quot;));</para>
        <para>��� Object mystery = in.readObject();</para>
        <para>��� System.out.println(mystery.getClass());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This program opens the file and reads in the object <emphasis role="bold">mystery</emphasis> successfully. However, as soon as you try to find out anything about the object�which requires the <emphasis role="bold">Class</emphasis> object for <emphasis role="bold">Alien</emphasis>�the Java Virtual Machine (JVM) cannot find <emphasis role="bold">Alien.class</emphasis> (unless it happens to be in the Classpath, which it shouldn�t be in this example). You�ll get a <emphasis role="bold">ClassNotFoundException.</emphasis> (Once again, all evidence of alien life vanishes before proof of its existence can be verified!)</para>
        <para>If you expect to do much after you�ve recovered an object that has been serialized, you must make sure that the JVM can find the associated <emphasis role="bold">.class</emphasis> file either in the local class path or somewhere on the Internet.</para>
      </section>
      <section>
        <title><anchor xreflabel="Controlling serialization" xml:id="_Toc481064764"/>Controlling serialization</title>
        <para>As you can see, the default serialization mechanism is trivial to use. But what if you have special needs? Perhaps you have special security issues and you don�t want to serialize portions of your object, or perhaps it just doesn�t make sense for one subobject to be serialized if that part needs to be created anew when the object is recovered.</para>
        <para>You can control the process of serialization by implementing the <emphasis role="bold">Externalizable</emphasis> interface instead of the <emphasis role="bold">Serializable</emphasis> interface. The <emphasis role="bold">Externalizable</emphasis> interface extends the <emphasis role="bold">Serializable</emphasis> interface and adds two methods, <emphasis role="bold">writeExternal( )</emphasis> and <emphasis role="bold">readExternal( ),</emphasis> that are automatically called for your object during serialization and deserialization so that you can perform your special operations.</para>
        <para>The following example shows simple implementations of the <emphasis role="bold">Externalizable</emphasis> interface methods. Note that <emphasis role="bold">Blip1</emphasis> and <emphasis role="bold">Blip2</emphasis> are nearly identical except for a subtle difference (see if you can discover it by looking at the code):</para>
        <para>//: c11:Blips.java</para>
        <para>// Simple use of Externalizable &amp; a pitfall.</para>
        <para>import java.io.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Blip1 implements Externalizable {</para>
        <para>� public Blip1() {</para>
        <para>��� System.out.println(&quot;Blip1 Constructor&quot;);</para>
        <para>� }</para>
        <para>� public void writeExternal(ObjectOutput out)</para>
        <para>����� throws IOException {</para>
        <para>��� System.out.println(&quot;Blip1.writeExternal&quot;);</para>
        <para>� }</para>
        <para>� public void readExternal(ObjectInput in)</para>
        <para>���� throws IOException, ClassNotFoundException {</para>
        <para>��� System.out.println(&quot;Blip1.readExternal&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Blip2 implements Externalizable {</para>
        <para>� Blip2() {</para>
        <para>��� System.out.println(&quot;Blip2 Constructor&quot;);</para>
        <para>� }</para>
        <para>� public void writeExternal(ObjectOutput out)</para>
        <para>����� throws IOException {</para>
        <para>��� System.out.println(&quot;Blip2.writeExternal&quot;);</para>
        <para>� }</para>
        <para>� public void readExternal(ObjectInput in)</para>
        <para>���� throws IOException, ClassNotFoundException {</para>
        <para>��� System.out.println(&quot;Blip2.readExternal&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Blips {</para>
        <para>� // Throw exceptions to console:</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws IOException, ClassNotFoundException {</para>
        <para>��� System.out.println(&quot;Constructing objects:&quot;);</para>
        <para>��� Blip1 b1 = new Blip1();</para>
        <para>��� Blip2 b2 = new Blip2();</para>
        <para>��� ObjectOutputStream o =</para>
        <para>����� new ObjectOutputStream(</para>
        <para>������� new FileOutputStream(&quot;Blips.out&quot;));</para>
        <para>��� System.out.println(&quot;Saving objects:&quot;);</para>
        <para>��� o.writeObject(b1);</para>
        <para>��� o.writeObject(b2);</para>
        <para>��� o.close();</para>
        <para>��� // Now get them back:</para>
        <para>��� ObjectInputStream in =</para>
        <para>��� ��new ObjectInputStream(</para>
        <para>������� new FileInputStream(&quot;Blips.out&quot;));</para>
        <para>��� System.out.println(&quot;Recovering b1:&quot;);</para>
        <para>��� b1 = (Blip1)in.readObject();</para>
        <para>��� // OOPS! Throws an exception:</para>
        <para>//! System.out.println(&quot;Recovering b2:&quot;);</para>
        <para>//! b2 = (Blip2)in.readObject();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The output for this program is:</para>
        <para>Constructing objects:</para>
        <para>Blip1 Constructor</para>
        <para>Blip2 Constructor</para>
        <para>Saving objects:</para>
        <para>Blip1.writeExternal</para>
        <para>Blip2.writeExternal</para>
        <para>Recovering b1:</para>
        <para>Blip1 Constructor</para>
        <para>Blip1.readExternal</para>
        <para> </para>
        <para>The reason that the <emphasis role="bold">Blip2</emphasis> object is not recovered is that trying to do so causes an exception. Can you see the difference between <emphasis role="bold">Blip1</emphasis> and <emphasis role="bold">Blip2</emphasis>? The constructor for <emphasis role="bold">Blip1</emphasis> is <emphasis role="bold">public</emphasis>, while the constructor for <emphasis role="bold">Blip2</emphasis> is not, and that causes the exception upon recovery. Try making <emphasis role="bold">Blip2</emphasis>�s constructor <emphasis role="bold">public </emphasis>and removing the <emphasis role="bold">//! </emphasis>comments to see the correct results.</para>
        <para>When <emphasis role="bold">b1</emphasis> is recovered, the <emphasis role="bold">Blip1</emphasis> default constructor is called. This is different from recovering a <emphasis role="bold">Serializable</emphasis> object, in which the object is constructed entirely from its stored bits, with no constructor calls. With an <emphasis role="bold">Externalizable</emphasis> object, all the normal default construction behavior occurs (including the initializations at the point of field definition), and <emphasis role="italic">then</emphasis><emphasis role="bold">readExternal( )</emphasis> is called. You need to be aware of this�in particular, the fact that all the default construction always takes place�to produce the correct behavior in your <emphasis role="bold">Externalizable</emphasis> objects.</para>
        <para>Here�s an example that shows what you must do to fully store and retrieve an <emphasis role="bold">Externalizable</emphasis> object:</para>
        <para>//: c11:Blip3.java</para>
        <para>// Reconstructing an externalizable object.</para>
        <para>import java.io.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Blip3 implements Externalizable {</para>
        <para>� int i;</para>
        <para>� String s; // No initialization</para>
        <para>� public Blip3() {</para>
        <para>��� System.out.println(&quot;Blip3 Constructor&quot;);</para>
        <para>��� // s, i not initialized</para>
        <para>� }</para>
        <para>� public Blip3(String x, int a) {</para>
        <para>��� System.out.println(&quot;Blip3(String x, int a)&quot;);</para>
        <para>��� s = x;</para>
        <para>��� i = a;</para>
        <para>��� // s &amp; i initialized only in nondefault</para>
        <para>��� // constructor.</para>
        <para>� }</para>
        <para>� public String toString() { return s + i; }</para>
        <para>� public void writeExternal(ObjectOutput out)</para>
        <para>� throws IOException {</para>
        <para>��� System.out.println(&quot;Blip3.writeExternal&quot;);</para>
        <para>��� // You must do this:</para>
        <para>��� out.writeObject(s); </para>
        <para>��� out.writeInt(i);</para>
        <para>� }</para>
        <para>� public void readExternal(ObjectInput in)</para>
        <para>� throws IOException, ClassNotFoundException {</para>
        <para>��� System.out.println(&quot;Blip3.readExternal&quot;);</para>
        <para>��� // You must do this:</para>
        <para>��� s = (String)in.readObject(); </para>
        <para>��� i =in.readInt();</para>
        <para>� }</para>
        <para>� public static void main(String[] args)</para>
        <para>� throws IOException, ClassNotFoundException {</para>
        <para>��� System.out.println(&quot;Constructing objects:&quot;);</para>
        <para>��� Blip3 b3 = new Blip3(&quot;A String &quot;, 47);</para>
        <para>��� System.out.println(b3);</para>
        <para>��� ObjectOutputStream o =</para>
        <para>����� new ObjectOutputStream(</para>
        <para>������� new FileOutputStream(&quot;Blip3.out&quot;));</para>
        <para>��� System.out.println(&quot;Saving object:&quot;);</para>
        <para>��� o.writeObject(b3);</para>
        <para>��� o.close();</para>
        <para>��� // Now get it back:</para>
        <para>��� ObjectInputStream in =</para>
        <para>����� new ObjectInputStream(</para>
        <para>������� new FileInputStream(&quot;Blip3.out&quot;));</para>
        <para>��� System.out.println(&quot;Recovering b3:&quot;);</para>
        <para>��� b3 = (Blip3)in.readObject();</para>
        <para>��� System.out.println(b3);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The fields <emphasis role="bold">s</emphasis> and <emphasis role="bold">i </emphasis>are initialized only in the second constructor, but not in the default constructor. This means that if you don�t initialize <emphasis role="bold">s</emphasis> and <emphasis role="bold">i </emphasis>in <emphasis role="bold">readExternal( )</emphasis>, it will be <emphasis role="bold">null</emphasis> (since the storage for the object gets wiped to zero in the first step of object creation). If you comment out the two lines of code following the phrases �You must do this� and run the program, you�ll see that when the object is recovered, <emphasis role="bold">s</emphasis> is <emphasis role="bold">null</emphasis> and <emphasis role="bold">i</emphasis> is zero.</para>
        <para>If you are inheriting from an <emphasis role="bold">Externalizable</emphasis> object, you�ll typically call the base-class versions of <emphasis role="bold">writeExternal( ) </emphasis>and <emphasis role="bold">readExternal( )</emphasis> to provide proper storage and retrieval of the base-class components.</para>
        <para>So to make things work correctly you must not only write the important data from the object during the <emphasis role="bold">writeExternal( ) </emphasis>method (there is no default behavior that writes any of the member objects for an <emphasis role="bold">Externalizable</emphasis> object), but you must also recover that data in the <emphasis role="bold">readExternal( )</emphasis> method. This can be a bit confusing at first because the default construction behavior for an <emphasis role="bold">Externalizable</emphasis> object can make it seem like some kind of storage and retrieval takes place automatically. It does not.</para>
        <section>
          <title>The transient keyword</title>
          <para>When you�re controlling serialization, there might be a particular subobject that you don�t want Java�s serialization mechanism to automatically save and restore. This is commonly the case if that subobject represents sensitive information that you don�t want to serialize, such as a password. Even if that information is <emphasis role="bold">private </emphasis>in the object, once it�s serialized it�s possible for someone to access it by reading a file or intercepting a network transmission.</para>
          <para>One way to prevent sensitive parts of your object from being serialized is to implement your class as <emphasis role="bold">Externalizable</emphasis>, as shown previously. Then nothing is automatically serialized and you can explicitly serialize only the necessary parts inside <emphasis role="bold">writeExternal( )</emphasis>.</para>
          <para>If you�re working with a <emphasis role="bold">Serializable </emphasis>object, however, all serialization happens automatically. To control this, you can turn off serialization on a field-by-field basis using the <emphasis role="bold">transient</emphasis> keyword, which says �Don�t bother saving or restoring this�I�ll take care of it.�</para>
          <para>For example, consider a <emphasis role="bold">Login </emphasis>object that keeps information about a particular login session. Suppose that, once you verify the login, you want to store the data, but without the password. The easiest way to do this is by implementing <emphasis role="bold">Serializable</emphasis> and marking the <emphasis role="bold">password</emphasis> field as <emphasis role="bold">transient</emphasis>. Here�s what it looks like:</para>
          <para>//: c11:Logon.java</para>
          <para>// Demonstrates the &quot;transient&quot; keyword.</para>
          <para>import java.io.*;</para>
          <para>import java.util.*;</para>
          <para> </para>
          <para>class Logon implements Serializable {</para>
          <para>� private Date date = new Date();</para>
          <para>� private String username;</para>
          <para>� private transient String password;</para>
          <para>� Logon(String name, String pwd) {</para>
          <para>��� username = name;</para>
          <para>��� password = pwd;</para>
          <para>� }</para>
          <para>� public String toString() {</para>
          <para>��� String pwd =</para>
          <para>����� (password == null) ? &quot;(n/a)&quot; : password;</para>
          <para>��� return &quot;logon info: \n�� &quot; +</para>
          <para>����� &quot;username: &quot; + username +</para>
          <para>����� &quot;\n�� date: &quot; + date +</para>
          <para>����� &quot;\n�� password: &quot; + pwd;</para>
          <para>� }</para>
          <para>� public static void main(String[] args)</para>
          <para>� throws IOException, ClassNotFoundException {</para>
          <para>��� Logon a = new Logon(&quot;Hulk&quot;, &quot;myLittlePony&quot;);</para>
          <para>��� System.out.println( &quot;logon a = &quot; + a);</para>
          <para>����� ObjectOutputStream o =</para>
          <para>������� new ObjectOutputStream(</para>
          <para>��������� new FileOutputStream(&quot;Logon.out&quot;));</para>
          <para>��� o.writeObject(a);</para>
          <para>��� o.close();</para>
          <para>��� // Delay:</para>
          <para>��� int seconds = 5;</para>
          <para>��� long t = System.currentTimeMillis()</para>
          <para>���������� + seconds * 1000;</para>
          <para>��� while(System.currentTimeMillis() &lt; t)</para>
          <para>����� ;</para>
          <para>��� // Now get them back:</para>
          <para>��� ObjectInputStream in =</para>
          <para>����� new ObjectInputStream(</para>
          <para>������� new FileInputStream(&quot;Logon.out&quot;));</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;Recovering object at &quot; + new Date());</para>
          <para>��� a = (Logon)in.readObject();</para>
          <para>��� System.out.println( &quot;logon a = &quot; + a);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>You can see that the <emphasis role="bold">date</emphasis> and <emphasis role="bold">username</emphasis> fields are ordinary (not <emphasis role="bold">transient</emphasis>), and thus are automatically serialized. However, the <emphasis role="bold">password</emphasis> is <emphasis role="bold">transient</emphasis>, and so is not stored to disk; also the serialization mechanism makes no attempt to recover it. The output is:</para>
          <para>logon a = logon info:</para>
          <para>�� username: Hulk</para>
          <para>�� date: Sun Mar 23 18:25:53 PST 1997</para>
          <para>�� password: myLittlePony</para>
          <para>Recovering object at Sun Mar 23 18:25:59 PST 1997</para>
          <para>logon a = logon info:</para>
          <para>�� username: Hulk</para>
          <para>�� date: Sun Mar 23 18:25:53 PST 1997</para>
          <para>�� password: (n/a)</para>
          <para> </para>
          <para>When the object is recovered, the <emphasis role="bold">password</emphasis> field is <emphasis role="bold">null</emphasis>. Note that <emphasis role="bold">toString( )</emphasis> must check for a <emphasis role="bold">null</emphasis> value of <emphasis role="bold">password </emphasis>because if you try to assemble a <emphasis role="bold">String</emphasis> object using the overloaded �<emphasis role="bold">+</emphasis>� operator, and that operator encounters a <emphasis role="bold">null </emphasis>reference, you�ll get a <emphasis role="bold">NullPointerException.</emphasis> (Newer versions of Java might contain code to avoid this problem.)</para>
          <para>You can also see that the <emphasis role="bold">date</emphasis> field is stored to and recovered from disk and not generated anew.</para>
          <para>Since <emphasis role="bold">Externalizable</emphasis> objects do not store any of their fields by default, the <emphasis role="bold">transient</emphasis> keyword is for use with <emphasis role="bold">Serializable</emphasis> objects only.</para>
        </section>
        <section>
          <title>An alternative to <emphasis role="bold">Externalizable</emphasis></title>
          <para>If you�re not keen on implementing the <emphasis role="bold">Externalizable </emphasis>interface, there�s another approach. You can implement the <emphasis role="bold">Serializable</emphasis> interface and <emphasis role="italic">add </emphasis>(notice I say �add� and not �override� or �implement�) methods called <emphasis role="bold">writeObject( )</emphasis> and <emphasis role="bold">readObject( )</emphasis> that will automatically be called when the object is serialized and deserialized, respectively. That is, if you provide these two methods they will be used instead of the default serialization.</para>
          <para>The methods must have these exact signatures:</para>
          <para>private void </para>
          <para>� writeObject(ObjectOutputStream stream)</para>
          <para>��� throws IOException;</para>
          <para> </para>
          <para>private void </para>
          <para>� readObject(ObjectInputStream stream)</para>
          <para>��� throws IOException, ClassNotFoundException</para>
          <para> </para>
          <para>From a design standpoint, things get really weird here. First of all, you might think that because these methods are not part of a base class or the <emphasis role="bold">Serializable</emphasis> interface, they ought to be defined in their own interface(s). But notice that they are defined as <emphasis role="bold">private</emphasis>, which means they are to be called only by other members of this class. However, you don�t actually call them from other members of this class, but instead the <emphasis role="bold">writeObject( )</emphasis> and <emphasis role="bold">readObject( )</emphasis> methods of the <emphasis role="bold">ObjectOutputStream</emphasis> and <emphasis role="bold">ObjectInputStream</emphasis> objects call your object�s <emphasis role="bold">writeObject( )</emphasis> and <emphasis role="bold">readObject( )</emphasis> methods. (Notice my tremendous restraint in not launching into a long diatribe about using the same method names here. In a word: confusing.) You might wonder how the <emphasis role="bold">ObjectOutputStream</emphasis> and <emphasis role="bold">ObjectInputStream</emphasis> objects have access to <emphasis role="bold">private</emphasis> methods of your class. We can only assume that this is part of the serialization magic.</para>
          <para>In any event, anything defined in an <emphasis role="bold">interface</emphasis> is automatically <emphasis role="bold">public</emphasis> so if <emphasis role="bold">writeObject( )</emphasis> and <emphasis role="bold">readObject( )</emphasis> must be <emphasis role="bold">private</emphasis>, then they can�t be part of an <emphasis role="bold">interface</emphasis>. Since you must follow the signatures exactly, the effect is the same as if you�re implementing an <emphasis role="bold">interface</emphasis>.</para>
          <para>It would appear that when you call <emphasis role="bold">ObjectOutputStream.writeObject( )</emphasis>, the <emphasis role="bold">Serializable</emphasis> object that you pass it to is interrogated (using reflection, no doubt) to see if it implements its own <emphasis role="bold">writeObject( )</emphasis>. If so, the normal serialization process is skipped and the <emphasis role="bold">writeObject( )</emphasis> is called. The same sort of situation exists for <emphasis role="bold">readObject( )</emphasis>.</para>
          <para>There�s one other twist. Inside your <emphasis role="bold">writeObject( )</emphasis>, you can choose to perform the default <emphasis role="bold">writeObject( )</emphasis> action by calling <emphasis role="bold">defaultWriteObject( )</emphasis>. Likewise, inside <emphasis role="bold">readObject( )</emphasis> you can call <emphasis role="bold">defaultReadObject( )</emphasis>. Here is a simple example that demonstrates how you can control the storage and retrieval of a <emphasis role="bold">Serializable</emphasis> object:</para>
          <para>//: c11:SerialCtl.java</para>
          <para>// Controlling serialization by adding your own</para>
          <para>// writeObject() and readObject() methods.</para>
          <para>import java.io.*;</para>
          <para> </para>
          <para>public class SerialCtl implements Serializable {</para>
          <para>� String a;</para>
          <para>� transient String b;</para>
          <para>� public SerialCtl(String aa, String bb) {</para>
          <para>��� a = &quot;Not Transient: &quot; + aa;</para>
          <para>��� b = &quot;Transient: &quot; + bb;</para>
          <para>� }</para>
          <para>� public String toString() {</para>
          <para>��� return a + &quot;\n&quot; + b;</para>
          <para>� }</para>
          <para>� private void </para>
          <para>��� writeObject(ObjectOutputStream stream)</para>
          <para>����� throws IOException {</para>
          <para>��� stream.defaultWriteObject();</para>
          <para>��� stream.writeObject(b);</para>
          <para>� }</para>
          <para>� private void </para>
          <para>��� readObject(ObjectInputStream stream)</para>
          <para>����� throws IOException, ClassNotFoundException {</para>
          <para>��� stream.defaultReadObject();</para>
          <para>��� b = (String)stream.readObject();</para>
          <para>� }</para>
          <para>��public static void main(String[] args)</para>
          <para>� throws IOException, ClassNotFoundException {</para>
          <para>��� SerialCtl sc = </para>
          <para>����� new SerialCtl(&quot;Test1&quot;, &quot;Test2&quot;);</para>
          <para>��� System.out.println(&quot;Before:\n&quot; + sc);</para>
          <para>��� ByteArrayOutputStream buf = </para>
          <para>����� new ByteArrayOutputStream();</para>
          <para>��� ObjectOutputStream o =</para>
          <para>����� new ObjectOutputStream(buf);</para>
          <para>��� o.writeObject(sc);</para>
          <para>��� // Now get it back:</para>
          <para>��� ObjectInputStream in =</para>
          <para>����� new ObjectInputStream(</para>
          <para>������� new ByteArrayInputStream(</para>
          <para>��������� buf.toByteArray()));</para>
          <para>��� SerialCtl sc2 = (SerialCtl)in.readObject();</para>
          <para>��� System.out.println(&quot;After:\n&quot; + sc2);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>In this example, one <emphasis role="bold">String</emphasis> field is ordinary and the other is <emphasis role="bold">transient</emphasis>, to prove that the non-<emphasis role="bold">transient</emphasis> field is saved by the <emphasis role="bold">defaultWriteObject( )</emphasis> method and the <emphasis role="bold">transient</emphasis> field is saved and restored explicitly. The fields are initialized inside the constructor rather than at the point of definition to prove that they are not being initialized by some automatic mechanism during deserialization.</para>
          <para>If you are going to use the default mechanism to write the non-<emphasis role="bold">transient</emphasis> parts of your object, you must call <emphasis role="bold">defaultWriteObject( )</emphasis> as the first operation in <emphasis role="bold">writeObject( )</emphasis> and <emphasis role="bold">defaultReadObject( )</emphasis> as the first operation in <emphasis role="bold">readObject( )</emphasis>. These are strange method calls. It would appear, for example, that you are calling <emphasis role="bold">defaultWriteObject( )</emphasis> for an <emphasis role="bold">ObjectOutputStream</emphasis> and passing it no arguments, and yet it somehow turns around and knows the reference to your object and how to write all the non-<emphasis role="bold">transient</emphasis> parts. Spooky.</para>
          <para>The storage and retrieval of the <emphasis role="bold">transient</emphasis> objects uses more familiar code. And yet, think about what happens here. In <emphasis role="bold">main( )</emphasis>, a <emphasis role="bold">SerialCtl</emphasis> object is created, and then it�s serialized to an <emphasis role="bold">ObjectOutputStream.</emphasis> (Notice in this case that a buffer is used instead of a file�it�s all the same to the <emphasis role="bold">ObjectOutputStream</emphasis>.) The serialization occurs in the line:</para>
          <para>o.writeObject(sc);</para>
          <para> </para>
          <para>The <emphasis role="bold">writeObject( )</emphasis> method must be examining <emphasis role="bold">sc</emphasis> to see if it has its own <emphasis role="bold">writeObject( )</emphasis> method. (Not by checking the interface�there isn�t one�or the class type, but by actually hunting for the method using reflection.) If it does, it uses that. A similar approach holds true for <emphasis role="bold">readObject( )</emphasis>. Perhaps this was the only practical way that they could solve the problem, but it�s certainly strange.</para>
        </section>
        <section>
          <title>Versioning</title>
          <para>It�s possible that you might want to change the version of a serializable class (objects of the original class might be stored in a database, for example). This is supported but you�ll probably do it only in special cases, and it requires an extra depth of understanding that we will not attempt to achieve here. The JDK HTML documents downloadable from <emphasis role="italic">java.sun.com</emphasis> cover this topic quite thoroughly.</para>
          <para>You will also notice in the JDK HTML documentation many comments that begin with:</para>
          <para><emphasis role="bold">Warning:</emphasis><emphasis role="italic"> Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between applications. �</emphasis></para>
          <para>This is because the versioning mechanism is too simple to work reliably in all situations, especially with JavaBeans. They�re working on a correction for the design, and that�s what the warning is about.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Using persistence" xml:id="_Toc481064765"/>Using persistence</title>
        <para>It�s quite appealing to use serialization technology to store some of the state of your program so that you can easily restore the program to the current state later. But before you can do this, some questions must be answered. What happens if you serialize two objects that both have a reference to a third object? When you restore those two objects from their serialized state, do you get only one occurrence of the third object? What if you serialize your two objects to separate files and deserialize them in different parts of your code?</para>
        <para>Here�s an example that shows the problem:</para>
        <para>//: c11:MyWorld.java</para>
        <para>import java.io.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class House implements Serializable {}</para>
        <para> </para>
        <para>class Animal implements Serializable {</para>
        <para>� String name;</para>
        <para>� House preferredHouse;</para>
        <para>� Animal(String nm, House h) { </para>
        <para>��� name = nm; </para>
        <para>��� preferredHouse = h;</para>
        <para>� }</para>
        <para>� public String toString() {</para>
        <para>��� return name + &quot;[&quot; + super.toString() + </para>
        <para>����� &quot;], &quot; + preferredHouse + &quot;\n&quot;;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class MyWorld {</para>
        <para>� public static void main(String[] args)</para>
        <para>� throws IOException, ClassNotFoundException {</para>
        <para>��� House house = new House();</para>
        <para>��� ArrayList� animals = new ArrayList();</para>
        <para>��� animals.add(</para>
        <para>����� new Animal(&quot;Bosco the dog&quot;, house));</para>
        <para>��� animals.add(</para>
        <para>����� new Animal(&quot;Ralph the hamster&quot;, house));</para>
        <para>��� animals.add(</para>
        <para>����� new Animal(&quot;Fronk the cat&quot;, house));</para>
        <para>��� System.out.println(&quot;animals: &quot; + animals);</para>
        <para> </para>
        <para>��� ByteArrayOutputStream buf1 = </para>
        <para>����� new ByteArrayOutputStream();</para>
        <para>��� ObjectOutputStream o1 =</para>
        <para>����� new ObjectOutputStream(buf1);</para>
        <para>��� o1.writeObject(animals);</para>
        <para>��� o1.writeObject(animals); // Write a 2nd set</para>
        <para>��� // Write to a different stream:</para>
        <para>��� ByteArrayOutputStream buf2 = </para>
        <para>����� new ByteArrayOutputStream();</para>
        <para>��� ObjectOutputStream o2 =</para>
        <para>����� new ObjectOutputStream(buf2);</para>
        <para>��� o2.writeObject(animals);</para>
        <para>��� // Now get them back:</para>
        <para>��� ObjectInputStream in1 =</para>
        <para>����� new ObjectInputStream(</para>
        <para>������� new ByteArrayInputStream(</para>
        <para>�� �������buf1.toByteArray()));</para>
        <para>��� ObjectInputStream in2 =</para>
        <para>����� new ObjectInputStream(</para>
        <para>������� new ByteArrayInputStream(</para>
        <para>��������� buf2.toByteArray()));</para>
        <para>��� ArrayList animals1 = </para>
        <para>����� (ArrayList)in1.readObject();</para>
        <para>��� ArrayList animals2 = </para>
        <para>����� (ArrayList)in1.readObject();</para>
        <para>��� ArrayList animals3 = </para>
        <para>����� (ArrayList)in2.readObject();</para>
        <para>��� System.out.println(&quot;animals1: &quot; + animals1);</para>
        <para>��� System.out.println(&quot;animals2: &quot; + animals2);</para>
        <para>��� System.out.println(&quot;animals3: &quot; + animals3);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>One thing that�s interesting here is that it�s possible to use object serialization to and from a byte array as a way of doing a �deep copy� of any object that�s <emphasis role="bold">Serializable.</emphasis> (A deep copy means that you�re duplicating the entire web of objects, rather than just the basic object and its references.) Copying is covered in depth in Appendix A.</para>
        <para><emphasis role="bold">Animal</emphasis> objects contain fields of type <emphasis role="bold">House</emphasis>. In <emphasis role="bold">main( )</emphasis>, an <emphasis role="bold">ArrayList</emphasis> of these <emphasis role="bold">Animal</emphasis>s is created and it is serialized twice to one stream and then again to a separate stream. When these are deserialized and printed, you see the following results for one run (the objects will be in different memory locations each run):</para>
        <para>animals: [Bosco the dog[Animal@1cc76c], House@1cc769</para>
        <para>, Ralph the hamster[Animal@1cc76d], House@1cc769</para>
        <para>, Fronk the cat[Animal@1cc76e], House@1cc769</para>
        <para>]</para>
        <para>animals1: [Bosco the dog[Animal@1cca0c], House@1cca16</para>
        <para>, Ralph the hamster[Animal@1cca17], House@1cca16</para>
        <para>, Fronk the cat[Animal@1cca1b], House@1cca16</para>
        <para>]</para>
        <para>animals2: [Bosco the dog[Animal@1cca0c], House@1cca16</para>
        <para>, Ralph the hamster[Animal@1cca17], House@1cca16</para>
        <para>, Fronk the cat[Animal@1cca1b], House@1cca16</para>
        <para>]</para>
        <para>animals3: [Bosco the dog[Animal@1cca52], House@1cca5c</para>
        <para>, Ralph the hamster[Animal@1cca5d], House@1cca5c</para>
        <para>, Fronk the cat[Animal@1cca61], House@1cca5c</para>
        <para>]</para>
        <para> </para>
        <para>Of course you expect that the deserialized objects have different addresses from their originals. But notice that in <emphasis role="bold">animals1</emphasis> and <emphasis role="bold">animals2</emphasis> the same addresses appear, including the references to the <emphasis role="bold">House </emphasis>object that both share. On the other hand, when <emphasis role="bold">animals3 </emphasis>is recovered the system has no way of knowing that the objects in this other stream are aliases of the objects in the first stream, so it makes a completely different web of objects.</para>
        <para>As long as you�re serializing everything to a single stream, you�ll be able to recover the same web of objects that you wrote, with no accidental duplication of objects. Of course, you can change the state of your objects in between the time you write the first and the last, but that�s your responsibility�the objects will be written in whatever state they are in (and with whatever connections they have to other objects) at the time you serialize them.</para>
        <para>The safest thing to do if you want to save the state of a system is to serialize as an �atomic� operation. If you serialize some things, do some other work, and serialize some more, etc., then you will not be storing the system safely. Instead, put all the objects that comprise the state of your system in a single container and simply write that container out in one operation. Then you can restore it with a single method call as well.</para>
        <para>The following example is an imaginary computer-aided design (CAD) system that demonstrates the approach. In addition, it throws in the issue of <emphasis role="bold">static</emphasis> fields�if you look at the documentation you�ll see that <emphasis role="bold">Class</emphasis> is <emphasis role="bold">Serializable</emphasis>, so it should be easy to store the <emphasis role="bold">static</emphasis> fields by simply serializing the <emphasis role="bold">Class</emphasis> object. That seems like a sensible approach, anyway.</para>
        <para>//: c11:CADState.java</para>
        <para>// Saving and restoring the state of a </para>
        <para>// pretend CAD system.</para>
        <para>import java.io.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>abstract class Shape implements Serializable {</para>
        <para>� public static final int </para>
        <para>��� RED = 1, BLUE = 2, GREEN = 3;</para>
        <para>� private int xPos, yPos, dimension;</para>
        <para>� private static Random r = new Random();</para>
        <para>� private static int counter = 0;</para>
        <para>� abstract public void setColor(int newColor);</para>
        <para>� abstract public int getColor();</para>
        <para>� public Shape(int xVal, int yVal, int dim) {</para>
        <para>��� xPos = xVal;</para>
        <para>��� yPos = yVal;</para>
        <para>��� dimension = dim;</para>
        <para>� }</para>
        <para>� public String toString() {</para>
        <para>��� return getClass() + </para>
        <para>����� &quot; color[&quot; + getColor() +</para>
        <para>����� &quot;] xPos[&quot; + xPos +</para>
        <para>����� &quot;] yPos[&quot; + yPos +</para>
        <para>����� &quot;] dim[&quot; + dimension + &quot;]\n&quot;;</para>
        <para>� }</para>
        <para>� public static Shape randomFactory() {</para>
        <para>��� int xVal = r.nextInt() % 100;</para>
        <para>��� int yVal = r.nextInt() % 100;</para>
        <para>��� int dim = r.nextInt() % 100;</para>
        <para>��� switch(counter++ % 3) {</para>
        <para>����� default: </para>
        <para>����� case 0: return new Circle(xVal, yVal, dim);</para>
        <para>����� case 1: return new Square(xVal, yVal, dim);</para>
        <para>����� case 2: return new Line(xVal, yVal, dim);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Circle extends Shape {</para>
        <para>� private static int color = RED;</para>
        <para>� public Circle(int xVal, int yVal, int dim) {</para>
        <para>��� super(xVal, yVal, dim);</para>
        <para>� }</para>
        <para>� public void setColor(int newColor) { </para>
        <para>��� color = newColor;</para>
        <para>� }</para>
        <para>� public int getColor() { </para>
        <para>��� return color;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Square extends Shape {</para>
        <para>� private static int color;</para>
        <para>� public Square(int xVal, int yVal, int dim) {</para>
        <para>��� super(xVal, yVal, dim);</para>
        <para>��� color = RED;</para>
        <para>� }</para>
        <para>� public void setColor(int newColor) { </para>
        <para>��� color = newColor;</para>
        <para>� }</para>
        <para>� public int getColor() { </para>
        <para>��� return color;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Line extends Shape {</para>
        <para>� private static int color = RED;</para>
        <para>� public static void </para>
        <para>� serializeStaticState(ObjectOutputStream os)</para>
        <para>����� throws IOException {</para>
        <para>��� os.writeInt(color);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� deserializeStaticState(ObjectInputStream os)</para>
        <para>����� throws IOException {</para>
        <para>��� color = os.readInt();</para>
        <para>� }</para>
        <para>� public Line(int xVal, int yVal, int dim) {</para>
        <para>��� super(xVal, yVal, dim);</para>
        <para>� }</para>
        <para>� public void setColor(int newColor) { </para>
        <para>��� color = newColor;</para>
        <para>� }</para>
        <para>� public int getColor() { </para>
        <para>��� return color;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class CADState {</para>
        <para>��public static void main(String[] args) </para>
        <para>� throws Exception {</para>
        <para>��� ArrayList shapeTypes, shapes;</para>
        <para>��� if(args.length == 0) {</para>
        <para>����� shapeTypes = new ArrayList();</para>
        <para>����� shapes = new ArrayList();</para>
        <para>����� // Add references to the class objects:</para>
        <para>����� shapeTypes.add(Circle.class);</para>
        <para>����� shapeTypes.add(Square.class);</para>
        <para>����� shapeTypes.add(Line.class);</para>
        <para>����� // Make some shapes:</para>
        <para>����� for(int i = 0; i &lt; 10; i++)</para>
        <para>������� shapes.add(Shape.randomFactory());</para>
        <para>����� // Set all the static colors to GREEN:</para>
        <para>����� for(int i = 0; i &lt; 10; i++)</para>
        <para>������� ((Shape)shapes.get(i))</para>
        <para>��������� .setColor(Shape.GREEN);</para>
        <para>����� // Save the state vector:</para>
        <para>����� ObjectOutputStream out =</para>
        <para>������� new ObjectOutputStream(</para>
        <para>��������� new FileOutputStream(&quot;CADState.out&quot;));</para>
        <para>����� out.writeObject(shapeTypes);</para>
        <para>����� Line.serializeStaticState(out);</para>
        <para>����� out.writeObject(shapes);</para>
        <para>��� } else { // There&apos;s a command-line argument</para>
        <para>����� ObjectInputStream in =</para>
        <para>������� new ObjectInputStream(</para>
        <para>��������� new FileInputStream(args[0]));</para>
        <para>����� // Read in the same order they were written:</para>
        <para>����� shapeTypes = (ArrayList)in.readObject();</para>
        <para>����� Line.deserializeStaticState(in);</para>
        <para>����� shapes = (ArrayList)in.readObject();</para>
        <para>��� }</para>
        <para>��� // Display the shapes:</para>
        <para>��� System.out.println(shapes);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">Shape</emphasis> class <emphasis role="bold">implements </emphasis><emphasis role="bold">Serializable</emphasis>, so anything that is inherited from <emphasis role="bold">Shape</emphasis> is automatically <emphasis role="bold">Serializable</emphasis> as well. Each <emphasis role="bold">Shape</emphasis> contains data, and each derived <emphasis role="bold">Shape</emphasis> class contains a <emphasis role="bold">static</emphasis> field that determines the color of all of those types of <emphasis role="bold">Shape</emphasis>s. (Placing a <emphasis role="bold">static</emphasis> field in the base class would result in only one field, since <emphasis role="bold">static</emphasis> fields are not duplicated in derived classes.) Methods in the base class can be overridden to set the color for the various types (<emphasis role="bold">static</emphasis> methods are not dynamically bound, so these are normal methods). The <emphasis role="bold">randomFactory( )</emphasis> method creates a different <emphasis role="bold">Shape</emphasis> each time you call it, using random values for the <emphasis role="bold">Shape</emphasis> data.</para>
        <para><emphasis role="bold">Circle</emphasis> and <emphasis role="bold">Square</emphasis> are straightforward extensions of <emphasis role="bold">Shape</emphasis>; the only difference is that <emphasis role="bold">Circle</emphasis> initializes <emphasis role="bold">color</emphasis> at the point of definition and <emphasis role="bold">Square</emphasis> initializes it in the constructor. We�ll leave the discussion of <emphasis role="bold">Line</emphasis> for later.</para>
        <para>In <emphasis role="bold">main( )</emphasis>, one <emphasis role="bold">ArrayList</emphasis> is used to hold the <emphasis role="bold">Class</emphasis> objects and the other to hold the shapes. If you don�t provide a command line argument the <emphasis role="bold">shapeTypes</emphasis><emphasis role="bold">ArrayList</emphasis> is created and the <emphasis role="bold">Class</emphasis> objects are added, and then the <emphasis role="bold">shapes</emphasis><emphasis role="bold">ArrayList</emphasis> is created and <emphasis role="bold">Shape</emphasis> objects are added. Next, all the <emphasis role="bold">static</emphasis><emphasis role="bold">color</emphasis> values are set to <emphasis role="bold">GREEN</emphasis>, and everything is serialized to the file <emphasis role="bold">CADState.out</emphasis>.</para>
        <para>If you provide a command line argument (presumably <emphasis role="bold">CADState.out</emphasis>), that file is opened and used to restore the state of the program. In both situations, the resulting <emphasis role="bold">ArrayList</emphasis> of <emphasis role="bold">Shape</emphasis>s is printed. The results from one run are:</para>
        <para>&gt;java CADState</para>
        <para>[class Circle color[3] xPos[-51] yPos[-99] dim[38]</para>
        <para>, class Square color[3] xPos[2] yPos[61] dim[-46]</para>
        <para>, class Line color[3] xPos[51] yPos[73] dim[64]</para>
        <para>, class Circle color[3] xPos[-70] yPos[1] dim[16]</para>
        <para>, class Square color[3] xPos[3] yPos[94] dim[-36]</para>
        <para>, class Line color[3] xPos[-84] yPos[-21] dim[-35]</para>
        <para>, class Circle color[3] xPos[-75] yPos[-43] dim[22]</para>
        <para>, class Square color[3] xPos[81] yPos[30] dim[-45]</para>
        <para>, class Line color[3] xPos[-29] yPos[92] dim[17]</para>
        <para>, class Circle color[3] xPos[17] yPos[90] dim[-76]</para>
        <para>]</para>
        <para> </para>
        <para>&gt;java CADState CADState.out</para>
        <para>[class Circle color[1] xPos[-51] yPos[-99] dim[38]</para>
        <para>, class Square color[0] xPos[2] yPos[61] dim[-46]</para>
        <para>, class Line color[3] xPos[51] yPos[73] dim[64]</para>
        <para>, class Circle color[1] xPos[-70] yPos[1] dim[16]</para>
        <para>, class Square color[0] xPos[3] yPos[94] dim[-36]</para>
        <para>, class Line color[3] xPos[-84] yPos[-21] dim[-35]</para>
        <para>, class Circle color[1] xPos[-75] yPos[-43] dim[22]</para>
        <para>, class Square color[0] xPos[81] yPos[30] dim[-45]</para>
        <para>, class Line color[3] xPos[-29] yPos[92] dim[17]</para>
        <para>, class Circle color[1] xPos[17] yPos[90] dim[-76]</para>
        <para>]</para>
        <para> </para>
        <para>You can see that the values of <emphasis role="bold">xPos</emphasis>, <emphasis role="bold">yPos,</emphasis> and <emphasis role="bold">dim</emphasis> were all stored and recovered successfully, but there�s something wrong with the retrieval of the <emphasis role="bold">static</emphasis> information. It�s all �3� going in, but it doesn�t come out that way. <emphasis role="bold">Circle</emphasis>s have a value of 1 (<emphasis role="bold">RED</emphasis>, which is the definition), and <emphasis role="bold">Square</emphasis>s have a value of 0 (remember, they are initialized in the constructor). It�s as if the <emphasis role="bold">static</emphasis>s didn�t get serialized at all! That�s right�even though class <emphasis role="bold">Class</emphasis> is <emphasis role="bold">Serializable</emphasis>, it doesn�t do what you expect. So if you want to serialize <emphasis role="bold">statics</emphasis>, you must do it yourself.</para>
        <para>This is what the <emphasis role="bold">serializeStaticState( ) </emphasis>and <emphasis role="bold">deserializeStaticState( )</emphasis><emphasis role="bold">static </emphasis>methods in <emphasis role="bold">Line</emphasis> are for. You can see that they are explicitly called as part of the storage and retrieval process. (Note that the order of writing to the serialize file and reading back from it must be maintained.) Thus to make <emphasis role="bold">CADState.java</emphasis> run correctly you must:</para>
        <para>Add a <emphasis role="bold">serializeStaticState( )</emphasis> and <emphasis role="bold">deserializeStaticState( )</emphasis> to the shapes.</para>
        <para>81.      Remove the <emphasis role="bold">ArrayList</emphasis><emphasis role="bold">shapeTypes</emphasis> and all code related to it.</para>
        <para>82.      Add calls to the new serialize and deserialize static methods in the shapes.</para>
        <para>Another issue you might have to think about is security, since serialization also saves <emphasis role="bold">private</emphasis> data. If you have a security issue, those fields should be marked as <emphasis role="bold">transient</emphasis>. But then you have to design a secure way to store that information so that when you do a restore you can reset those <emphasis role="bold">private</emphasis> variables. </para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Tokenizing input" xml:id="_Toc481064766"/>Tokenizing input</title>
      <para>�<emphasis role="italic">Tokenizing </emphasis>is the process of breaking a sequence of characters into a sequence of �tokens,� which are bits of text delimited by whatever you choose. For example, your tokens could be words, and then they would be delimited by white space and punctuation. There are two classes provided in the standard Java library that can be used for tokenization: <emphasis role="bold">StreamTokenizer</emphasis> and <emphasis role="bold">StringTokenizer</emphasis>.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064767"/><anchor xreflabel="StreamTokenizer" xml:id="_Toc375545398"/><emphasis role="bold">StreamTokenizer</emphasis></title>
        <para>Although <emphasis role="bold">StreamTokenizer</emphasis> is not derived from <emphasis role="bold">InputStream</emphasis> or <emphasis role="bold">OutputStream</emphasis>, it works only with <emphasis role="bold">InputStream</emphasis> objects, so it rightfully belongs in the I/O portion of the library.</para>
        <para>Consider a program to count the occurrence of words in a text file:</para>
        <para>//: c11:WordCount.java</para>
        <para>// Counts words from a file, outputs</para>
        <para>// results in sorted form.</para>
        <para>import java.io.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Counter {</para>
        <para>� private int i = 1;</para>
        <para>� int read() { return i; }</para>
        <para>� void increment() { i++; }</para>
        <para>}</para>
        <para> </para>
        <para>public class WordCount {</para>
        <para>� private FileReader file;</para>
        <para>� private StreamTokenizer st;</para>
        <para>� // A TreeMap keeps keys in sorted order:</para>
        <para>� private TreeMap counts = new TreeMap();</para>
        <para>� WordCount(String filename)</para>
        <para>��� throws FileNotFoundException {</para>
        <para>��� try {</para>
        <para>����� file = new FileReader(filename);</para>
        <para>����� st = new StreamTokenizer(</para>
        <para>������� new BufferedReader(file));</para>
        <para>����� st.ordinaryChar(&apos;.&apos;);</para>
        <para>����� st.ordinaryChar(&apos;-&apos;);</para>
        <para>��� } catch(FileNotFoundException e) {</para>
        <para>����� System.err.println(</para>
        <para>������� &quot;Could not open &quot; + filename);</para>
        <para>����� throw e;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� void cleanup() {</para>
        <para>��� try {</para>
        <para>����� file.close();</para>
        <para>��� } catch(IOException e) {</para>
        <para>����� System.err.println(</para>
        <para>������� &quot;file.close() unsuccessful&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� void countWords() {</para>
        <para>��� try {</para>
        <para>����� while(st.nextToken() !=</para>
        <para>������� StreamTokenizer.TT_EOF) {</para>
        <para>������� String s;</para>
        <para>������� switch(st.ttype) {</para>
        <para>��������� case StreamTokenizer.TT_EOL:</para>
        <para>����������� s = new String(&quot;EOL&quot;);</para>
        <para>����������� break;</para>
        <para>��������� case StreamTokenizer.TT_NUMBER:</para>
        <para>����������� s = Double.toString(st.nval);</para>
        <para>����������� break;</para>
        <para>��������� case StreamTokenizer.TT_WORD:</para>
        <para>����������� s = st.sval; // Already a String</para>
        <para>����������� break;</para>
        <para>��������� default: // single character in ttype</para>
        <para>����������� s = String.valueOf((char)st.ttype);</para>
        <para>������� }</para>
        <para>������� if(counts.containsKey(s))</para>
        <para>��������� ((Counter)counts.get(s)).increment();</para>
        <para>������� else</para>
        <para>��������� counts.put(s, new Counter());</para>
        <para>����� }</para>
        <para>��� } catch(IOException e) {</para>
        <para>����� System.err.println(</para>
        <para>������� &quot;st.nextToken() unsuccessful&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� Collection values() {</para>
        <para>��� return counts.values();</para>
        <para>� }</para>
        <para>� Set keySet() { return counts.keySet(); }</para>
        <para>� Counter getCounter(String s) {</para>
        <para>��� return (Counter)counts.get(s);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws FileNotFoundException {</para>
        <para>��� WordCount wc =</para>
        <para>����� new WordCount(args[0]);</para>
        <para>��� wc.countWords();</para>
        <para>��� Iterator keys = wc.keySet().iterator();</para>
        <para>��� while(keys.hasNext()) {</para>
        <para>����� String key = (String)keys.next();</para>
        <para>����� System.out.println(key + &quot;: &quot;</para>
        <para>���������� ����+ wc.getCounter(key).read());</para>
        <para>��� }</para>
        <para>��� wc.cleanup();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Presenting the words in sorted form is easy to do by storing the data in a <emphasis role="bold">TreeMap</emphasis>, which automatically organizes<emphasis role="bold"/>its keys in sorted order (see Chapter 9). When you get a set of keys using <emphasis role="bold">keySet( )</emphasis>, they will also be in sorted order.</para>
        <para>To open the file, a <emphasis role="bold">FileReader</emphasis> is used, and to turn the file into words a <emphasis role="bold">StreamTokenizer</emphasis> is created from the <emphasis role="bold">FileReader</emphasis> wrapped in a <emphasis role="bold">BufferedReader</emphasis>. In <emphasis role="bold">StreamTokenizer</emphasis>, there is a default list of separators, and you can add more with a set of methods. Here, <emphasis role="bold">ordinaryChar( )</emphasis> is used to say �This character has no significance that I�m interested in,� so the parser doesn�t include it as part of any of the words that it creates. For example, saying <emphasis role="bold">st.ordinaryChar(&apos;.&apos;)</emphasis> means that periods will not be included as parts of the words that are parsed. You can find more information in the JDK HTML documentation from <emphasis role="italic">java.sun.com</emphasis>.</para>
        <para>In <emphasis role="bold">countWords( )</emphasis>, the tokens are pulled one at a time from the stream, and the <emphasis role="bold">ttype</emphasis> information is used to determine what to do with each token, since a token can be an end-of-line, a number, a string, or a single character.</para>
        <para>Once a token is found, the <emphasis role="bold">TreeMap</emphasis><emphasis role="bold"> counts</emphasis> is queried to see if it already contains the token as a key. If it does, the corresponding <emphasis role="bold">Counter</emphasis> object is incremented to indicate that another instance of this word has been found. If not, a new <emphasis role="bold">Counter</emphasis> is created�since the <emphasis role="bold">Counter</emphasis> constructor initializes its value to one, this also acts to count the word.</para>
        <para><emphasis role="bold">WordCount</emphasis> is not a type of <emphasis role="bold">TreeMap</emphasis>, so it wasn�t inherited. It performs a specific type of functionality, so even though the <emphasis role="bold">keys( )</emphasis> and <emphasis role="bold">values( )</emphasis> methods must be reexposed, that still doesn�t mean that inheritance should be used since a number of <emphasis role="bold">TreeMap</emphasis> methods are inappropriate here. In addition, other methods like <emphasis role="bold">getCounter( )</emphasis>, which get the <emphasis role="bold">Counter</emphasis> for a particular <emphasis role="bold">String</emphasis>, and <emphasis role="bold">sortedKeys( )</emphasis>, which produces an <emphasis role="bold">Iterator</emphasis>, finish the change in the shape of <emphasis role="bold">WordCount</emphasis>�s interface.</para>
        <para>In <emphasis role="bold">main( )</emphasis> you can see the use of a <emphasis role="bold">WordCount</emphasis> to open and count the words in a file�it just takes two lines of code. Then an Iterator to a sorted list of keys (words) is extracted, and this is used to pull out each key and associated <emphasis role="bold">Count</emphasis>. The call to <emphasis role="bold">cleanup( )</emphasis> is necessary to ensure that the file is closed.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064768"/><anchor xreflabel="StringTokenizer" xml:id="_Toc375545399"/><emphasis role="bold">StringTokenizer</emphasis></title>
        <para>Although it isn�t part of the I/O library, the <emphasis role="bold">StringTokenizer</emphasis> has sufficiently similar functionality to <emphasis role="bold">StreamTokenizer</emphasis> that it will be described here.</para>
        <para>The <emphasis role="bold">StringTokenizer</emphasis> returns the tokens within a string one at a time. These tokens are consecutive characters delimited by tabs, spaces, and newlines. Thus, the tokens of the string �Where is my cat?� are �Where�, �is�, �my�, and �cat?� Like the <emphasis role="bold">StreamTokenizer</emphasis>,<emphasis role="bold"/>you can tell the <emphasis role="bold">StringTokenizer</emphasis> to break up the input in any way that you want, but with <emphasis role="bold">StringTokenizer </emphasis>you do this by passing a second argument to the constructor, which is a <emphasis role="bold">String </emphasis>of the delimiters you wish to use. In general, if you need more sophistication, use a <emphasis role="bold">StreamTokenizer</emphasis>.</para>
        <para>You ask a <emphasis role="bold">StringTokenizer</emphasis> object for the next token in the string using the <emphasis role="bold">nextToken( )</emphasis> method, which either returns the token or an empty string to indicate that no tokens remain. </para>
        <para>As an example, the following program performs a limited analysis of a sentence, looking for key phrase sequences to indicate whether happiness or sadness is implied. </para>
        <para>//: c11:AnalyzeSentence.java</para>
        <para>// Look for particular sequences in sentences.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class AnalyzeSentence {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� analyze(&quot;I am happy about this&quot;);</para>
        <para>��� analyze(&quot;I am not happy about this&quot;);</para>
        <para>��� analyze(&quot;I am not! I am happy&quot;);</para>
        <para>��� analyze(&quot;I am sad about this&quot;);</para>
        <para>��� analyze(&quot;I am not sad about this&quot;);</para>
        <para>��� analyze(&quot;I am not! I am sad&quot;);</para>
        <para>��� analyze(&quot;Are you happy about this?&quot;);</para>
        <para>��� analyze(&quot;Are you sad about this?&quot;);</para>
        <para>��� analyze(&quot;It&apos;s you! I am happy&quot;);</para>
        <para>��� analyze(&quot;It&apos;s you! I am sad&quot;);</para>
        <para>� }</para>
        <para>� static StringTokenizer st;</para>
        <para>� static void analyze(String s) {</para>
        <para>��� prt(&quot;\nnew sentence &gt;&gt; &quot; + s);</para>
        <para>��� boolean sad = false;</para>
        <para>��� st = new StringTokenizer(s);</para>
        <para>��� while (st.hasMoreTokens()) {</para>
        <para>����� String token = next();</para>
        <para>����� // Look until you find one of the</para>
        <para>����� // two starting tokens:</para>
        <para>����� if(!token.equals(&quot;I&quot;) &amp;&amp;</para>
        <para>�������� !token.equals(&quot;Are&quot;))</para>
        <para>������� continue; // Top of while loop</para>
        <para>����� if(token.equals(&quot;I&quot;)) {</para>
        <para>������� String tk2 = next();</para>
        <para>������� if(!tk2.equals(&quot;am&quot;)) // Must be after I</para>
        <para>��������� break; // Out of while loop</para>
        <para>������� else {</para>
        <para>������ ���String tk3 = next();</para>
        <para>��������� if(tk3.equals(&quot;sad&quot;)) {</para>
        <para>����������� sad = true;</para>
        <para>����������� break; // Out of while loop</para>
        <para>��������� }</para>
        <para>��������� if (tk3.equals(&quot;not&quot;)) {</para>
        <para>����������� String tk4 = next();</para>
        <para>����������� if(tk4.equals(&quot;sad&quot;))</para>
        <para>������������� break; // Leave sad false</para>
        <para>����������� if(tk4.equals(&quot;happy&quot;)) {</para>
        <para>������������� sad = true;</para>
        <para>������������� break;</para>
        <para>����������� }</para>
        <para>��������� }</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>����� if(token.equals(&quot;Are&quot;)) {</para>
        <para>������� String tk2 = next();</para>
        <para>������� if(!tk2.equals(&quot;you&quot;))</para>
        <para>��������� break; // Must be after Are</para>
        <para>������� String tk3 = next();</para>
        <para>������� if(tk3.equals(&quot;sad&quot;))</para>
        <para>��������� sad = true;</para>
        <para>������� break; // Out of while loop</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� if(sad) prt(&quot;Sad detected&quot;);</para>
        <para>� }</para>
        <para>� static String next() {</para>
        <para>��� if(st.hasMoreTokens()) {</para>
        <para>����� String s = st.nextToken();</para>
        <para>����� prt(s);</para>
        <para>����� return s;</para>
        <para>��� } </para>
        <para>��� else</para>
        <para>����� return &quot;&quot;;</para>
        <para>� }</para>
        <para>� static void prt(String s) {</para>
        <para>��� System.out.println(s);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>For each string being analyzed, a <emphasis role="bold">while</emphasis> loop is entered and tokens are pulled off the string. Notice the first <emphasis role="bold">if</emphasis> statement, which says to <emphasis role="bold">continue</emphasis> (go back to the beginning of the loop and start again) if the token is neither an �I� nor an �Are.� �This means that it will get tokens until an �I� or an �Are� is found. You might think to use the <emphasis role="bold">==</emphasis> instead of the <emphasis role="bold">equals( )</emphasis> method, but that won�t work correctly, since <emphasis role="bold">==</emphasis> compares reference values while <emphasis role="bold">equals( )</emphasis> compares contents.</para>
        <para>The logic of the rest of the <emphasis role="bold">analyze( )</emphasis> method is that the pattern that�s being searched for is �I am sad,� �I am not happy,� or �Are you sad?� Without the <emphasis role="bold">break</emphasis> statement, the code for this would be even messier than it is. You should be aware that a typical parser (this is a primitive example of one) normally has a table of these tokens and a piece of code that moves through the states in the table as new tokens are read.</para>
        <para>You should think of the <emphasis role="bold">StringTokenizer</emphasis> only as shorthand for a simple and specific kind of <emphasis role="bold">StreamTokenizer</emphasis>. However, if you have a <emphasis role="bold">String</emphasis> that you want to tokenize and <emphasis role="bold">StringTokenizer</emphasis> is too limited, all you have to do is turn it into a stream with <emphasis role="bold">StringBufferInputStream</emphasis> and then use that to create a much more powerful <emphasis role="bold">StreamTokenizer</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064769"/><anchor xreflabel="Checking
capitalization style" xml:id="_Toc375545504"/>Checking capitalization style</title>
        <para>In this section we�ll look at a more complete example of the use of Java I/O, which also uses tokenization. This project is directly useful because it performs a style check to make sure that your capitalization conforms to the Java style as found at <emphasis role="italic">java.sun.com/docs/codeconv/index.html</emphasis>. It opens each <emphasis role="bold">.java</emphasis> file in the current directory and extracts all the class names and identifiers, then shows you if any of them don�t meet the Java style.</para>
        <para>For the program to operate correctly, you must first build a class name repository to hold all the class names in the standard Java library. You do this by moving into all the source code subdirectories for the standard Java library and running <emphasis role="bold">ClassScanner</emphasis> in each subdirectory. Provide as arguments the name of the repository file (using the same path and name each time) and the <emphasis role="bold">-a</emphasis> command-line option to indicate that the class names should be added to the repository.</para>
        <para>To use the program to check your code, hand it the path and name of the repository to use. It will check all the classes and identifiers in the current directory and tell you which ones don�t follow the typical Java capitalization style.</para>
        <para>You should be aware that the program isn�t perfect; there are a few times when it will point out what it thinks is a problem but on looking at the code you�ll see that nothing needs to be changed. This is a little annoying, but it�s still much easier than trying to find all these cases by staring at your code.</para>
        <para>//: c11:ClassScanner.java</para>
        <para>// Scans all files in directory for classes</para>
        <para>// and identifiers, to check capitalization.</para>
        <para>// Assumes properly compiling code listings.</para>
        <para>// Doesn&apos;t do everything right, but is a </para>
        <para>// useful aid.</para>
        <para>import java.io.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class MultiStringMap extends HashMap {</para>
        <para>� public void add(String key, String value) {</para>
        <para>��� if(!containsKey(key))</para>
        <para>����� put(key, new ArrayList());</para>
        <para>��� ((ArrayList)get(key)).add(value);</para>
        <para>� }</para>
        <para>� public ArrayList getArrayList(String key) {</para>
        <para>��� if(!containsKey(key)) {</para>
        <para>����� System.err.println(</para>
        <para>������� &quot;ERROR: can&apos;t find key: &quot; + key);</para>
        <para>����� System.exit(1);</para>
        <para>��� }</para>
        <para>��� return (ArrayList)get(key);</para>
        <para>� }</para>
        <para>� public void printValues(PrintStream p) {</para>
        <para>��� Iterator k = keySet().iterator();</para>
        <para>��� while(k.hasNext()) {</para>
        <para>����� String oneKey = (String)k.next();</para>
        <para>����� ArrayList val = getArrayList(oneKey);</para>
        <para>����� for(int i = 0; i &lt; val.size(); i++)</para>
        <para>������� p.println((String)val.get(i));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class ClassScanner {</para>
        <para>� private File path;</para>
        <para>� private String[] fileList;</para>
        <para>� private Properties classes = new Properties();</para>
        <para>� private MultiStringMap </para>
        <para>��� classMap = new MultiStringMap(),</para>
        <para>��� identMap = new MultiStringMap();</para>
        <para>� private StreamTokenizer in;</para>
        <para>� public ClassScanner() throws IOException {</para>
        <para>��� path = new File(&quot;.&quot;);</para>
        <para>��� fileList = path.list(new JavaFilter());</para>
        <para>��� for(int i = 0; i &lt; fileList.length; i++) {</para>
        <para>����� System.out.println(fileList[i]);</para>
        <para>����� try {</para>
        <para>������� scanListing(fileList[i]);</para>
        <para>����� } catch(FileNotFoundException e) {</para>
        <para>������� System.err.println(&quot;Could not open &quot; +</para>
        <para>��������� fileList[i]);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� void scanListing(String fname) </para>
        <para>� throws IOException {</para>
        <para>��� in = new StreamTokenizer(</para>
        <para>������� new BufferedReader(</para>
        <para>��������� new FileReader(fname)));</para>
        <para>��� // Doesn&apos;t seem to work:</para>
        <para>��� // in.slashStarComments(true);</para>
        <para>��� // in.slashSlashComments(true);</para>
        <para>��� in.ordinaryChar(&apos;/&apos;);</para>
        <para>��� in.ordinaryChar(&apos;.&apos;);</para>
        <para>��� in.wordChars(&apos;_&apos;, &apos;_&apos;);</para>
        <para>��� in.eolIsSignificant(true);</para>
        <para>��� while(in.nextToken() != </para>
        <para>��������� StreamTokenizer.TT_EOF) {</para>
        <para>����� if(in.ttype == &apos;/&apos;)</para>
        <para>�� �����eatComments();</para>
        <para>����� else if(in.ttype == </para>
        <para>������������� StreamTokenizer.TT_WORD) {</para>
        <para>������� if(in.sval.equals(&quot;class&quot;) || </para>
        <para>���������� in.sval.equals(&quot;interface&quot;)) {</para>
        <para>��������� // Get class name:</para>
        <para>������������ while(in.nextToken() != </para>
        <para>������������������ StreamTokenizer.TT_EOF</para>
        <para>������������������ &amp;&amp; in.ttype != </para>
        <para>������������������ StreamTokenizer.TT_WORD)</para>
        <para>�������������� ;</para>
        <para>������������ classes.put(in.sval, in.sval);</para>
        <para>������������ classMap.add(fname, in.sval);</para>
        <para>������� }</para>
        <para>������� if(in.sval.equals(&quot;import&quot;) ||</para>
        <para>� ���������in.sval.equals(&quot;package&quot;))</para>
        <para>��������� discardLine();</para>
        <para>������� else // It&apos;s an identifier or keyword</para>
        <para>��������� identMap.add(fname, in.sval);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� void discardLine() throws IOException {</para>
        <para>��� while(in.nextToken() != </para>
        <para>��������� StreamTokenizer.TT_EOF</para>
        <para>��������� &amp;&amp; in.ttype != </para>
        <para>��������� StreamTokenizer.TT_EOL)</para>
        <para>����� ; // Throw away tokens to end of line</para>
        <para>� }</para>
        <para>� // StreamTokenizer&apos;s comment removal seemed</para>
        <para>� // to be broken. This extracts them:</para>
        <para>� void eatComments() throws IOException {</para>
        <para>��� if(in.nextToken() != </para>
        <para>������ StreamTokenizer.TT_EOF) {</para>
        <para>����� if(in.ttype == &apos;/&apos;)</para>
        <para>������� discardLine();</para>
        <para>����� else if(in.ttype != &apos;*&apos;)</para>
        <para>������� in.pushBack();</para>
        <para>����� else </para>
        <para>������� while(true) {</para>
        <para>��������� if(in.nextToken() == </para>
        <para>����������� StreamTokenizer.TT_EOF)</para>
        <para>����������� break;</para>
        <para>��������� if(in.ttype == &apos;*&apos;)</para>
        <para>����������� if(in.nextToken() != </para>
        <para>������������� StreamTokenizer.TT_EOF</para>
        <para>������������� &amp;&amp; in.ttype == &apos;/&apos;)</para>
        <para>������������� break;</para>
        <para>������� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public String[] classNames() {</para>
        <para>��� String[] result = new String[classes.size()];</para>
        <para>��� Iterator e = classes.keySet().iterator();</para>
        <para>��� int i = 0;</para>
        <para>��� while(e.hasNext())</para>
        <para>����� result[i++] = (String)e.next();</para>
        <para>��� return result;</para>
        <para>� }</para>
        <para>� public void checkClassNames() {</para>
        <para>��� Iterator files = classMap.keySet().iterator();</para>
        <para>��� while(files.hasNext()) {</para>
        <para>����� String file = (String)files.next();</para>
        <para>����� ArrayList cls = classMap.getArrayList(file);</para>
        <para>����� for(int i = 0; i &lt; cls.size(); i++) {</para>
        <para>������� String className = (String)cls.get(i);</para>
        <para>������� if(Character.isLowerCase(</para>
        <para>������������ className.charAt(0)))</para>
        <para>��������� System.out.println(</para>
        <para>����������� &quot;class capitalization error, file: &quot;</para>
        <para>����������� + file + &quot;, class: &quot; </para>
        <para>����������� + className);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void checkIdentNames() {</para>
        <para>��� Iterator files = identMap.keySet().iterator();</para>
        <para>��� ArrayList reportSet = new ArrayList();</para>
        <para>��� while(files.hasNext()) {</para>
        <para>����� String file = (String)files.next();</para>
        <para>����� ArrayList ids = identMap.getArrayList(file);</para>
        <para>����� for(int i = 0; i &lt; ids.size(); i++) {</para>
        <para>������� String id = (String)ids.get(i);</para>
        <para>������� if(!classes.contains(id)) {</para>
        <para>��������� // Ignore identifiers of length 3 or</para>
        <para>��������� // longer that are all uppercase</para>
        <para>��������� // (probably static final values):</para>
        <para>��������� if(id.length() &gt;= 3 &amp;&amp;</para>
        <para>������������ id.equals(</para>
        <para>�������������� id.toUpperCase()))</para>
        <para>����������� continue;</para>
        <para>��������� // Check to see if first char is upper:</para>
        <para>��������� if(Character.isUpperCase(id.charAt(0))){</para>
        <para>����������� if(reportSet.indexOf(file + id)</para>
        <para>��������������� == -1){ // Not reported yet</para>
        <para>������������� reportSet.add(file + id);</para>
        <para>������������� System.out.println(</para>
        <para>��������������� &quot;Ident capitalization error in:&quot;</para>
        <para>��������������� + file + &quot;, ident: &quot; + id);</para>
        <para>����������� }</para>
        <para>��������� }</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� static final String usage =</para>
        <para>��� &quot;Usage: \n&quot; + </para>
        <para>��� &quot;ClassScanner classnames -a\n&quot; +</para>
        <para>��� &quot;\tAdds all the class names in this \n&quot; +</para>
        <para>��� &quot;\tdirectory to the repository file \n&quot; +</para>
        <para>��� &quot;\tcalled &apos;classnames&apos;\n&quot; +</para>
        <para>��� &quot;ClassScanner classnames\n&quot; +</para>
        <para>��� &quot;\tChecks all the java files in this \n&quot; +</para>
        <para>��� &quot;\tdirectory for capitalization errors, \n&quot; +</para>
        <para>��� &quot;\tusing the repository file &apos;classnames&apos;&quot;;</para>
        <para>� private static void usage() {</para>
        <para>��� System.err.println(usage);</para>
        <para>��� System.exit(1);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws IOException {</para>
        <para>��� if(args.length &lt; 1 || args.length &gt; 2)</para>
        <para>����� usage();</para>
        <para>��� ClassScanner c = new ClassScanner();</para>
        <para>��� File old = new File(args[0]);</para>
        <para>��� if(old.exists()) {</para>
        <para>����� try {</para>
        <para>������� // Try to open an existing </para>
        <para>������� // properties file:</para>
        <para>������� InputStream oldlist =</para>
        <para>��������� new BufferedInputStream(</para>
        <para>�� ���������new FileInputStream(old));</para>
        <para>������� c.classes.load(oldlist);</para>
        <para>������� oldlist.close();</para>
        <para>����� } catch(IOException e) {</para>
        <para>������� System.err.println(&quot;Could not open &quot;</para>
        <para>��������� + old + &quot; for reading&quot;);</para>
        <para>������� System.exit(1);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� if(args.length == 1) {</para>
        <para>����� c.checkClassNames();</para>
        <para>����� c.checkIdentNames();</para>
        <para>��� }</para>
        <para>��� // Write the class names to a repository:</para>
        <para>��� if(args.length == 2) {</para>
        <para>����� if(!args[1].equals(&quot;-a&quot;))</para>
        <para>������� usage();</para>
        <para>����� try {</para>
        <para>������� BufferedOutputStream out =</para>
        <para>��������� new BufferedOutputStream(</para>
        <para>����������� new FileOutputStream(args[0]));</para>
        <para>������� c.classes.store(out,</para>
        <para>��������� &quot;Classes found by ClassScanner.java&quot;);</para>
        <para>������� out.close();</para>
        <para>����� } catch(IOException e) {</para>
        <para>������� System.err.println(</para>
        <para>��������� &quot;Could not write &quot; + args[0]);</para>
        <para>������� System.exit(1);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class JavaFilter implements FilenameFilter {</para>
        <para>� public boolean accept(File dir, String name) {</para>
        <para>��� // Strip path information:</para>
        <para>��� String f = new File(name).getName();</para>
        <para>��� return f.trim().endsWith(&quot;.java&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The class <emphasis role="bold">MultiStringMap</emphasis> is a tool that allows you to map a group of strings onto each key entry. It uses a <emphasis role="bold">HashMap</emphasis> (this time with inheritance) with the key as the single string that�s mapped onto the <emphasis role="bold">ArrayList</emphasis> value. The <emphasis role="bold">add( )</emphasis> method simply checks to see if there�s a key already in the <emphasis role="bold">HashMap</emphasis>, and if not it puts one there. The <emphasis role="bold">getArrayList( )</emphasis> method produces an <emphasis role="bold">ArrayList</emphasis> for a particular key, and <emphasis role="bold">printValues( )</emphasis>, which is primarily useful for debugging, prints out all the values <emphasis role="bold">ArrayList</emphasis> by <emphasis role="bold">ArrayList</emphasis>.</para>
        <para>To keep life simple, the class names from the standard Java libraries are all put into a <emphasis role="bold">Properties</emphasis> object (from the standard Java library). Remember that a <emphasis role="bold">Properties</emphasis> object is a <emphasis role="bold">HashMap</emphasis> that holds only<emphasis role="bold"> String</emphasis> objects for both the key and value entries. However, it can be saved to disk and restored from disk in one method call, so it�s ideal for the repository of names. Actually, we need only a list of names, and a <emphasis role="bold">HashMap</emphasis> can�t accept <emphasis role="bold">null</emphasis> for either its key or its value entry. So the same object will be used for both the key and the value.</para>
        <para>For the classes and identifiers that are discovered for the files in a particular directory, two <emphasis role="bold">MultiStringMap</emphasis>s are used: <emphasis role="bold">classMap </emphasis>and <emphasis role="bold">identMap</emphasis>. Also, when the program starts up it loads the standard class name repository into the <emphasis role="bold">Properties </emphasis>object called <emphasis role="bold">classes</emphasis>, and when a new class name is found in the local directory that is also added to <emphasis role="bold">classes </emphasis>as well as to <emphasis role="bold">classMap</emphasis>. This way, <emphasis role="bold">classMap</emphasis> can be used to step through all the classes in the local directory, and <emphasis role="bold">classes</emphasis> can be used to see if the current token is a class name (which indicates a definition of an object or method is beginning, so grab the next tokens�until a semicolon�and put them into <emphasis role="bold">identMap</emphasis>).</para>
        <para>The default constructor for <emphasis role="bold">ClassScanner</emphasis> creates a list of file names, using the <emphasis role="bold">JavaFilter</emphasis> implementation of <emphasis role="bold">FilenameFilter</emphasis>, shown at the end of the file. Then it calls <emphasis role="bold">scanListing( )</emphasis> for each file name.</para>
        <para>Inside <emphasis role="bold">scanListing( )</emphasis> the source code file is opened and turned into a <emphasis role="bold">StreamTokenizer</emphasis>. In the documentation, passing <emphasis role="bold">true </emphasis>to <emphasis role="bold">slashStarComments( )</emphasis> and <emphasis role="bold">slashSlashComments( )</emphasis> is supposed to strip those comments out, but this seems to be a bit flawed, as it doesn�t quite work. Instead, those lines are commented out and the comments are extracted by another method. To do this, the �<emphasis role="bold">/</emphasis>� must be captured as an ordinary character rather than letting the <emphasis role="bold">StreamTokenizer</emphasis> absorb it as part of a comment, and the <emphasis role="bold">ordinaryChar( )</emphasis> method tells the <emphasis role="bold">StreamTokenizer </emphasis>to<emphasis role="bold"/>do this. This is also true for dots (�<emphasis role="bold">.</emphasis>�), since we want to have the method calls pulled apart into individual identifiers. However, the underscore, which is ordinarily treated by <emphasis role="bold">StreamTokenizer</emphasis> as an individual character, should be left as part of identifiers since it appears in such <emphasis role="bold">static</emphasis><emphasis role="bold">final</emphasis> values as <emphasis role="bold">TT_EOF</emphasis>, etc., used in this very program. The <emphasis role="bold">wordChars( ) </emphasis>method takes a range of characters you want to add to those that are left inside a token that is being parsed as a word. Finally, when parsing for one-line comments or discarding a line we need to know when an end-of-line occurs, so by calling <emphasis role="bold">eolIsSignificant(true)</emphasis> the EOL will show up rather than being absorbed by the <emphasis role="bold">StreamTokenizer</emphasis>.</para>
        <para>The rest of <emphasis role="bold">scanListing( )</emphasis> reads and reacts to tokens until the end of the file, signified when <emphasis role="bold">nextToken( )</emphasis> returns the <emphasis role="bold">final static </emphasis>value <emphasis role="bold">StreamTokenizer.TT_EOF</emphasis>. </para>
        <para>If the token is a �/� it is potentially a comment, so <emphasis role="bold">eatComments( )</emphasis> is called to deal with it. The only other situation we�re interested in here is if it�s a word, of which there are some special cases.</para>
        <para>If the word is <emphasis role="bold">class</emphasis> or <emphasis role="bold">interface</emphasis> then the next token represents a class or interface name, and it is put into <emphasis role="bold">classes</emphasis> and <emphasis role="bold">classMap</emphasis>. If the word is <emphasis role="bold">import</emphasis> or <emphasis role="bold">package</emphasis>, then we don�t want the rest of the line. Anything else must be an identifier (which we�re interested in) or a keyword (which we�re not, but they�re all lowercase anyway so it won�t spoil things to put those in). These are added to <emphasis role="bold">identMap</emphasis>.</para>
        <para>The <emphasis role="bold">discardLine( )</emphasis> method is a simple tool that looks for the end of a line. Note that any time you get a new token, you must check for the end of the file.</para>
        <para>The <emphasis role="bold">eatComments( )</emphasis> method is called whenever a forward slash is encountered in the main parsing loop. However, that doesn�t necessarily mean a comment has been found, so the next token must be extracted to see if it�s another forward slash (in which case the line is discarded) or an asterisk. But if it�s neither of those, it means the token you�ve just pulled out is needed back in the main parsing loop! Fortunately, the <emphasis role="bold">pushBack( )</emphasis> method allows you to �push back� the current token onto the input stream so that when the main parsing loop calls <emphasis role="bold">nextToken( )</emphasis> it will get the one you just pushed back.</para>
        <para>For convenience, the <emphasis role="bold">classNames( )</emphasis> method produces an array of all the names in the <emphasis role="bold">classes</emphasis> container. This method is not used in the program but is helpful for debugging.</para>
        <para>The next two methods are the ones in which the actual checking takes place. In <emphasis role="bold">checkClassNames( )</emphasis>, the class names are extracted from the <emphasis role="bold">classMap</emphasis> (which, remember, contains only the names in this directory, organized by file name so the file name can be printed along with the errant class name). This is accomplished by pulling each associated <emphasis role="bold">ArrayList</emphasis> and stepping through that, looking to see if the first character is lowercase. If so, the appropriate error message is printed.</para>
        <para>In <emphasis role="bold">checkIdentNames( )</emphasis>, a similar approach is taken: each identifier name is extracted from <emphasis role="bold">identMap</emphasis>. If the name is not in the <emphasis role="bold">classes</emphasis> list, it�s assumed to be an identifier or keyword. A special case is checked: if the identifier length is three or more <emphasis role="italic">and</emphasis> all the characters are uppercase, this identifier is ignored because it�s probably a <emphasis role="bold">static</emphasis><emphasis role="bold">final</emphasis> value such as <emphasis role="bold">TT_EOF</emphasis>. Of course, this is not a perfect algorithm, but it assumes that you�ll eventually notice any all-uppercase identifiers that are out of place.</para>
        <para>Instead of reporting every identifier that starts with an uppercase character, this method keeps track of which ones have already been reported in an <emphasis role="bold">ArrayList</emphasis> called <emphasis role="bold">reportSet( )</emphasis>. This treats the <emphasis role="bold">ArrayList</emphasis> as a �set� that tells you whether an item is already in the set. The item is produced by concatenating the file name and identifier. If the element isn�t in the set, it�s added and then the report is made.</para>
        <para>The rest of the listing is comprised of <emphasis role="bold">main( )</emphasis>, which busies itself by handling the command line arguments and figuring out whether you�re building a repository of class names from the standard Java library or checking the validity of code you�ve written. In both cases it makes a <emphasis role="bold">ClassScanner</emphasis> object.</para>
        <para>Whether you�re building a repository or using one, you must try to open the existing repository. By making a <emphasis role="bold">File</emphasis> object and testing for existence, you can decide whether to open the file and <emphasis role="bold">load( )</emphasis> the <emphasis role="bold">Properties</emphasis> list <emphasis role="bold">classes</emphasis> inside <emphasis role="bold">ClassScanner</emphasis>. (The classes from the repository add to, rather than overwrite, the classes found by the <emphasis role="bold">ClassScanner</emphasis> constructor.) If you provide only one command-line argument it means that you want to perform a check of the class names and identifier names, but if you provide two arguments (the second being �<emphasis role="bold">-a</emphasis>�)<emphasis role="bold"/>you�re building a class name repository. In this case, an output file is opened and the method <emphasis role="bold">Properties.save( )</emphasis> is used to write the list into a file, along with a string that provides header file information.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Summary" xml:id="_Toc481064770"/>Summary</title>
      <para>The Java I/O stream library does satisfy the basic requirements: you can perform reading and writing with the console, a file, a block of memory, or even across the Internet (as you will see in Chapter 15). With inheritance, you can create new types of input and output objects. And you can even add a simple extensibility to the kinds of objects a stream will accept by redefining the <emphasis role="bold">toString( )</emphasis> method that�s automatically called when you pass an object to a method that�s expecting a <emphasis role="bold">String</emphasis> (Java�s limited �automatic type conversion�). </para>
      <para>There are questions left unanswered by the documentation and design of the I/O stream library. For example, it would have been nice if you could say that you want an exception thrown if you try to overwrite a file when opening it for output�some programming systems allow you to specify that you want to open an output file, but only if it doesn�t already exist. In Java, it appears that you are supposed to use a <emphasis role="bold">File</emphasis> object to determine whether a file exists, because if you open it as a <emphasis role="bold">FileOutputStream</emphasis> or <emphasis role="bold">FileWriter </emphasis>it will always get overwritten.</para>
      <para>The I/O stream library brings up mixed feelings; it does much of the job and it�s portable. But if you don�t already understand the decorator pattern, the design is nonintuitive, so there�s extra overhead in learning and teaching it. It�s also incomplete: there�s no support for the kind of output formatting that almost every other language�s I/O package supports. </para>
      <para>However, once you <emphasis role="italic">do</emphasis> understand the decorator pattern and begin using the library in situations that require its flexibility, you can begin to benefit from this design, at which point its cost in extra lines of code may not bother you as much.</para>
      <para>If you do not find what you�re looking for in this chapter (which has only been an introduction, and is not meant to be comprehensive), you can find in-depth coverage in <emphasis role="italic">Java I/O</emphasis>, by Elliotte Rusty Harold (O�Reilly, 1999).</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064771"/><anchor xreflabel="Exercises" xml:id="_Toc375545401"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Open a text file so that you can read the file one line at a time. Read each line as a <emphasis role="bold">String </emphasis>and place that <emphasis role="bold">String </emphasis>object into a <emphasis role="bold">LinkedList</emphasis>. Print all of the lines in the <emphasis role="bold">LinkedList</emphasis> in reverse order.</para>
      <para>  179.         Modify Exercise 1 so that the name of the file you read is provided as a command-line argument.</para>
      <para>  180.         Modify Exercise 2 to also open a text file so you can write text into it. Write the lines in the <emphasis role="bold">ArrayList</emphasis>, along with line numbers (do not attempt to use the �LineNumber� classes), out to the file.</para>
      <para>  181.         Modify Exercise 2 to force all the lines in the <emphasis role="bold">ArrayList</emphasis> to upper case and send the results to <emphasis role="bold">System.out</emphasis>.</para>
      <para>  182.         Modify Exercise 2 to take additional command-line arguments of words to find in the file. Print any lines in which the words match.</para>
      <para>  183.         Modify <emphasis role="bold">DirList.java</emphasis> so that the <emphasis role="bold">FilenameFilter</emphasis> actually opens each file and accepts the file based on whether any of the trailing arguments on the command line exist in that file.</para>
      <para>  184.         Create a class called <emphasis role="bold">SortedDirList</emphasis> with a constructor that takes file path information and builds a sorted directory list from the files at that path. Create two overloaded <emphasis role="bold">list( ) </emphasis>methods that will either produce the whole list or a subset of the list based on an argument. Add a <emphasis role="bold">size( )</emphasis> method that takes a file name and produces the size of that file.</para>
      <para>  185.         Modify <emphasis role="bold">WordCount.java</emphasis> so that it produces an alphabetic sort instead, using the tool from Chapter 9.</para>
      <para>  186.         Modify <emphasis role="bold">WordCount.java</emphasis> so that it uses a class containing a <emphasis role="bold">String</emphasis> and a count value to store each different word, and a <emphasis role="bold">Set</emphasis> of these objects to maintain the list of words.</para>
      <para>  187.         Modify <emphasis role="bold">IOStreamDemo.java</emphasis> so that it uses <emphasis role="bold">LineNumberInputStream</emphasis> to keep track of the line count. Note that it�s much easier to just keep track programmatically.</para>
      <para>  188.         Starting with section 4 of <emphasis role="bold">IOStreamDemo.java</emphasis>, write a program that compares the performance of writing to a file when using buffered and unbuffered I/O.</para>
      <para>  189.         Modify section 5 of <emphasis role="bold">IOStreamDemo.java</emphasis> to eliminate the spaces in the line produced by the first call to <emphasis role="bold">in5br.readLine( )</emphasis>. Do this using a <emphasis role="bold">while</emphasis> loop and <emphasis role="bold">readChar( )</emphasis>.</para>
      <para>  190.         Repair the program <emphasis role="bold">CADState.java</emphasis> as described in the text.</para>
      <para>  191.         In <emphasis role="bold">Blips.java</emphasis>, copy the file and rename it to <emphasis role="bold">BlipCheck.java </emphasis>and rename the class <emphasis role="bold">Blip2</emphasis> to <emphasis role="bold">BlipCheck </emphasis>(making it <emphasis role="bold">public</emphasis> and removing the public scope from the class <emphasis role="bold">Blips</emphasis> in the process). Remove the <emphasis role="bold">//!</emphasis> marks in the file and execute the program including the offending lines. Next, comment out the default constructor for <emphasis role="bold">BlipCheck</emphasis>. Run it and explain why it works. Note that after compiling, you must execute the program with �<emphasis role="bold">java Blips</emphasis>� because the <emphasis role="bold">main( )</emphasis> method is still in class <emphasis role="bold">Blips</emphasis>.</para>
      <para>  192.         In <emphasis role="bold">Blip3.java</emphasis>, comment out the two lines after the phrases �You must do this:� and run the program. Explain the result and why it differs from when the two lines are in the program.</para>
      <para>  193.         (Intermediate) In Chapter 8, locate the <emphasis role="bold">GreenhouseControls.java</emphasis> example, which consists of three files. In <emphasis role="bold">GreenhouseControls.java</emphasis>, the <emphasis role="bold">Restart( )</emphasis> inner class has a hard-coded set of events. Change the program so that it reads the events and their relative times from a text file. (Challenging: Use a design patterns <emphasis role="italic">factory method </emphasis>to build the events�see <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com.</emphasis>)</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064772"/><anchor xreflabel="" xml:id="_Toc477690732"/><anchor xreflabel="" xml:id="_Toc375545404"/><anchor xreflabel="" xml:id="Chapter_11"/><anchor xreflabel="" xml:id="Chapter_12"/>12: Run-time Type Identification</title>
    <para>The idea of run-time type identification (RTTI) seems fairly simple at first: it lets you find the exact type of an object when you only have a reference to the base type. </para>
    <para>However, the <emphasis role="italic">need</emphasis> for RTTI uncovers a whole plethora of interesting (and often perplexing) OO design issues, and raises fundamental questions of how you should structure your programs. </para>
    <para>This chapter looks at the ways that Java allows you to discover information about objects and classes at run-time. This takes two forms: �traditional� RTTI, which assumes that you have all the types available at compile-time and run-time, and the �reflection� mechanism, which allows you to discover class information solely at run-time. The �traditional� RTTI will be covered first, followed by a discussion of reflection.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064773"/><anchor xreflabel="The
need for RTTI" xml:id="_Toc375545405"/>The need for RTTI</title>
      <para>Consider the now familiar example of a class hierarchy that uses polymorphism. The generic type is the base class <emphasis role="bold">Shape</emphasis>, and the specific derived types are <emphasis role="bold">Circle</emphasis>, <emphasis role="bold">Square</emphasis>, and <emphasis role="bold">Triangle</emphasis>:</para>
      <para><inlinemediaobject><imageobject role="html">
            <imagedata contentdepth="143" contentwidth="286" fileref="./TIJ2_files/image030.png" format="PNG" scalefit="1"/>
          </imageobject>
<imageobject role="fo">
            <imagedata contentdepth="100%" fileref="./TIJ2_files/image030.png" format="PNG" scalefit="1" width="100%"/>
          </imageobject>
</inlinemediaobject></para>
      <para>This is a typical class hierarchy diagram, with the base class at the top and the derived classes growing downward. The normal goal in object-oriented programming�is for the bulk of your code to manipulate references to the base type (<emphasis role="bold">Shape</emphasis>, in this case), so if you decide to extend the program by adding a new class (<emphasis role="bold">Rhomboid</emphasis>, derived from <emphasis role="bold">Shape</emphasis>, for example), the bulk of the code is not affected. In this example, the dynamically bound method in the <emphasis role="bold">Shape</emphasis> interface is <emphasis role="bold">draw( )</emphasis>, so the intent is for the client programmer to call <emphasis role="bold">draw( )</emphasis> through a generic <emphasis role="bold">Shape</emphasis> reference. <emphasis role="bold">draw( )</emphasis> is overridden in all of the derived classes, and because it is a dynamically bound method, the proper behavior will occur even though it is called through a generic <emphasis role="bold">Shape</emphasis> reference. That�s polymorphism.</para>
      <para>Thus, you generally create a specific object (<emphasis role="bold">Circle</emphasis>, <emphasis role="bold">Square</emphasis>, or <emphasis role="bold">Triangle</emphasis>), upcast it to a <emphasis role="bold">Shape</emphasis> (forgetting the specific type of the object), and use that anonymous <emphasis role="bold">Shape </emphasis>reference in the rest of the program.</para>
      <para>As a brief review of polymorphism and upcasting, you might code the above example as follows:</para>
      <para>//: c12:Shapes.java</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>class Shape {</para>
      <para>� void draw() {</para>
      <para>��� System.out.println(this + &quot;.draw()&quot;);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class Circle extends Shape {</para>
      <para>� public String toString() { return &quot;Circle&quot;; }</para>
      <para>}</para>
      <para> </para>
      <para>class Square extends Shape {</para>
      <para>� public String toString() { return &quot;Square&quot;; }</para>
      <para>}</para>
      <para> </para>
      <para>class Triangle extends Shape {</para>
      <para>� public String toString() { return &quot;Triangle&quot;; }</para>
      <para>}</para>
      <para> </para>
      <para>public class Shapes {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� ArrayList s = new ArrayList();</para>
      <para>��� s.add(new Circle());</para>
      <para>��� s.add(new Square());</para>
      <para>��� s.add(new Triangle());</para>
      <para>��� Iterator e = s.iterator();</para>
      <para>��� while(e.hasNext())</para>
      <para>����� ((Shape)e.next()).draw();</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The base class contains a <emphasis role="bold">draw( )</emphasis> method that indirectly uses <emphasis role="bold">toString( ) </emphasis>to print an identifier for the class by passing <emphasis role="bold">this</emphasis> to <emphasis role="bold">System.out.println( )</emphasis>. If that function sees an object, it automatically calls the <emphasis role="bold">toString( )</emphasis> method to produce a <emphasis role="bold">String</emphasis> representation.</para>
      <para>Each of the derived classes overrides the <emphasis role="bold">toString( )</emphasis> method (from <emphasis role="bold">Object</emphasis>) so that <emphasis role="bold">draw( )</emphasis> ends up printing something different in each case. In <emphasis role="bold">main( )</emphasis>, specific types of <emphasis role="bold">Shape</emphasis> are created and then added to an <emphasis role="bold">ArrayList</emphasis>. This is the point at which the upcast occurs because the <emphasis role="bold">ArrayList</emphasis> holds only <emphasis role="bold">Object</emphasis>s. Since everything in Java (with the exception of primitives) is an <emphasis role="bold">Object</emphasis>, an <emphasis role="bold">ArrayList</emphasis> can also hold <emphasis role="bold">Shape</emphasis> objects. But during an upcast to <emphasis role="bold">Object</emphasis>,<emphasis role="bold"/>it also loses any specific information, including the fact that the objects are <emphasis role="bold">Shape</emphasis>s. To the <emphasis role="bold">ArrayList</emphasis>, they are just <emphasis role="bold">Object</emphasis>s.</para>
      <para>At the point you fetch an element out of the <emphasis role="bold">ArrayList</emphasis> with <emphasis role="bold">next( )</emphasis>, things get a little busy. Since <emphasis role="bold">ArrayList</emphasis> holds only <emphasis role="bold">Object</emphasis>s, <emphasis role="bold">next( )</emphasis> naturally produces an <emphasis role="bold">Object reference</emphasis>. But we know it�s really a <emphasis role="bold">Shape</emphasis> reference, and we want to send <emphasis role="bold">Shape</emphasis> messages to that object. So a cast to <emphasis role="bold">Shape </emphasis>is necessary using the traditional �<emphasis role="bold">(Shape)</emphasis>� cast. This is the most basic form of RTTI, since in Java all casts are checked at run-time for correctness. That�s exactly what RTTI means: at run-time, the type of an object is identified.</para>
      <para>In this case, the RTTI cast is only partial: the <emphasis role="bold">Object</emphasis> is cast to a <emphasis role="bold">Shape</emphasis>, and not all the way to a <emphasis role="bold">Circle</emphasis>, <emphasis role="bold">Square</emphasis>, or <emphasis role="bold">Triangle</emphasis>. That�s because the only thing we <emphasis role="italic">know</emphasis> at this point is that the <emphasis role="bold">ArrayList</emphasis> is full of <emphasis role="bold">Shape</emphasis>s. At compile-time, this is enforced only by your own self-imposed rules, but at run-time the cast ensures it.</para>
      <para>Now polymorphism takes over and the exact method that�s called for the <emphasis role="bold">Shape</emphasis> is determined by whether the reference is for a <emphasis role="bold">Circle</emphasis>, <emphasis role="bold">Square</emphasis>, or <emphasis role="bold">Triangle</emphasis>. And in general, this is how it should be; you want the bulk of your code to know as little as possible about <emphasis role="italic">specific</emphasis> types of objects, and to just deal with the general representation of a family of objects (in this case, <emphasis role="bold">Shape</emphasis>). As a result, your code will be easier to write, read, and maintain, and your designs will be easier to implement, understand, and change. So polymorphism is the general goal in object-oriented programming.</para>
      <para>But what if you have a special programming problem that�s easiest to solve if you know the exact type of a generic reference? For example, suppose you want to allow your users to highlight all the shapes of any particular type by turning them purple. This way, they can find all the triangles on the screen by highlighting them. This is what RTTI accomplishes: you can ask a <emphasis role="bold">Shape</emphasis> reference the exact type that it�s referring to.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc312374135"/><anchor xreflabel="" xml:id="_Toc481064774"/><anchor xreflabel="The Class object" xml:id="_Toc375545406"/>The <emphasis role="bold">Class</emphasis> object</title>
        <para>To understand how RTTI works in Java, you must first know how type information is represented at run-time. This is accomplished through a special kind of object called the <emphasis role="italic">Class object,</emphasis> which contains information about the class. (This is sometimes called a <emphasis role="italic">meta-class.</emphasis>) In fact, the <emphasis role="bold">Class</emphasis> object is used to create all of the �regular� objects of your class.</para>
        <para>There�s a <emphasis role="bold">Class</emphasis> object for each class that is part of your program. That is, each time you write and compile a new class, a single <emphasis role="bold">Class</emphasis> object is also created (and stored, appropriately enough, in an identically named <emphasis role="bold">.class </emphasis>file). At run-time, when you want to make an object of that class, the Java Virtual Machine (JVM) that�s executing your program first checks to see if the <emphasis role="bold">Class</emphasis> object for that type is loaded. If not, the JVM loads it by finding the <emphasis role="bold">.class </emphasis>file with that name. Thus, a Java program isn�t completely loaded before it begins, which is different from many traditional languages.</para>
        <para>Once the <emphasis role="bold">Class</emphasis> object for that type is in memory, it is used to create all objects of that type.</para>
        <para>If this seems shadowy or if you don�t really believe it, here�s a demonstration program to prove it:</para>
        <para>//: c12:SweetShop.java</para>
        <para>// Examination of the way the class loader works.</para>
        <para> </para>
        <para>class Candy {</para>
        <para>� static {</para>
        <para>��� System.out.println(&quot;Loading Candy&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Gum {</para>
        <para>� static {</para>
        <para>��� System.out.println(&quot;Loading Gum&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Cookie {</para>
        <para>� static {</para>
        <para>��� System.out.println(&quot;Loading Cookie&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class SweetShop {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� System.out.println(&quot;inside main&quot;);</para>
        <para>��� new Candy();</para>
        <para>��� System.out.println(&quot;After creating Candy&quot;);</para>
        <para>��� try {</para>
        <para>����� Class.forName(&quot;Gum&quot;);</para>
        <para>��� } catch(ClassNotFoundException e) {</para>
        <para>����� e.printStackTrace(System.err);</para>
        <para>��� }</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;After Class.forName(\&quot;Gum\&quot;)&quot;);</para>
        <para>��� new Cookie();</para>
        <para>��� System.out.println(&quot;After creating Cookie&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Each of the classes <emphasis role="bold">Candy</emphasis>, <emphasis role="bold">Gum</emphasis>, and <emphasis role="bold">Cookie</emphasis> have a <emphasis role="bold">static</emphasis> clause that is executed as the class is loaded for the first time. Information will be printed to tell you when loading occurs for that class. In <emphasis role="bold">main( )</emphasis>, the object creations are spread out between print statements to help detect the time of loading.</para>
        <para>A particularly interesting line is:</para>
        <para>Class.forName(&quot;Gum&quot;);</para>
        <para> </para>
        <para>This method is a <emphasis role="bold">static</emphasis> member of <emphasis role="bold">Class</emphasis> (to which all <emphasis role="bold">Class</emphasis> objects belong). A <emphasis role="bold">Class</emphasis> object is like any other object and so you can get and manipulate a reference to it. (That�s what the loader does.) One of the ways to get a reference to the <emphasis role="bold">Class</emphasis> object is <emphasis role="bold">forName( )</emphasis>, which takes a <emphasis role="bold">String</emphasis> containing the textual name (watch the spelling and capitalization!) of the particular class you want a reference for. It returns a <emphasis role="bold">Class</emphasis> reference.</para>
        <para>The output of this program for one JVM is:</para>
        <para>inside main</para>
        <para>Loading Candy</para>
        <para>After creating Candy</para>
        <para>Loading Gum</para>
        <para>After Class.forName(&quot;Gum&quot;)</para>
        <para>Loading Cookie</para>
        <para>After creating Cookie</para>
        <para> </para>
        <para>You can see that each <emphasis role="bold">Class</emphasis> object is loaded only when it�s needed, and the <emphasis role="bold">static</emphasis> initialization is performed upon class loading.</para>
        <section>
          <title>Class literals</title>
          <para>Java provides a second way to produce the reference to the <emphasis role="bold">Class</emphasis> object, using a <emphasis role="italic">class literal</emphasis>. In the above program this would look like:</para>
          <para>Gum.class;</para>
          <para> </para>
          <para>which is not only simpler, but also safer since it�s checked at compile-time. Because it eliminates the method call, it�s also more efficient.</para>
          <para>Class literals work with regular classes as well as interfaces, arrays, and primitive types. In addition, there�s a standard field called <emphasis role="bold">TYPE</emphasis> that exists for each of the primitive wrapper classes. The <emphasis role="bold">TYPE</emphasis> field produces a reference to the <emphasis role="bold">Class</emphasis> object for the associated primitive type, such that:</para>
          <informaltable frame="all">
            <tgroup cols="2">
              <colspec colname="c1" colwidth="31*"/>
              <colspec colname="c2" colwidth="16*"/>
              <thead>
                <row>
                  <entry nameend="c2" namest="c1" valign="top"><para> � is equivalent to �</para></entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry valign="top"><para> <emphasis role="bold">boolean.class</emphasis></para></entry>
                  <entry valign="top"><para> <emphasis role="bold">Boolean.TYPE</emphasis></para></entry>
                </row>
                <row>
                  <entry valign="top"><para> <emphasis role="bold">char.class</emphasis></para></entry>
                  <entry valign="top"><para> <emphasis role="bold">Character.TYPE</emphasis></para></entry>
                </row>
                <row>
                  <entry valign="top"><para> <emphasis role="bold">byte.class</emphasis></para></entry>
                  <entry valign="top"><para> <emphasis role="bold">Byte.TYPE</emphasis></para></entry>
                </row>
                <row>
                  <entry valign="top"><para> <emphasis role="bold">short.class</emphasis></para></entry>
                  <entry valign="top"><para> <emphasis role="bold">Short.TYPE</emphasis></para></entry>
                </row>
                <row>
                  <entry valign="top"><para> <emphasis role="bold">int.class</emphasis></para></entry>
                  <entry valign="top"><para> <emphasis role="bold">Integer.TYPE</emphasis></para></entry>
                </row>
                <row>
                  <entry valign="top"><para> <emphasis role="bold">long.class</emphasis></para></entry>
                  <entry valign="top"><para> <emphasis role="bold">Long.TYPE</emphasis></para></entry>
                </row>
                <row>
                  <entry valign="top"><para> <emphasis role="bold">float.class</emphasis></para></entry>
                  <entry valign="top"><para> <emphasis role="bold">Float.TYPE</emphasis></para></entry>
                </row>
                <row>
                  <entry valign="top"><para> <emphasis role="bold">double.class</emphasis></para></entry>
                  <entry valign="top"><para> <emphasis role="bold">Double.TYPE</emphasis></para></entry>
                </row>
                <row>
                  <entry valign="top"><para> <emphasis role="bold">void.class</emphasis></para></entry>
                  <entry valign="top"><para> <emphasis role="bold">Void.TYPE</emphasis></para></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para><anchor xreflabel="My preference
is to use the �.class� versions if you can, since they�re more
consistent with regular classes." xml:id="_Toc375545408"/>My preference is to use the �<emphasis role="bold">.class</emphasis>� versions if you can, since they�re more consistent with regular classes.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Checking before a cast" xml:id="_Toc481064775"/>Checking before a cast</title>
        <para>So far, you�ve seen RTTI forms including:</para>
        <para>The classic cast; e.g., �<emphasis role="bold">(Shape),</emphasis>� which uses RTTI to make sure the cast is correct and throws a <emphasis role="bold">ClassCastException</emphasis> if you�ve performed a bad cast.</para>
        <para>83.      The <emphasis role="bold">Class</emphasis> object representing the type of your object. The <emphasis role="bold">Class</emphasis> object can be queried for useful run-time information.</para>
        <para>In C++, the classic cast �<emphasis role="bold">(Shape)</emphasis>� does <emphasis role="italic">not </emphasis>perform RTTI. It simply tells the compiler to treat the object as the new type. In Java, which does perform the type check, this cast is often called a �type safe downcast.� The reason for the term �downcast� is the historical arrangement of the class hierarchy diagram. If casting a <emphasis role="bold">Circle</emphasis> to a <emphasis role="bold">Shape</emphasis> is an upcast, then casting a <emphasis role="bold">Shape</emphasis> to a <emphasis role="bold">Circle</emphasis> is a downcast. However, you know a <emphasis role="bold">Circle</emphasis> is also a <emphasis role="bold">Shape</emphasis>, and the compiler freely allows an upcast assignment, but you <emphasis role="italic">don�t</emphasis> know that a <emphasis role="bold">Shape</emphasis> is necessarily a <emphasis role="bold">Circle</emphasis>, so the compiler doesn�t allow you to perform a downcast assignment without using an explicit cast. </para>
        <para>There�s a third form of RTTI in Java. This is the keyword <emphasis role="bold">instanceof</emphasis> that tells you if an object is an instance of a particular type. It returns a <emphasis role="bold">boolean </emphasis>so you use it in the form of a question, like this:</para>
        <para>if(x instanceof Dog)</para>
        <para>� ((Dog)x).bark();</para>
        <para> </para>
        <para>The above <emphasis role="bold">if</emphasis> statement checks to see if the object <emphasis role="bold">x</emphasis> belongs to the class <emphasis role="bold">Dog</emphasis><emphasis role="italic">before</emphasis> casting <emphasis role="bold">x</emphasis> to a <emphasis role="bold">Dog</emphasis>. It�s important to use <emphasis role="bold">instanceof</emphasis> before a downcast when you don�t have other information that tells you the type of the object; otherwise you�ll end up with a <emphasis role="bold">ClassCastException</emphasis>.</para>
        <para>Ordinarily, you might be hunting for one type (triangles to turn purple, for example), but you can easily tally <emphasis role="italic">all</emphasis> of the objects using <emphasis role="bold">instanceof</emphasis>. Suppose you have a family of <emphasis role="bold">Pet</emphasis> classes:</para>
        <para>//: c12:Pets.java</para>
        <para>class Pet {}</para>
        <para>class Dog extends Pet {}</para>
        <para>class Pug extends Dog {}</para>
        <para>class Cat extends Pet {}</para>
        <para>class Rodent extends Pet {}</para>
        <para>class Gerbil extends Rodent {}</para>
        <para>class Hamster extends Rodent {}</para>
        <para> </para>
        <para>class Counter { int i; } ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">Counter</emphasis> class is used to keep track of the number of any particular type of <emphasis role="bold">Pet</emphasis>. You could think of it as an <emphasis role="bold">Integer</emphasis> that can be modified.</para>
        <para>Using <emphasis role="bold">instanceof</emphasis>, all the pets can be counted:</para>
        <para>//: c12:PetCount.java</para>
        <para>// Using instanceof.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class PetCount {</para>
        <para>� static String[] typenames = {</para>
        <para>��� &quot;Pet&quot;, &quot;Dog&quot;, &quot;Pug&quot;, &quot;Cat&quot;,</para>
        <para>��� &quot;Rodent&quot;, &quot;Gerbil&quot;, &quot;Hamster&quot;,</para>
        <para>� };</para>
        <para>� // Exceptions thrown out to console:</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws Exception {</para>
        <para>��� ArrayList pets = new ArrayList();</para>
        <para>��� try {</para>
        <para>����� Class[] petTypes = {</para>
        <para>������� Class.forName(&quot;Dog&quot;),</para>
        <para>������� Class.forName(&quot;Pug&quot;),</para>
        <para>������� Class.forName(&quot;Cat&quot;),</para>
        <para>������� Class.forName(&quot;Rodent&quot;),</para>
        <para>������� Class.forName(&quot;Gerbil&quot;),</para>
        <para>������� Class.forName(&quot;Hamster&quot;),</para>
        <para>����� };</para>
        <para>����� for(int i = 0; i &lt; 15; i++)</para>
        <para>������� pets.add(</para>
        <para>��������� petTypes[</para>
        <para>������� ����(int)(Math.random()*petTypes.length)]</para>
        <para>����������� .newInstance());</para>
        <para>��� } catch(InstantiationException e) {</para>
        <para>����� System.err.println(&quot;Cannot instantiate&quot;);</para>
        <para>����� throw e;</para>
        <para>��� } catch(IllegalAccessException e) {</para>
        <para>����� System.err.println(&quot;Cannot access&quot;);</para>
        <para>����� throw e;</para>
        <para>��� } catch(ClassNotFoundException e) {</para>
        <para>����� System.err.println(&quot;Cannot find class&quot;);</para>
        <para>����� throw e;</para>
        <para>��� }</para>
        <para>��� HashMap h = new HashMap();</para>
        <para>��� for(int i = 0; i &lt; typenames.length; i++)</para>
        <para>����� h.put(typenames[i], new Counter());</para>
        <para>��� for(int i = 0; i &lt; pets.size(); i++) {</para>
        <para>����� Object o = pets.get(i);</para>
        <para>����� if(o instanceof Pet)</para>
        <para>������� ((Counter)h.get(&quot;Pet&quot;)).i++;</para>
        <para>����� if(o instanceof Dog)</para>
        <para>������� ((Counter)h.get(&quot;Dog&quot;)).i++;</para>
        <para>����� if(o instanceof Pug)</para>
        <para>������� ((Counter)h.get(&quot;Pug&quot;)).i++;</para>
        <para>��� ��if(o instanceof Cat)</para>
        <para>������� ((Counter)h.get(&quot;Cat&quot;)).i++;</para>
        <para>����� if(o instanceof Rodent)</para>
        <para>������� ((Counter)h.get(&quot;Rodent&quot;)).i++;</para>
        <para>����� if(o instanceof Gerbil)</para>
        <para>������� ((Counter)h.get(&quot;Gerbil&quot;)).i++;</para>
        <para>����� if(o instanceof Hamster)</para>
        <para>������� ((Counter)h.get(&quot;Hamster&quot;)).i++;</para>
        <para>��� }</para>
        <para>��� for(int i = 0; i &lt; pets.size(); i++)</para>
        <para>����� System.out.println(pets.get(i).getClass());</para>
        <para>��� for(int i = 0; i &lt; typenames.length; i++)</para>
        <para>����� System.out.println(</para>
        <para>������� typenames[i] + &quot; quantity: &quot; +</para>
        <para>������� ((Counter)h.get(typenames[i])).i);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><anchor xreflabel="" xml:id="_Toc305628782"/><anchor xreflabel="There�s a rather narrow restriction on instanceof: you can compare
it to a named type only, and not to a Class object. In the example above
you might feel that it�s tedious to write out all of those instanceof
expressions, and you�re right. But there is no way to cleverly automate instanceof by creating an ArrayList of Class objects and comparing it to
those instead (stay tuned�you�ll see an alternative). This isn�t as great a
restriction as you might think, because you�ll eventually understand that your
design is probably flawed if you end up writing a lot of instanceof
expressions." xml:id="_Toc305593310"/>There�s a rather narrow restriction on <emphasis role="bold">instanceof</emphasis>: you can compare it to a named type only, and not to a <emphasis role="bold">Class</emphasis> object. In the example above you might feel that it�s tedious to write out all of those <emphasis role="bold">instanceof</emphasis> expressions, and you�re right. But there is no way to cleverly automate <emphasis role="bold">instanceof </emphasis>by creating an <emphasis role="bold">ArrayList</emphasis> of <emphasis role="bold">Class</emphasis> objects and comparing it to those instead (stay tuned�you�ll see an alternative). This isn�t as great a restriction as you might think, because you�ll eventually understand that your design is probably flawed if you end up writing a lot of <emphasis role="bold">instanceof</emphasis> expressions.</para>
        <para>Of course this example is contrived�you�d probably put a <emphasis role="bold">static</emphasis> data member in each type and increment it in the constructor to keep track of the counts. You would do something like that <emphasis role="italic">if</emphasis> you had control of the source code for the class and could change it. Since this is not always the case, RTTI can come in handy.</para>
        <section>
          <title>Using class literals</title>
          <para>It�s interesting to see how the <emphasis role="bold">PetCount.java</emphasis> example can be rewritten using class literals. The result is cleaner in many ways:</para>
          <para>//: c12:PetCount2.java</para>
          <para>// Using class literals.</para>
          <para>import java.util.*;</para>
          <para> </para>
          <para>public class PetCount2 {</para>
          <para>� public static void main(String[] args) </para>
          <para>� throws Exception {</para>
          <para>��� ArrayList pets = new ArrayList();</para>
          <para>��� Class[] petTypes = {</para>
          <para>����� // Class literals:</para>
          <para>����� Pet.class,</para>
          <para>����� Dog.class,</para>
          <para>����� Pug.class,</para>
          <para>����� Cat.class,</para>
          <para>����� Rodent.class,</para>
          <para>����� Gerbil.class,</para>
          <para>����� Hamster.class,</para>
          <para>��� };</para>
          <para>��� try {</para>
          <para>����� for(int i = 0; i &lt; 15; i++) {</para>
          <para>������� // Offset by one to eliminate Pet.class:</para>
          <para>������� int rnd = 1 + (int)(</para>
          <para>��������� Math.random() * (petTypes.length - 1));</para>
          <para>������� pets.add(</para>
          <para>��������� petTypes[rnd].newInstance());</para>
          <para>����� }</para>
          <para>��� } catch(InstantiationException e) {</para>
          <para>����� System.err.println(&quot;Cannot instantiate&quot;);</para>
          <para>����� throw e;</para>
          <para>��� } catch(IllegalAccessException e) {</para>
          <para>����� System.err.println(&quot;Cannot access&quot;);</para>
          <para>����� throw e;</para>
          <para>��� }</para>
          <para>��� HashMap h = new HashMap();</para>
          <para>��� for(int i = 0; i &lt; petTypes.length; i++)</para>
          <para>����� h.put(petTypes[i].toString(),</para>
          <para>������� new Counter());</para>
          <para>��� for(int i = 0; i &lt; pets.size(); i++) {</para>
          <para>����� Object o = pets.get(i);</para>
          <para>����� if(o instanceof Pet)</para>
          <para>������� ((Counter)h.get(&quot;class Pet&quot;)).i++;</para>
          <para>����� if(o instanceof Dog)</para>
          <para>������� ((Counter)h.get(&quot;class Dog&quot;)).i++;</para>
          <para>����� if(o instanceof Pug)</para>
          <para>������� ((Counter)h.get(&quot;class Pug&quot;)).i++;</para>
          <para>����� if(o instanceof Cat)</para>
          <para>������� ((Counter)h.get(&quot;class Cat&quot;)).i++;</para>
          <para>����� if(o instanceof Rodent)</para>
          <para>������� ((Counter)h.get(&quot;class Rodent&quot;)).i++;</para>
          <para>����� if(o instanceof Gerbil)</para>
          <para>������� ((Counter)h.get(&quot;class Gerbil&quot;)).i++;</para>
          <para>����� if(o instanceof Hamster)</para>
          <para>������� ((Counter)h.get(&quot;class Hamster&quot;)).i++;</para>
          <para>��� }</para>
          <para>��� for(int i = 0; i &lt; pets.size(); i++)</para>
          <para>����� System.out.println(pets.get(i).getClass());</para>
          <para>��� Iterator keys = h.keySet().iterator();</para>
          <para>��� while(keys.hasNext()) {</para>
          <para>����� String nm = (String)keys.next();</para>
          <para>����� Counter cnt = (Counter)h.get(nm);</para>
          <para>����� System.out.println(</para>
          <para>������� nm.substring(nm.lastIndexOf(&apos;.&apos;) + 1) + </para>
          <para>������� &quot; quantity: &quot; + cnt.i);</para>
          <para>��� }</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>Here, the <emphasis role="bold">typenames</emphasis> array has been removed in favor of getting the type name strings from the <emphasis role="bold">Class</emphasis> object. Notice that the system can distinguish between classes and interfaces.</para>
          <para>You can also see that the creation of <emphasis role="bold">petTypes</emphasis> does not need to be surrounded by a <emphasis role="bold">try</emphasis> block since it�s evaluated at compile-time and thus won�t throw any exceptions, unlike <emphasis role="bold">Class.forName( )</emphasis>.</para>
          <para>When the <emphasis role="bold">Pet</emphasis> objects are dynamically created, you can see that the random number is restricted so it is between one and <emphasis role="bold">petTypes.length</emphasis> and does not include zero. That�s because zero refers to <emphasis role="bold">Pet.class</emphasis>, and presumably a generic <emphasis role="bold">Pet</emphasis> object is not interesting. However, since <emphasis role="bold">Pet.class</emphasis> is part of <emphasis role="bold">petTypes</emphasis> the result is that all of the pets get counted.</para>
        </section>
        <section>
          <title>A dynamic <emphasis role="bold">instanceof</emphasis></title>
          <para>The <emphasis role="bold">Class</emphasis><emphasis role="bold">isInstance</emphasis> method provides a way to dynamically call the <emphasis role="bold">instanceof</emphasis> operator. Thus, all those tedious <emphasis role="bold">instanceof</emphasis> statements can be removed in the <emphasis role="bold">PetCount</emphasis> example:</para>
          <para>//: c12:PetCount3.java</para>
          <para>// Using isInstance().</para>
          <para>import java.util.*;</para>
          <para> </para>
          <para>public class PetCount3 {</para>
          <para>� public static void main(String[] args) </para>
          <para>� throws Exception {</para>
          <para>��� ArrayList pets = new ArrayList();</para>
          <para>��� Class[] petTypes = {</para>
          <para>����� Pet.class,</para>
          <para>����� Dog.class,</para>
          <para>����� Pug.class,</para>
          <para>����� Cat.class,</para>
          <para>����� Rodent.class,</para>
          <para>����� Gerbil.class,</para>
          <para>����� Hamster.class,</para>
          <para>��� };</para>
          <para>��� try {</para>
          <para>����� for(int i = 0; i &lt; 15; i++) {</para>
          <para>������� // Offset by one to eliminate Pet.class:</para>
          <para>������� int rnd = 1 + (int)(</para>
          <para>��������� Math.random() * (petTypes.length - 1));</para>
          <para>������� pets.add(</para>
          <para>��������� petTypes[rnd].newInstance());</para>
          <para>����� }</para>
          <para>��� } catch(InstantiationException e) {</para>
          <para>����� System.err.println(&quot;Cannot instantiate&quot;);</para>
          <para>����� throw e;</para>
          <para>��� } catch(IllegalAccessException e) {</para>
          <para>����� System.err.println(&quot;Cannot access&quot;);</para>
          <para>����� throw e;</para>
          <para>��� }</para>
          <para>��� HashMap h = new HashMap();</para>
          <para>��� for(int i = 0; i &lt; petTypes.length; i++)</para>
          <para>����� h.put(petTypes[i].toString(),</para>
          <para>������� new Counter());</para>
          <para>��� for(int i = 0; i &lt; pets.size(); i++) {</para>
          <para>����� Object o = pets.get(i);</para>
          <para>����� // Using isInstance to eliminate individual</para>
          <para>����� // instanceof expressions:</para>
          <para>����� for (int j = 0; j &lt; petTypes.length; ++j)</para>
          <para>������� if (petTypes[j].isInstance(o)) {</para>
          <para>��������� String key = petTypes[j].toString();</para>
          <para>��������� ((Counter)h.get(key)).i++;</para>
          <para>������� }</para>
          <para>��� }</para>
          <para>� ��for(int i = 0; i &lt; pets.size(); i++)</para>
          <para>����� System.out.println(pets.get(i).getClass());</para>
          <para>��� Iterator keys = h.keySet().iterator();</para>
          <para>��� while(keys.hasNext()) {</para>
          <para>����� String nm = (String)keys.next();</para>
          <para>����� Counter cnt = (Counter)h.get(nm);</para>
          <para>����� System.out.println(</para>
          <para>������� nm.substring(nm.lastIndexOf(&apos;.&apos;) + 1) + </para>
          <para>������� &quot; quantity: &quot; + cnt.i);</para>
          <para>��� }</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>You can see that the <emphasis role="bold">isInstance( )</emphasis> method has eliminated the need for the <emphasis role="bold">instanceof</emphasis> expressions. In addition, this means that you can add new types of pets simply by changing the <emphasis role="bold">petTypes</emphasis> array; the rest of the program does not need modification (as it did when using the <emphasis role="bold">instanceof</emphasis> expressions).</para>
        </section>
        <section>
          <title><emphasis role="bold">instanceof</emphasis> vs. <emphasis role="bold">Class</emphasis> equivalence</title>
          <para>When querying for type information, there�s an important difference between either form of <emphasis role="bold">instanceof</emphasis> (that is, <emphasis role="bold">instanceof</emphasis> or <emphasis role="bold">isInstance( )</emphasis>, which produce equivalent results) and the direct comparison of the <emphasis role="bold">Class</emphasis> objects. Here�s an example that demonstrates the difference:</para>
          <para>//: c12:FamilyVsExactType.java</para>
          <para>// The difference between instanceof and class</para>
          <para> </para>
          <para>class Base {}</para>
          <para>class Derived extends Base {}</para>
          <para> </para>
          <para>public class FamilyVsExactType {</para>
          <para>� static void test(Object x) {</para>
          <para>��� System.out.println(&quot;Testing x of type &quot; +</para>
          <para>����� x.getClass());</para>
          <para>��� System.out.println(&quot;x instanceof Base &quot; +</para>
          <para>����� (x instanceof Base));</para>
          <para>��� System.out.println(&quot;x instanceof Derived &quot; +</para>
          <para>����� (x instanceof Derived));</para>
          <para>��� System.out.println(&quot;Base.isInstance(x) &quot; +</para>
          <para>����� Base.class.isInstance(x));</para>
          <para>��� System.out.println(&quot;Derived.isInstance(x) &quot; +</para>
          <para>����� Derived.class.isInstance(x));</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;x.getClass() == Base.class &quot; +</para>
          <para>����� (x.getClass() == Base.class));</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;x.getClass() == Derived.class &quot; +</para>
          <para>����� (x.getClass() == Derived.class));</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;x.getClass().equals(Base.class)) &quot; +</para>
          <para>����� (x.getClass().equals(Base.class)));</para>
          <para>��� System.out.println(</para>
          <para>����� &quot;x.getClass().equals(Derived.class)) &quot; +</para>
          <para>����� (x.getClass().equals(Derived.class)));</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� test(new Base());</para>
          <para>��� test(new Derived());</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The <emphasis role="bold">test( )</emphasis> method performs type checking with its argument using both forms of <emphasis role="bold">instanceof</emphasis>. It then gets the <emphasis role="bold">Class</emphasis> reference and uses <emphasis role="bold">==</emphasis> and <emphasis role="bold">equals( ) </emphasis>to test for equality of the <emphasis role="bold">Class</emphasis> objects. Here is the output:</para>
          <para>Testing x of type class Base</para>
          <para>x instanceof Base true</para>
          <para>x instanceof Derived false</para>
          <para>Base.isInstance(x) true</para>
          <para>Derived.isInstance(x) false</para>
          <para>x.getClass() == Base.class true</para>
          <para>x.getClass() == Derived.class false</para>
          <para>x.getClass().equals(Base.class)) true</para>
          <para>x.getClass().equals(Derived.class)) false</para>
          <para>Testing x of type class Derived</para>
          <para>x instanceof Base true</para>
          <para>x instanceof Derived true</para>
          <para>Base.isInstance(x) true</para>
          <para>Derived.isInstance(x) true</para>
          <para>x.getClass() == Base.class false</para>
          <para>x.getClass() == Derived.class true</para>
          <para>x.getClass().equals(Base.class)) false</para>
          <para>x.getClass().equals(Derived.class)) true</para>
          <para> </para>
          <para>Reassuringly, <emphasis role="bold">instanceof </emphasis>and <emphasis role="bold">isInstance( )</emphasis> produce exactly the same results, as do <emphasis role="bold">equals( )</emphasis> and <emphasis role="bold">==</emphasis>. But the tests themselves draw different conclusions. In keeping with the concept of type, <emphasis role="bold">instanceof</emphasis> says �are you this class, or a class derived from this class?� On the other hand, if you compare the actual <emphasis role="bold">Class</emphasis> objects using <emphasis role="bold">==</emphasis>, there is no concern with inheritance�it�s either the exact type or it isn�t.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545409"/><anchor xreflabel="" xml:id="_Toc312374146"/><anchor xreflabel="" xml:id="_Toc305628785"/><anchor xreflabel="" xml:id="_Toc305593313"/><anchor xreflabel="" xml:id="_Toc481064776"/><anchor xreflabel="RTTI syntax" xml:id="_Toc375545407"/>RTTI syntax</title>
      <para>Java performs its RTTI using the <emphasis role="bold">Class</emphasis> object, even if you�re doing something like a cast. The class <emphasis role="bold">Class</emphasis> also has a number of other ways you can use RTTI.</para>
      <para>First, you must get a reference to the appropriate <emphasis role="bold">Class</emphasis> object. One way to do this, as shown in the previous example, is to use a string and the <emphasis role="bold">Class.forName( )</emphasis> method. This is convenient because you don�t need an object of that type in order to get the <emphasis role="bold">Class</emphasis> reference. However, if you do already have an object of the type you�re interested in, you can fetch the <emphasis role="bold">Class</emphasis> reference by calling a method that�s part of the <emphasis role="bold">Object</emphasis> root class:<emphasis role="bold"/><emphasis role="bold">getClass( )</emphasis>. This returns the <emphasis role="bold">Class</emphasis> reference representing the actual type of the object. <emphasis role="bold">Class</emphasis> has many interesting methods, demonstrated in the following example:</para>
      <para>//: c12:ToyTest.java</para>
      <para>// Testing class Class.</para>
      <para> </para>
      <para>interface HasBatteries {}</para>
      <para>interface Waterproof {}</para>
      <para>interface ShootsThings {}</para>
      <para>class Toy {</para>
      <para>� // Comment out the following default</para>
      <para>� // constructor to see </para>
      <para>� // NoSuchMethodError from (*1*)</para>
      <para>� Toy() {} </para>
      <para>� Toy(int i) {} </para>
      <para>}</para>
      <para> </para>
      <para>class FancyToy extends Toy </para>
      <para>��� implements HasBatteries, </para>
      <para>����� Waterproof, ShootsThings {</para>
      <para>� FancyToy() { super(1); }</para>
      <para>}</para>
      <para> </para>
      <para>public class ToyTest {</para>
      <para>� public static void main(String[] args) </para>
      <para>� throws Exception {</para>
      <para>��� Class c = null;</para>
      <para>��� try {</para>
      <para>����� c = Class.forName(&quot;FancyToy&quot;);</para>
      <para>��� } catch(ClassNotFoundException e) {</para>
      <para>����� System.err.println(&quot;Can&apos;t find FancyToy&quot;);</para>
      <para>����� throw e;</para>
      <para>��� }</para>
      <para>��� printInfo(c);</para>
      <para>��� Class[] faces = c.getInterfaces();</para>
      <para>��� for(int i = 0; i &lt; faces.length; i++)</para>
      <para>����� printInfo(faces[i]);</para>
      <para>��� Class cy = c.getSuperclass();</para>
      <para>��� Object o = null;</para>
      <para>��� try {</para>
      <para>����� // Requires default constructor:</para>
      <para>����� o = cy.newInstance(); // (*1*)</para>
      <para>��� } catch(InstantiationException e) {</para>
      <para>����� System.err.println(&quot;Cannot instantiate&quot;);</para>
      <para>����� throw e;</para>
      <para>��� } catch(IllegalAccessException e) {</para>
      <para>����� System.err.println(&quot;Cannot access&quot;);</para>
      <para>����� throw e;</para>
      <para>��� }</para>
      <para>��� printInfo(o.getClass());</para>
      <para>� }</para>
      <para>� static void printInfo(Class cc) {</para>
      <para>��� System.out.println(</para>
      <para>����� &quot;Class name: &quot; + cc.getName() +</para>
      <para>����� &quot; is interface? [&quot; +</para>
      <para>����� cc.isInterface() + &quot;]&quot;);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>You can see that <emphasis role="bold">class FancyToy</emphasis> is quite complicated, since it inherits from <emphasis role="bold">Toy</emphasis> and <emphasis role="bold">implements</emphasis> the <emphasis role="bold">interface</emphasis>s of <emphasis role="bold">HasBatteries</emphasis>, <emphasis role="bold">Waterproof</emphasis>, and <emphasis role="bold">ShootsThings</emphasis>. In <emphasis role="bold">main( )</emphasis>, a <emphasis role="bold">Class</emphasis> reference is created and initialized to the <emphasis role="bold">FancyToy</emphasis><emphasis role="bold">Class</emphasis> using <emphasis role="bold">forName( )</emphasis> inside an appropriate <emphasis role="bold">try</emphasis> block.</para>
      <para>The <emphasis role="bold">Class.getInterfaces( )</emphasis>method returns an array of <emphasis role="bold">Class</emphasis> objects representing the interfaces that are contained in the <emphasis role="bold">Class</emphasis> object of interest.</para>
      <para>If you have a <emphasis role="bold">Class</emphasis> object you can also ask it for its direct base class using <emphasis role="bold">getSuperclass( )</emphasis>. This, of course, returns a <emphasis role="bold">Class</emphasis> reference that you can further query. This means that, at run-time, you can discover an object�s entire class hierarchy.</para>
      <para>The <emphasis role="bold">newInstance( )</emphasis> method of <emphasis role="bold">Class</emphasis> can, at first, seem like just another way to <emphasis role="bold">clone( )</emphasis> an object. However, you can create a new object with <emphasis role="bold">newInstance( )</emphasis><emphasis role="italic">without</emphasis> an existing object, as seen here, because there is no <emphasis role="bold">Toy</emphasis> object�only <emphasis role="bold">cy</emphasis>, which is a reference to <emphasis role="bold">y</emphasis>�s <emphasis role="bold">Class</emphasis> object. This is a way to implement a �virtual constructor,� which allows you to say �I don�t know exactly what type you are, but create yourself properly anyway.� In the example above, <emphasis role="bold">cy</emphasis> is just a <emphasis role="bold">Class</emphasis> reference with no further type information known at compile-time. And when you create a new instance, you get back an <emphasis role="bold">Object reference</emphasis>. But that reference is pointing to a <emphasis role="bold">Toy</emphasis> object. Of course, before you can send any messages other than those accepted by <emphasis role="bold">Object</emphasis>, you have to investigate it a bit and do some casting. In addition, the class that�s being created with <emphasis role="bold">newInstance( )</emphasis> must have a default constructor. In the next section, you�ll see how<emphasis role="bold"/>to dynamically create objects of classes using any constructor, with the Java <emphasis role="italic">reflection</emphasis> API.</para>
      <para>The final method in the listing is <emphasis role="bold">printInfo( ),</emphasis> which takes a <emphasis role="bold">Class</emphasis> reference and gets its name with <emphasis role="bold">getName( ),</emphasis> and finds out whether it�s an interface with <emphasis role="bold">isInterface( )</emphasis>.</para>
      <para>The output from this program is:</para>
      <para>Class name: FancyToy is interface? [false]</para>
      <para>Class name: HasBatteries is interface? [true]</para>
      <para>Class name: Waterproof is interface? [true]</para>
      <para>Class name: ShootsThings is interface? [true]</para>
      <para>Class name: Toy is interface? [false]</para>
      <para> </para>
      <para>Thus, with the <emphasis role="bold">Class</emphasis> object you can find out just about everything you want to know about an object.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc312374147"/><anchor xreflabel="" xml:id="_Toc481064777"/><anchor xreflabel="Reflection: run-time 
class information" xml:id="_Toc375545410"/>Reflection: run-time   class information</title>
      <para>If you don�t know the precise type of an object, RTTI will tell you. However, there�s a limitation: the type must be known at compile-time in order for you to be able to detect it using RTTI and do something useful with the information. Put another way, the compiler must know about all the classes you�re working with for RTTI.</para>
      <para>This doesn�t seem like that much of a limitation at first, but suppose you�re given a reference to an object that�s not in your program space. In fact, the class of the object isn�t even available to your program at compile-time. For example, suppose you get a bunch of bytes from a disk file or from a network connection and you�re told that those bytes represent a class. Since the compiler can�t know about the class while it�s compiling the code, how can you possibly use such a class?</para>
      <para>In a traditional programming environment this seems like a far-fetched scenario. But as we move into a larger programming world there are important cases in which this happens. The first is component-based programming, in which you build projects using <emphasis role="italic">Rapid Application Development</emphasis> (RAD) in an application builder tool. This is a visual approach to creating a program (which you see on the screen as a �form�) by moving icons that represent components onto the form. These components are then configured by setting some of their values at program time. This design-time configuration requires that any component be instantiable, that it exposes parts of itself, and that it allows its values to be read and set. In addition, components that handle GUI events must expose information about appropriate methods so that the RAD environment can assist the programmer in overriding these event-handling methods. Reflection provides the mechanism to detect the available methods and produce the method names. Java provides a structure for component-based programming through JavaBeans (described in Chapter 13).</para>
      <para>Another compelling motivation for discovering class information at run-time is to provide the ability to create and execute objects on remote platforms across a network. This is called <emphasis role="italic">Remote Method Invocation</emphasis> (RMI�) and it allows a Java program to have objects distributed across many machines. This distribution can happen for a number of reasons: for example, perhaps you�re doing a computation-intensive task and you want to break it up and put pieces on machines that are idle in order to speed things up. In some situations you might want to place code that handles particular types of tasks (e.g., �Business Rules� in a multitier client/server architecture) on a particular machine, so that machine becomes a common repository describing those actions and it can be easily changed to affect everyone in the system. (This is an interesting development, since the machine exists solely to make software changes easy!) Along these lines, distributed computing also supports specialized hardware that might be good at a particular task�matrix inversions, for example�but inappropriate or too expensive for general purpose programming.</para>
      <para>The class <emphasis role="bold">Class</emphasis> (described previously in this chapter) supports the concept of <emphasis role="italic">reflection</emphasis>, and there�s an additional library, <emphasis role="bold">java.lang.reflect, </emphasis>with classes <emphasis role="bold">Field</emphasis>, <emphasis role="bold">Method</emphasis>, and <emphasis role="bold">Constructor </emphasis>(each of which implement the <emphasis role="bold">Member interface</emphasis>). Objects of these types are created by the JVM at run-time to represent the corresponding member in the unknown class. You can then use the <emphasis role="bold">Constructor</emphasis>s to create new objects, the <emphasis role="bold">get( )</emphasis> and <emphasis role="bold">set( )</emphasis> methods to read and modify the fields associated with <emphasis role="bold">Field</emphasis> objects, and the <emphasis role="bold">invoke( )</emphasis> method to call a method associated with a <emphasis role="bold">Method</emphasis> object. In addition, you can call the convenience methods <emphasis role="bold">getFields( )</emphasis>, <emphasis role="bold">getMethods( )</emphasis>, <emphasis role="bold">getConstructors( )</emphasis>, etc., to return arrays of the objects representing the fields, methods, and constructors. (You can find out more by looking up the class <emphasis role="bold">Class</emphasis> in your online documentation.)<emphasis role="bold"/>Thus, the class information for anonymous objects can be completely determined at run-time, and nothing need be known at compile-time.</para>
      <para>It�s important to realize that there�s nothing magic about reflection. When you�re using reflection to interact with an object of an unknown type, the JVM will simply look at the object and see that it belongs to a particular class (just like ordinary RTTI) but then, before it can do anything else, the <emphasis role="bold">Class</emphasis> object must be loaded. Thus, the <emphasis role="bold">.class</emphasis> file for that particular type must still be available to the JVM, either on the local machine or across the network. So the true difference between RTTI and reflection is that with RTTI, the compiler opens and examines the <emphasis role="bold">.class</emphasis> file at compile-time. Put another way, you can call all the methods of an object in the �normal� way. With reflection, the <emphasis role="bold">.class</emphasis> file is unavailable at compile-time; it is opened and examined by the run-time environment.</para>
      <section>
        <title><anchor xreflabel="A class method extractor" xml:id="_Toc481064778"/>A class method extractor</title>
        <para>You�ll rarely need to use the reflection tools directly; they�re in the language to support other Java features, such as object serialization (Chapter 11), JavaBeans (Chapter 13), and RMI (Chapter 15). However, there are times when it�s quite useful to be able to dynamically extract information about a class. One extremely useful tool is a class method extractor. As mentioned before, looking at a class definition source code or online documentation shows only the methods that are defined or overridden <emphasis role="italic">within that class definition</emphasis>. But there could be dozens more available to you that have come from base classes. To locate these is both tedious and time consuming<anchor xreflabel="[60]" xml:id="_ftnref60"/>[60]. Fortunately, reflection provides a way to write a simple tool that will automatically show you the entire interface. Here�s the way it works:</para>
        <para>//: c12:ShowMethods.java</para>
        <para>// Using reflection to show all the methods of </para>
        <para>// a class, even if the methods are defined in </para>
        <para>// the base class.</para>
        <para>import java.lang.reflect.*;</para>
        <para> </para>
        <para>public class ShowMethods {</para>
        <para>� static final String usage =</para>
        <para>��� &quot;usage: \n&quot; +</para>
        <para>��� &quot;ShowMethods qualified.class.name\n&quot; +</para>
        <para>��� &quot;To show all methods in class or: \n&quot; +</para>
        <para>��� &quot;ShowMethods qualified.class.name word\n&quot; +</para>
        <para>��� &quot;To search for methods involving &apos;word&apos;&quot;;</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� if(args.length &lt; 1) {</para>
        <para>����� System.out.println(usage);</para>
        <para>����� System.exit(0);</para>
        <para>��� }</para>
        <para>��� try {</para>
        <para>����� Class c = Class.forName(args[0]);</para>
        <para>����� Method[] m = c.getMethods();</para>
        <para>����� Constructor[] ctor = c.getConstructors();</para>
        <para>����� if(args.length == 1) {</para>
        <para>������� for (int i = 0; i &lt; m.length; i++)</para>
        <para>��������� System.out.println(m[i]);</para>
        <para>������� for (int i = 0; i &lt; ctor.length; i++)</para>
        <para>��������� System.out.println(ctor[i]);</para>
        <para>����� } else {</para>
        <para>������� for (int i = 0; i &lt; m.length; i++)</para>
        <para>��������� if(m[i].toString()</para>
        <para>������������ .indexOf(args[1])!= -1)</para>
        <para>����������� System.out.println(m[i]);</para>
        <para>������� for (int i = 0; i &lt; ctor.length; i++)</para>
        <para>��������� if(ctor[i].toString()</para>
        <para>���������� ��.indexOf(args[1])!= -1)</para>
        <para>��������� System.out.println(ctor[i]);</para>
        <para>����� }</para>
        <para>��� } catch(ClassNotFoundException e) {</para>
        <para>����� System.err.println(&quot;No such class: &quot; + e);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">Class</emphasis> methods <emphasis role="bold">getMethods( )</emphasis> and <emphasis role="bold">getConstructors( )</emphasis> return an array of <emphasis role="bold">Method</emphasis> and <emphasis role="bold">Constructor</emphasis>, respectively. Each of these classes has further methods to dissect the names, arguments, and return values of the methods they represent. But you can also just use <emphasis role="bold">toString( )</emphasis>, as is done here, to produce a <emphasis role="bold">String</emphasis> with the entire method signature. The rest of the code is just for extracting command line information, determining if a particular signature matches with your target string (using <emphasis role="bold">indexOf( )</emphasis>), and printing the results.</para>
        <para>This shows reflection in action, since the result produced by <emphasis role="bold">Class.forName( )</emphasis> cannot be known at compile-time, and therefore all the method signature information is being extracted at run-time. If you investigate your online documentation on reflection, you�ll see that there is enough support to actually set up and make a method call on an object that�s totally unknown at compile-time (there will be examples of this later in this book). Again, this is something you may never need to do yourself�the support is there for RMI and so a programming environment can manipulate JavaBeans�but it�s interesting.</para>
        <para>An interesting experiment is to run </para>
        <para>java ShowMethods ShowMethods</para>
        <para> </para>
        <para>This produces a listing that includes a <emphasis role="bold">public</emphasis> default constructor, even though you can see from the code that no constructor was defined. The constructor you see is the one that�s automatically synthesized by the compiler. If you then make <emphasis role="bold">ShowMethods</emphasis> a non-<emphasis role="bold">public</emphasis> class (that is, friendly), the synthesized default constructor no longer shows up in the output. The synthesized default constructor is automatically given the same access as the class.</para>
        <para>The output for <emphasis role="bold">ShowMethods</emphasis> is still a little tedious. For example, here�s a portion of the output produced by invoking <emphasis role="bold">java ShowMethods java.lang.String</emphasis>:</para>
        <para>public boolean </para>
        <para>� java.lang.String.startsWith(java.lang.String,int)</para>
        <para>public boolean </para>
        <para>� java.lang.String.startsWith(java.lang.String)</para>
        <para>public boolean</para>
        <para>� java.lang.String.endsWith(java.lang.String)</para>
        <para> </para>
        <para>It would be even nicer if the qualifiers like <emphasis role="bold">java.lang</emphasis> could be stripped off. The <emphasis role="bold">StreamTokenizer</emphasis> class introduced in the previous chapter can help create a tool to solve this problem:</para>
        <para>//: com:bruceeckel:util:StripQualifiers.java</para>
        <para>package com.bruceeckel.util;</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>public class StripQualifiers {</para>
        <para>� private StreamTokenizer st;</para>
        <para>� public StripQualifiers(String qualified) {</para>
        <para>��� st = new StreamTokenizer(</para>
        <para>����� new StringReader(qualified));</para>
        <para>��� st.ordinaryChar(&apos;&apos;); // Keep the spaces</para>
        <para>� }</para>
        <para>� public String getNext() {</para>
        <para>��� String s = null;</para>
        <para>��� try {</para>
        <para>����� int token = st.nextToken();</para>
        <para>����� if(token != StreamTokenizer.TT_EOF) {</para>
        <para>������� switch(st.ttype) {</para>
        <para>��������� case StreamTokenizer.TT_EOL:</para>
        <para>����������� s = null;</para>
        <para>����������� break;</para>
        <para>��������� case StreamTokenizer.TT_NUMBER:</para>
        <para>����������� s = Double.toString(st.nval);</para>
        <para>����������� break;</para>
        <para>��������� case StreamTokenizer.TT_WORD:</para>
        <para>����������� s = new String(st.sval);</para>
        <para>����������� break;</para>
        <para>��������� default: // single character in ttype</para>
        <para>����������� s = String.valueOf((char)st.ttype);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� } catch(IOException e) {</para>
        <para>����� System.err.println(&quot;Error fetching token&quot;);</para>
        <para>��� }</para>
        <para>��� return s;</para>
        <para>� }</para>
        <para>� public static String strip(String qualified) {</para>
        <para>��� StripQualifiers sq = </para>
        <para>����� new StripQualifiers(qualified);</para>
        <para>��� String s = &quot;&quot;, si;</para>
        <para>��� while((si = sq.getNext()) != null) {</para>
        <para>����� int lastDot = si.lastIndexOf(&apos;.&apos;);</para>
        <para>����� if(lastDot != -1)</para>
        <para>������� si = si.substring(lastDot + 1);</para>
        <para>����� s += si;</para>
        <para>��� }</para>
        <para>��� return s;</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>To facilitate reuse, this class is placed in <emphasis role="bold">com.bruceeckel.util</emphasis>. As you can see, this uses the <emphasis role="bold">StreamTokenizer</emphasis> and <emphasis role="bold">String</emphasis> manipulation to do its work.</para>
        <para>The new version of the program uses the above class to clean up the output:</para>
        <para>//: c12:ShowMethodsClean.java</para>
        <para>// ShowMethods with the qualifiers stripped</para>
        <para>// to make the results easier to read.</para>
        <para>import java.lang.reflect.*;</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>public class ShowMethodsClean {</para>
        <para>� static final String usage =</para>
        <para>��� &quot;usage: \n&quot; +</para>
        <para>��� &quot;ShowMethodsClean qualified.class.name\n&quot; +</para>
        <para>��� &quot;To show all methods in class or: \n&quot; +</para>
        <para>��� &quot;ShowMethodsClean qualif.class.name word\n&quot; +</para>
        <para>��� &quot;To search for methods involving &apos;word&apos;&quot;;</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� if(args.length &lt; 1) {</para>
        <para>����� System.out.println(usage);</para>
        <para>����� System.exit(0);</para>
        <para>��� }</para>
        <para>��� try {</para>
        <para>����� Class c = Class.forName(args[0]);</para>
        <para>����� Method[] m = c.getMethods();</para>
        <para>����� Constructor[] ctor = c.getConstructors();</para>
        <para>����� // Convert to an array of cleaned Strings:</para>
        <para>����� String[] n = </para>
        <para>������� new String[m.length + ctor.length];</para>
        <para>����� for(int i = 0; i &lt; m.length; i++) {</para>
        <para>������� String s = m[i].toString();</para>
        <para>������� n[i] = StripQualifiers.strip(s);</para>
        <para>����� }</para>
        <para>����� for(int i = 0; i &lt; ctor.length; i++) {</para>
        <para>������� String s = ctor[i].toString();</para>
        <para>������� n[i + m.length] = </para>
        <para>��������� StripQualifiers.strip(s);</para>
        <para>����� }</para>
        <para>����� if(args.length == 1)</para>
        <para>����� ��for (int i = 0; i &lt; n.length; i++)</para>
        <para>��������� System.out.println(n[i]);</para>
        <para>����� else</para>
        <para>������� for (int i = 0; i &lt; n.length; i++)</para>
        <para>��������� if(n[i].indexOf(args[1])!= -1)</para>
        <para>����������� System.out.println(n[i]);</para>
        <para>��� } catch(ClassNotFoundException e) {</para>
        <para>����� System.err.println(&quot;No such class: &quot; + e);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The class <emphasis role="bold">ShowMethodsClean</emphasis> is quite similar to the previous <emphasis role="bold">ShowMethods</emphasis>, except that it takes the arrays of <emphasis role="bold">Method</emphasis> and <emphasis role="bold">Constructor</emphasis> and converts them into a single array of <emphasis role="bold">String</emphasis>. Each of these <emphasis role="bold">String</emphasis> objects is then passed through<emphasis role="bold"> StripQualifiers.Strip( )</emphasis> to remove all the method qualification.</para>
        <para>This tool can be a real time-saver while you�re programming, when you can�t remember if a class has a particular method and you don�t want to go walking through the class hierarchy in the online documentation, or if you don�t know whether that class can do anything with, for example, <emphasis role="bold">Color</emphasis> objects.</para>
        <para>Chapter 13 contains a GUI version of this program (customized to extract information for Swing components) so you can leave it running while you�re writing code, to allow quick lookups.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545411"/><anchor xreflabel="Summary" xml:id="_Toc481064779"/>Summary</title>
      <para>RTTI allows you to discover type information from an anonymous base-class reference. Thus, it�s ripe for misuse by the novice since it might make sense before polymorphic method calls do. For many people coming from a procedural background, it�s difficult not to organize their programs into sets of <emphasis role="bold">switch</emphasis> statements. They could accomplish this with RTTI and thus lose the important value of polymorphism in code development and maintenance. The intent of Java is that you use polymorphic method calls throughout your code, and you use RTTI only when you must.</para>
      <para>However, using polymorphic method calls as they are intended requires that you have control of the base-class definition because at some point in the extension of your program you might discover that the base class doesn�t include the method you need. If the base class comes from a library or is otherwise controlled by someone else, a solution to the problem is RTTI: You can inherit a new type and add your extra method. Elsewhere in the code you can detect your particular type and call that special method. This doesn�t destroy the polymorphism and extensibility of the program because adding a new type will not require you to hunt for switch statements in your program. However, when you add new code in your main body that requires your new feature, you must use RTTI to detect your particular type.</para>
      <para>Putting a feature in a base class might mean that, for the benefit of one particular class, all of the other classes derived from that base require some meaningless stub of a method. This makes the interface less clear and annoys those who must override abstract methods when they derive from that base class. For example, consider a class hierarchy representing musical instruments. Suppose you wanted to clear the spit valves of all the appropriate instruments in your orchestra. One option is to put a <emphasis role="bold">clearSpitValve( ) </emphasis>method in the base class <emphasis role="bold">Instrument</emphasis>, but this is confusing because it implies that <emphasis role="bold">Percussion</emphasis> and <emphasis role="bold">Electronic</emphasis> instruments also have spit valves. RTTI provides a much more reasonable solution in this case because you can place the method in the specific class (<emphasis role="bold">Wind </emphasis>in this case), where it�s appropriate. However, a more appropriate solution is to put a <emphasis role="bold">prepareInstrument( )</emphasis> method in the base class, but you might not see this when you�re first solving the problem and could mistakenly assume that you must use RTTI.</para>
      <para>Finally, RTTI will sometimes solve efficiency problems. If your code nicely uses polymorphism, but it turns out that one of your objects reacts to this general purpose code in a horribly inefficient way, you can pick out that type using RTTI and write case-specific code to improve the efficiency. Be wary, however, of programming for efficiency too soon. It�s a seductive trap. It�s best to get the program working <emphasis role="italic">first</emphasis>, then decide if it�s running fast enough, and only then should you attack efficiency issues�with a profiler.</para>
    </section>
    <section>
      <title><anchor xreflabel="Exercises" xml:id="_Toc481064780"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Add <emphasis role="bold">Rhomboid </emphasis>to <emphasis role="bold">Shapes.java</emphasis>. Create a <emphasis role="bold">Rhomboid</emphasis>, upcast it to a <emphasis role="bold">Shape</emphasis>, then downcast it back to a <emphasis role="bold">Rhomboid</emphasis>. Try downcasting to a <emphasis role="bold">Circle</emphasis> and see what happens.</para>
      <para>  194.         Modify Exercise 1 so that it uses <emphasis role="bold">instanceof</emphasis> to check the type before performing the downcast.</para>
      <para>  195.         Modify <emphasis role="bold">Shapes.java</emphasis> so that it can �highlight� (set a flag) in all shapes of a particular type. The <emphasis role="bold">toString( )</emphasis> method for each derived <emphasis role="bold">Shape</emphasis> should indicate whether that <emphasis role="bold">Shape </emphasis>is �highlighted.�</para>
      <para>  196.         Modify <emphasis role="bold">SweetShop.java</emphasis> so that each type of object creation is controlled by a command-line argument. That is, if your command line is �<emphasis role="bold">java SweetShop Candy</emphasis>,� then only the <emphasis role="bold">Candy</emphasis> object is created. Notice how you can control which <emphasis role="bold">Class</emphasis> objects are loaded via the command-line argument.</para>
      <para>  197.         Add a new type of <emphasis role="bold">Pet</emphasis> to <emphasis role="bold">PetCount3.java</emphasis>. Verify that it is created and counted correctly in <emphasis role="bold">main( )</emphasis>.</para>
      <para>  198.         Write a method that takes an object and recursively prints all the classes in that object�s hierarchy.</para>
      <para>  199.         Modify Exercise 6 so that it uses <emphasis role="bold">Class.</emphasis><link xl:href="../../../../My%20Documents/ProgToolsjdk1.3docsapijavalangClass.html#getDeclaredFields()"><emphasis role="bold">getDeclaredFields</emphasis></link><emphasis role="bold">( )</emphasis> to also display information about the fields in a class.</para>
      <para>  200.         In <emphasis role="bold">ToyTest.java</emphasis>, comment out <emphasis role="bold">Toy</emphasis>�s default constructor and explain what happens.</para>
      <para>  201.         Incorporate a new kind of <emphasis role="bold">interface</emphasis> into <emphasis role="bold">ToyTest.java</emphasis> and verify that it is detected and displayed properly.</para>
      <para>  202.         Create a new type of container that uses a <emphasis role="bold">private</emphasis><emphasis role="bold">ArrayList</emphasis> to hold the objects.<emphasis role="bold"/>Capture the type of the first object you put in it, and then allow the user to insert objects of only that type from then on.</para>
      <para>  203.         Write a program to determine whether an array of <emphasis role="bold">char</emphasis> is a primitive type or a true object.</para>
      <para>  204.         Implement <emphasis role="bold">clearSpitValve( )</emphasis> as described in the summary.</para>
      <para>  205.         Implement the <emphasis role="bold">rotate(Shape)</emphasis> method described in this chapter, such that it checks to see if it is rotating a <emphasis role="bold">Circle</emphasis> (and, if so, doesn�t perform the operation).</para>
      <para>  206.         Modify Exercise 6 so that it uses reflection instead of RTTI.</para>
      <para>  207.         Modify Exercise 7 so that it uses reflection instead of RTTI.</para>
      <para>  208.         In <emphasis role="bold">ToyTest.java</emphasis>, use reflection to create a <emphasis role="bold">Toy</emphasis> object using the nondefault constructor.</para>
      <para>  209.         Look up the interface for <emphasis role="bold">java.lang.Class</emphasis> in the HTML Java documentation from <emphasis role="italic">java.sun.com</emphasis>. Write a program that takes the name of a class as a command-line argument, then uses the <emphasis role="bold">Class</emphasis> methods to dump all the information available for that class. Test your program with a standard library class and� a class you create.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="Chapter_14"/><anchor xreflabel="" xml:id="_Toc481064781"/><anchor xreflabel="" xml:id="_Toc477690733"/><anchor xreflabel="" xml:id="_Toc375545444"/><anchor xreflabel="" xml:id="Chapter_15"/>13: Creating Windows   &amp; Applets</title>
    <para>A fundamental design guideline is �make simple things easy, and difficult things possible.�<anchor xreflabel="[61]" xml:id="_ftnref61"/>[61]</para>
    <para>The original design goal of the graphical user interface (GUI) library in Java 1.0 was to allow the programmer to build a GUI that looks good on all platforms. That goal was not achieved. Instead, the Java 1.0�<emphasis role="italic">Abstract Window Toolkit</emphasis> (AWT) produces a GUI that looks equally mediocre on all systems. In addition, it�s restrictive: you can use only four fonts and you cannot access any of the more sophisticated GUI elements that exist in your operating system. The Java 1.0 AWT programming model is also awkward and non-object-oriented. A student in one of my seminars (who had been at Sun during the creation of Java) explained why: the original AWT had been conceptualized, designed, and implemented in a month. Certainly a marvel of productivity, and also an object lesson in why design is important.</para>
    <para>The situation improved with the Java 1.1 AWT event model, which takes a much clearer, object-oriented approach, along with the addition of JavaBeans, a component programming model that is oriented toward the easy creation of visual programming environments. Java 2 finishes the transformation away from the old Java 1.0 AWT by essentially replacing everything with the <emphasis role="italic">Java Foundation Classes</emphasis> (JFC), the GUI portion of which is called �Swing.� These are a rich set of easy-to-use, easy-to-understand JavaBeans that can be dragged and dropped (as well as hand programmed) to create a GUI that you can (finally) be satisfied with. The �revision 3� rule of the software industry (a product isn�t good until revision 3) seems to hold true with programming languages as well.</para>
    <para>This chapter does not cover anything but the modern, Java 2 Swing library, and makes the reasonable assumption that Swing is the final destination GUI library for Java. If for some reason you need to use the original �old� AWT (because you�re supporting old code or you have browser limitations), you can find that introduction in the first edition of this book, downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis> (also included on the CD ROM bound with this book).</para>
    <para>Early in this chapter, you�ll see how things are different when you want to create an applet vs. a regular application using Swing, and how to create programs that are both applets and applications so they can be run either inside a browser or from the command line. Almost all the GUI examples in this book will be executable as either applets or applications.</para>
    <para>Please be aware that this is not a comprehensive glossary of either all the Swing components, or all the methods for the described classes. What you see here is intended to be simple. The Swing library is vast, and the goal of this chapter is only to get you started with the essentials and comfortable with the concepts. If you need to do more, then Swing can probably give you what you want if you�re willing to do the research. </para>
    <para>I assume here that you have downloaded and installed the (free) Java library documents in HTML format from <emphasis role="italic">java.sun.com</emphasis> and will browse the <emphasis role="bold">javax.swing</emphasis> classes in that documentation to see the full details and methods of the Swing library. Because of the simplicity of the Swing design, this will often be enough information to solve your problem. There are numerous (rather thick) books dedicated solely to Swing and you�ll want to go to those if you need more depth, or if you want to modify the default Swing behavior.</para>
    <para>As you learn about Swing you�ll discover: </para>
    <para>Swing is a much better programming model than you�ve probably seen in other languages and development environments. JavaBeans (which will be introduced toward the end of this chapter) is the framework for that library.</para>
    <para>84.      �GUI builders� (visual programming environments) are a <emphasis role="italic">de rigueur</emphasis> aspect of a complete Java development environment. JavaBeans and Swing allow the GUI builder to write code for you as you place components onto forms using graphical tools. This not only rapidly speeds development during GUI building, but it allows for greater experimentation and thus the ability to try out more designs and presumably come up with a better one.</para>
    <para>85.      The simplicity and well-designed nature of Swing means that even if you do use a GUI builder rather than coding by hand, the resulting code will still be comprehensible�this solves a big problem with GUI builders from the past, which could easily generate unreadable code.</para>
    <para>Swing contains all the components that you expect to see in a modern UI, everything from buttons that contain pictures to trees and tables. It�s a big library, but it�s designed to have appropriate complexity for the task at hand�if something is simple, you don�t have to write much code but as you try to do more complex things, your code becomes proportionally more complex. This means an easy entry point, but you�ve got the power if you need it.</para>
    <para>Much of what you�ll like about Swing could be called �orthogonality of use.� That is, once you pick up the general ideas about the library you can apply them everywhere. Primarily because of the standard naming conventions, much of the time that I was writing these examples I could guess at the method names and get it right the first time, without looking anything up. This is certainly the hallmark of a good library design. In addition, you can generally plug components into other components and things will work correctly.</para>
    <para>For speed, all the components are �lightweight,� and Swing is written entirely in Java for portability.</para>
    <para>Keyboard navigation is automatic�you can run a Swing application without using the mouse, and this doesn�t require any extra programming. Scrolling support is effortless�you simply wrap your component in a <emphasis role="bold">JScrollPane</emphasis> as you add it to your form. Features such as tool tips typically require a single line of code to use.</para>
    <para>Swing also supports a rather radical feature called �pluggable look and feel,� which means that the appearance of the UI can be dynamically changed to suit the expectations of users working under different platforms and operating systems. It�s even possible (albeit difficult) to invent your own look and feel.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064782"/><anchor xreflabel="The
basic applet" xml:id="_Toc375545446"/>The basic applet</title>
      <para>One of Java�s design goals is to create <emphasis role="italic">applets</emphasis>, which are little programs that run inside a Web browser. Because they must be safe, applets are limited in what they can accomplish. However, applets are a powerful tool that support client-side programming, a major issue for the Web.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064783"/><anchor xreflabel="Applet
restrictions" xml:id="_Toc375545464"/>Applet restrictions</title>
        <para>Programming within an applet is so restrictive that it�s often referred to as being �inside the sandbox,� since you always have someone�that is, the Java run-time security system�watching over you. </para>
        <para>However, you can also step outside the sandbox and write regular applications rather than applets, in which case you can access the other features of your OS. We�ve been writing regular applications all along in this book, but they�ve been <emphasis role="italic">console applications</emphasis> without any graphical components. Swing can also be used to build GUI interfaces for regular applications.</para>
        <para>You can generally answer the question of what an applet is able to do by looking at what it is <emphasis role="italic">supposed</emphasis> to do: extend the functionality of a Web page in a browser. Since, as a Net surfer, you never really know if a Web page is from a friendly place or not, you want any code that it runs to be safe. So the biggest restrictions you�ll notice are probably: </para>
        <para><emphasis role="italic">An applet can�t touch the local disk</emphasis>. This means writing <emphasis role="italic">or</emphasis> reading, since you wouldn�t want an applet to read and transmit private information over the Internet without your permission. Writing is prevented, of course, since that would be an open invitation to a virus. Java offers <emphasis role="italic">digital signing</emphasis> for applets. Many applet restrictions are relaxed when you choose to allow <emphasis role="italic">trusted applets</emphasis> (those signed by a trusted source) to have access to your machine.</para>
        <para>86.      <emphasis role="italic">Applets can take longer to display, </emphasis>since you must download the whole thing every time, including a separate server hit for each different class. Your browser can cache the applet, but there are no guarantees. Because of this, you should always package your applets in a JAR (Java ARchive) file that combines all the applet components (including other <emphasis role="bold">.class</emphasis> files as well as images and sounds) together into a single compressed file that can be downloaded in a single server transaction. �Digital signing� is available for each individual entry in the JAR file.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064784"/><anchor xreflabel="Applet
advantages" xml:id="_Toc375545465"/>Applet advantages</title>
        <para>If you can live within the restrictions, applets have definite advantages, especially when building client/server or other networked applications: </para>
        <para><emphasis role="italic">There is no installation issue.</emphasis> An applet has true platform independence (including the ability to easily play audio files, etc.) so you don�t need to make any changes in your code for different platforms nor does anyone have to perform any �tweaking� on installation. In fact, installation is automatic every time the user loads the Web page that contains applets, so updates happen silently and automatically. In traditional client/server systems, building and installing a new version of the client software is often a nightmare.</para>
        <para>87.      <emphasis role="italic">You don�t have to worry about bad code causing damage to someone�s system,</emphasis> because of the security built into the core Java language and applet structure. This, along with the previous point, makes Java popular for so-called <emphasis role="italic">intranet</emphasis> client/server applications that live only within a company or restricted arena of operation where the user environment (Web browser and add-ins) can be specified and/or controlled.</para>
        <para>Because applets are automatically integrated with HTML, you have a built-in platform-independent documentation system to support the applet. It�s an interesting twist, since we�re used to having the documentation part of the program rather than vice versa.</para>
      </section>
      <section>
        <title><anchor xreflabel="Application frameworks" xml:id="_Toc481064785"/>Application frameworks</title>
        <para>Libraries are often grouped according to their functionality. Some libraries, for example, are used as is, off the shelf. The standard Java library <emphasis role="bold">String</emphasis> and <emphasis role="bold">ArrayList</emphasis> classes are examples of these. Other libraries are designed specifically as building blocks to create other classes. A certain category of library is the <emphasis role="italic">application framework</emphasis>, whose goal is to help you build applications by providing a class or set of classes that produces the basic behavior that you need in every application of a particular type. Then, to customize the behavior to your own needs, you inherit from the application class and override the methods of interest. The application framework�s default control mechanism will call your overridden methods at the appropriate time. An application framework is a good example of �separating the things that change from the things that stay the same,� since it attempts to localize all the unique parts of a program in the overridden methods<anchor xreflabel="[62]" xml:id="_ftnref62"/>[62].</para>
        <para>Applets are built using an application framework. You inherit from class <emphasis role="bold">JApplet</emphasis> and override the appropriate methods. There are a few methods that control the creation and execution of an applet on a Web page: </para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="9*"/>
            <colspec colname="c2" colwidth="38*"/>
            <thead>
              <row>
                <entry valign="top"><para> Method</para></entry>
                <entry valign="top"><para> Operation</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry valign="top"><para> init( )</para></entry>
                <entry valign="top"><para> Automatically called to perform first-time initialization of the applet, including component layout. You�ll always override this method.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> start( )</para></entry>
                <entry valign="top"><para> Called every time the applet moves into sight on the Web browser to allow the applet to start up its normal operations (especially those that are shut off by stop( )). Also called after init( ).</para></entry>
              </row>
              <row>
                <entry valign="top"><para> stop( )</para></entry>
                <entry valign="top"><para> Called every time the applet moves out of sight on the Web browser to allow the applet to shut off expensive operations. Also called right before destroy( ).</para></entry>
              </row>
              <row>
                <entry valign="top"><para> destroy( )</para></entry>
                <entry valign="top"><para> Called when the applet is being unloaded from the page to perform final release of resources when the applet is no longer used</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>With this information you are ready to create a simple applet:</para>
        <para>//: c13:Applet1.java</para>
        <para>// Very simple applet.</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para> </para>
        <para>public class Applet1 extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� getContentPane().add(new JLabel(&quot;Applet!&quot;));</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Note that applets are not required to have a <emphasis role="bold">main( )</emphasis>. That�s all wired into the application framework; you put any startup code in <emphasis role="bold">init( )</emphasis>.</para>
        <para>In this program, the only activity is putting a text label on the applet, via the <emphasis role="bold">JLabel</emphasis> class (the old AWT appropriated the name <emphasis role="bold">Label</emphasis> as well as other names of components, so you will often see a leading �<emphasis role="bold">J</emphasis>� used with Swing components). The constructor for this class takes a <emphasis role="bold">String</emphasis> and uses it to create the label. In the above program this label is placed on the form.</para>
        <para>The <emphasis role="bold">init( )</emphasis> method is responsible for putting all the components on the form using the <emphasis role="bold">add( )</emphasis> method. You might think that you ought to be able to simply call <emphasis role="bold">add( )</emphasis> by itself, and in fact that�s the way it used to be in the old AWT. However, Swing requires you to add all components to the �content pane� of a form, and so you must call <emphasis role="bold">getContentPane( )</emphasis> as part of the <emphasis role="bold">add( )</emphasis> process.</para>
      </section>
      <section>
        <title><anchor xreflabel="Running applets inside a Web
browser" xml:id="_Toc481064786"/>Running applets inside a Web browser</title>
        <para>To run this program you must place it inside a Web page and view that page inside your Java-enabled Web browser. To place an applet inside a Web page you put a special tag inside the HTML source for that Web page<anchor xreflabel="[63]" xml:id="_ftnref63"/>[63] to tell the page how to load and run the applet. </para>
        <para>This process used to be very simple, when Java itself was simple and everyone was on the same bandwagon and incorporated the same Java support inside their Web browsers. Then you might have been able to get away with a very simple bit of HTML inside your Web page, like this:</para>
        <para>&lt;applet code=Applet1 width=100 height=50&gt;</para>
        <para>&lt;/applet&gt;</para>
        <para> </para>
        <para>Then along came the browser and language wars, and we (programmers and end users alike) lost. After awhile, JavaSoft realized that we could no longer expect browsers to support the correct flavor of Java, and the only solution was to provide some kind of add-on that would conform to a browser�s extension mechanism. By using the extension mechanism (which a browser vendor cannot disable�in an attempt to gain competitive advantage�without breaking all the third-party extensions), JavaSoft guarantees that Java cannot be shut out of the Web browser by an antagonistic vendor.</para>
        <para>With Internet Explorer, the extension mechanism is the ActiveX control, and with Netscape it is the plug-in. In your HTML code, you must provide tags to support both. Here�s what the simplest resulting HTML page looks like for <emphasis role="bold">Applet1</emphasis>:<anchor xreflabel="[64]" xml:id="_ftnref64"/><emphasis role="bold"><emphasis role="bold">[64]</emphasis></emphasis></para>
        <para>//:! c13:Applet1.html</para>
        <para>&lt;html&gt;&lt;head&gt;&lt;title&gt;Applet1&lt;/title&gt;&lt;/head&gt;&lt;hr&gt;</para>
        <para>&lt;OBJECT </para>
        <para>� classid=&quot;clsid:8AD9C840-044E-11D1-B3E9-00805F499D93&quot;</para>
        <para>� width=&quot;100&quot; height=&quot;50&quot; align=&quot;baseline&quot;� codebase=&quot;http://java.sun.com/products/plugin/1.2.2/jinstall-1_2_2-win.cab#Version=1,2,2,0&quot;&gt;</para>
        <para>&lt;PARAM NAME=&quot;code&quot; VALUE=&quot;Applet1.class&quot;&gt;</para>
        <para>&lt;PARAM NAME=&quot;codebase&quot; VALUE=&quot;.&quot;&gt;</para>
        <para>&lt;PARAM NAME=&quot;type&quot; VALUE=&quot;application/x-java-applet;version=1.2.2&quot;&gt;</para>
        <para>&lt;COMMENT&gt;</para>
        <para>� &lt;EMBED type=</para>
        <para>��� &quot;application/x-java-applet;version=1.2.2&quot; </para>
        <para>��� width=&quot;200&quot; height=&quot;200&quot; align=&quot;baseline&quot;</para>
        <para>��� code=&quot;Applet1.class&quot; codebase=&quot;.&quot;</para>
        <para>pluginspage=&quot;http://java.sun.com/products/plugin/1.2/plugin-install.html&quot;&gt;</para>
        <para>� &lt;NOEMBED&gt;</para>
        <para>&lt;/COMMENT&gt;</para>
        <para>�� No Java 2 support for APPLET!!</para>
        <para>� &lt;/NOEMBED&gt;</para>
        <para>&lt;/EMBED&gt;</para>
        <para>&lt;/OBJECT&gt;</para>
        <para>&lt;hr&gt;&lt;/body&gt;&lt;/html&gt;</para>
        <para>///:~</para>
        <para> </para>
        <para>Some of these lines were too long and had to be wrapped to fit on the page. The code in this book�s source code (on the book�s CD ROM, and downloadable from <emphasis role="italic">www.BruceEckel.com</emphasis>) will work without having to worry about correcting line wraps.</para>
        <para>The <emphasis role="bold">code </emphasis>value gives the name of the <emphasis role="bold">.class </emphasis>file where the applet resides. The <emphasis role="bold">width</emphasis> and <emphasis role="bold">height</emphasis> specify the initial size of the applet (in pixels, as before). There are other items you can place within the applet tag: a place to find other <emphasis role="bold">.class </emphasis>files on the Internet (<emphasis role="bold">codebase</emphasis>), alignment information (<emphasis role="bold">align</emphasis>), a special identifier that makes it possible for applets to communicate with each other (<emphasis role="bold">name</emphasis>), and applet parameters to provide information that the applet can retrieve. Parameters are in the form:</para>
        <para>&lt;param name=&quot;identifier&quot; value = &quot;information&quot;&gt;</para>
        <para> </para>
        <para>and there can be as many as you want.</para>
        <para>The source code package for this book provides an HTML page for each of the applets in this book, and thus many examples of the applet tag. You can find a full and current description of the details of placing applets in Web pages at <emphasis role="italic">java.sun.com</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="Using Appletviewer" xml:id="_Toc481064787"/>Using <emphasis role="italic">Appletviewer</emphasis></title>
        <para>Sun�s JDK (freely downloadable from <emphasis role="italic">java.sun.com</emphasis>) contains a tool called the <emphasis role="italic">Appletviewer</emphasis> that picks the <emphasis role="bold">&lt;applet&gt;</emphasis> tags out of the HTML file and runs the applets without displaying the surrounding HTML text. Because the Appletviewer ignores everything but APPLET tags, you can put those tags in the Java source file as comments:</para>
        <para>// &lt;applet code=MyApplet width=200 height=100&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para> </para>
        <para>This way, you can run �<emphasis role="bold">appletviewer MyApplet.java</emphasis>� and you don�t need to create tiny HTML files to run tests. For example, you can add the commented HTML tags to <emphasis role="bold">Applet1.java</emphasis>:</para>
        <para>//: c13:Applet1b.java</para>
        <para>// Embedding the applet tag for Appletviewer.</para>
        <para>// &lt;applet code=Applet1b width=100 height=50&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para> </para>
        <para>public class Applet1b extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� getContentPane().add(new JLabel(&quot;Applet!&quot;));</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Now you can invoke the applet with the command</para>
        <para>appletviewer Applet1b.java</para>
        <para> </para>
        <para>In this book, this form will be used for easy testing of applets. Shortly, you�ll see another coding approach which will allow you to execute applets from the command line without the Appletviewer.</para>
      </section>
      <section>
        <title><anchor xreflabel="Testing applets" xml:id="_Toc481064788"/>Testing applets</title>
        <para>You can perform a simple test without any network connection by starting up your Web browser and opening the HTML file containing the applet tag. As the HTML file is loaded, the browser will discover the applet tag and go hunt for the <emphasis role="bold">.class</emphasis> file specified by the <emphasis role="bold">code</emphasis> value. Of course, it looks at the CLASSPATH to find out where to hunt, and if your <emphasis role="bold">.class</emphasis> file isn�t in the CLASSPATH then it will give an error message on the status line of the browser to the effect that it couldn�t find that <emphasis role="bold">.class</emphasis> file.</para>
        <para>When you want to try this out on your Web site things are a little more complicated. First of all, you must <emphasis role="italic">have</emphasis> a Web site, which for most people means a third-party Internet Service Provider (ISP) at a remote location. Since the applet is just a file or set of files, the ISP does not have to provide any special support for Java. You must also have a way to move the HTML files and the <emphasis role="bold">.class</emphasis> files from your site to the correct directory on the ISP machine. This is typically done with a File Transfer Protocol (FTP) program, of which there are many different types available for free or as shareware. So it would seem that all you need to do is move the files to the ISP machine with FTP, then connect to the site and HTML file using your browser; if the applet comes up and works, then everything checks out, right?</para>
        <para>Here�s where you can get fooled. If the browser on the client machine cannot locate the <emphasis role="bold">.class</emphasis> file on the server, it will hunt through the CLASSPATH on your <emphasis role="italic">local</emphasis> machine. Thus, the applet might not be loading properly from the server, but to you it looks fine during your testing process because the browser finds it on your machine. When someone else connects, however, his or her browser can�t find it. So when you�re testing, make sure you erase the relevant <emphasis role="bold">.class</emphasis> files (or <emphasis role="bold">.jar </emphasis>file) on your local machine to verify that they exist in the proper location on the server.</para>
        <para>One of the most insidious places where this happened to me is when I innocently placed an applet inside a <emphasis role="bold">package</emphasis>. After uploading the HTML file and applet, it turned out that the server path to the applet was confused because of the package name. However, my browser found it in the local CLASSPATH. So I was the only one who could properly load the applet. It took some time to discover that the <emphasis role="bold">package</emphasis> statement was the culprit. In general, you�ll want to leave the <emphasis role="bold">package</emphasis> statement out of an applet.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Running applets from the command
line" xml:id="_Toc481064789"/>Running applets from the command line</title>
      <para>There are times when you�d like to make a windowed program do something else other than sit on a Web page. Perhaps you�d also like it to do some of the things a �regular� application can do but still have the vaunted instant portability provided by Java. In previous chapters in this book we�ve made command-line applications, but in some operating environments (the Macintosh, for example) there isn�t a command line. So for any number of reasons you�d like to build a windowed, non-applet program using Java. This is certainly a reasonable desire.</para>
      <para>The Swing library allows you to make an application that preserves the look and feel of the underlying operating environment. If you want to build windowed applications, it makes sense to do so<anchor xreflabel="[65]" xml:id="_ftnref65"/>[65] only if you can use the latest version of Java and associated tools so you can deliver applications that won�t confound your users. If for some reason you�re forced to use an older version of Java, think hard before committing to building a significant windowed application.</para>
      <para>Often you�ll want to be able to create a class that can be invoked as either a window or an applet. This is especially convenient when you�re testing the applets, since it�s typically much faster and easier to run the resulting applet-application from the command line than it is to start up a Web browser or the Appletviewer.</para>
      <para>To create an applet that can be run from the console command line, you simply add a <emphasis role="bold">main( )</emphasis> to your applet that builds an instance of the applet inside a <emphasis role="bold">J</emphasis><emphasis role="bold">Frame</emphasis>.<anchor xreflabel="[66]" xml:id="_ftnref66"/><emphasis role="bold"><emphasis role="bold">[66]</emphasis></emphasis> As a simple example, let�s look at <emphasis role="bold">Applet1b</emphasis><emphasis role="bold">.java</emphasis> modified to work as both an application and an applet:</para>
      <para>//: c13:Applet1c.java</para>
      <para>// An application and an applet.</para>
      <para>// &lt;applet code=Applet1c width=100 height=50&gt;</para>
      <para>// &lt;/applet&gt;</para>
      <para>import javax.swing.*;</para>
      <para>import java.awt.*;</para>
      <para>import com.bruceeckel.swing.*;</para>
      <para> </para>
      <para>public class Applet1c extends JApplet {</para>
      <para>� public void init() {</para>
      <para>��� getContentPane().add(new JLabel(&quot;Applet!&quot;));</para>
      <para>� }</para>
      <para>� // A main() for the application:</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� JApplet applet = new Applet1c();</para>
      <para>��� JFrame frame = new JFrame(&quot;Applet1c&quot;);</para>
      <para>��� // To close the application:</para>
      <para>��� Console.setupClosing(frame);</para>
      <para>��� frame.getContentPane().add(applet);</para>
      <para>��� frame.setSize(100,50);</para>
      <para>��� applet.init();</para>
      <para>��� applet.start();</para>
      <para>��� frame.setVisible(true);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para><emphasis role="bold">main( )</emphasis> is the only element added to the applet, and the rest of the applet is untouched. The applet is created and added to a <emphasis role="bold">JFrame</emphasis> so that it can be displayed. </para>
      <para>The line:</para>
      <para>Console.setupClosing(frame);</para>
      <para> </para>
      <para>Causes the window to be properly closed. <emphasis role="bold">Console</emphasis> comes from <emphasis role="bold">com.bruceeckel.swing</emphasis> and will be explained a little later.</para>
      <para>You can see that in <emphasis role="bold">main( )</emphasis>, the applet is explicitly initialized and started since in this case the browser isn�t available to do it for you. Of course, this doesn�t provide the full behavior of the browser, which also calls <emphasis role="bold">stop( )</emphasis> and <emphasis role="bold">destroy( )</emphasis>, but for most situations it�s acceptable. If it�s a problem, you can force the calls yourself.<anchor xreflabel="[67]" xml:id="_ftnref67"/>[67]</para>
      <para>Notice the last line:</para>
      <para>frame.setVisible(true);</para>
      <para> </para>
      <para>Without this, you won�t see anything on the screen.</para>
      <section>
        <title><anchor xreflabel="A display framework" xml:id="_Toc481064790"/>A display framework</title>
        <para>Although the code that turns programs into both applets and applications produces valuable results, if used everywhere it becomes distracting and wastes paper. Instead, the following display framework will be used for the Swing examples in the rest of this book:</para>
        <para>//: com:bruceeckel:swing:Console.java</para>
        <para>// Tool for running Swing demos from the</para>
        <para>// console, both applets and JFrames.</para>
        <para>package com.bruceeckel.swing;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.event.*;</para>
        <para> </para>
        <para>public class Console {</para>
        <para>� // Create a title string from the class name:</para>
        <para>� public static String title(Object o) {</para>
        <para>��� String t = o.getClass().toString();</para>
        <para>��� // Remove the word &quot;class&quot;:</para>
        <para>��� if(t.indexOf(&quot;class&quot;) != -1)</para>
        <para>����� t = t.substring(6);</para>
        <para>��� return t;</para>
        <para>� }</para>
        <para>� public static void setupClosing(JFrame frame) {</para>
        <para>��� // The JDK 1.2 Solution as an </para>
        <para>��� // anonymous inner class:</para>
        <para>��� frame.addWindowListener(new WindowAdapter() {</para>
        <para>����� public void windowClosing(WindowEvent e) {</para>
        <para>������� System.exit(0);</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� // The improved solution in JDK 1.3:</para>
        <para>��� // frame.setDefaultCloseOperation(</para>
        <para>��� //���� EXIT_ON_CLOSE);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� run(JFrame frame, int width, int height) {</para>
        <para>��� setupClosing(frame);</para>
        <para>��� frame.setSize(width, height);</para>
        <para>��� frame.setVisible(true);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� run(JApplet applet, int width, int height) {</para>
        <para>��� JFrame frame = new JFrame(title(applet));</para>
        <para>��� setupClosing(frame);</para>
        <para>��� frame.getContentPane().add(applet);</para>
        <para>��� frame.setSize(width, height);</para>
        <para>��� applet.init();</para>
        <para>��� applet.start();</para>
        <para>��� frame.setVisible(true);</para>
        <para>� }</para>
        <para>� public static void </para>
        <para>� run(JPanel panel, int width, int height) {</para>
        <para>��� JFrame frame = new JFrame(title(panel));</para>
        <para>��� setupClosing(frame);</para>
        <para>��� frame.getContentPane().add(panel);</para>
        <para>��� frame.setSize(width, height);</para>
        <para>��� frame.setVisible(true);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This is a tool you may want to use yourself, so it�s placed in the library <emphasis role="bold">com.bruceeckel.swing</emphasis>. The <emphasis role="bold">Console</emphasis> class consists entirely of <emphasis role="bold">static</emphasis> methods. The first is used to extract the class name (using RTTI) from any object and to remove the word �class,� which is typically prepended by <emphasis role="bold">getClass( )</emphasis>. This uses the <emphasis role="bold">String</emphasis> methods <emphasis role="bold">indexOf( )</emphasis> to determine whether the word �class� is there, and <emphasis role="bold">substring( )</emphasis> to produce the new string without �class� or the trailing space. This name is used to label the window that is displayed by the <emphasis role="bold">run( )</emphasis> methods.</para>
        <para><emphasis role="bold">setupClosing( )</emphasis> is used to hide the code that causes a <emphasis role="bold">JFrame</emphasis> to exit a program when that <emphasis role="bold">JFrame</emphasis> is closed. The default behavior is to do nothing, so if you don�t call <emphasis role="bold">setupClosing( )</emphasis> or write the equivalent code for your <emphasis role="bold">JFrame</emphasis>, the application won�t close. The reason this code is hidden rather than placing it directly in the subsequent <emphasis role="bold">run( )</emphasis> methods is partly because it allows you to use the method by itself when what you want to do is more complicated than what <emphasis role="bold">run( )</emphasis> provides. However, it also isolates a change factor: Java 2 has two ways of causing certain types of windows to close. In JDK 1.2, the solution is to create a new <emphasis role="bold">WindowAdapter</emphasis> class and implement <emphasis role="bold">windowClosing( )</emphasis>, as seen above (the meaning of this will be fully explained later in this chapter). However, during the creation of JDK 1.3 the library designers observed that you typically need to close windows whenever you�re creating a non-applet, and so they added the <emphasis role="bold">setDefaultCloseOperation( )</emphasis> to <emphasis role="bold">JFrame</emphasis> and <emphasis role="bold">JDialog</emphasis>. From the standpoint of writing code, the new method is much nicer to use but this book was written while there was still no JDK 1.3 implemented on Linux and other platforms, so in the interest of cross-version portability the change was isolated inside <emphasis role="bold">setupClosing( )</emphasis>.</para>
        <para>The <emphasis role="bold">run( )</emphasis> method is overloaded to work with <emphasis role="bold">JApplet</emphasis>s, <emphasis role="bold">JPanel</emphasis>s, and <emphasis role="bold">JFrame</emphasis>s. Note that only if it�s a <emphasis role="bold">JApplet</emphasis> are <emphasis role="bold">init( )</emphasis> and <emphasis role="bold">start( )</emphasis> called.</para>
        <para>Now any applet can be run from the console by creating a <emphasis role="bold">main( )</emphasis> containing a line like this:</para>
        <para>Console.run(new MyClass(), 500, 300);</para>
        <para> </para>
        <para>in which the last two arguments are the display width and height. Here�s <emphasis role="bold">Applet1c.java</emphasis> modified to use <emphasis role="bold">Console</emphasis>:</para>
        <para>//: c13:Applet1d.java</para>
        <para>// Console runs applets from the command line.</para>
        <para>// &lt;applet code=Applet1d width=100 height=50&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Applet1d extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� getContentPane().add(new JLabel(&quot;Applet!&quot;));</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Applet1d(), 100, 50);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This allows the elimination of repeated code while providing the greatest flexibility in running the examples.</para>
      </section>
      <section>
        <title><anchor xreflabel="Using the Windows Explorer" xml:id="_Toc481064791"/>Using the Windows Explorer</title>
        <para>If you�re using Windows, you can simplify the process of running a command-line Java program by configuring the Windows Explorer�the file browser in Windows, <emphasis role="italic">not</emphasis> the Internet Explorer�so that you can simply double-click on a <emphasis role="bold">.class</emphasis> file to execute it. There are several steps in this process.</para>
        <para>First, download and install the Perl programming language from <emphasis role="italic">www.Perl.org</emphasis>. You�ll find the instructions and language documentation on that site.</para>
        <para>Next, create the following script without the first and last lines (this script is part of this book�s source-code package):</para>
        <para>//:! c13:RunJava.bat</para>
        <para>@rem = &apos;--*-Perl-*--</para>
        <para>@echo off</para>
        <para>perl -x -S &quot;%0&quot; %1 %2 %3 %4 %5 %6 %7 %8 %9</para>
        <para>goto endofperl</para>
        <para>@rem &apos;;</para>
        <para>#!perl</para>
        <para>$file = $ARGV[0];</para>
        <para>$file =~ s/(.*)\..*/\1/;</para>
        <para>$file =~ s/(.*\\)*(.*)/$+/;</para>
        <para>`java $file`;</para>
        <para>__END__</para>
        <para>:endofperl</para>
        <para>///:~</para>
        <para> </para>
        <para>Now, open the Windows Explorer, select �View,� �Folder Options,� then click on the �File Types� tab. Press the �New Type� button. For �Description of Type� enter �Java class file.� For �Associated Extension,� enter �class.� Under �Actions� press the �New� button. For �Action� enter �Open,� and for �Application used to perform action� enter a line like this:</para>
        <para>&quot;c:\aaa\Perl\RunJava.bat&quot; &quot;%L&quot;</para>
        <para> </para>
        <para>You must customize the path before �RunJava.bat� to conform to the location where you placed the batch file.</para>
        <para>Once you perform this installation, you may run any Java program by simply double-clicking on the <emphasis role="bold">.class</emphasis> file containing a <emphasis role="bold">main( )</emphasis>.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064792"/><anchor xreflabel="Making
a button" xml:id="_Toc375545447"/>Making a button</title>
      <para>Making a button is quite simple: you just call the <emphasis role="bold">J</emphasis><emphasis role="bold">Button</emphasis> constructor with the label you want on the button. You�ll see later that you can do fancier things, like putting graphic images on buttons.</para>
      <para>Usually you�ll want to create a field for the button inside your class so that you can refer to it later.</para>
      <para>The <emphasis role="bold">J</emphasis><emphasis role="bold">Button</emphasis> is a component�its own little window�that will automatically get repainted as part of an update. This means that you don�t explicitly paint a button or any other kind of control; you simply place them on the form and let them automatically take care of painting themselves. So to place a button on a form, you do it inside <emphasis role="bold">init( )</emphasis>:</para>
      <para>//: c13:Button1.java</para>
      <para>// Putting buttons on an applet.</para>
      <para>// &lt;applet code=Button1 width=200 height=50&gt;</para>
      <para>// &lt;/applet&gt;</para>
      <para>import javax.swing.*;</para>
      <para>import java.awt.*;</para>
      <para>import com.bruceeckel.swing.*;</para>
      <para> </para>
      <para>public class Button1 extends JApplet {</para>
      <para>� JButton </para>
      <para>��� b1 = new JButton(&quot;Button 1&quot;), </para>
      <para>��� b2 = new JButton(&quot;Button 2&quot;);</para>
      <para>� public void init() {</para>
      <para>��� Container cp = getContentPane();</para>
      <para>��� cp.setLayout(new FlowLayout());</para>
      <para>��� cp.add(b1);</para>
      <para>��� cp.add(b2);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Console.run(new Button1(), 200, 50);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Something new has been added here: before any elements are placed on the content pane, it is given a new �layout manager,� of type <emphasis role="bold">FlowLayout</emphasis>. The layout manager is the way that the pane implicitly decides where to place the control on the form. The normal behavior of an applet is to use the <emphasis role="bold">BorderLayout</emphasis>, but that won�t work here because (as you will learn later in this chapter when controlling the layout of a form is examined in more detail) it defaults to covering each control entirely with every new one that is added. However, <emphasis role="bold">FlowLayout</emphasis> causes the controls to flow evenly onto the form, left to right and top to bottom.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064793"/><anchor xreflabel="Capturing
an event" xml:id="_Toc375545448"/>Capturing an event</title>
      <para>You�ll notice that if you compile and run the applet above, nothing happens when you press the buttons. This is where you must step in and write some code to determine what will happen. The basis of event-driven programming, which comprises a lot of what a GUI is about, is tying events to code that responds to those events.</para>
      <para>The way that this is accomplished in Swing is by cleanly separating the interface (the graphical components) and the implementation (the code that you want to run when an event happens to a component). Each Swing component can report all the events that might happen to it, and it can report each kind of event individually. So if you�re not interested in, for example, whether the mouse is being moved over your button, you don�t register your interest in that event. It�s a very straightforward and elegant way to handle event-driven programming, and once you understand the basic concepts you can easily use Swing components that you haven�t seen before�in fact, this model extends to anything that can be classified as a JavaBean (which you�ll learn about later in the chapter).</para>
      <para>At first, we will just focus on the main event of interest for the components being used. In the case of a <emphasis role="bold">JButton</emphasis>, this �event of interest� is that the button is pressed.<emphasis role="bold"/>To register your interest in when a button is pressed, you call the <emphasis role="bold">JButton</emphasis>�s <emphasis role="bold">addActionListener( )</emphasis> method. This method expects an argument that is an object that implements the <emphasis role="bold">ActionListener</emphasis> interface, which contains a single method called <emphasis role="bold">actionPerformed( )</emphasis>. So all you have to do to attach code to a <emphasis role="bold">JButton</emphasis> is to implement the <emphasis role="bold">ActionListener</emphasis> interface in a class, and register an object of that class with the <emphasis role="bold">JButton</emphasis> via <emphasis role="bold">addActionListener( )</emphasis>. The method will be called when the button is pressed (this is normally referred to as a <emphasis role="italic">callback</emphasis>).</para>
      <para>But what should the result of pressing that button be? We�d like to see something change on the screen, so a new Swing component will be introduced: the <emphasis role="bold">JTextField</emphasis>. This is a place where text can be typed, or in this case modified by the program. Although there are a number of ways to create a <emphasis role="bold">JTextField</emphasis>, the simplest is just to tell the constructor how wide you want that field to be. Once the <emphasis role="bold">JTextField</emphasis> is placed on the form, you can modify its contents by using the <emphasis role="bold">setText( )</emphasis> method (there are many other methods in <emphasis role="bold">JTextField</emphasis>, but you must look these up in the HTML documentation for the JDK from <emphasis role="italic">java.sun.com</emphasis>). Here is what it looks like:</para>
      <para>//: c13:Button2.java</para>
      <para>// Responding to button presses.</para>
      <para>// &lt;applet code=Button2 width=200 height=75&gt;</para>
      <para>// &lt;/applet&gt;</para>
      <para>import javax.swing.*;</para>
      <para>import java.awt.event.*;</para>
      <para>import java.awt.*;</para>
      <para>import com.bruceeckel.swing.*;</para>
      <para> </para>
      <para>public class Button2 extends JApplet {</para>
      <para>� JButton </para>
      <para>��� b1 = new JButton(&quot;Button 1&quot;), </para>
      <para>��� b2 = new JButton(&quot;Button 2&quot;);</para>
      <para>� JTextField txt = new JTextField(10);</para>
      <para>� class BL implements ActionListener {</para>
      <para>��� public void actionPerformed(ActionEvent e){</para>
      <para>����� String name = </para>
      <para>������� ((JButton)e.getSource()).getText();</para>
      <para>����� txt.setText(name);</para>
      <para>��� }</para>
      <para>� }</para>
      <para>� BL al = new BL();</para>
      <para>� public void init() {</para>
      <para>��� b1.addActionListener(al);</para>
      <para>��� b2.addActionListener(al);</para>
      <para>��� Container cp = getContentPane();</para>
      <para>��� cp.setLayout(new FlowLayout());</para>
      <para>��� cp.add(b1);</para>
      <para>��� cp.add(b2);</para>
      <para>��� cp.add(txt);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Console.run(new Button2(), 200, 75);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Creating a <emphasis role="bold">JTextField</emphasis> and placing it on the canvas takes the same steps as for <emphasis role="bold">JButton</emphasis>s, or for any Swing component. The difference in the above program is in the creation of the aforementioned <emphasis role="bold">ActionListener</emphasis> class <emphasis role="bold">BL</emphasis>. The argument to <emphasis role="bold">actionPerformed( )</emphasis> is of type <emphasis role="bold">ActionEvent</emphasis>, which contains all the information about the event and where it came from. In this case, I wanted to describe the button that was pressed: <emphasis role="bold">getSource( )</emphasis> produces the object where the event originated, and I assumed that is a <emphasis role="bold">JButton</emphasis>. <emphasis role="bold">getText( )</emphasis> returns the text that�s on the button, and this is placed in the <emphasis role="bold">JTextField</emphasis> to prove that the code was actually called when the button was pressed.</para>
      <para>In <emphasis role="bold">init( )</emphasis>, <emphasis role="bold">addActionListener( )</emphasis> is used to register the <emphasis role="bold">BL</emphasis> object with both the buttons.</para>
      <para>It is often more convenient to code the <emphasis role="bold">ActionListener</emphasis> as an anonymous inner class, especially since you tend to only use a single instance of each listener class. <emphasis role="bold">Button2.java</emphasis> can be modified to use an anonymous inner class as follows:</para>
      <para>//: c13:Button2b.java</para>
      <para>// Using anonymous inner classes.</para>
      <para>// &lt;applet code=Button2b width=200 height=75&gt;</para>
      <para>// &lt;/applet&gt;</para>
      <para>import javax.swing.*;</para>
      <para>import java.awt.event.*;</para>
      <para>import java.awt.*;</para>
      <para>import com.bruceeckel.swing.*;</para>
      <para> </para>
      <para>public class Button2b extends JApplet {</para>
      <para>� JButton </para>
      <para>��� b1 = new JButton(&quot;Button 1&quot;), </para>
      <para>��� b2 = new JButton(&quot;Button 2&quot;);</para>
      <para>� JTextField txt = new JTextField(10);</para>
      <para>� ActionListener al = new ActionListener() {</para>
      <para>��� public void actionPerformed(ActionEvent e){</para>
      <para>����� String name = </para>
      <para>������� ((JButton)e.getSource()).getText();</para>
      <para>����� txt.setText(name);</para>
      <para>��� }</para>
      <para>� };</para>
      <para>� public void init() {</para>
      <para>��� b1.addActionListener(al);</para>
      <para>��� b2.addActionListener(al);</para>
      <para>��� Container cp = getContentPane();</para>
      <para>��� cp.setLayout(new FlowLayout());</para>
      <para>��� cp.add(b1);</para>
      <para>��� cp.add(b2);</para>
      <para>��� cp.add(txt);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Console.run(new Button2b(), 200, 75);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The approach of using an anonymous inner class will be preferred (when possible) for the examples in this book.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064794"/><anchor xreflabel="Text
areas" xml:id="_Toc375545450"/>Text areas</title>
      <para>A <emphasis role="bold">J</emphasis><emphasis role="bold">TextArea</emphasis> is like a <emphasis role="bold">J</emphasis><emphasis role="bold">TextField</emphasis> except that it can have multiple lines and has more functionality. A particularly useful method is <emphasis role="bold">append( )</emphasis>; with this you can easily pour output into the <emphasis role="bold">JTextArea</emphasis>, thus making a Swing program an improvement (since you can scroll backward) over what has been accomplished thus far using command-line programs that print to standard output. As an example, the following program fills a <emphasis role="bold">JTextArea</emphasis> with the output from the <emphasis role="bold">geography</emphasis> generator in Chapter 9:</para>
      <para>//: c13:TextArea.java</para>
      <para>// Using the JTextArea control.</para>
      <para>// &lt;applet code=TextArea width=475 height=425&gt;</para>
      <para>// &lt;/applet&gt;</para>
      <para>import javax.swing.*;</para>
      <para>import java.awt.event.*;</para>
      <para>import java.awt.*;</para>
      <para>import java.util.*;</para>
      <para>import com.bruceeckel.swing.*;</para>
      <para>import com.bruceeckel.util.*;</para>
      <para> </para>
      <para>public class TextArea extends JApplet {</para>
      <para>� JButton </para>
      <para>��� b = new JButton(&quot;Add Data&quot;),</para>
      <para>��� c = new JButton(&quot;Clear Data&quot;);</para>
      <para>� JTextArea t = new JTextArea(20, 40);</para>
      <para>� Map m = new HashMap();</para>
      <para>� public void init() {</para>
      <para>��� // Use up all the data:</para>
      <para>��� Collections2.fill(m, </para>
      <para>����� Collections2.geography, </para>
      <para>����� CountryCapitals.pairs.length);</para>
      <para>��� b.addActionListener(new ActionListener() {</para>
      <para>����� public void actionPerformed(ActionEvent e){</para>
      <para>������� for(Iterator it= m.entrySet().iterator();</para>
      <para>����������� it.hasNext();){</para>
      <para>��������� Map.Entry me = (Map.Entry)(it.next());</para>
      <para>��������� t.append(me.getKey() + &quot;: &quot; </para>
      <para>����������� + me.getValue() + &quot;\n&quot;);</para>
      <para>������� }</para>
      <para>����� }</para>
      <para>��� });</para>
      <para>��� c.addActionListener(new ActionListener() {</para>
      <para>����� public void actionPerformed(ActionEvent e){</para>
      <para>������� t.setText(&quot;&quot;);</para>
      <para>����� }</para>
      <para>��� });</para>
      <para>��� Container cp = getContentPane();</para>
      <para>��� cp.setLayout(new FlowLayout());</para>
      <para>��� cp.add(new JScrollPane(t));</para>
      <para>��� cp.add(b);</para>
      <para>��� cp.add(c);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Console.run(new TextArea(), 475, 425);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>In <emphasis role="bold">init( )</emphasis>, the <emphasis role="bold">Map</emphasis> is filled with all the countries and their capitals. Note that for both buttons the <emphasis role="bold">ActionListener</emphasis> is created and added without defining an intermediate variable, since you never need to refer to that listener again during the program. The �Add Data� button formats and appends all the data, while the �Clear Data� button uses <emphasis role="bold">setText( )</emphasis> to remove all the text from the <emphasis role="bold">JTextArea</emphasis>.</para>
      <para>As the <emphasis role="bold">JTextArea</emphasis> is added to the applet, it is wrapped in a <emphasis role="bold">JScrollPane</emphasis>, to control scrolling when too much text is placed on the screen. That�s all you must do in order to produce full scrolling capabilities. Having tried to figure out how to do the equivalent in some other GUI programming environments, I am very impressed with the simplicity and good design of components like <emphasis role="bold">JScrollPane</emphasis>.</para>
    </section>
    <section>
      <title><anchor xreflabel="Controlling layout" xml:id="_Toc481064795"/>Controlling layout</title>
      <para>The way that you place components on a form in Java is probably different from any other GUI system you�ve used. First, it�s all code; there are no �resources� that control placement of components. Second, the way components are placed on a form is controlled not by absolute positioning but by a �layout manager� that decides how the components lie based on the order that you <emphasis role="bold">add( )</emphasis> them. The size, shape, and placement of components will be remarkably different from one layout manager to another. In addition, the layout managers adapt to the dimensions of your applet or application window, so if the window dimension is changed, the size, shape, and placement of the components can change in response.</para>
      <para><emphasis role="bold">J</emphasis><emphasis role="bold">Applet</emphasis>, <emphasis role="bold">J</emphasis><emphasis role="bold">Frame JWindow</emphasis>, and <emphasis role="bold">JDialog</emphasis> can all produce a <emphasis role="bold">Container </emphasis>with <emphasis role="bold">getContentPane( ) </emphasis>that can contain and display <emphasis role="bold">Component</emphasis>s. In <emphasis role="bold">Container,</emphasis> there�s a method called <emphasis role="bold">setLayout( )</emphasis> that allows you to choose a different layout manager. Other classes, such as <emphasis role="bold">JPanel</emphasis>, contain and display components directly and so you also set the layout manager directly, without using the content pane.</para>
      <para>In this section we�ll explore the various layout managers by placing buttons in them (since that�s the simplest thing to do). There won�t be any capturing of button events since these examples are just intended to show how the buttons are laid out.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545458"/><anchor xreflabel="" xml:id="_Toc481064796"/><anchor xreflabel="BorderLayout" xml:id="_Toc375545459"/>BorderLayout</title>
        <para>The applet uses a default layout scheme: the <emphasis role="bold">BorderLayout</emphasis> (a number of the previous example have changed the layout manager to <emphasis role="bold">FlowLayout</emphasis>). Without any other instruction, this takes whatever you <emphasis role="bold">add( ) </emphasis>to it and places it in the center, stretching the object all the way out to the edges. </para>
        <para>However, there�s more to the <emphasis role="bold">BorderLayout</emphasis>. This layout manager has the concept of four border regions and a center area. When you add something to a panel that�s using a <emphasis role="bold">BorderLayout</emphasis> you can use the overloaded <emphasis role="bold">add( )</emphasis> method that takes a constant value as its first argument. This value can be any of the following:<emphasis role="bold"/></para>
        <para><emphasis role="bold">BorderLayout. NORTH </emphasis>(top)</para>
        <para><emphasis role="bold">BorderLayout. SOUTH</emphasis> (bottom)</para>
        <para><emphasis role="bold">BorderLayout. EAST</emphasis> (right)</para>
        <para><emphasis role="bold">BorderLayout. WEST</emphasis> (left)</para>
        <para><emphasis role="bold">BorderLayout.CENTER</emphasis> (fill the middle, up to the other components or to the edges)</para>
        <para>If you don�t specify an area to place the object, it defaults to <emphasis role="bold">CENTER</emphasis>.</para>
        <para>Here�s a simple example. The default layout is used, since <emphasis role="bold">JApplet</emphasis> defaults to <emphasis role="bold">BorderLayout</emphasis>:</para>
        <para>//: c13:BorderLayout1.java</para>
        <para>// Demonstrates BorderLayout.</para>
        <para>// &lt;applet code=BorderLayout1 </para>
        <para>// width=300 height=250&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class BorderLayout1 extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(BorderLayout.NORTH, </para>
        <para>����� new JButton(&quot;North&quot;));</para>
        <para>��� cp.add(BorderLayout.SOUTH, </para>
        <para>����� new JButton(&quot;South&quot;));</para>
        <para>��� cp.add(BorderLayout.EAST, </para>
        <para>����� new JButton(&quot;East&quot;));</para>
        <para>��� cp.add(BorderLayout.WEST, </para>
        <para>����� new JButton(&quot;West&quot;));</para>
        <para>��� cp.add(BorderLayout.CENTER, </para>
        <para>����� new JButton(&quot;Center&quot;));</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new BorderLayout1(), 300, 250);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>For every placement but <emphasis role="bold">CENTER</emphasis>, the element that you add is compressed to fit in the smallest amount of space along one dimension while it is stretched to the maximum along the other dimension. <emphasis role="bold">CENTER</emphasis>, however, spreads out in both dimensions to occupy the middle.</para>
      </section>
      <section>
        <title><anchor xreflabel="FlowLayout" xml:id="_Toc481064797"/>FlowLayout</title>
        <para>This simply �flows� the components onto the form, from left to right until the top space is full, then moves down a row and continues flowing.</para>
        <para>Here�s an example that sets the layout manager to <emphasis role="bold">FlowLayout</emphasis> and then places buttons on the form. You�ll notice that with <emphasis role="bold">FlowLayout</emphasis> the components take on their �natural� size. A <emphasis role="bold">J</emphasis><emphasis role="bold">Button</emphasis>, for example, will be the size of its string. </para>
        <para>//: c13:FlowLayout1.java</para>
        <para>// Demonstrates FlowLayout.</para>
        <para>// &lt;applet code=FlowLayout1 </para>
        <para>// width=300 height=250&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class FlowLayout1 extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� for(int i = 0; i &lt; 20; i++)</para>
        <para>����� cp.add(new JButton(&quot;Button &quot; + i));</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new FlowLayout1(), 300, 250);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>All components will be compacted to their smallest size in a <emphasis role="bold">FlowLayout</emphasis>, so you might get a little bit of surprising behavior. For example, because a <emphasis role="bold">JLabel</emphasis> will be the size of its string, attempting to right-justify its text yields an unchanged display when using <emphasis role="bold">FlowLayout</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064798"/><anchor xreflabel="GridLayout" xml:id="_Toc375545460"/>GridLayout</title>
        <para>A <emphasis role="bold">GridLayout</emphasis> allows you to build a table of components, and as you add them they are placed left-to-right and top-to-bottom in the grid. In the constructor you specify the number of rows and columns that you need and these are laid out in equal proportions.</para>
        <para>//: c13:GridLayout1.java</para>
        <para>// Demonstrates GridLayout.</para>
        <para>// &lt;applet code=GridLayout1 </para>
        <para>// width=300 height=250&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class GridLayout1 extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new GridLayout(7,3));</para>
        <para>��� for(int i = 0; i &lt; 20; i++)</para>
        <para>����� cp.add(new JButton(&quot;Button &quot; + i));</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new GridLayout1(), 300, 250);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In this case there are 21 slots but only 20 buttons. The last slot is left empty because no �balancing� goes on with a <emphasis role="bold">GridLayout</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064799"/><anchor xreflabel="GridBagLayout" xml:id="_Toc375545462"/>GridBagLayout</title>
        <para>The <emphasis role="bold">GridBagLayout </emphasis>provides you with tremendous control in deciding exactly how the regions of your window will lay themselves out and reformat themselves when the window is resized. However, it�s also the most complicated layout manager, and quite difficult to understand. It is intended primarily for automatic code generation by a GUI builder (good GUI builders will use <emphasis role="bold">GridBagLayout</emphasis> instead of absolute placement). If your design is so complicated that you feel you need to use <emphasis role="bold">GridBagLayout</emphasis>, then you should be using a GUI builder tool to generate that design. If you feel you must know the intricate details, I�ll refer you to <emphasis role="italic">Core Java 2</emphasis> by Horstmann &amp; Cornell (Prentice-Hall, 1999), or a dedicated Swing book, as a starting point.</para>
      </section>
      <section>
        <title><anchor xreflabel="Absolute positioning" xml:id="_Toc481064800"/>Absolute positioning</title>
        <para>It is also possible to set the absolute position of the graphical components in this way:</para>
        <para>Set a <emphasis role="bold">null</emphasis> layout manager for your <emphasis role="bold">Container</emphasis>: <emphasis role="bold">setLayout(null)</emphasis>.</para>
        <para>88.      Call <emphasis role="bold">setBounds( )</emphasis> or <emphasis role="bold">reshape( )</emphasis> (depending on the language version) for each component, passing a bounding rectangle in pixel coordinates. You can do this in the constructor, or in <emphasis role="bold">paint( )</emphasis>, depending on what you want to achieve.</para>
        <para>Some GUI builders use this approach extensively, but this is usually not the best way to generate code. More useful GUI builders will use <emphasis role="bold">GridBagLayout</emphasis> instead.</para>
      </section>
      <section>
        <title><anchor xreflabel="BoxLayout" xml:id="_Toc481064801"/>BoxLayout</title>
        <para>Because people had so much trouble understanding and working with <emphasis role="bold">GridBagLayout</emphasis>, Swing also includes the <emphasis role="bold">BoxLayout</emphasis>, which gives you many of the benefits of <emphasis role="bold">GridBagLayout</emphasis> without the complexity, so you can often use it when you need to do hand-coded layouts (again, if your design becomes too complex, use a GUI builder that generates <emphasis role="bold">GridBagLayout</emphasis>s for you). <emphasis role="bold">BoxLayout</emphasis> allows you to control the placement of components either vertically or horizontally, and to control the space between the components using something called �struts and glue.� First, let�s see how to use the <emphasis role="bold">BoxLayout</emphasis> directly, in the same way that the other layout managers have been demonstrated:</para>
        <para>//: c13:BoxLayout1.java</para>
        <para>// Vertical and horizontal BoxLayouts.</para>
        <para>// &lt;applet code=BoxLayout1 </para>
        <para>// width=450 height=200&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class BoxLayout1 extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� JPanel jpv = new JPanel();</para>
        <para>��� jpv.setLayout(</para>
        <para>����� new BoxLayout(jpv, BoxLayout.Y_AXIS));</para>
        <para>��� for(int i = 0; i &lt; 5; i++)</para>
        <para>����� jpv.add(new JButton(&quot;&quot; + i));</para>
        <para>��� JPanel jph = new JPanel();</para>
        <para>��� jph.setLayout(</para>
        <para>����� new BoxLayout(jph, BoxLayout.X_AXIS));</para>
        <para>��� for(int i = 0; i &lt; 5; i++)</para>
        <para>����� jph.add(new JButton(&quot;&quot; + i));</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(BorderLayout.EAST, jpv);</para>
        <para>��� cp.add(BorderLayout.SOUTH, jph);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new BoxLayout1(), 450, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The constructor for <emphasis role="bold">BoxLayout</emphasis> is a bit different than the other layout managers�you provide the <emphasis role="bold">Container</emphasis> that is to be controlled by the <emphasis role="bold">BoxLayout</emphasis> as the first argument, and the direction of the layout as the second argument.</para>
        <para>To simplify matters, there�s a special container called <emphasis role="bold">Box</emphasis> that uses <emphasis role="bold">BoxLayout</emphasis> as its native manager. The following example lays out components horizontally and vertically using <emphasis role="bold">Box</emphasis>, which has two <emphasis role="bold">static</emphasis> methods to create boxes with vertical and horizontal alignment:</para>
        <para>//: c13:Box1.java</para>
        <para>// Vertical and horizontal BoxLayouts.</para>
        <para>// &lt;applet code=Box1 </para>
        <para>// width=450 height=200&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Box1 extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� Box bv = Box.createVerticalBox();</para>
        <para>��� for(int i = 0; i &lt; 5; i++)</para>
        <para>����� bv.add(new JButton(&quot;&quot; + i));</para>
        <para>��� Box bh = Box.createHorizontalBox();</para>
        <para>��� for(int i = 0; i &lt; 5; i++)</para>
        <para>����� bh.add(new JButton(&quot;&quot; + i));</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(BorderLayout.EAST, bv);</para>
        <para>��� cp.add(BorderLayout.SOUTH, bh);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Box1(), 450, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Once you have a <emphasis role="bold">Box</emphasis>, you pass it as a second argument when adding components to the content pane.</para>
        <para>Struts add space between components, measured in pixels. To use a strut, you simply add it in between the addition of the components that you want spaced apart:</para>
        <para>//: c13:Box2.java</para>
        <para>// Adding struts.</para>
        <para>// &lt;applet code=Box2 </para>
        <para>// width=450 height=300&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Box2 extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� Box bv = Box.createVerticalBox();</para>
        <para>��� for(int i = 0; i &lt; 5; i++) {</para>
        <para>����� bv.add(new JButton(&quot;&quot; + i));</para>
        <para>����� bv.add(Box.createVerticalStrut(i*10));</para>
        <para>��� }</para>
        <para>��� Box bh = Box.createHorizontalBox();</para>
        <para>��� for(int i = 0; i &lt; 5; i++) {</para>
        <para>����� bh.add(new JButton(&quot;&quot; + i));</para>
        <para>����� bh.add(Box.createHorizontalStrut(i*10));</para>
        <para>��� }</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(BorderLayout.EAST, bv);</para>
        <para>��� cp.add(BorderLayout.SOUTH, bh);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Box2(), 450, 300);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Struts separate components by a fixed amount, but glue is the opposite: it separates components by as much as possible. Thus it�s more of a �spring� than �glue� (and the design on which this was based was called �springs and struts� so the choice of the term is a bit mysterious).</para>
        <para>//: c13:Box3.java</para>
        <para>// Using Glue.</para>
        <para>// &lt;applet code=Box3 </para>
        <para>// width=450 height=300&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Box3 extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� Box bv = Box.createVerticalBox();</para>
        <para>��� bv.add(new JLabel(&quot;Hello&quot;));</para>
        <para>��� bv.add(Box.createVerticalGlue());</para>
        <para>��� bv.add(new JLabel(&quot;Applet&quot;));</para>
        <para>��� bv.add(Box.createVerticalGlue());</para>
        <para>��� bv.add(new JLabel(&quot;World&quot;));</para>
        <para>��� Box bh = Box.createHorizontalBox();</para>
        <para>��� bh.add(new JLabel(&quot;Hello&quot;));</para>
        <para>��� bh.add(Box.createHorizontalGlue());</para>
        <para>��� bh.add(new JLabel(&quot;Applet&quot;));</para>
        <para>��� bh.add(Box.createHorizontalGlue());</para>
        <para>��� bh.add(new JLabel(&quot;World&quot;));</para>
        <para>��� bv.add(Box.createVerticalGlue());</para>
        <para>��� bv.add(bh);</para>
        <para>��� bv.add(Box.createVerticalGlue());</para>
        <para>��� getContentPane().add(bv);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Box3(), 450, 300);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>A strut works in one direction, but a rigid area fixes the spacing between components in both directions:</para>
        <para>//: c13:Box4.java</para>
        <para>// Rigid Areas are like pairs of struts.</para>
        <para>// &lt;applet code=Box4 </para>
        <para>// width=450 height=300&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Box4 extends JApplet {</para>
        <para>� public void init() {</para>
        <para>��� Box bv = Box.createVerticalBox();</para>
        <para>��� bv.add(new JButton(&quot;Top&quot;));</para>
        <para>��� bv.add(Box.createRigidArea(</para>
        <para>����� new Dimension(120, 90)));</para>
        <para>��� bv.add(new JButton(&quot;Bottom&quot;));</para>
        <para>��� Box bh = Box.createHorizontalBox();</para>
        <para>��� bh.add(new JButton(&quot;Left&quot;));</para>
        <para>��� bh.add(Box.createRigidArea(</para>
        <para>����� new Dimension(160, 80)));</para>
        <para>��� bh.add(new JButton(&quot;Right&quot;));</para>
        <para>��� bv.add(bh);</para>
        <para>��� getContentPane().add(bv);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Box4(), 450, 300);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You should be aware that rigid areas are a bit controversial. Since they use absolute values, some people feel that they cause more trouble than they are worth.</para>
      </section>
      <section>
        <title><anchor xreflabel="The best approach?" xml:id="_Toc481064802"/>The best approach?</title>
        <para>Swing is powerful; it can get a lot done with a few lines of code. The examples shown in this book are reasonably simple, and for learning purposes it makes sense to write them by hand. You can actually accomplish quite a bit by combining simple layouts. At some point, however, it stops making sense to hand-code GUI forms�it becomes too complicated and is not a good use of your programming time. The Java and Swing designers oriented the language and libraries to support GUI building tools, which have been created for the express purpose of making your programming experience easier. As long as you understand what�s going on with layouts and how to deal with the events (described next), it�s not particularly important that you actually know the details of how to lay out components by hand�let the appropriate tool do that for you (Java is, after all, designed to increase programmer productivity).</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="The Swing event model" xml:id="_Toc481064803"/>The Swing event model</title>
      <para>In the Swing event model a component can initiate (�fire�) an event. Each type of event is represented by a distinct class. When an event is fired, it is received by one or more �listeners,� which act on that event. Thus, the source of an event and the place where the event is handled can be separate. Since you typically use Swing components as they are, but need to write code that is called when the components receive an event, this is an excellent example of the separation of interface and implementation.</para>
      <para>Each event listener is an object of a class that implements a particular type of listener <emphasis role="bold">interface</emphasis>. So as a programmer, all you do is create a listener object and register it with the component that�s firing the event. This registration is performed by calling an <emphasis role="bold">addXXXListener( )</emphasis> method in the event-firing component, in which �<emphasis role="bold">XXX</emphasis>� represents the type of event listened for. You can easily know what types of events can be handled by noticing the names of the �addListener� methods, and if you try to listen for the wrong events you�ll discover your mistake at compile-time. You�ll see later in the chapter that JavaBeans also use the names of the �addListener� methods to determine what events a Bean can handle.</para>
      <para>All of your event logic, then, will go inside a listener class. When you create a listener class, the sole restriction is that it must implement the appropriate interface. You can create a global listener class, but this is a situation in which inner classes tend to be quite useful, not only because they provide a logical grouping of your listener classes inside the UI or business logic classes they are serving, but because (as you shall see later) the fact that an inner class object keeps a reference to its parent object provides a nice way to call across class and subsystem boundaries.</para>
      <para>All the examples so far in this chapter have been using the Swing event model, but the remainder of this section will fill out the details of that model.</para>
      <section>
        <title><anchor xreflabel="Event and listener types" xml:id="_Toc481064804"/>Event and listener types</title>
        <para>All Swing components include <emphasis role="bold">addXXXListener( )</emphasis> and <emphasis role="bold">removeXXXListener( )</emphasis> methods so that the appropriate types of listeners can be added and removed from each component. You�ll notice that the �<emphasis role="bold">XXX</emphasis>� in each case also represents the argument for the method, for example: <emphasis role="bold">addMyListener(MyListener m)</emphasis>. The following table includes the basic associated events, listeners, and methods, along with the basic components that support those particular events by providing the <emphasis role="bold">addXXXListener( )</emphasis> and <emphasis role="bold">removeXXXListener( )</emphasis> methods. You should keep in mind that the event model is designed to be extensible, so you may encounter other events and listener types that are not covered in this table.</para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="24*"/>
            <colspec colname="c2" colwidth="24*"/>
            <thead>
              <row>
                <entry valign="top"><para> Event, listener interface and add- and remove-methods</para></entry>
                <entry valign="top"><para> Components supporting this event</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry valign="top"><para> ActionEvent</para><para> ActionListener</para><para> addActionListener( )</para><para> removeActionListener( )</para></entry>
                <entry valign="top"><para> JButton, JList, JTextField, JMenuItem and its derivativesincluding JCheckBoxMenuItem, JMenu, and JpopupMenu.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> AdjustmentEvent</para><para> AdjustmentListener</para><para> addAdjustmentListener( )</para><para> removeAdjustmentListener( )</para></entry>
                <entry valign="top"><para> JScrollbarand anything you create that implements the Adjustable interface.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> ComponentEvent</para><para> ComponentListener</para><para> addComponentListener( )</para><para> removeComponentListener( )</para></entry>
                <entry valign="top"><para> *Component and its derivatives, including JButton, JCanvas, JCheckBox, JComboBox, Container, JPanel, JApplet, JScrollPane, Window, JDialog, JFileDialog, JFrame, JLabel, JList, JScrollbar, JTextArea, and JTextField.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> ContainerEvent</para><para> ContainerListener</para><para> addContainerListener( )</para><para> removeContainerListener( )</para></entry>
                <entry valign="top"><para> Container and its derivatives, including JPanel, JApplet, JScrollPane, Window, JDialog, JFileDialog, and JFrame.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> FocusEvent</para><para> FocusListener</para><para> addFocusListener( )</para><para> removeFocusListener( )</para></entry>
                <entry valign="top"><para> Component and derivatives*.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> KeyEvent</para><para> KeyListener</para><para> addKeyListener( )</para><para> removeKeyListener( )</para></entry>
                <entry valign="top"><para> Component and derivatives*.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> MouseEvent (for both clicks and motion)MouseListener</para><para> addMouseListener( )</para><para> removeMouseListener( )</para></entry>
                <entry valign="top"><para> Component and derivatives*. </para></entry>
              </row>
              <row>
                <entry valign="top"><para> MouseEvent<anchor xreflabel="[68]" xml:id="_ftnref68"/><emphasis role="bold">[68]</emphasis>(for both clicks and motion)MouseMotionListener</para><para> addMouseMotionListener( )</para><para> removeMouseMotionListener( )</para></entry>
                <entry valign="top"><para> Component and derivatives*.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> WindowEvent</para><para> WindowListener</para><para> addWindowListener( )</para><para> removeWindowListener( )</para></entry>
                <entry valign="top"><para> Window and its derivatives, including JDialog, JFileDialog, and JFrame.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> ItemEvent</para><para> ItemListener</para><para> addItemListener( )</para><para> removeItemListener( )</para></entry>
                <entry valign="top"><para> JCheckBox, JCheckBoxMenuItem, JComboBox, JList, and anything that implements the ItemSelectable interface.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> TextEvent</para><para> TextListener</para><para> addTextListener( )</para><para> removeTextListener( )</para></entry>
                <entry valign="top"><para> Anything derived from JTextComponent, including JTextArea and JTextField.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>You can see that each type of component supports only certain types of events. It turns out to be rather difficult to look up all the events supported by each component. A simpler approach is to modify the <emphasis role="bold">ShowMethodsClean.java</emphasis> program from Chapter 12 so that it displays all the event listeners supported by any Swing component that you enter.</para>
        <para>Chapter 12 introduced <emphasis role="italic">reflection</emphasis> and used that feature to look up methods for a particular class�either the entire list of methods or a subset of those whose names match a keyword that you provide. The magic of this is that it can automatically show you <emphasis role="italic">all</emphasis> the methods for a class without forcing you to walk up the inheritance hierarchy examining the base classes at each level. Thus, it provides a valuable timesaving tool for programming: because the names of most Java methods are made nicely verbose and descriptive, you can search for the method names that contain a particular word of interest. When you find what you think you�re looking for, check the online documentation.</para>
        <para>However, by Chapter 12 you hadn�t seen Swing, so the tool in that chapter was developed as a command-line application. Here is the more useful GUI version, specialized to look for the �addListener� methods in Swing components: </para>
        <para>//: c13:ShowAddListeners.java</para>
        <para>// Display the &quot;addXXXListener&quot; methods of any </para>
        <para>// Swing class.</para>
        <para>// &lt;applet code = ShowAddListeners </para>
        <para>// width=500 height=400&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import javax.swing.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.lang.reflect.*;</para>
        <para>import java.io.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>public class ShowAddListeners extends JApplet {</para>
        <para>� Class cl;</para>
        <para>� Method[] m;</para>
        <para>� Constructor[] ctor;</para>
        <para>� String[] n = new String[0];</para>
        <para>� JTextField name = new JTextField(25);</para>
        <para>� JTextArea results = new JTextArea(40, 65);</para>
        <para>� class NameL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� String nm = name.getText().trim();</para>
        <para>����� if(nm.length() == 0) {</para>
        <para>������� results.setText(&quot;No match&quot;);</para>
        <para>������� n = new String[0];</para>
        <para>������� return;</para>
        <para>����� }</para>
        <para>����� try {</para>
        <para>������� cl = Class.forName(&quot;javax.swing.&quot; + nm);</para>
        <para>����� } catch(ClassNotFoundException ex) {</para>
        <para>������� results.setText(&quot;No match&quot;);</para>
        <para>������� return;</para>
        <para>����� }</para>
        <para>��� ��m = cl.getMethods();</para>
        <para>����� // Convert to an array of Strings:</para>
        <para>����� n = new String[m.length];</para>
        <para>����� for(int i = 0; i &lt; m.length; i++)</para>
        <para>������� n[i] = m[i].toString();</para>
        <para>����� reDisplay();</para>
        <para>��� }</para>
        <para>� } </para>
        <para>� void reDisplay() {</para>
        <para>��� // Create the result set:</para>
        <para>��� String[] rs = new String[n.length];</para>
        <para>��� int j = 0;</para>
        <para>��� for (int i = 0; i &lt; n.length; i++)</para>
        <para>����� if(n[i].indexOf(&quot;add&quot;) != -1 &amp;&amp;</para>
        <para>������� n[i].indexOf(&quot;Listener&quot;) != -1)</para>
        <para>��������� rs[j++] = </para>
        <para>����������� n[i].substring(n[i].indexOf(&quot;add&quot;));</para>
        <para>��� results.setText(&quot;&quot;);</para>
        <para>��� for (int i = 0; i &lt; j; i++)</para>
        <para>����� results.append(</para>
        <para>������� StripQualifiers.strip(rs[i]) + &quot;\n&quot;);</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� name.addActionListener(new NameL());</para>
        <para>��� JPanel top = new JPanel();</para>
        <para>��� top.add(new JLabel(</para>
        <para>����� &quot;Swing class name (press ENTER):&quot;));</para>
        <para>��� top.add(name);</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(BorderLayout.NORTH, top);</para>
        <para>��� cp.add(new JScrollPane(results));</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new ShowAddListeners(), 500,400);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">StripQualifiers</emphasis> class defined in Chapter 12 is reused here by importing the <emphasis role="bold">com.bruceeckel.util</emphasis> library.</para>
        <para>The GUI contains a<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis><emphasis role="bold">name </emphasis>in which you can enter the Swing class name you want to look up. The results are displayed in a<emphasis role="bold"> JText</emphasis><emphasis role="bold">Area</emphasis>.</para>
        <para>You�ll notice that there are no buttons or other components by which to indicate that you want the search to begin. That�s because the<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis> is monitored by an <emphasis role="bold">ActionListener</emphasis>. Whenever you make a change and press ENTER, the list is immediately updated. If the text isn�t empty, it is used inside <emphasis role="bold">Class.forName( )</emphasis> to try to look up the class. If the name is incorrect, <emphasis role="bold">Class.forName( )</emphasis> will fail, which means that it throws an exception. This is trapped and the<emphasis role="bold"> JText</emphasis><emphasis role="bold">Area</emphasis> is set to �No match.� But if you type in a correct name (capitalization counts), <emphasis role="bold">Class.forName( )</emphasis> is successful and <emphasis role="bold">getMethods( )</emphasis> will return an array of <emphasis role="bold">Method</emphasis> objects. Each of the objects in the array is turned into a <emphasis role="bold">String</emphasis> via <emphasis role="bold">toString( )</emphasis> (this produces the complete method signature) and added to <emphasis role="bold">n</emphasis>, a <emphasis role="bold">String</emphasis> array. The array <emphasis role="bold">n</emphasis> is a member of <emphasis role="bold">class ShowAddListeners</emphasis> and is used in updating the display whenever <emphasis role="bold">reDisplay( )</emphasis> is called.</para>
        <para><emphasis role="bold">reDisplay( )</emphasis> creates an array of <emphasis role="bold">String</emphasis> called <emphasis role="bold">rs</emphasis> (for �result set�). The result set is conditionally copied from the <emphasis role="bold">String</emphasis>s in <emphasis role="bold">n</emphasis> that contain �add� and �Listener.� <emphasis role="bold">indexOf( ) </emphasis>and <emphasis role="bold">substring( ) </emphasis>are then used to remove the qualifiers like <emphasis role="bold">public</emphasis>, <emphasis role="bold">static</emphasis>, etc. Finally, <emphasis role="bold">StripQualifiers.strip( )</emphasis> removes the extra name qualifiers.</para>
        <para>This program is a convenient way to investigate the capabilities of a Swing component. Once you know which events a particular component supports, you don�t need to look anything up to react to that event. You simply:</para>
        <para>Take the name of the event class and remove the word �<emphasis role="bold">Event</emphasis>.� Add the word �<emphasis role="bold">Listener</emphasis>� to what remains. This is the listener interface you must implement in your inner class. </para>
        <para>89.      Implement the interface above and write out the methods for the events you want to capture. For example, you might be looking for mouse movements, so you write code for the <emphasis role="bold">mouseMoved( )</emphasis> method of the <emphasis role="bold">MouseMotionListener</emphasis> interface. (You must implement the other methods, of course, but there�s often a shortcut for that which you�ll see soon.)</para>
        <para>90.      Create an object of the listener class in Step 2. Register it with your component with the method produced by prefixing �<emphasis role="bold">add</emphasis>� to your listener name. For example, <emphasis role="bold">addMouseMotionListener( )</emphasis>.</para>
        <para>Here are some of the listener interfaces: </para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="19*"/>
            <colspec colname="c2" colwidth="31*"/>
            <thead>
              <row>
                <entry valign="top"><para> Listener interface</para><para> w/ adapter</para></entry>
                <entry valign="top"><para> Methods in interface</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry valign="top"><para> ActionListener</para></entry>
                <entry valign="top"><para> actionPerformed(ActionEvent)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> AdjustmentListener</para></entry>
                <entry valign="top"><para> adjustmentValueChanged(</para><para> � AdjustmentEvent)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> ComponentListener</para><para> ComponentAdapter</para></entry>
                <entry valign="top"><para> componentHidden(ComponentEvent)</para><para> componentShown(ComponentEvent)</para><para> componentMoved(ComponentEvent)</para><para> componentResized(ComponentEvent)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> ContainerListener</para><para> ContainerAdapter</para></entry>
                <entry valign="top"><para> componentAdded(ContainerEvent)</para><para> componentRemoved(ContainerEvent)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> FocusListener</para><para> FocusAdapter</para></entry>
                <entry valign="top"><para> focusGained(FocusEvent)</para><para> focusLost(FocusEvent)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> KeyListener</para><para> KeyAdapter</para></entry>
                <entry valign="top"><para> keyPressed(KeyEvent)</para><para> keyReleased(KeyEvent)</para><para> keyTyped(KeyEvent)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> MouseListener</para><para> MouseAdapter</para></entry>
                <entry valign="top"><para> mouseClicked(MouseEvent)</para><para> mouseEntered(MouseEvent)</para><para> mouseExited(MouseEvent)</para><para> mousePressed(MouseEvent)</para><para> mouseReleased(MouseEvent)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> MouseMotionListener</para><para> MouseMotionAdapter</para></entry>
                <entry valign="top"><para> mouseDragged(MouseEvent)</para><para> mouseMoved(MouseEvent)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> WindowListener</para><para> WindowAdapter</para></entry>
                <entry valign="top"><para> windowOpened(WindowEvent)</para><para> windowClosing(WindowEvent) </para><para> windowClosed(WindowEvent) </para><para> windowActivated(WindowEvent) </para><para> windowDeactivated(WindowEvent) </para><para> windowIconified(WindowEvent) </para><para> windowDeiconified(WindowEvent)</para></entry>
              </row>
              <row>
                <entry valign="top"><para> ItemListener</para></entry>
                <entry valign="top"><para> itemStateChanged(ItemEvent)</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>This is not an exhaustive listing, partly because the event model allows you to create your own event types and associated listeners. Thus, you�ll regularly come across libraries that have invented their own events, and the knowledge gained in this chapter will allow you to figure out how to use these events.</para>
        <section>
          <title>Using listener adapters for simplicity</title>
          <para>In the table above, you can see that some listener interfaces have only one method. These are trivial to implement since you�ll implement them only when you want to write that particular method. However, the listener interfaces that have multiple methods can be less pleasant to use. For example, something you must always do when creating an application is provide a <emphasis role="bold">WindowListener</emphasis> to the <emphasis role="bold">JFrame</emphasis> so that when you get the <emphasis role="bold">windowClosing( )</emphasis> event you can call <emphasis role="bold">System.exit( )</emphasis> to exit the application. But since <emphasis role="bold">WindowListener</emphasis> is an <emphasis role="bold">interface</emphasis>, you must implement all of the other methods even if they don�t do anything. This can be annoying.</para>
          <para>To solve the problem, some (but not all) of the listener interfaces that have more than one method are provided with <emphasis role="italic">adapters</emphasis>, the names of which you can see in the table above. Each adapter provides default empty methods for each of the interface methods. Then all you need to do is inherit from the adapter and override only the methods you need to change. For example, the typical <emphasis role="bold">WindowListener</emphasis> you�ll use looks like this (remember that this has been wrapped inside the <emphasis role="bold">Console</emphasis> class in <emphasis role="bold">com.bruceeckel.swing</emphasis>):</para>
          <para>class MyWindowListener extends WindowAdapter {</para>
          <para>� public void windowClosing(WindowEvent e) {</para>
          <para>��� System.exit(0);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>The whole point of the adapters is to make the creation of listener classes easy.</para>
          <para>There is a downside to adapters, however, in the form of a pitfall. Suppose you write a <emphasis role="bold">WindowAdapter</emphasis> like the one above:</para>
          <para>class MyWindowListener extends WindowAdapter {</para>
          <para>� public void WindowClosing(WindowEvent e) {</para>
          <para>��� System.exit(0);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>This doesn�t work, but it will drive you crazy trying to figure out why, since everything will compile and run fine�except that closing the window won�t exit the program. Can you see the problem? It�s in the name of the method: <emphasis role="bold">WindowClosing( )</emphasis> instead of <emphasis role="bold">windowClosing( )</emphasis>. A simple slip in capitalization results in the addition of a completely new method. However, this is not the method that�s called when the window is closing, so you don�t get the desired results. Despite the inconvenience, an <emphasis role="bold">interface</emphasis> will guarantee that the methods are properly implemented.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545452"/><anchor xreflabel="Tracking
multiple events" xml:id="_Toc481064805"/>Tracking multiple events</title>
        <para>To prove to yourself that these events are in fact being fired, and as an interesting experiment, it�s worth creating an applet that tracks extra behavior in a <emphasis role="bold">JButton </emphasis>(other than just whether it�s pressed or not). This example also shows you how to inherit your own button object because that�s what is used as the target of all the events of interest. To do so, you can just inherit from�<emphasis role="bold">J</emphasis><emphasis role="bold">Button</emphasis>.<anchor xreflabel="[69]" xml:id="_ftnref69"/><emphasis role="bold"><emphasis role="bold">[69]</emphasis></emphasis></para>
        <para>The <emphasis role="bold">MyButton</emphasis> class is an inner class of <emphasis role="bold">TrackEvent</emphasis>, so <emphasis role="bold">MyButton</emphasis> can reach into the parent window and manipulate its text fields, which is what�s necessary to be able to write the status information into the fields of the parent. Of course this is a limited solution, since <emphasis role="bold">myButton</emphasis> can be used only in conjunction with <emphasis role="bold">TrackEvent</emphasis>. This kind of code is sometimes called �highly coupled�: </para>
        <para>//: c13:TrackEvent.java</para>
        <para>// Show events as they happen.</para>
        <para>// &lt;applet code=TrackEvent</para>
        <para>//� width=700 height=500&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class TrackEvent extends JApplet {</para>
        <para>� HashMap h = new HashMap();</para>
        <para>� String[] event = {</para>
        <para>��� &quot;focusGained&quot;, &quot;focusLost&quot;, &quot;keyPressed&quot;,</para>
        <para>��� &quot;keyReleased&quot;, &quot;keyTyped&quot;, &quot;mouseClicked&quot;,</para>
        <para>��� &quot;mouseEntered&quot;, &quot;mouseExited&quot;,&quot;mousePressed&quot;,</para>
        <para>��� &quot;mouseReleased&quot;, &quot;mouseDragged&quot;, &quot;mouseMoved&quot;</para>
        <para>� };</para>
        <para>� MyButton</para>
        <para>��� b1 = new MyButton(Color.blue, &quot;test1&quot;),</para>
        <para>��� b2 = new MyButton(Color.red, &quot;test2&quot;);</para>
        <para>� class MyButton extends JButton {</para>
        <para>��� void report(String field, String msg) {</para>
        <para>����� ((JTextField)h.get(field)).setText(msg);</para>
        <para>��� }��� </para>
        <para>��� FocusListener fl = new FocusListener() {</para>
        <para>����� public void focusGained(FocusEvent e) {</para>
        <para>������� report(&quot;focusGained&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>����� public void focusLost(FocusEvent e) {</para>
        <para>������� report(&quot;focusLost&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>��� };</para>
        <para>��� KeyListener kl = new KeyListener() {</para>
        <para>����� public void keyPressed(KeyEvent e) {</para>
        <para>������� report(&quot;keyPressed&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>����� public void keyReleased(KeyEvent e) {</para>
        <para>������� report(&quot;keyReleased&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>����� public void keyTyped(KeyEvent e) {</para>
        <para>������� report(&quot;keyTyped&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>��� };</para>
        <para>��� MouseListener ml = new MouseListener() {</para>
        <para>����� public void mouseClicked(MouseEvent e) {</para>
        <para>������� report(&quot;mouseClicked&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>����� public void mouseEntered(MouseEvent e) {</para>
        <para>������� report(&quot;mouseEntered&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>����� public void mouseExited(MouseEvent e) {</para>
        <para>������� report(&quot;mouseExited&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>����� public void mousePressed(MouseEvent e) {</para>
        <para>������� report(&quot;mousePressed&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>����� public void mouseReleased(MouseEvent e) {</para>
        <para>������� report(&quot;mouseReleased&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>��� };</para>
        <para>��� MouseMotionListener mml = </para>
        <para>����� new MouseMotionListener() {</para>
        <para>����� public void mouseDragged(MouseEvent e) {</para>
        <para>������� report(&quot;mouseDragged&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>����� public void mouseMoved(MouseEvent e) {</para>
        <para>������� report(&quot;mouseMoved&quot;, e.paramString());</para>
        <para>����� }</para>
        <para>��� };</para>
        <para>��� public MyButton(Color color, String label) {</para>
        <para>����� super(label);</para>
        <para>����� setBackground(color);</para>
        <para>����� addFocusListener(fl);</para>
        <para>����� addKeyListener(kl);</para>
        <para>����� addMouseListener(ml);</para>
        <para>����� addMouseMotionListener(mml);</para>
        <para>��� }</para>
        <para>� }� </para>
        <para>� public void init() {</para>
        <para>��� Container c = getContentPane();</para>
        <para>��� c.setLayout(new GridLayout(event.length+1,2));</para>
        <para>��� for(int i = 0; i &lt; event.length; i++) {</para>
        <para>����� JTextField t = new JTextField();</para>
        <para>����� t.setEditable(false);</para>
        <para>����� c.add(new JLabel(event[i], JLabel.RIGHT));</para>
        <para>����� c.add(t);</para>
        <para>����� h.put(event[i], t);</para>
        <para>��� }</para>
        <para>��� c.add(b1);</para>
        <para>��� c.add(b2);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new TrackEvent(), 700, 500);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In the <emphasis role="bold">MyButton</emphasis> constructor, the button�s color is set with a call to <emphasis role="bold">SetBackground( )</emphasis>. The listeners are all installed with simple method calls.</para>
        <para>The <emphasis role="bold">TrackEvent</emphasis> class contains a <emphasis role="bold">HashMap</emphasis> to hold the strings representing the type of event and <emphasis role="bold">JText</emphasis><emphasis role="bold">Field</emphasis>s where information about that event is held. Of course, these could have been created statically rather than putting them in a <emphasis role="bold">HashMap</emphasis>, but I think you�ll agree that it�s a lot easier to use and change. In particular, if you need to add or remove a new type of event in <emphasis role="bold">TrackEvent</emphasis>, you simply add or remove a string in the <emphasis role="bold">event</emphasis> array�everything else happens automatically.</para>
        <para>When <emphasis role="bold">report( )</emphasis> is called it is given the name of the event and the parameter string from the event. It uses the <emphasis role="bold">HashMap h </emphasis>in the outer class to look up the actual <emphasis role="bold">JTextField </emphasis>associated with that event name, and then places the parameter string into that field.</para>
        <para>This example is fun to play with since you can really see what�s going on with the events in your program.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="A catalog of Swing components" xml:id="_Toc481064806"/>A catalog of Swing components</title>
      <para>Now that you understand layout managers and the event model, you�re ready to see how Swing components can be used. This section is a nonexhaustive tour of the Swing components and features that you�ll probably use most of the time. Each example is intended to be reasonably small so that you can easily lift the code and use it in your own programs.</para>
      <para>You can easily see what each of these examples looks like while running by viewing the HTML pages in the downloadable source code for this chapter.</para>
      <para>Keep in mind: </para>
      <para>The HTML documentation from <emphasis role="italic">java.sun.com</emphasis> contains all of the Swing classes and methods (only a few are shown here). </para>
      <para>Because of the naming convention used for Swing events, it�s fairly easy to guess how to write and install a handler for a particular type of event. Use the lookup program <emphasis role="bold">ShowAddListeners.java</emphasis> from earlier in this chapter to aid in your investigation of a particular component.</para>
      <para>91.      When things start to get complicated you should graduate to a GUI builder.</para>
      <section>
        <title><anchor xreflabel="Buttons" xml:id="_Toc481064807"/>Buttons</title>
        <para>Swing includes a number of different types of buttons. All buttons, check boxes, radio buttons, and even menu items are inherited from <emphasis role="bold">AbstractButton</emphasis> (which, since menu items are included, would probably have been better named �AbstractChooser� or something equally general). You�ll see the use of menu items shortly, but the following example shows the various types of buttons available:</para>
        <para>//: c13:Buttons.java</para>
        <para>// Various Swing buttons.</para>
        <para>// &lt;applet code=Buttons</para>
        <para>//� width=350 height=100&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import javax.swing.plaf.basic.*;</para>
        <para>import javax.swing.border.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Buttons extends JApplet {</para>
        <para>� JButton jb = new JButton(&quot;JButton&quot;);</para>
        <para>� BasicArrowButton</para>
        <para>��� up = new BasicArrowButton(</para>
        <para>����� BasicArrowButton.NORTH),</para>
        <para>��� down = new BasicArrowButton(</para>
        <para>����� BasicArrowButton.SOUTH),</para>
        <para>��� right = new BasicArrowButton(</para>
        <para>����� BasicArrowButton.EAST),</para>
        <para>��� left = new BasicArrowButton(</para>
        <para>����� BasicArrowButton.WEST);</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(jb);</para>
        <para>��� cp.add(new JToggleButton(&quot;JToggleButton&quot;));</para>
        <para>��� cp.add(new JCheckBox(&quot;JCheckBox&quot;));</para>
        <para>��� cp.add(new JRadioButton(&quot;JRadioButton&quot;));</para>
        <para>��� JPanel jp = new JPanel();</para>
        <para>��� jp.setBorder(new TitledBorder(&quot;Directions&quot;));</para>
        <para>��� jp.add(up);</para>
        <para>��� jp.add(down);</para>
        <para>��� jp.add(left);</para>
        <para>��� jp.add(right);</para>
        <para>��� cp.add(jp);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Buttons(), 350, 100);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This begins with the <emphasis role="bold">BasicArrowButton</emphasis> from <emphasis role="bold">javax.swing.plaf.basic</emphasis>, then continues with the various specific types of buttons. When you run the example, you�ll see that the toggle button holds its last position, in or out. But the check boxes and radio buttons behave identically to each other, just clicking on or off (they are inherited from <emphasis role="bold">JToggleButton</emphasis>). </para>
        <section>
          <title>Button groups</title>
          <para>If you want radio buttons to behave in an �exclusive or� fashion, you must add them to a �button group.� But, as the example below demonstrates, any <emphasis role="bold">AbstractButton</emphasis> can be added to a <emphasis role="bold">ButtonGroup</emphasis>.</para>
          <para>To avoid repeating a lot of code, this example uses reflection to generate the groups of different types of buttons. This is seen in <emphasis role="bold">makeBPanel( )</emphasis>, which creates a button group and a <emphasis role="bold">JPanel</emphasis>. The second argument to <emphasis role="bold">makeBPanel( )</emphasis> is an array of <emphasis role="bold">String</emphasis>. For each <emphasis role="bold">String</emphasis>, a button of the class represented by the first argument is added to the <emphasis role="bold">JPanel</emphasis>:</para>
          <para>//: c13:ButtonGroups.java</para>
          <para>// Uses reflection to create groups </para>
          <para>// of different types of AbstractButton.</para>
          <para>// &lt;applet code=ButtonGroups</para>
          <para>//� width=500 height=300&gt;&lt;/applet&gt;</para>
          <para>import javax.swing.*;</para>
          <para>import java.awt.*;</para>
          <para>import java.awt.event.*;</para>
          <para>import javax.swing.border.*;</para>
          <para>import java.lang.reflect.*;</para>
          <para>import com.bruceeckel.swing.*;</para>
          <para> </para>
          <para>public class ButtonGroups extends JApplet {</para>
          <para>� static String[] ids = { </para>
          <para>��� &quot;June&quot;, &quot;Ward&quot;, &quot;Beaver&quot;, </para>
          <para>��� &quot;Wally&quot;, &quot;Eddie&quot;, &quot;Lumpy&quot;,</para>
          <para>� };</para>
          <para>� static JPanel </para>
          <para>� makeBPanel(Class bClass, String[] ids) {</para>
          <para>��� ButtonGroup bg = new ButtonGroup();</para>
          <para>��� JPanel jp = new JPanel();</para>
          <para>��� String title = bClass.getName();</para>
          <para>��� title = title.substring(</para>
          <para>����� title.lastIndexOf(&apos;.&apos;) + 1);</para>
          <para>��� jp.setBorder(new TitledBorder(title));</para>
          <para>��� for(int i = 0; i &lt; ids.length; i++) {</para>
          <para>����� AbstractButton ab = new JButton(&quot;failed&quot;);</para>
          <para>����� try {</para>
          <para>������� // Get the dynamic constructor method</para>
          <para>������� // that takes a String argument:</para>
          <para>������� Constructor ctor = bClass.getConstructor(</para>
          <para>��������� new Class[] { String.class });</para>
          <para>������� // Create a new object:</para>
          <para>������� ab = (AbstractButton)ctor.newInstance(</para>
          <para>��������� new Object[]{ids[i]});</para>
          <para>����� } catch(Exception ex) {</para>
          <para>������� System.err.println(&quot;can&apos;t create &quot; + </para>
          <para>��������� bClass);</para>
          <para>����� }</para>
          <para>����� bg.add(ab);</para>
          <para>����� jp.add(ab);</para>
          <para>��� }</para>
          <para>��� return jp;</para>
          <para>� }</para>
          <para>� public void init() {</para>
          <para>��� Container cp = getContentPane();</para>
          <para>��� cp.setLayout(new FlowLayout());</para>
          <para>��� cp.add(makeBPanel(JButton.class, ids));</para>
          <para>��� cp.add(makeBPanel(JToggleButton.class, ids));</para>
          <para>��� cp.add(makeBPanel(JCheckBox.class, ids));</para>
          <para>��� cp.add(makeBPanel(JRadioButton.class, ids));</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Console.run(new ButtonGroups(), 500, 300);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The title for the border is taken from the name of the class, stripping off all the path information. The <emphasis role="bold">AbstractButton</emphasis> is initialized to a <emphasis role="bold">JButton</emphasis> that has the label �Failed� so if you ignore the exception message, you�ll still see the problem on screen. The <emphasis role="bold">getConstructor( )</emphasis> method produces a <emphasis role="bold">Constructor</emphasis> object that takes the array of arguments of the types in the <emphasis role="bold">Class </emphasis>array passed to <emphasis role="bold">getConstructor( )</emphasis>. Then all you do is call <emphasis role="bold">newInstance( )</emphasis>, passing it an array of <emphasis role="bold">Object</emphasis> containing your actual arguments�in this case, just the <emphasis role="bold">String</emphasis> from the <emphasis role="bold">ids</emphasis> array.</para>
          <para>This adds a little complexity to what is a simple process. To get �exclusive or� behavior with buttons, you create a button group and add each button for which you want that behavior to the group. When you run the program, you�ll see that all the buttons except <emphasis role="bold">JButton</emphasis> exhibit this �exclusive or� behavior.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Icons" xml:id="_Toc481064808"/>Icons</title>
        <para>You can use an <emphasis role="bold">Icon</emphasis> inside a <emphasis role="bold">JLabel</emphasis> or anything that inherits from <emphasis role="bold">AbstractButton</emphasis> (including <emphasis role="bold">JButton</emphasis>, <emphasis role="bold">JCheckBox</emphasis>, <emphasis role="bold">JRadioButton,</emphasis> and the different kinds of <emphasis role="bold">JMenuItem</emphasis>). Using <emphasis role="bold">Icon</emphasis>s with <emphasis role="bold">JLabel</emphasis>s is quite straightforward (you�ll see an example later). The following example explores all the additional ways you can use <emphasis role="bold">Icon</emphasis>s with buttons and their descendants.</para>
        <para>You can use any <emphasis role="bold">gif</emphasis> files you want, but the ones used in this example are part of this book�s code distribution, available at <emphasis role="italic">www.BruceEckel.com</emphasis>. To open a file and bring in the image, simply create an <emphasis role="bold">ImageIcon</emphasis> and hand it the file name. From then on, you can use the resulting <emphasis role="bold">Icon</emphasis> in your program.</para>
        <para>Note that path information is hard-coded into this example; you will need to change the path to correspond to the location of the image files.</para>
        <para>//: c13:Faces.java</para>
        <para>// Icon behavior in Jbuttons.</para>
        <para>// &lt;applet code=Faces</para>
        <para>//� width=250 height=100&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Faces extends JApplet {</para>
        <para>� // The following path information is necessary</para>
        <para>� // to run via an applet directly from the disk:</para>
        <para>� static String path = </para>
        <para>��� &quot;C:/aaa-TIJ2-distribution/code/c13/&quot;;</para>
        <para>� static Icon[] faces = {</para>
        <para>��� new ImageIcon(path + &quot;face0.gif&quot;),</para>
        <para>��� new ImageIcon(path + &quot;face1.gif&quot;),</para>
        <para>��� new ImageIcon(path + &quot;face2.gif&quot;),</para>
        <para>��� new ImageIcon(path + &quot;face3.gif&quot;),</para>
        <para>��� new ImageIcon(path + &quot;face4.gif&quot;),</para>
        <para>� };</para>
        <para>� JButton </para>
        <para>��� jb = new JButton(&quot;JButton&quot;, faces[3]),</para>
        <para>��� jb2 = new JButton(&quot;Disable&quot;);</para>
        <para>� boolean mad = false;</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� jb.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� if(mad) {</para>
        <para>��������� jb.setIcon(faces[3]);</para>
        <para>��������� mad = false;</para>
        <para>������� } else {</para>
        <para>��������� jb.setIcon(faces[0]);</para>
        <para>��������� mad = true;</para>
        <para>������� }</para>
        <para>������� jb.setVerticalAlignment(JButton.TOP);</para>
        <para>������� jb.setHorizontalAlignment(JButton.LEFT);</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� jb.setRolloverEnabled(true);</para>
        <para>��� jb.setRolloverIcon(faces[1]);</para>
        <para>��� jb.setPressedIcon(faces[2]);</para>
        <para>��� jb.setDisabledIcon(faces[4]);</para>
        <para>��� jb.setToolTipText(&quot;Yow!&quot;);</para>
        <para>��� cp.add(jb);</para>
        <para>��� jb2.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� if(jb.isEnabled()) {</para>
        <para>��� ������jb.setEnabled(false);</para>
        <para>��������� jb2.setText(&quot;Enable&quot;);</para>
        <para>������� } else {</para>
        <para>��������� jb.setEnabled(true);</para>
        <para>��������� jb2.setText(&quot;Disable&quot;);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� cp.add(jb2);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Faces(), 400, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>An <emphasis role="bold">Icon</emphasis> can be used in many constructors, but you can also use <emphasis role="bold">setIcon( )</emphasis> to add or change an <emphasis role="bold">Icon</emphasis>. This example also shows how a <emphasis role="bold">JButton</emphasis> (or any <emphasis role="bold">AbstractButton</emphasis>) can set the various different sorts of icons that appear when things happen to that button: when it�s pressed, disabled, or �rolled over� (the mouse moves over it without clicking). You�ll see that this gives the button a nice animated feel.</para>
      </section>
      <section>
        <title><anchor xreflabel="Tool tips" xml:id="_Toc481064809"/>Tool tips</title>
        <para>The previous example added a �tool tip� to the button. Almost all of the classes that you�ll be using to create your user interfaces are derived from <emphasis role="bold">JComponent</emphasis>, which contains a method called <emphasis role="bold">setToolTipText(String)</emphasis>. So, for virtually anything you place on your form, all you need to do is say (for an object <emphasis role="bold">jc </emphasis>of any <emphasis role="bold">JComponent</emphasis>-derived class):</para>
        <para>jc.setToolTipText(&quot;My tip&quot;);</para>
        <para> </para>
        <para>and when the mouse stays over that <emphasis role="bold">JComponent</emphasis> for a predetermined period of time, a tiny box containing your text will pop up next to the mouse.</para>
      </section>
      <section>
        <title><anchor xreflabel="Text fields" xml:id="_Toc481064810"/>Text fields</title>
        <para>This example shows the extra behavior that <emphasis role="bold">JTextField</emphasis>s are capable of:</para>
        <para>//: c13:TextFields.java</para>
        <para>// Text fields and Java events.</para>
        <para>// &lt;applet code=TextFields width=375</para>
        <para>// height=125&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import javax.swing.event.*;</para>
        <para>import javax.swing.text.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class TextFields extends JApplet {</para>
        <para>� JButton</para>
        <para>��� b1 = new JButton(&quot;Get Text&quot;),</para>
        <para>��� b2 = new JButton(&quot;Set Text&quot;);</para>
        <para>� JTextField</para>
        <para>��� t1 = new JTextField(30),</para>
        <para>��� t2 = new JTextField(30),</para>
        <para>��� t3 = new JTextField(30);</para>
        <para>� String s = new String();</para>
        <para>� UpperCaseDocument</para>
        <para>��� ucd = new UpperCaseDocument();</para>
        <para>� public void init() {</para>
        <para>��� t1.setDocument(ucd);</para>
        <para>��� ucd.addDocumentListener(new T1());</para>
        <para>��� b1.addActionListener(new B1());</para>
        <para>��� b2.addActionListener(new B2());</para>
        <para>��� DocumentListener dl = new T1();</para>
        <para>��� t1.addActionListener(new T1A());</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(b1);</para>
        <para>��� cp.add(b2);</para>
        <para>��� cp.add(t1);</para>
        <para>��� cp.add(t2);</para>
        <para>��� cp.add(t3);</para>
        <para>� }</para>
        <para>� class T1 implements DocumentListener {</para>
        <para>��� public void changedUpdate(DocumentEvent e){}</para>
        <para>��� public void insertUpdate(DocumentEvent e){</para>
        <para>����� t2.setText(t1.getText());</para>
        <para>����� t3.setText(&quot;Text: &quot;+ t1.getText());</para>
        <para>��� }</para>
        <para>��� public void removeUpdate(DocumentEvent e){</para>
        <para>����� t2.setText(t1.getText());</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class T1A implements ActionListener {</para>
        <para>��� private int count = 0;</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� t3.setText(&quot;t1 Action Event &quot; + count++);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class B1 implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� if(t1.getSelectedText() == null)</para>
        <para>������� s = t1.getText();</para>
        <para>����� else</para>
        <para>������� s = t1.getSelectedText();</para>
        <para>����� t1.setEditable(true);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class B2 implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� ucd.setUpperCase(false);</para>
        <para>����� t1.setText(&quot;Inserted by Button 2: &quot; + s);</para>
        <para>����� ucd.setUpperCase(true);</para>
        <para>����� t1.setEditable(false);</para>
        <para>�� �}</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new TextFields(), 375, 125);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class UpperCaseDocument extends PlainDocument {</para>
        <para>� boolean upperCase = true;</para>
        <para>� public void setUpperCase(boolean flag) {</para>
        <para>��� upperCase = flag;</para>
        <para>� }</para>
        <para>� public void insertString(int offset, </para>
        <para>��� String string, AttributeSet attributeSet)</para>
        <para>��� throws BadLocationException {</para>
        <para>����� if(upperCase)</para>
        <para>������� string = string.toUpperCase();</para>
        <para>����� super.insertString(offset, </para>
        <para>������� string, attributeSet);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">JTextField</emphasis><emphasis role="bold"> t3</emphasis> is included as a place to report when the action listener for the<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis><emphasis role="bold">t1</emphasis> is fired. You�ll see that the action listener for a<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis> is fired only when you press the �enter� key.</para>
        <para>The<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field t1</emphasis> has several listeners attached to it. The <emphasis role="bold">T1</emphasis> listener is a <emphasis role="bold">DocumentListener </emphasis>that responds to any change in the �document� (the contents of the <emphasis role="bold">JTextField</emphasis>, in this case).<emphasis role="bold"/>It automatically copies all text from <emphasis role="bold">t1</emphasis> into <emphasis role="bold">t2</emphasis>. In addition, <emphasis role="bold">t1</emphasis>�s document is set to a derived class of <emphasis role="bold">PlainDocument</emphasis>, called <emphasis role="bold">UpperCaseDocument</emphasis>, which forces all characters to uppercase. It automatically detects backspaces and performs the deletion, adjusting the caret and handling everything as you would expect.</para>
      </section>
      <section>
        <title><anchor xreflabel="Borders" xml:id="_Toc481064811"/>Borders</title>
        <para><emphasis role="bold">JComponent</emphasis> contains a method called <emphasis role="bold">setBorder( )</emphasis>, which allows you to place various interesting borders on any visible component. The following example demonstrates a number of the different borders that are available, using a method called <emphasis role="bold">showBorder( )</emphasis> that creates a <emphasis role="bold">JPanel</emphasis> and puts on the border in each case. Also, it uses RTTI to find the name of the border that you�re using (stripping off all the path information), then puts that name in a <emphasis role="bold">JLabel</emphasis> in the middle of the panel:</para>
        <para>//: c13:Borders.java</para>
        <para>// Different Swing borders.</para>
        <para>// &lt;applet code=Borders</para>
        <para>//� width=500 height=300&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import javax.swing.border.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Borders extends JApplet {</para>
        <para>� static JPanel showBorder(Border b) {</para>
        <para>��� JPanel jp = new JPanel();</para>
        <para>��� jp.setLayout(new BorderLayout());</para>
        <para>��� String nm = b.getClass().toString();</para>
        <para>��� nm = nm.substring(nm.lastIndexOf(&apos;.&apos;) + 1);</para>
        <para>��� jp.add(new JLabel(nm, JLabel.CENTER), </para>
        <para>����� BorderLayout.CENTER);</para>
        <para>��� jp.setBorder(b);</para>
        <para>��� return jp;</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.setLayout(new GridLayout(2,4));</para>
        <para>��� cp.add(showBorder(new TitledBorder(&quot;Title&quot;)));</para>
        <para>��� cp.add(showBorder(new EtchedBorder()));</para>
        <para>��� cp.add(showBorder(new LineBorder(Color.blue)));</para>
        <para>��� cp.add(showBorder(</para>
        <para>����� new MatteBorder(5,5,30,30,Color.green)));</para>
        <para>��� cp.add(showBorder(</para>
        <para>����� new BevelBorder(BevelBorder.RAISED)));</para>
        <para>��� cp.add(showBorder(</para>
        <para>����� new SoftBevelBorder(BevelBorder.LOWERED)));</para>
        <para>��� cp.add(showBorder(new CompoundBorder(</para>
        <para>����� new EtchedBorder(),</para>
        <para>����� new LineBorder(Color.red))));</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Borders(), 500, 300);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can also create your own borders and put them inside buttons, labels, etc.�anything derived from <emphasis role="bold">JComponent</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="JScrollPanes" xml:id="_Toc481064812"/>JScrollPanes</title>
        <para>Most of the time you�ll just want to let a <emphasis role="bold">JScrollPane</emphasis> do it�s job, but you can also control which scroll bars are allowed�vertical, horizontal, both, or neither:</para>
        <para>//: c13:JScrollPanes.java</para>
        <para>// Controlling the scrollbars in a JScrollPane.</para>
        <para>// &lt;applet code=JScrollPanes width=300 height=725&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import javax.swing.border.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class JScrollPanes extends JApplet {</para>
        <para>� JButton </para>
        <para>��� b1 = new JButton(&quot;Text Area 1&quot;),</para>
        <para>��� b2 = new JButton(&quot;Text Area 2&quot;),</para>
        <para>��� b3 = new JButton(&quot;Replace Text&quot;),</para>
        <para>��� b4 = new JButton(&quot;Insert Text&quot;);</para>
        <para>� JTextArea </para>
        <para>��� t1 = new JTextArea(&quot;t1&quot;, 1, 20),</para>
        <para>��� t2 = new JTextArea(&quot;t2&quot;, 4, 20),</para>
        <para>��� t3 = new JTextArea(&quot;t3&quot;, 1, 20),</para>
        <para>��� t4 = new JTextArea(&quot;t4&quot;, 10, 10),</para>
        <para>��� t5 = new JTextArea(&quot;t5&quot;, 4, 20),</para>
        <para>��� t6 = new JTextArea(&quot;t6&quot;, 10, 10);</para>
        <para>� JScrollPane </para>
        <para>��� sp3 = new JScrollPane(t3,</para>
        <para>����� JScrollPane.VERTICAL_SCROLLBAR_NEVER,</para>
        <para>����� JScrollPane.HORIZONTAL_SCROLLBAR_NEVER),</para>
        <para>��� sp4 = new JScrollPane(t4,</para>
        <para>����� JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,</para>
        <para>����� JScrollPane.HORIZONTAL_SCROLLBAR_NEVER),</para>
        <para>��� sp5 = new JScrollPane(t5,</para>
        <para>����� JScrollPane.VERTICAL_SCROLLBAR_NEVER,</para>
        <para>����� JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS),</para>
        <para>��� sp6 = new JScrollPane(t6,</para>
        <para>����� JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,</para>
        <para>����� JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);</para>
        <para>� class B1L implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� t5.append(t1.getText() + &quot;\n&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class B2L implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� t2.setText(&quot;Inserted by Button 2&quot;);</para>
        <para>����� t2.append(&quot;: &quot; + t1.getText());</para>
        <para>����� t5.append(t2.getText() + &quot;\n&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class B3L implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� String s = &quot; Replacement &quot;;</para>
        <para>����� t2.replaceRange(s, 3, 3 + s.length());</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class B4L implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� t2.insert(&quot; Inserted &quot;, 10);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� // Create Borders for components:</para>
        <para>��� Border brd = BorderFactory.createMatteBorder(</para>
        <para>����� 1, 1, 1, 1, Color.black);</para>
        <para>��� t1.setBorder(brd);</para>
        <para>��� t2.setBorder(brd);</para>
        <para>��� sp3.setBorder(brd);</para>
        <para>��� sp4.setBorder(brd);</para>
        <para>��� sp5.setBorder(brd);</para>
        <para>��� sp6.setBorder(brd);</para>
        <para>��� // Initialize listeners and add components:</para>
        <para>��� b1.addActionListener(new B1L());</para>
        <para>��� cp.add(b1);</para>
        <para>��� cp.add(t1);</para>
        <para>��� b2.addActionListener(new B2L());</para>
        <para>��� cp.add(b2);</para>
        <para>��� cp.add(t2);</para>
        <para>��� b3.addActionListener(new B3L());</para>
        <para>��� cp.add(b3);</para>
        <para>��� b4.addActionListener(new B4L());</para>
        <para>��� cp.add(b4);</para>
        <para>��� cp.add(sp3); </para>
        <para>��� cp.add(sp4); </para>
        <para>��� cp.add(sp5);</para>
        <para>��� cp.add(sp6);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new JScrollPanes(), 300, 725);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Using different arguments in the <emphasis role="bold">JScrollPane</emphasis> constructor controls the scrollbars that are available. This example also dresses things up a bit using borders.</para>
      </section>
      <section>
        <title><anchor xreflabel="A mini-editor" xml:id="_Toc481064813"/>A mini-editor</title>
        <para>The <emphasis role="bold">JTextPane</emphasis> control provides a great deal of support for editing, without much effort. The following example makes very simple use of this, ignoring the bulk of the functionality of the class:</para>
        <para>//: c13:TextPane.java</para>
        <para>// The JTextPane control is a little editor.</para>
        <para>// &lt;applet code=TextPane width=475 height=425&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para>import com.bruceeckel.util.*;</para>
        <para> </para>
        <para>public class TextPane extends JApplet {</para>
        <para>� JButton b = new JButton(&quot;Add Text&quot;);</para>
        <para>� JTextPane tp = new JTextPane();</para>
        <para>� static Generator sg = </para>
        <para>��� new Arrays2.RandStringGenerator(7);� </para>
        <para>��public void init() {</para>
        <para>��� b.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� for(int i = 1; i &lt; 10; i++)</para>
        <para>��������� tp.setText(tp.getText() + </para>
        <para>����������� sg.next() + &quot;\n&quot;);</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(new JScrollPane(tp));</para>
        <para>��� cp.add(BorderLayout.SOUTH, b);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new TextPane(), 475, 425);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The button just adds randomly generated text. The intent of the <emphasis role="bold">JTextPane</emphasis> is to allow text to be edited in place, so you will see that there is no <emphasis role="bold">append( )</emphasis> method. In this case (admittedly, a poor use of the capabilities of <emphasis role="bold">JTextPane</emphasis>), the text must be captured, modified, and placed back into the pane using <emphasis role="bold">setText( )</emphasis>.</para>
        <para>As mentioned before, the default layout behavior of an applet is to use the <emphasis role="bold">BorderLayout</emphasis>. If you add something to the pane without specifying any details, it just fills the center of the pane out to the edges. However, if you specify one of the surrounding regions (NORTH, SOUTH, EAST, or WEST) as is done here, the component will fit itself into that region�in this case, the button will nest down at the bottom of the screen.</para>
        <para>Notice the built-in features of <emphasis role="bold">JTextPane</emphasis>, such as automatic line wrapping. There are lots of other features that you can look up using the JDK documentation.</para>
      </section>
      <section>
        <title><anchor xreflabel="Check boxes" xml:id="_Toc481064814"/>Check boxes</title>
        <para>A check box provides a way to make a single on/off choice; it consists of a tiny box and a label. The box typically holds a little �x� (or some other indication that it is set) or is empty, depending on whether that item was selected.</para>
        <para>You�ll normally create a <emphasis role="bold">JCheckBox</emphasis> using a constructor that takes the label as an argument. You can get and set the state, and also get and set the label if you want to read or change it after the <emphasis role="bold">JCheckBox</emphasis> has been created.</para>
        <para>Whenever a <emphasis role="bold">JCheckBox</emphasis> is set or cleared, an event occurs, which you can capture the same way you do a button, by using an <emphasis role="bold">ActionListener</emphasis>. The following example uses a<emphasis role="bold"> JText</emphasis><emphasis role="bold">Area</emphasis> to enumerate all the check boxes that have been checked:</para>
        <para>//: c13:CheckBoxes.java</para>
        <para>// Using JCheckBoxes.</para>
        <para>// &lt;applet code=CheckBoxes width=200 height=200&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class CheckBoxes extends JApplet {</para>
        <para>� JTextArea t = new JTextArea(6, 15);</para>
        <para>� JCheckBox </para>
        <para>��� cb1 = new JCheckBox(&quot;Check Box 1&quot;),</para>
        <para>��� cb2 = new JCheckBox(&quot;Check Box 2&quot;),</para>
        <para>��� cb3 = new JCheckBox(&quot;Check Box 3&quot;);</para>
        <para>� public void init() {</para>
        <para>��� cb1.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� trace(&quot;1&quot;, cb1);</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� cb2.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� trace(&quot;2&quot;, cb2);</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� cb3.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� trace(&quot;3&quot;, cb3);</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(new JScrollPane(t));</para>
        <para>��� cp.add(cb1); </para>
        <para>��� cp.add(cb2); </para>
        <para>��� cp.add(cb3);</para>
        <para>� }</para>
        <para>� void trace(String b, JCheckBox cb) {</para>
        <para>��� if(cb.isSelected())</para>
        <para>����� t.append(&quot;Box &quot; + b + &quot; Set\n&quot;);</para>
        <para>��� else</para>
        <para>����� t.append(&quot;Box &quot; + b + &quot; Cleared\n&quot;);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new CheckBoxes(), 200, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">trace( )</emphasis> method sends the name of the selected <emphasis role="bold">JCheckBox</emphasis> and its current state to the<emphasis role="bold"> JText</emphasis><emphasis role="bold">Area</emphasis> using <emphasis role="bold">append( )</emphasis>, so you�ll see a cumulative list of the checkboxes that were selected and what their state is.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064815"/><anchor xreflabel="Radio
buttons" xml:id="_Toc375545453"/>Radio buttons</title>
        <para>The concept of a radio button in GUI programming comes from pre-electronic car radios with mechanical buttons: when you push one in, any other button that was pressed pops out. Thus, it allows you to force a single choice among many.</para>
        <para>All you need to do to set up an associated group of <emphasis role="bold">JRadioButton</emphasis>s is to add them to a <emphasis role="bold">ButtonGroup</emphasis> (you can have any number of <emphasis role="bold">ButtonGroup</emphasis>s on a form). One of the buttons can optionally have its starting state set to <emphasis role="bold">true</emphasis> (using the second argument in the constructor). If you try to set more than one radio button to <emphasis role="bold">true</emphasis> then only the final one set will be <emphasis role="bold">true</emphasis>.</para>
        <para>Here�s a simple example of the use of radio buttons. Note that you capture radio button events like all others:</para>
        <para>//: c13:RadioButtons.java</para>
        <para>// Using JRadioButtons.</para>
        <para>// &lt;applet code=RadioButtons </para>
        <para>// width=200 height=100&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class RadioButtons extends JApplet {</para>
        <para>� JTextField t = new JTextField(15);</para>
        <para>� ButtonGroup g = new ButtonGroup();</para>
        <para>� JRadioButton </para>
        <para>��� rb1 = new JRadioButton(&quot;one&quot;, false),</para>
        <para>��� rb2 = new JRadioButton(&quot;two&quot;, false),</para>
        <para>��� rb3 = new JRadioButton(&quot;three&quot;, false);</para>
        <para>� ActionListener al = new ActionListener() {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� t.setText(&quot;Radio button &quot; + </para>
        <para>������� ((JRadioButton)e.getSource()).getText());</para>
        <para>��� }</para>
        <para>� };</para>
        <para>� public void init() {</para>
        <para>��� rb1.addActionListener(al);</para>
        <para>��� rb2.addActionListener(al);</para>
        <para>��� rb3.addActionListener(al);</para>
        <para>��� g.add(rb1); g.add(rb2); g.add(rb3);</para>
        <para>��� t.setEditable(false);</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(t); </para>
        <para>��� cp.add(rb1); </para>
        <para>��� cp.add(rb2); </para>
        <para>��� cp.add(rb3); </para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new RadioButtons(), 200, 100);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>To display the state, a text field is used. This field is set to noneditable because it�s used only to display data, not to collect it. Thus it is an alternative to using a <emphasis role="bold">J</emphasis><emphasis role="bold">Label</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064816"/><anchor xreflabel="" xml:id="_Toc375545454"/><anchor xreflabel="" xml:id="AAAIndexingCurrentPoint"/>Combo boxes (drop-down lists)</title>
        <para>Like a group of radio buttons, a drop-down list is a way to force the user to select only one element from a group of possibilities. However, it�s a more compact way to accomplish this, and it�s easier to change the elements of the list without surprising the user. (You can change radio buttons dynamically, but that tends to be visibly jarring).</para>
        <para>Java�s <emphasis role="bold">JComboBox</emphasis> box is not like the combo box in Windows, which lets you select from a list <emphasis role="italic">or</emphasis> type in your own selection. With a <emphasis role="bold">JComboBox</emphasis> box you choose one and only one element from the list. In the following example, the <emphasis role="bold">JComboBox</emphasis> box starts with a certain number of entries and then new entries are added to the box when a button is pressed.</para>
        <para>//: c13:ComboBoxes.java</para>
        <para>// Using drop-down lists.</para>
        <para>// &lt;applet code=ComboBoxes</para>
        <para>// width=200 height=100&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class ComboBoxes extends JApplet {</para>
        <para>� String[] description = { &quot;Ebullient&quot;, &quot;Obtuse&quot;,</para>
        <para>��� &quot;Recalcitrant&quot;, &quot;Brilliant&quot;, &quot;Somnescent&quot;,</para>
        <para>��� &quot;Timorous&quot;, &quot;Florid&quot;, &quot;Putrescent&quot; };</para>
        <para>� JTextField t = new JTextField(15);</para>
        <para>� JComboBox c = new JComboBox();</para>
        <para>� JButton b = new JButton(&quot;Add items&quot;);</para>
        <para>� int count = 0;</para>
        <para>� public void init() {</para>
        <para>��� for(int i = 0; i &lt; 4; i++)</para>
        <para>����� c.addItem(description[count++]);</para>
        <para>��� t.setEditable(false);</para>
        <para>��� b.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� if(count &lt; description.length)</para>
        <para>��������� c.addItem(description[count++]);</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� c.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� t.setText(&quot;index: &quot;+ c.getSelectedIndex()</para>
        <para>��������� + &quot;�� &quot; + ((JComboBox)e.getSource())</para>
        <para>��������� .getSelectedItem());</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(t);</para>
        <para>��� cp.add(c);</para>
        <para>��� cp.add(b);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new ComboBoxes(), 200, 100);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis> displays the �selected index,� which is the sequence number of the currently selected element, as well as the label on the radio button.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064817"/><anchor xreflabel="List
boxes" xml:id="_Toc375545455"/>List boxes</title>
        <para>List boxes are significantly different from <emphasis role="bold">JComboBox</emphasis> boxes, and not just in appearance. While a <emphasis role="bold">JComboBox</emphasis> box drops down when you activate it, a <emphasis role="bold">JList</emphasis> occupies some fixed number of lines on a screen all the time and doesn�t change. If you want to see the items in a list, you simply call <emphasis role="bold">getSelectedValues( ), </emphasis>which produces an array of <emphasis role="bold">String</emphasis> of the items that have been selected.</para>
        <para>A <emphasis role="bold">JList</emphasis> allows multiple selection: if you control-click on more than one item (holding down the �control� key while performing additional mouse clicks) the original item stays highlighted and you can select as many as you want. If you select an item, then shift-click on another item, all the items in the span between the two are selected. To remove an item from a group you can control-click it.</para>
        <para>//: c13:List.java</para>
        <para>// &lt;applet code=List width=250</para>
        <para>// height=375&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import javax.swing.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import javax.swing.border.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class List extends JApplet {</para>
        <para>� String[] flavors = { &quot;Chocolate&quot;, &quot;Strawberry&quot;,</para>
        <para>��� &quot;Vanilla Fudge Swirl&quot;, &quot;Mint Chip&quot;,</para>
        <para>��� &quot;Mocha Almond Fudge&quot;, &quot;Rum Raisin&quot;,</para>
        <para>��� &quot;Praline Cream&quot;, &quot;Mud Pie&quot; };</para>
        <para>� DefaultListModel lItems=new DefaultListModel();</para>
        <para>� JList lst = new JList(lItems);</para>
        <para>� JTextArea t = new JTextArea(flavors.length,20);</para>
        <para>� JButton b = new JButton(&quot;Add Item&quot;);</para>
        <para>� ActionListener bl = new ActionListener() {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� if(count &lt; flavors.length) {</para>
        <para>������� lItems.add(0, flavors[count++]);</para>
        <para>����� } else {</para>
        <para>������� // Disable, since there are no more</para>
        <para>������� // flavors left to be added to the List</para>
        <para>������� b.setEnabled(false);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� };</para>
        <para>� ListSelectionListener ll =</para>
        <para>��� new ListSelectionListener() {</para>
        <para>����� public void valueChanged(</para>
        <para>������� ListSelectionEvent e) {</para>
        <para>��������� t.setText(&quot;&quot;);</para>
        <para>��������� Object[] items=lst.getSelectedValues();</para>
        <para>��������� for(int i = 0; i &lt; items.length; i++)</para>
        <para>����������� t.append(items[i] + &quot;\n&quot;);</para>
        <para>������� }</para>
        <para>��� };</para>
        <para>� int count = 0;</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� t.setEditable(false);</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� // Create Borders for components:</para>
        <para>��� Border brd = BorderFactory.createMatteBorder(</para>
        <para>����� 1, 1, 2, 2, Color.black);</para>
        <para>��� lst.setBorder(brd);</para>
        <para>��� t.setBorder(brd);</para>
        <para>��� // Add the first four items to the List</para>
        <para>��� for(int i = 0; i &lt; 4; i++)</para>
        <para>����� lItems.addElement(flavors[count++]);</para>
        <para>��� // Add items to the Content Pane for Display</para>
        <para>��� cp.add(t);</para>
        <para>��� cp.add(lst);</para>
        <para>��� cp.add(b);</para>
        <para>��� // Register event listeners</para>
        <para>��� lst.addListSelectionListener(ll);</para>
        <para>��� b.addActionListener(bl);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new List(), 250, 375);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>When you press the button it adds items to the <emphasis role="italic">top</emphasis> of the list (because <emphasis role="bold">addItem( )</emphasis>�s<emphasis role="bold"/>second argument is 0). </para>
        <para>You can see that borders have also been added to the lists.</para>
        <para>If you just want to put an array of <emphasis role="bold">String</emphasis>s into a <emphasis role="bold">JList</emphasis>, there�s a much simpler solution: you pass the array to the <emphasis role="bold">JList </emphasis>constructor, and it builds the list automatically. The only reason for using the �list model� in the above example is so that the list could be manipulated during the execution of the program.</para>
        <para><emphasis role="bold">JList</emphasis>s do not automatically provide direct support for scrolling. Of course, all you need to do is wrap the <emphasis role="bold">JList</emphasis> in a <emphasis role="bold">JScrollPane</emphasis> and all the details are automatically managed for you.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545457"/><anchor xreflabel="Tabbed
panes" xml:id="_Toc481064818"/>Tabbed panes</title>
        <para>The <emphasis role="bold">JTabbedPane</emphasis> allows you to create a �tabbed dialog,� which has file-folder tabs running across one edge, and all you have to do is press a tab to bring forward a different dialog.</para>
        <para>//: c13:TabbedPane1.java</para>
        <para>// Demonstrates the Tabbed Pane.</para>
        <para>// &lt;applet code=TabbedPane1 </para>
        <para>// width=350 height=200&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import javax.swing.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class TabbedPane1 extends JApplet {</para>
        <para>� String[] flavors = { &quot;Chocolate&quot;, &quot;Strawberry&quot;,</para>
        <para>� ��&quot;Vanilla Fudge Swirl&quot;, &quot;Mint Chip&quot;, </para>
        <para>��� &quot;Mocha Almond Fudge&quot;, &quot;Rum Raisin&quot;, </para>
        <para>��� &quot;Praline Cream&quot;, &quot;Mud Pie&quot; };</para>
        <para>� JTabbedPane tabs = new JTabbedPane();</para>
        <para>� JTextField txt = new JTextField(20);</para>
        <para>� public void init() {</para>
        <para>��� for(int i = 0; i &lt; flavors.length; i++)</para>
        <para>����� tabs.addTab(flavors[i], </para>
        <para>������� new JButton(&quot;Tabbed pane &quot; + i));</para>
        <para>��� tabs.addChangeListener(new ChangeListener(){</para>
        <para>����� public void stateChanged(ChangeEvent e) {</para>
        <para>������� txt.setText(&quot;Tab selected: &quot; + </para>
        <para>��������� tabs.getSelectedIndex());</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(BorderLayout.SOUTH, txt);</para>
        <para>��� cp.add(tabs);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new TabbedPane1(), 350, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In Java, the use of some sort of �tabbed panel� mechanism is quite important because in applet programming the use of pop-up dialogs is discouraged by automatically adding a little warning to any dialog that pops up out of an applet. </para>
        <para>When you run the program you�ll see that the <emphasis role="bold">JTabbedPane</emphasis> automatically stacks the tabs if there are too many of them to fit on one row. You can see this by resizing the window when you run the program from the console command line.</para>
      </section>
      <section>
        <title><anchor xreflabel="Message boxes" xml:id="_Toc481064819"/>Message boxes</title>
        <para>Windowing environments commonly contain a standard set of message boxes that allow you to quickly post information to the user or to capture information from the user. In Swing, these message boxes are contained in <emphasis role="bold">JOptionPane</emphasis>. You have many different possibilities (some quite sophisticated), but the ones you�ll most commonly use are probably the message dialog and confirmation dialog, invoked using the <emphasis role="bold">static</emphasis><emphasis role="bold">JOptionPane.showMessageDialog( )</emphasis> and <emphasis role="bold">JOptionPane. showConfirmDialog( )</emphasis>. The following example shows a subset of the message boxes available with <emphasis role="bold">JOptionPane</emphasis>:</para>
        <para>//: c13:MessageBoxes.java</para>
        <para>// Demonstrates JoptionPane.</para>
        <para>// &lt;applet code=MessageBoxes </para>
        <para>// width=200 height=150&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class MessageBoxes extends JApplet {</para>
        <para>� JButton[] b = { new JButton(&quot;Alert&quot;), </para>
        <para>��� new JButton(&quot;Yes/No&quot;), new JButton(&quot;Color&quot;),</para>
        <para>��� new JButton(&quot;Input&quot;), new JButton(&quot;3 Vals&quot;)</para>
        <para>� };</para>
        <para>� JTextField txt = new JTextField(15);</para>
        <para>� ActionListener al = new ActionListener() {</para>
        <para>��� public void actionPerformed(ActionEvent e){</para>
        <para>����� String id = </para>
        <para>������� ((JButton)e.getSource()).getText();</para>
        <para>����� if(id.equals(&quot;Alert&quot;))</para>
        <para>������� JOptionPane.showMessageDialog(null, </para>
        <para>��������� &quot;There&apos;s a bug on you!&quot;, &quot;Hey!&quot;, </para>
        <para>��������� JOptionPane.ERROR_MESSAGE);</para>
        <para>����� else if(id.equals(&quot;Yes/No&quot;))</para>
        <para>������� JOptionPane.showConfirmDialog(null, </para>
        <para>��������� &quot;or no&quot;, &quot;choose yes&quot;, </para>
        <para>��������� JOptionPane.YES_NO_OPTION);</para>
        <para>����� else if(id.equals(&quot;Color&quot;)) {</para>
        <para>������� Object[] options = { &quot;Red&quot;, &quot;Green&quot; };</para>
        <para>� ������int sel = JOptionPane.showOptionDialog(</para>
        <para>��������� null, &quot;Choose a Color!&quot;, &quot;Warning&quot;, </para>
        <para>��������� JOptionPane.DEFAULT_OPTION, </para>
        <para>��������� JOptionPane.WARNING_MESSAGE, null, </para>
        <para>��������� options, options[0]);</para>
        <para>��������� if(sel != JOptionPane.CLOSED_OPTION)</para>
        <para>����������� txt.setText(</para>
        <para>������������� &quot;Color Selected: &quot; + options[sel]);</para>
        <para>����� } else if(id.equals(&quot;Input&quot;)) {</para>
        <para>������� String val = JOptionPane.showInputDialog(</para>
        <para>����������� &quot;How many fingers do you see?&quot;); </para>
        <para>������� txt.setText(val);</para>
        <para>����� } else if(id.equals(&quot;3 Vals&quot;)) {</para>
        <para>������� Object[] selections = {</para>
        <para>��������� &quot;First&quot;, &quot;Second&quot;, &quot;Third&quot; };</para>
        <para>������� Object val = JOptionPane.showInputDialog(</para>
        <para>��������� null, &quot;Choose one&quot;, &quot;Input&quot;,</para>
        <para>��������� JOptionPane.INFORMATION_MESSAGE, </para>
        <para>��������� null, selections, selections[0]);</para>
        <para>������� if(val != null)</para>
        <para>��������� txt.setText(</para>
        <para>����������� val.toString());</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� };</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� for(int i = 0; i &lt; b.length; i++) {</para>
        <para>����� b[i].addActionListener(al);</para>
        <para>����� cp.add(b[i]);</para>
        <para>��� }</para>
        <para>��� cp.add(txt);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new MessageBoxes(), 200, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>To be able to write a single <emphasis role="bold">ActionListener</emphasis>, I�ve used the somewhat risky approach of checking the <emphasis role="bold">String</emphasis> labels on the buttons. The problem with this is that it�s easy to get the label a little bit wrong, typically in capitalization, and this bug can be hard to spot.</para>
        <para>Note that <emphasis role="bold">showOptionDialog( )</emphasis> and <emphasis role="bold">showInputDialog( )</emphasis> provide return objects that contain the value entered by the user.</para>
      </section>
      <section>
        <title><anchor xreflabel="Menus" xml:id="_Toc481064820"/>Menus</title>
        <para>Each component capable of holding a menu, including <emphasis role="bold">JApplet</emphasis>, <emphasis role="bold">JFrame</emphasis>, <emphasis role="bold">JDialog</emphasis>, and their descendants, has a <emphasis role="bold">setJMenuBar( ) </emphasis>method that accepts a <emphasis role="bold">J</emphasis><emphasis role="bold">MenuBar</emphasis> (you can have only one <emphasis role="bold">JMenuBar</emphasis> on a particular component). You add <emphasis role="bold">JMenu</emphasis>s to the <emphasis role="bold">JMenuBar</emphasis>, and <emphasis role="bold">JMenuItem</emphasis>s to the <emphasis role="bold">JMenu</emphasis>s. Each <emphasis role="bold">JMenuItem</emphasis> can have an <emphasis role="bold">ActionListener</emphasis> attached to it, to be fired when that menu item is selected.</para>
        <para>Unlike a system that uses resources, with Java and Swing you must hand assemble all the menus in source code. Here is a very simple menu example:</para>
        <para>//: c13:SimpleMenus.java</para>
        <para>// &lt;applet code=SimpleMenus </para>
        <para>// width=200 height=75&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class SimpleMenus extends JApplet {</para>
        <para>� JTextField t = new JTextField(15);</para>
        <para>� ActionListener al = new ActionListener() {</para>
        <para>��� public void actionPerformed(ActionEvent e){</para>
        <para>����� t.setText(</para>
        <para>������� ((JMenuItem)e.getSource()).getText());</para>
        <para>��� }</para>
        <para>� };</para>
        <para>� JMenu[] menus = { new JMenu(&quot;Winken&quot;), </para>
        <para>��� new JMenu(&quot;Blinken&quot;), new JMenu(&quot;Nod&quot;) };</para>
        <para>� JMenuItem[] items = {</para>
        <para>��� new JMenuItem(&quot;Fee&quot;), new JMenuItem(&quot;Fi&quot;),</para>
        <para>��� new JMenuItem(&quot;Fo&quot;),� new JMenuItem(&quot;Zip&quot;),</para>
        <para>��� new JMenuItem(&quot;Zap&quot;), new JMenuItem(&quot;Zot&quot;), </para>
        <para>��� new JMenuItem(&quot;Olly&quot;), new JMenuItem(&quot;Oxen&quot;),</para>
        <para>��� new JMenuItem(&quot;Free&quot;) };</para>
        <para>� public void init() {</para>
        <para>��� for(int i = 0; i &lt; items.length; i++) {</para>
        <para>����� items[i].addActionListener(al);</para>
        <para>����� menus[i%3].add(items[i]);</para>
        <para>��� }</para>
        <para>��� JMenuBar mb = new JMenuBar();</para>
        <para>��� for(int i = 0; i &lt; menus.length; i++)</para>
        <para>����� mb.add(menus[i]);</para>
        <para>��� setJMenuBar(mb);</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(t); </para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new SimpleMenus(), 200, 75);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The use of the modulus operator in �<emphasis role="bold">i%3</emphasis>� distributes the menu items among the three <emphasis role="bold">JMenu</emphasis>s. Each <emphasis role="bold">JMenuItem</emphasis> must have an <emphasis role="bold">ActionListener</emphasis> attached to it; here, the same <emphasis role="bold">ActionListener</emphasis> is used everywhere but you�ll usually need an individual one for each <emphasis role="bold">JMenuItem</emphasis>.</para>
        <para><emphasis role="bold">JMenuItem </emphasis>inherits <emphasis role="bold">AbstractButton</emphasis>, so it has some buttonlike behaviors. By itself, it provides an item that can be placed on a drop-down menu. There are also three types inherited from <emphasis role="bold">JMenuItem</emphasis>: <emphasis role="bold">J</emphasis><emphasis role="bold">Menu</emphasis> to hold other <emphasis role="bold">JMenuItem</emphasis>s (so you can have cascading menus),� <emphasis role="bold">JCheckBox</emphasis><emphasis role="bold">MenuItem</emphasis>, which produces a checkmark to indicate whether that menu item is selected, and <emphasis role="bold">JRadioButtonMenuItem</emphasis>, which contains a radio button.</para>
        <para>As a more sophisticated example, here are the ice cream flavors again, used to create menus. This example also shows cascading menus, keyboard mnemonics,  <emphasis role="bold">JCheckBox</emphasis><emphasis role="bold">MenuItem</emphasis>s, and the way you can dynamically change menus:</para>
        <para>//: c13:Menus.java</para>
        <para>// Submenus, checkbox menu items, swapping menus,</para>
        <para>// mnemonics (shortcuts) and action commands.</para>
        <para>// &lt;applet code=Menus width=300</para>
        <para>// height=100&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Menus extends JApplet {</para>
        <para>� String[] flavors = { &quot;Chocolate&quot;, &quot;Strawberry&quot;,</para>
        <para>��� &quot;Vanilla Fudge Swirl&quot;, &quot;Mint Chip&quot;, </para>
        <para>��� &quot;Mocha Almond Fudge&quot;, &quot;Rum Raisin&quot;, </para>
        <para>��� &quot;Praline Cream&quot;, &quot;Mud Pie&quot; };</para>
        <para>� JTextField t = new JTextField(&quot;No flavor&quot;, 30);</para>
        <para>� JMenuBar mb1 = new JMenuBar();</para>
        <para>� JMenu </para>
        <para>��� f = new JMenu(&quot;File&quot;),</para>
        <para>��� m = new JMenu(&quot;Flavors&quot;),</para>
        <para>��� s = new JMenu(&quot;Safety&quot;);</para>
        <para>� // Alternative approach:</para>
        <para>� JCheckBoxMenuItem[] safety = {</para>
        <para>��� new JCheckBoxMenuItem(&quot;Guard&quot;),</para>
        <para>��� new JCheckBoxMenuItem(&quot;Hide&quot;)</para>
        <para>� };</para>
        <para>� JMenuItem[] file = {</para>
        <para>��� new JMenuItem(&quot;Open&quot;),</para>
        <para>� };</para>
        <para>� // A second menu bar to swap to:</para>
        <para>� JMenuBar mb2 = new JMenuBar();</para>
        <para>� JMenu fooBar = new JMenu(&quot;fooBar&quot;);</para>
        <para>� JMenuItem[] other = {</para>
        <para>��� // Adding a menu shortcut (mnemonic) is very </para>
        <para>��� // simple, but only JMenuItems can have them </para>
        <para>��� // in their constructors:</para>
        <para>��� new JMenuItem(&quot;Foo&quot;, KeyEvent.VK_F),</para>
        <para>��� new JMenuItem(&quot;Bar&quot;, KeyEvent.VK_A),</para>
        <para>��� // No shortcut:</para>
        <para>��� new JMenuItem(&quot;Baz&quot;),</para>
        <para>� };</para>
        <para>� JButton b = new JButton(&quot;Swap Menus&quot;);</para>
        <para>� class BL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� JMenuBar m = getJMenuBar();</para>
        <para>����� setJMenuBar(m == mb1 ? mb2 : mb1);</para>
        <para>����� validate(); // Refresh the frame</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class ML implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� JMenuItem target = (JMenuItem)e.getSource();</para>
        <para>����� String actionCommand = </para>
        <para>������� target.getActionCommand();</para>
        <para>����� if(actionCommand.equals(&quot;Open&quot;)) {</para>
        <para>������� String s = t.getText();</para>
        <para>������� boolean chosen = false;</para>
        <para>������� for(int i = 0; i &lt; flavors.length; i++)</para>
        <para>��������� if(s.equals(flavors[i])) chosen = true;</para>
        <para>������� if(!chosen)</para>
        <para>��������� t.setText(&quot;Choose a flavor first!&quot;);</para>
        <para>������� else</para>
        <para>���� �����t.setText(&quot;Opening &quot;+ s +&quot;. Mmm, mm!&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class FL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� JMenuItem target = (JMenuItem)e.getSource();</para>
        <para>����� t.setText(target.getText());</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� // Alternatively, you can create a different</para>
        <para>� // class for each different MenuItem. Then you</para>
        <para>� // Don&apos;t have to figure out which one it is:</para>
        <para>� class FooL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� t.setText(&quot;Foo selected&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class BarL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� t.setText(&quot;Bar selected&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class BazL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� t.setText(&quot;Baz selected&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class CMIL implements ItemListener {</para>
        <para>��� public void itemStateChanged(ItemEvent e) {</para>
        <para>����� JCheckBoxMenuItem target = </para>
        <para>������� (JCheckBoxMenuItem)e.getSource();</para>
        <para>����� String actionCommand = </para>
        <para>������� target.getActionCommand();</para>
        <para>����� if(actionCommand.equals(&quot;Guard&quot;))</para>
        <para>������� t.setText(&quot;Guard the Ice Cream! &quot; +</para>
        <para>��������� &quot;Guarding is &quot; + target.getState());</para>
        <para>����� else if(actionCommand.equals(&quot;Hide&quot;))</para>
        <para>������� t.setText(&quot;Hide the Ice Cream! &quot; +</para>
        <para>��������� &quot;Is it cold? &quot; + target.getState());</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� ML ml = new ML();</para>
        <para>��� CMIL cmil = new CMIL();</para>
        <para>��� safety[0].setActionCommand(&quot;Guard&quot;);</para>
        <para>��� safety[0].setMnemonic(KeyEvent.VK_G);</para>
        <para>��� safety[0].addItemListener(cmil);</para>
        <para>��� safety[1].setActionCommand(&quot;Hide&quot;);</para>
        <para>��� safety[0].setMnemonic(KeyEvent.VK_H);</para>
        <para>��� safety[1].addItemListener(cmil);</para>
        <para>��� other[0].addActionListener(new FooL());</para>
        <para>��� other[1].addActionListener(new BarL());</para>
        <para>��� other[2].addActionListener(new BazL());</para>
        <para>��� FL fl = new FL();</para>
        <para>��� for(int i = 0; i &lt; flavors.length; i++) {</para>
        <para>����� JMenuItem mi = new JMenuItem(flavors[i]);</para>
        <para>����� mi.addActionListener(fl);</para>
        <para>����� m.add(mi);</para>
        <para>����� // Add separators at intervals:</para>
        <para>����� if((i+1) % 3 == 0) </para>
        <para>������� m.addSeparator();</para>
        <para>��� }</para>
        <para>��� for(int i = 0; i &lt; safety.length; i++)</para>
        <para>����� s.add(safety[i]);</para>
        <para>��� s.setMnemonic(KeyEvent.VK_A);</para>
        <para>��� f.add(s);</para>
        <para>��� f.setMnemonic(KeyEvent.VK_F);</para>
        <para>��� for(int i = 0; i &lt; file.length; i++) {</para>
        <para>����� file[i].addActionListener(fl);</para>
        <para>����� f.add(file[i]);</para>
        <para>��� }</para>
        <para>��� mb1.add(f);</para>
        <para>��� mb1.add(m);</para>
        <para>��� setJMenuBar(mb1);</para>
        <para>��� t.setEditable(false);</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(t, BorderLayout.CENTER);</para>
        <para>��� // Set up the system for swapping menus:</para>
        <para>��� b.addActionListener(new BL());</para>
        <para>��� b.setMnemonic(KeyEvent.VK_S);</para>
        <para>��� cp.add(b, BorderLayout.NORTH);</para>
        <para>��� for(int i = 0; i &lt; other.length; i++)</para>
        <para>����� fooBar.add(other[i]);</para>
        <para>��� fooBar.setMnemonic(KeyEvent.VK_B);</para>
        <para>��� mb2.add(fooBar);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Menus(), 300, 100);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In this program I placed the menu items into arrays and then stepped through each array calling <emphasis role="bold">add( )</emphasis> for each <emphasis role="bold">JMenuItem</emphasis>. This makes adding or subtracting a menu item somewhat less tedious.</para>
        <para>This program creates not one but two<emphasis role="bold"> JMenuBar</emphasis>s to demonstrate that menu bars can be actively swapped while the program is running. You can see how a<emphasis role="bold"> JMenuBar</emphasis> is made up of <emphasis role="bold">JMenus</emphasis>, and each <emphasis role="bold">JMenu</emphasis> is made up of <emphasis role="bold">JMenuItems</emphasis>,<emphasis role="bold"> JCheckBox</emphasis><emphasis role="bold">MenuItem</emphasis>s, or even other <emphasis role="bold">JMenu</emphasis>s (which produce submenus). When a<emphasis role="bold"> JMenuBar</emphasis> is assembled it can be installed into the current program with the <emphasis role="bold">setJMenuBar( )</emphasis> method. Note that when the button is pressed, it checks to see which menu is currently installed by calling <emphasis role="bold">getJMenuBar( )</emphasis>, then it puts the other menu bar in its place.</para>
        <para>When testing for �Open,� notice that spelling and capitalization are critical, but Java signals no error if there is no match with �Open.� This kind of string comparison is a source of programming errors.</para>
        <para>The checking and unchecking of the menu items is taken care of automatically. The code handling the <emphasis role="bold">JCheckBoxMenuItem</emphasis>s shows two different ways to determine what was checked: string matching (which, as mentioned above, isn�t a very safe approach although you�ll see it used) and matching on the event target object. As shown, the <emphasis role="bold">getState( ) </emphasis>method can be used to reveal the state. You can also change the state of a <emphasis role="bold">JCheckBoxMenuItem</emphasis> with <emphasis role="bold">setState( )</emphasis>.</para>
        <para>The events for menus are a bit inconsistent and can lead to confusion: <emphasis role="bold">JMenuItem</emphasis>s use <emphasis role="bold">ActionListener</emphasis>s, but <emphasis role="bold">JCheckboxMenuItem</emphasis>s use <emphasis role="bold">ItemListener</emphasis>s. The <emphasis role="bold">JMenu</emphasis> objects can also support <emphasis role="bold">ActionListener</emphasis>s, but that�s not usually helpful. In general, you�ll attach listeners to each <emphasis role="bold">JMenuItem</emphasis>, <emphasis role="bold">JCheckBox</emphasis><emphasis role="bold">MenuItem</emphasis>, or <emphasis role="bold">JRadioButton</emphasis><emphasis role="bold">MenuItem</emphasis>, but the example shows <emphasis role="bold">ItemListener</emphasis>s and <emphasis role="bold">ActionListener</emphasis>s attached to the various menu components.</para>
        <para>Swing supports mnemonics, or �keyboard shortcuts,� so you can select anything derived from <emphasis role="bold">AbstractButton</emphasis> (button, menu item, etc.) using the keyboard instead of the mouse. These are quite simple: for <emphasis role="bold">JMenuItem</emphasis> you can use the overloaded constructor that takes as a second argument the identifier for the key. However, most <emphasis role="bold">AbstractButton</emphasis>s do not have constructors like this so the more general way to solve the problem is to use the <emphasis role="bold">setMnemonic( ) </emphasis>method. The example above adds mnemonics to the button and some of the menu items; shortcut indicators automatically appear on the components.</para>
        <para>You can also see the use of <emphasis role="bold">setActionCommand( )</emphasis>. This seems a bit strange because in each case the �action command� is exactly the same as the label on the menu component. Why not just use the label instead of this alternative string? The problem is internationalization. If you retarget this program to another language, you want to change only the label in the menu, and not change the code (which would no doubt introduce new errors). So to make this easy for code that checks the text string associated with a menu component, the �action command� can be immutable while the menu label can change. All the code works with the �action command,� so it�s unaffected by changes to the menu labels. Note that in this program, not all the menu components are examined for their action commands, so those that aren�t don�t have their action command set.</para>
        <para>The bulk of the work happens in the listeners. <emphasis role="bold">BL</emphasis> performs the <emphasis role="bold">JMenuBar</emphasis> swapping. In <emphasis role="bold">ML</emphasis>, the �figure out who rang� approach is taken by getting the source of the <emphasis role="bold">ActionEvent</emphasis> and casting it to a <emphasis role="bold">JMenuItem</emphasis>, then getting the action command string to pass it through a cascaded <emphasis role="bold">if</emphasis> statement.</para>
        <para>The <emphasis role="bold">FL</emphasis> listener is simple even though it�s handling all the different flavors in the flavor menu. This approach is useful if you have enough simplicity in your logic, but in general, you�ll want to take the approach used with <emphasis role="bold">FooL</emphasis>, <emphasis role="bold">BarL,</emphasis> and <emphasis role="bold">BazL</emphasis>, in which they are each attached to only a single menu component so no extra detection logic is necessary and you know exactly who called the listener. Even with the profusion of classes generated this way, the code inside tends to be smaller and the process is more foolproof.</para>
        <para>You can see that menu code quickly gets long-winded and messy. This is another case where the use of a GUI builder is the appropriate solution. A good tool will also handle the maintenance of the menus.</para>
      </section>
      <section>
        <title><anchor xreflabel="Pop-up menus" xml:id="_Toc481064821"/>Pop-up menus</title>
        <para>The most straightforward way to implement a <emphasis role="bold">JPopupMenu</emphasis> is to create an inner class that extends <emphasis role="bold">MouseAdapter</emphasis>, then add an object of that inner class to each component that you want to produce pop-up behavior:</para>
        <para>//: c13:Popup.java</para>
        <para>// Creating popup menus with Swing.</para>
        <para>// &lt;applet code=Popup</para>
        <para>//� width=300 height=200&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Popup extends JApplet {</para>
        <para>� JPopupMenu popup = new JPopupMenu();</para>
        <para>� JTextField t = new JTextField(10);</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(t);</para>
        <para>��� ActionListener al = new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� t.setText(</para>
        <para>� ��������((JMenuItem)e.getSource()).getText());</para>
        <para>����� }</para>
        <para>��� };</para>
        <para>��� JMenuItem m = new JMenuItem(&quot;Hither&quot;);</para>
        <para>��� m.addActionListener(al);</para>
        <para>��� popup.add(m);</para>
        <para>��� m = new JMenuItem(&quot;Yon&quot;);</para>
        <para>��� m.addActionListener(al);</para>
        <para>��� popup.add(m);</para>
        <para>��� m = new JMenuItem(&quot;Afar&quot;);</para>
        <para>��� m.addActionListener(al);</para>
        <para>��� popup.add(m);</para>
        <para>��� popup.addSeparator();</para>
        <para>��� m = new JMenuItem(&quot;Stay Here&quot;);</para>
        <para>��� m.addActionListener(al);</para>
        <para>��� popup.add(m);</para>
        <para>��� PopupListener pl = new PopupListener();</para>
        <para>��� addMouseListener(pl);</para>
        <para>��� t.addMouseListener(pl);</para>
        <para>� }</para>
        <para>� class PopupListener extends MouseAdapter {</para>
        <para>��� public void mousePressed(MouseEvent e) {</para>
        <para>����� maybeShowPopup(e);</para>
        <para>��� }</para>
        <para>��� public void mouseReleased(MouseEvent e) {</para>
        <para>����� maybeShowPopup(e);</para>
        <para>��� }</para>
        <para>��� private void maybeShowPopup(MouseEvent e) {</para>
        <para>��� ��if(e.isPopupTrigger()) {</para>
        <para>������� popup.show(</para>
        <para>��������� e.getComponent(), e.getX(), e.getY());</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Popup(), 300, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The same <emphasis role="bold">ActionListener</emphasis> is added to each <emphasis role="bold">JMenuItem</emphasis>, so that it fetches the text from the menu label and inserts it into the <emphasis role="bold">JTextField</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="Drawing" xml:id="_Toc481064822"/>Drawing</title>
        <para>In a good GUI framework, drawing should be reasonably easy�and it is, in the Swing library. The problem with any drawing example is that the calculations that determine where things go are typically a lot more complicated that the calls to the drawing routines, and these calculations are often mixed together with the drawing calls so it can seem that the interface is more complicated than it actually is.</para>
        <para>For simplicity, consider the problem of representing data on the screen�here, the data will be provided by the built-in <emphasis role="bold">Math.sin( )</emphasis> method which is a mathematical sine function. To make things a little more interesting, and to further demonstrate how easy it is to use Swing components, a slider will be placed at the bottom of the form to dynamically control the number of sine wave cycles that are displayed. In addition, if you resize the window, you�ll see that the sine wave refits itself to the new window size. </para>
        <para>Although any <emphasis role="bold">JComponent</emphasis> may be painted and thus used as a canvas, if you just want a straightforward drawing surface you will typically inherit from a <emphasis role="bold">JPanel</emphasis>. The only method you need to override is <emphasis role="bold">paintComponent( )</emphasis>, which is called whenever that component must be repainted (you normally don�t need to worry about this, as the decision is managed by Swing). When it is called, Swing passes a <emphasis role="bold">Graphics</emphasis> object to the method, and you can then use this object to draw or paint on the surface.</para>
        <para>In the following example, all the intelligence concerning painting is in the <emphasis role="bold">SineDraw</emphasis> class; the <emphasis role="bold">SineWave</emphasis> class simply configures the program and the slider control. Inside <emphasis role="bold">SineDraw</emphasis>, the <emphasis role="bold">setCycles( )</emphasis> method provides a hook to allow another object�the slider control, in this case�to control the number of cycles.</para>
        <para>//: c13:SineWave.java</para>
        <para>// Drawing with Swing, using a JSlider.</para>
        <para>// &lt;applet code=SineWave</para>
        <para>//� width=700 height=400&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import javax.swing.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>class SineDraw extends JPanel {</para>
        <para>� static final int SCALEFACTOR = 200;</para>
        <para>� int cycles;</para>
        <para>� int points;</para>
        <para>� double[] sines;</para>
        <para>� int[] pts;</para>
        <para>� SineDraw() { setCycles(5); }</para>
        <para>� public void setCycles(int newCycles) {</para>
        <para>��� cycles = newCycles;</para>
        <para>��� points = SCALEFACTOR * cycles * 2;</para>
        <para>��� sines = new double[points];</para>
        <para>��� pts = new int[points];</para>
        <para>�� �for(int i = 0; i &lt; points; i++) {</para>
        <para>����� double radians = (Math.PI/SCALEFACTOR) * i;</para>
        <para>����� sines[i] = Math.sin(radians);</para>
        <para>��� }</para>
        <para>��� repaint();</para>
        <para>� }��� </para>
        <para>� public void paintComponent(Graphics g) {</para>
        <para>��� super.paintComponent(g);</para>
        <para>��� int maxWidth = getWidth();</para>
        <para>�� �double hstep = (double)maxWidth/(double)points;</para>
        <para>��� int maxHeight = getHeight();</para>
        <para>��� for(int i = 0; i &lt; points; i++)</para>
        <para>����� pts[i] = (int)(sines[i] * maxHeight/2 * .95</para>
        <para>�������������������� + maxHeight/2);</para>
        <para>��� g.setColor(Color.red);</para>
        <para>��� for(int i = 1; i &lt; points; i++) {</para>
        <para>����� int x1 = (int)((i - 1) * hstep);</para>
        <para>����� int x2 = (int)(i * hstep);</para>
        <para>����� int y1 = pts[i-1];</para>
        <para>����� int y2 = pts[i];</para>
        <para>����� g.drawLine(x1, y1, x2, y2);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class SineWave extends JApplet {</para>
        <para>� SineDraw sines = new SineDraw();</para>
        <para>� JSlider cycles = new JSlider(1, 30, 5);</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(sines);</para>
        <para>��� cycles.addChangeListener(new ChangeListener(){</para>
        <para>����� public void stateChanged(ChangeEvent e) {</para>
        <para>������� sines.setCycles(</para>
        <para>��������� ((JSlider)e.getSource()).getValue());</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� cp.add(BorderLayout.SOUTH, cycles);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new SineWave(), 700, 400);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>All of the data members and arrays are used in the calculation of the sine wave points: <emphasis role="bold">cycles</emphasis> indicates the number of complete sine waves desired, <emphasis role="bold">points</emphasis> contains the total number of points that will be graphed, <emphasis role="bold">sines</emphasis> contains the sine function values, and <emphasis role="bold">pts</emphasis> contains the y-coordinates of the points that will be drawn on the <emphasis role="bold">JPanel</emphasis>. The <emphasis role="bold">setCycles( )</emphasis> method creates the arrays according to the number of points needed and fills the <emphasis role="bold">sines</emphasis> array with numbers. By calling <emphasis role="bold">repaint( )</emphasis> , <emphasis role="bold">setCycles( )</emphasis> forces <emphasis role="bold">paintComponent( )</emphasis> to be called so the rest of the calculation and redraw will take place.</para>
        <para>The first thing you must do when you override <emphasis role="bold">paintComponent( )</emphasis> is to call the base-class version of the method. Then you are free to do whatever you like; normally, this means using the <emphasis role="bold">Graphics</emphasis> methods that you can find in the documentation for <emphasis role="bold">java.awt.Graphics</emphasis> (in the HTML documentation from <emphasis role="italic">java.sun.com</emphasis>) to draw and paint pixels onto the <emphasis role="bold">JPanel</emphasis>. Here, you can see that almost all the code is involved in performing the calculations; the only two method calls that actually manipulate the screen are <emphasis role="bold">setColor( )</emphasis> and <emphasis role="bold">drawLine( )</emphasis>. You will probably have a similar experience when creating your own program that displays graphical data�you�ll spend most of your time figuring out what it is you want to draw, but the actual drawing process will be quite simple.</para>
        <para>When I created this program, the bulk of my time was spent in getting the sine wave to display. Once I did that, I thought it would be nice to be able to dynamically change the number of cycles. My programming experiences when trying to do such things in other languages made me a bit reluctant to try this, but it turned out to be the easiest part of the project. I created a <emphasis role="bold">JSlider</emphasis> (the arguments are the left-most value of the <emphasis role="bold">JSlider</emphasis>, the right-most value, and the starting value, respectively, but there are other constructors as well) and dropped it into the <emphasis role="bold">JApplet</emphasis>. Then I looked at the HTML documentation and noticed that the only listener was the <emphasis role="bold">addChangeListener</emphasis>, which was triggered whenever the slider was changed enough for it to produce a different value. The only method for this was the obviously named <emphasis role="bold">stateChanged( )</emphasis>, which provided a <emphasis role="bold">ChangeEvent</emphasis> object so that I could look backward to the source of the change and find the new value. By calling the <emphasis role="bold">sines</emphasis> object�s <emphasis role="bold">setCycles( )</emphasis>, the new value was incorporated and the <emphasis role="bold">JPanel</emphasis> redrawn.</para>
        <para>In general, you will find that most of your Swing problems can be solved by following a similar process, and you�ll find that it�s generally quite simple, even if you haven�t used a particular component before.</para>
        <para>If your problem is more complex, there are other more sophisticated alternatives for drawing, including third-party JavaBeans components and the Java 2D API. These solutions are beyond the scope of this book, but you should look them up if your drawing code becomes too onerous.</para>
      </section>
      <section>
        <title><anchor xreflabel="Dialog Boxes" xml:id="_Toc481064823"/>Dialog Boxes</title>
        <para>A dialog box is a window that pops up out of another window. Its purpose is to deal with some specific issue without cluttering the original window with those details. Dialog boxes are heavily used in windowed programming environments, but less frequently used in applets.</para>
        <para>To create a dialog box, you inherit from <emphasis role="bold">J</emphasis><emphasis role="bold">Dialog</emphasis>, which is just another kind of <emphasis role="bold">Window</emphasis>, like a <emphasis role="bold">J</emphasis><emphasis role="bold">Frame</emphasis>. A <emphasis role="bold">JDialog</emphasis> has a layout manager (which defaults to <emphasis role="bold">BorderLayout</emphasis>) and you add event listeners to deal with events. One significant difference when <emphasis role="bold">windowClosing( )</emphasis> is called is that you don�t want to shut down the application. Instead, you release the resources used by the dialog�s window by calling <emphasis role="bold">dispose( )</emphasis>. Here�s a very simple example:</para>
        <para>//: c13:Dialogs.java</para>
        <para>// Creating and using Dialog Boxes.</para>
        <para>// &lt;applet code=Dialogs width=125 height=75&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>class MyDialog extends JDialog {</para>
        <para>� public MyDialog(JFrame parent) {</para>
        <para>��� super(parent, &quot;My dialog&quot;, true);</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(new JLabel(&quot;Here is my dialog&quot;));</para>
        <para>��� JButton ok = new JButton(&quot;OK&quot;);</para>
        <para>��� ok.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� dispose(); // Closes the dialog</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� cp.add(ok);</para>
        <para>��� setSize(150,125);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Dialogs extends JApplet {</para>
        <para>� JButton b1 = new JButton(&quot;Dialog Box&quot;);</para>
        <para>� MyDialog dlg = new MyDialog(null);</para>
        <para>� public void init() {</para>
        <para>��� b1.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� dlg.show();</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� getContentPane().add(b1);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Dialogs(), 125, 75);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Once the <emphasis role="bold">JDialog</emphasis> is created, the <emphasis role="bold">show( )</emphasis> method must be called to display and activate it. For the dialog to close, it must call <emphasis role="bold">dispose( )</emphasis>.</para>
        <para>You�ll see that anything that pops up out of an applet, including dialog boxes, is �untrusted.� That is, you get a warning in the window that�s been popped up. This is because, in theory, it would be possible to fool the user into thinking that they�re dealing with a regular native application and to get them to type in their credit card number, which then goes across the Web. An applet is always attached to a Web page and visible within your Web browser, while a dialog box is detached�so in theory, it could be possible. As a result it is not so common to see an applet that uses a dialog box.</para>
        <para>The following example is more complex; the dialog box is made up of a grid (using <emphasis role="bold">GridLayout</emphasis>) of a special kind of button that is defined here as class <emphasis role="bold">ToeButton</emphasis>. This button draws a frame around itself and, depending on its state, a blank, an �x,� or an �o� in the middle. It starts out blank, and then depending on whose turn it is, changes to an �x� or an �o.� However, it will also flip back and forth between �x� and �o� when you click on the button. (This makes the tic-tac-toe concept only slightly more annoying than it already is.) In addition, the dialog box can be set up for any number of rows and columns by changing numbers in the main application window.</para>
        <para>//: c13:TicTacToe.java</para>
        <para>// Demonstration of dialog boxes</para>
        <para>// and creating your own components.</para>
        <para>// &lt;applet code=TicTacToe</para>
        <para>//� width=200 height=100&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class TicTacToe extends JApplet {</para>
        <para>� JTextField </para>
        <para>��� rows = new JTextField(&quot;3&quot;),</para>
        <para>��� cols = new JTextField(&quot;3&quot;);</para>
        <para>� static final int BLANK = 0, XX = 1, OO = 2;</para>
        <para>� class ToeDialog extends JDialog {</para>
        <para>��� int turn = XX; // Start with x&apos;s turn</para>
        <para>��� // w = number of cells wide</para>
        <para>��� // h = number of cells high</para>
        <para>��� public ToeDialog(int w, int h) {</para>
        <para>����� setTitle(&quot;The game itself&quot;);</para>
        <para>����� Container cp = getContentPane();</para>
        <para>����� cp.setLayout(new GridLayout(w, h));</para>
        <para>����� for(int i = 0; i &lt; w * h; i++)</para>
        <para>������� cp.add(new ToeButton());</para>
        <para>����� setSize(w * 50, h * 50);</para>
        <para>����� // JDK 1.3 close dialog:</para>
        <para>����� //#setDefaultCloseOperation(</para>
        <para>����� //#� DISPOSE_ON_CLOSE);</para>
        <para>����� // JDK 1.2 close dialog:</para>
        <para>����� addWindowListener(new WindowAdapter() {</para>
        <para>������� public void windowClosing(WindowEvent e){</para>
        <para>��������� dispose();</para>
        <para>������� }</para>
        <para>����� });��� </para>
        <para>��� }</para>
        <para>��� class ToeButton extends JPanel {</para>
        <para>����� int state = BLANK;</para>
        <para>����� public ToeButton() {</para>
        <para>������� addMouseListener(new ML());</para>
        <para>� ����}</para>
        <para>����� public void paintComponent(Graphics g) {</para>
        <para>������� super.paintComponent(g);</para>
        <para>������� int x1 = 0;</para>
        <para>������� int y1 = 0;</para>
        <para>������� int x2 = getSize().width - 1;</para>
        <para>������� int y2 = getSize().height - 1;</para>
        <para>������� g.drawRect(x1, y1, x2, y2);</para>
        <para>������� x1 = x2/4;</para>
        <para>������� y1 = y2/4;</para>
        <para>������� int wide = x2/2;</para>
        <para>������� int high = y2/2;</para>
        <para>������� if(state == XX) {</para>
        <para>��������� g.drawLine(x1, y1, </para>
        <para>����������� x1 + wide, y1 + high);</para>
        <para>��������� g.drawLine(x1, y1 + high, </para>
        <para>����������� x1 + wide, y1);</para>
        <para>������� }</para>
        <para>������� if(state == OO) {</para>
        <para>��������� g.drawOval(x1, y1, </para>
        <para>����������� x1 + wide/2, y1 + high/2);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>����� class ML extends MouseAdapter {</para>
        <para>������� public void mousePressed(MouseEvent e) {</para>
        <para>��������� if(state == BLANK) {</para>
        <para>����������� state = turn;</para>
        <para>����������� turn = (turn == XX ? OO : XX);</para>
        <para>��������� } </para>
        <para>��������� else</para>
        <para>����������� state = (state == XX ? OO : XX);</para>
        <para>��������� repaint();</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class BL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� JDialog d = new ToeDialog(</para>
        <para>������� Integer.parseInt(rows.getText()),</para>
        <para>������� Integer.parseInt(cols.getText()));</para>
        <para>����� d.setVisible(true);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� JPanel p = new JPanel();</para>
        <para>��� p.setLayout(new GridLayout(2,2));</para>
        <para>��� p.add(new JLabel(&quot;Rows&quot;, JLabel.CENTER));</para>
        <para>��� p.add(rows);</para>
        <para>��� p.add(new JLabel(&quot;Columns&quot;, JLabel.CENTER));</para>
        <para>��� p.add(cols);</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(p, BorderLayout.NORTH);</para>
        <para>��� JButton b = new JButton(&quot;go&quot;);</para>
        <para>��� b.addActionListener(new BL());</para>
        <para>��� cp.add(b, BorderLayout.SOUTH);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new TicTacToe(), 200, 100);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Because <emphasis role="bold">static</emphasis>s can only be at the outer level of the class, inner classes cannot have <emphasis role="bold">static</emphasis> data or <emphasis role="bold">static</emphasis> inner classes.</para>
        <para>The� <emphasis role="bold">paintComponent</emphasis><emphasis role="bold">( )</emphasis> method draws the square around the panel, and the �x� or the �o.� This is full of tedious calculations, but it�s straightforward. </para>
        <para>A mouse click is captured by the <emphasis role="bold">MouseListener</emphasis>, which first checks to see if the panel has anything written on it. If not, the parent window is queried to find out whose turn it is and that is used to establish the state of the <emphasis role="bold">ToeButton</emphasis>. Via the inner class mechanism, the <emphasis role="bold">ToeButton</emphasis> then reaches back into the parent and changes the turn. If the button is already displaying an �x� or an �o� then that is flopped. You can see in these calculations the convenient use of the ternary if-else described in Chapter 3. After a state change, the <emphasis role="bold">ToeButton</emphasis> is repainted.</para>
        <para>The constructor for <emphasis role="bold">ToeDialog</emphasis> is quite simple: it adds into a <emphasis role="bold">GridLayout</emphasis> as many buttons as you request, then resizes it for 50 pixels on a side for each button.</para>
        <para><emphasis role="bold">TicTacToe</emphasis> sets up the whole application by creating the<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis>s (for inputting the rows and columns of the button grid) and the �go� button with its <emphasis role="bold">ActionListener</emphasis>. When the button is pressed, the data in the<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis>s must be fetched, and, since they are in <emphasis role="bold">String</emphasis> form, turned into <emphasis role="bold">int</emphasis>s using the <emphasis role="bold">static</emphasis><emphasis role="bold">Integer.parseInt( )</emphasis> method. </para>
      </section>
      <section>
        <title><anchor xreflabel="File dialogs" xml:id="_Toc481064824"/>File dialogs</title>
        <para>Some operating systems have a number of special built-in dialog boxes to handle the selection of things such as fonts, colors, printers, and the like. Virtually all graphical operating systems support the opening and saving of files, however, and so Java�s <emphasis role="bold">JFileChooser</emphasis> encapsulates these for easy use.</para>
        <para>The following application exercises two forms of <emphasis role="bold">JFileChooser</emphasis> dialogs, one for opening and one for saving. Most of the code should by now be familiar, and all the interesting activities happen in the action listeners for the two different button clicks:</para>
        <para>//: c13:FileChooserTest.java</para>
        <para>// Demonstration of File dialog boxes.</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class FileChooserTest extends JFrame {</para>
        <para>� JTextField </para>
        <para>��� filename = new JTextField(),</para>
        <para>��� dir = new JTextField();</para>
        <para>� JButton </para>
        <para>��� open = new JButton(&quot;Open&quot;),</para>
        <para>��� save = new JButton(&quot;Save&quot;);</para>
        <para>� public FileChooserTest() {</para>
        <para>��� JPanel p = new JPanel();</para>
        <para>��� open.addActionListener(new OpenL());</para>
        <para>��� p.add(open);</para>
        <para>��� save.addActionListener(new SaveL());</para>
        <para>��� p.add(save);</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(p, BorderLayout.SOUTH);</para>
        <para>��� dir.setEditable(false);</para>
        <para>��� filename.setEditable(false);</para>
        <para>��� p = new JPanel();</para>
        <para>��� p.setLayout(new GridLayout(2,1));</para>
        <para>��� p.add(filename);</para>
        <para>��� p.add(dir);</para>
        <para>��� cp.add(p, BorderLayout.NORTH);</para>
        <para>� }</para>
        <para>� class OpenL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� JFileChooser c = new JFileChooser();</para>
        <para>����� // Demonstrate &quot;Open&quot; dialog:</para>
        <para>����� int rVal = </para>
        <para>������� c.showOpenDialog(FileChooserTest.this);</para>
        <para>����� if(rVal == JFileChooser.APPROVE_OPTION) {</para>
        <para>������� filename.setText(</para>
        <para>��������� c.getSelectedFile().getName());</para>
        <para>��������� dir.setText(</para>
        <para>����������� c.getCurrentDirectory().toString());</para>
        <para>����� }</para>
        <para>����� if(rVal == JFileChooser.CANCEL_OPTION) {</para>
        <para>������� filename.setText(&quot;You pressed cancel&quot;);</para>
        <para>������� dir.setText(&quot;&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class SaveL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� JFileChooser c = new JFileChooser();</para>
        <para>����� // Demonstrate &quot;Save&quot; dialog:</para>
        <para>����� int rVal = </para>
        <para>������� c.showSaveDialog(FileChooserTest.this);</para>
        <para>����� if(rVal == JFileChooser.APPROVE_OPTION) {</para>
        <para>������� filename.setText(</para>
        <para>��������� c.getSelectedFile().getName());</para>
        <para>��������� dir.setText(</para>
        <para>����������� c.getCurrentDirectory().toString());</para>
        <para>����� }</para>
        <para>����� if(rVal == JFileChooser.CANCEL_OPTION) {</para>
        <para>������� filename.setText(&quot;You pressed cancel&quot;);</para>
        <para>� ������dir.setText(&quot;&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new FileChooserTest(), 250, 110);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Note that there are many variations you can apply to <emphasis role="bold">JFileChooser</emphasis>, including filters to narrow the file names that you will allow.</para>
        <para>For an �open file� dialog, you call <emphasis role="bold">showOpenDialog( )</emphasis>, and for a �save file� dialog you call <emphasis role="bold">showSaveDialog( )</emphasis>. These commands don�t return until the dialog is closed. The <emphasis role="bold">JFileChooser</emphasis> object still exists, so you can read data from it. The methods <emphasis role="bold">getSelectedFile( )</emphasis> and <emphasis role="bold">getCurrentDirectory( )</emphasis> are two ways you can interrogate the results of the operation. If these return <emphasis role="bold">null</emphasis> it means the user canceled out of the dialog.</para>
      </section>
      <section>
        <title><anchor xreflabel="HTML on Swing components" xml:id="_Toc481064825"/>HTML on Swing components</title>
        <para>Any component that can take text can also take HTML text, which it will reformat according to HTML rules. This means you can very easily add fancy text to a Swing component. For example,</para>
        <para>//: c13:HTMLButton.java</para>
        <para>// Putting HTML text on Swing components.</para>
        <para>// &lt;applet code=HTMLButton width=200 height=500&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.awt.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class HTMLButton extends JApplet {</para>
        <para>� JButton b = new JButton(&quot;&lt;html&gt;&lt;b&gt;&lt;font size=+2&gt;&quot; +</para>
        <para>��� &quot;&lt;center&gt;Hello!&lt;br&gt;&lt;i&gt;Press me now!&quot;);</para>
        <para>� public void init() {</para>
        <para>��� b.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� getContentPane().add(new JLabel(&quot;&lt;html&gt;&quot;+</para>
        <para>��������� &quot;&lt;i&gt;&lt;font size=+4&gt;Kapow!&quot;));</para>
        <para>������� // Force a re-layout to</para>
        <para>������� // include the new label:</para>
        <para>������� validate();</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(b);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new HTMLButton(), 200, 500);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You must start the text with �&lt;html&gt;,� and then you can use normal HTML tags. Note that you are not forced to include the normal closing tags.</para>
        <para>The <emphasis role="bold">ActionListener</emphasis> adds a new <emphasis role="bold">JLabel</emphasis> to the form, which also contains HTML text. However, this label is not added during <emphasis role="bold">init( )</emphasis> so you must call the container�s <emphasis role="bold">validate( )</emphasis> method in order to force a re-layout of the components (and thus the display of the new label).</para>
        <para>You can also use HTML text for <emphasis role="bold">JTabbedPane</emphasis>, <emphasis role="bold">JMenuItem</emphasis>, <emphasis role="bold">JToolTip</emphasis>, <emphasis role="bold">JRadioButton</emphasis> and <emphasis role="bold">JCheckBox</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="Sliders and progress bars" xml:id="_Toc481064826"/>Sliders and progress bars</title>
        <para>A slider (which has already been used in the sine wave example) allows the user to input data by moving a point back and forth, which is intuitive in some situations (volume controls, for example). A progress bar displays data in a relative fashion from �full� to �empty� so the user gets a perspective. My favorite example for these is to simply hook the slider to the progress bar so when you move the slider the progress bar changes accordingly:</para>
        <para>//: c13:Progress.java</para>
        <para>// Using progress bars and sliders.</para>
        <para>// &lt;applet code=Progress</para>
        <para>//� width=300 height=200&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import javax.swing.event.*;</para>
        <para>import javax.swing.border.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Progress extends JApplet {</para>
        <para>� JProgressBar pb = new JProgressBar();</para>
        <para>� JSlider sb = </para>
        <para>��� new JSlider(JSlider.HORIZONTAL, 0, 100, 60);</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new GridLayout(2,1));</para>
        <para>��� cp.add(pb);</para>
        <para>��� sb.setValue(0);</para>
        <para>��� sb.setPaintTicks(true);</para>
        <para>��� sb.setMajorTickSpacing(20);</para>
        <para>��� sb.setMinorTickSpacing(5);</para>
        <para>��� sb.setBorder(new TitledBorder(&quot;Slide Me&quot;));</para>
        <para>��� pb.setModel(sb.getModel()); // Share model</para>
        <para>��� cp.add(sb);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Progress(), 300, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The key to hooking the two components together is in sharing their model, in the line:</para>
        <para>pb.setModel(sb.getModel());</para>
        <para> </para>
        <para>Of course, you could also control the two using a listener, but this is more straightforward for simple situations.</para>
        <para>The <emphasis role="bold">JProgressBar </emphasis>is fairly straightforward, but the <emphasis role="bold">JSlider</emphasis> has a lot of options, such as the orientation and major and minor tick marks. Notice how straightforward it is to add a titled border.</para>
      </section>
      <section>
        <title><anchor xreflabel="Trees" xml:id="_Toc481064827"/>Trees</title>
        <para>Using a <emphasis role="bold">JTree </emphasis>can be as simple as saying:</para>
        <para>add(new JTree(</para>
        <para>� new Object[] {&quot;this&quot;, &quot;that&quot;, &quot;other&quot;}));</para>
        <para> </para>
        <para>This displays a primitive tree. The API for trees is vast, however�certainly one of the largest in Swing. It appears that you can do just about anything with trees, but more sophisticated tasks might require quite a bit of research and experimentation. </para>
        <para>Fortunately, there is a middle ground provided in the library: the �default� tree components, which generally do what you need. So most of the time you can use these components, and only in special cases will you need to delve in and understand trees more deeply.</para>
        <para>The following example uses the �default� tree components to display a tree in an applet. When you press the button, a new subtree is added under the currently selected node (if no node is selected, the root node is used):</para>
        <para>//: c13:Trees.java</para>
        <para>// Simple Swing tree example. Trees can </para>
        <para>// be made vastly more complex than this.</para>
        <para>// &lt;applet code=Trees</para>
        <para>//� width=250 height=250&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import javax.swing.tree.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>// Takes an array of Strings and makes the first</para>
        <para>// element a node and the rest leaves:</para>
        <para>class Branch {</para>
        <para>� DefaultMutableTreeNode r;</para>
        <para>� public Branch(String[] data) {</para>
        <para>��� r = new DefaultMutableTreeNode(data[0]);</para>
        <para>��� for(int i = 1; i &lt; data.length; i++)</para>
        <para>����� r.add(new DefaultMutableTreeNode(data[i]));</para>
        <para>� }</para>
        <para>� public DefaultMutableTreeNode node() { </para>
        <para>��� return r; </para>
        <para>� }</para>
        <para>}� </para>
        <para> </para>
        <para>public class Trees extends JApplet {</para>
        <para>� String[][] data = {</para>
        <para>��� { &quot;Colors&quot;, &quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot; },</para>
        <para>��� { &quot;Flavors&quot;, &quot;Tart&quot;, &quot;Sweet&quot;, &quot;Bland&quot; },</para>
        <para>��� { &quot;Length&quot;, &quot;Short&quot;, &quot;Medium&quot;, &quot;Long&quot; },</para>
        <para>��� { &quot;Volume&quot;, &quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot; },</para>
        <para>��� { &quot;Temperature&quot;, &quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot; },</para>
        <para>��� { &quot;Intensity&quot;, &quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot; },</para>
        <para>� };</para>
        <para>� static int i = 0;</para>
        <para>� DefaultMutableTreeNode root, child, chosen;</para>
        <para>� JTree tree;</para>
        <para>� DefaultTreeModel model;</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� root = new DefaultMutableTreeNode(&quot;root&quot;);</para>
        <para>��� tree = new JTree(root);</para>
        <para>��� // Add it and make it take care of scrolling:</para>
        <para>��� cp.add(new JScrollPane(tree), </para>
        <para>����� BorderLayout.CENTER);</para>
        <para>��� // Capture the tree&apos;s model:</para>
        <para>��� model =(DefaultTreeModel)tree.getModel();</para>
        <para>��� JButton test = new JButton(&quot;Press me&quot;);</para>
        <para>��� test.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� if(i &lt; data.length) {</para>
        <para>��������� child = new Branch(data[i++]).node();</para>
        <para>��������� // What&apos;s the last one you clicked?</para>
        <para>��������� chosen = (DefaultMutableTreeNode)</para>
        <para>����������� tree.getLastSelectedPathComponent();</para>
        <para>��������� if(chosen == null) chosen = root;</para>
        <para>��������� // The model will create the </para>
        <para>��������� // appropriate event. In response, the</para>
        <para>��������� // tree will update itself:</para>
        <para>��������� model.insertNodeInto(child, chosen, 0);</para>
        <para>��������� // This puts the new node on the </para>
        <para>��������� // currently chosen node.</para>
        <para>������� }</para>
        <para>��� ��}</para>
        <para>��� });</para>
        <para>��� // Change the button&apos;s colors:</para>
        <para>��� test.setBackground(Color.blue);</para>
        <para>��� test.setForeground(Color.white);</para>
        <para>��� JPanel p = new JPanel();</para>
        <para>��� p.add(test);</para>
        <para>��� cp.add(p, BorderLayout.SOUTH);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Trees(), 250, 250);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The first class, <emphasis role="bold">Branch</emphasis>, is a tool to take an array of <emphasis role="bold">String</emphasis> and build a <emphasis role="bold">DefaultMutableTreeNode</emphasis> with the first <emphasis role="bold">String</emphasis> as the root and the rest of the <emphasis role="bold">String</emphasis>s in the array as leaves. Then <emphasis role="bold">node( )</emphasis> can be called to produce the root of this �branch.�</para>
        <para>The <emphasis role="bold">Trees</emphasis> class contains a two-dimensional array of <emphasis role="bold">String</emphasis>s from which <emphasis role="bold">Branch</emphasis>es can be made and a <emphasis role="bold">static int i</emphasis> to count through this array. The <emphasis role="bold">DefaultMutableTreeNode</emphasis> objects hold the nodes, but the physical representation on screen is controlled by the <emphasis role="bold">JTree</emphasis> and its associated model, the <emphasis role="bold">DefaultTreeModel</emphasis>. Note that when the <emphasis role="bold">JTree</emphasis> is added to the applet, it is wrapped in a <emphasis role="bold">JScrollPane</emphasis>�this is all it takes to provide automatic scrolling.</para>
        <para>The <emphasis role="bold">JTree</emphasis> is controlled through its <emphasis role="italic">model</emphasis>. When you make a change to the model, the model generates an event that causes the <emphasis role="bold">JTree</emphasis> to perform any necessary updates to the visible representation of the tree. In <emphasis role="bold">init( )</emphasis>, the model is captured by calling <emphasis role="bold">getModel( )</emphasis>. When the button is pressed, a new �branch� is created. Then the currently selected component is found (or the root is used if nothing is selected) and the model�s <emphasis role="bold">insertNodeInto( )</emphasis> method does all the work of changing the tree and causing it to be updated.</para>
        <para>An example like the one above may give you what you need in a tree. However, trees have the power to do just about anything you can imagine�everywhere you see the word �default� in the example above, you can substitute your own class to get different behavior. But beware: almost all of these classes have a large interface, so you could spend a lot of time struggling to understand the intricacies of trees. Despite this, it�s a good design and the alternatives are usually much worse.</para>
      </section>
      <section>
        <title><anchor xreflabel="Tables" xml:id="_Toc481064828"/>Tables</title>
        <para>Like trees, tables in Swing are vast and powerful. They are primarily intended to be the popular �grid� interface to databases via Java Database Connectivity (JDBC, discussed in Chapter 15) and thus they have a tremendous amount of flexibility, which you pay for in complexity. There�s easily enough here to be the basis of a full-blown spreadsheet and could probably justify an entire book. However, it is also possible to create a relatively simple <emphasis role="bold">JTable</emphasis> if you understand the basics.</para>
        <para>The <emphasis role="bold">JTable</emphasis> controls how the data is displayed, but the <emphasis role="bold">TableModel</emphasis> controls the data itself. So to create a <emphasis role="bold">JTable</emphasis> you�ll typically create a <emphasis role="bold">TableModel</emphasis> first. You can fully implement the <emphasis role="bold">TableModel</emphasis> interface, but it�s usually simpler to inherit from the helper class <emphasis role="bold">AbstractTableModel</emphasis>:</para>
        <para>//: c13:Table.java</para>
        <para>// Simple demonstration of JTable.</para>
        <para>// &lt;applet code=Table</para>
        <para>//� width=350 height=200&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import javax.swing.table.*;</para>
        <para>import javax.swing.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Table extends JApplet {</para>
        <para>� JTextArea txt = new JTextArea(4, 20);</para>
        <para>� // The TableModel controls all the data:</para>
        <para>� class DataModel extends AbstractTableModel {</para>
        <para>��� Object[][] data = {</para>
        <para>����� {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;},</para>
        <para>����� {&quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;},</para>
        <para>����� {&quot;nine&quot;, &quot;ten&quot;, &quot;eleven&quot;, &quot;twelve&quot;},</para>
        <para>��� };</para>
        <para>��� // Prints data when table changes:</para>
        <para>��� class TML implements TableModelListener {</para>
        <para>����� public void tableChanged(TableModelEvent e){</para>
        <para>������� txt.setText(&quot;&quot;); // Clear it</para>
        <para>������� for(int i = 0; i &lt; data.length; i++) {</para>
        <para>��������� for(int j = 0; j &lt; data[0].length; j++)</para>
        <para>����������� txt.append(data[i][j] + &quot; &quot;);</para>
        <para>��������� txt.append(&quot;\n&quot;);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� public DataModel() {</para>
        <para>����� addTableModelListener(new TML());</para>
        <para>��� }</para>
        <para>��� public int getColumnCount() { </para>
        <para>����� return data[0].length; </para>
        <para>��� }</para>
        <para>��� public int getRowCount() { </para>
        <para>����� return data.length;</para>
        <para>��� }</para>
        <para>��� public Object getValueAt(int row, int col) {</para>
        <para>����� return data[row][col]; </para>
        <para>��� }</para>
        <para>��� public void </para>
        <para>��� setValueAt(Object val, int row, int col) {</para>
        <para>����� data[row][col] = val;</para>
        <para>����� // Indicate the change has happened:</para>
        <para>����� fireTableDataChanged();</para>
        <para>��� }</para>
        <para>��� public boolean </para>
        <para>��� isCellEditable(int row, int col) { </para>
        <para>����� return true; </para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� JTable table = new JTable(new DataModel());</para>
        <para>��� cp.add(new JScrollPane(table));</para>
        <para>��� cp.add(BorderLayout.SOUTH, txt);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Table(), 350, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">DataModel</emphasis> contains an array of data, but you could also get the data from some other source such as a database. The constructor adds a <emphasis role="bold">TableModelListener</emphasis> that prints the array every time the table is changed. The rest of the methods follow the Beans naming convention, and are used by <emphasis role="bold">JTable</emphasis> when it wants to present the information in <emphasis role="bold">DataModel</emphasis>. <emphasis role="bold">AbstractTableModel</emphasis> provides default methods for <emphasis role="bold">setValueAt( )</emphasis> and <emphasis role="bold">isCellEditable( )</emphasis> that prevent changes to the data, so if you want to be able to edit the data, you must override these methods.</para>
        <para>Once you have a <emphasis role="bold">TableModel</emphasis>, you only need to hand it to the <emphasis role="bold">JTable</emphasis> constructor. All the details of displaying, editing, and updating will be taken care of for you. This example also puts the <emphasis role="bold">JTable</emphasis> in a <emphasis role="bold">JScrollPane</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="Selecting Look &amp; Feel" xml:id="_Toc481064829"/>Selecting Look &amp; Feel</title>
        <para>One of the very interesting aspects of Swing is the �Pluggable Look &amp; Feel.� This allows your program to emulate the look and feel of various operating environments. You can even do all sorts of fancy things like dynamically changing the look and feel while the program is executing. However, you generally just want to do one of two things, either select the �cross platform� look and feel (which is Swing�s �metal�), or select the look and feel for the system you are currently on, so your Java program looks like it was created specifically for that system. The code to select either of these behaviors is quite simple�but you must execute it <emphasis role="italic">before</emphasis> you create any visual components, because the components will be made based on the current look and feel and will not be changed just because you happen to change the look and feel midway during the program (that process is more complicated and uncommon, and is relegated to Swing-specific books).</para>
        <para>Actually, if you want to use the cross-platform (�metal�) look and feel that is characteristic of Swing programs, you don�t have to do anything�it�s the default. But if you want instead to use the current operating environment�s look and feel, you just insert the following code, typically at the beginning of your <emphasis role="bold">main( )</emphasis> but somehow before any components are added:</para>
        <para>try {</para>
        <para>� UIManager.setLookAndFeel(UIManager.</para>
        <para>��� getSystemLookAndFeelClassName());</para>
        <para>} catch(Exception e) {}</para>
        <para> </para>
        <para>You don�t need anything in the <emphasis role="bold">catch</emphasis> clause because the <emphasis role="bold">UIManager</emphasis> will default to the cross-platform look and feel if your attempts to set up any of the alternatives fail. However, during debugging the exception can be quite useful so you may at least want to put a print statement in the catch clause.</para>
        <para>Here is a program that takes a command-line argument to select a look and feel, and shows how several different components look under the chosen look and feel:</para>
        <para>//: c13:LookAndFeel.java</para>
        <para>// Selecting different looks &amp; feels.</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class LookAndFeel extends JFrame {</para>
        <para>� String[] choices = { </para>
        <para>��� &quot;eeny&quot;, &quot;meeny&quot;, &quot;minie&quot;, &quot;moe&quot;, &quot;toe&quot;, &quot;you&quot;</para>
        <para>� };</para>
        <para>� Component[] samples = {</para>
        <para>��� new JButton(&quot;JButton&quot;),</para>
        <para>��� new JTextField(&quot;JTextField&quot;),</para>
        <para>��� new JLabel(&quot;JLabel&quot;),</para>
        <para>��� new JCheckBox(&quot;JCheckBox&quot;),</para>
        <para>��� new JRadioButton(&quot;Radio&quot;),</para>
        <para>��� new JComboBox(choices),</para>
        <para>��� new JList(choices),</para>
        <para>� };</para>
        <para>� public LookAndFeel() {</para>
        <para>��� super(&quot;Look And Feel&quot;);</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� for(int i = 0; i &lt; samples.length; i++)</para>
        <para>����� cp.add(samples[i]);</para>
        <para>� }</para>
        <para>� private static void usageError() {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;Usage:LookAndFeel [cross|system|motif]&quot;);</para>
        <para>��� System.exit(1);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� if(args.length == 0) usageError();</para>
        <para>��� if(args[0].equals(&quot;cross&quot;)) {</para>
        <para>����� try {</para>
        <para>����� ��UIManager.setLookAndFeel(UIManager.</para>
        <para>��������� getCrossPlatformLookAndFeelClassName());</para>
        <para>����� } catch(Exception e) {</para>
        <para>��������� e.printStackTrace(System.err);</para>
        <para>����� }</para>
        <para>��� } else if(args[0].equals(&quot;system&quot;)) {</para>
        <para>����� try {</para>
        <para>������� UIManager.setLookAndFeel(UIManager.</para>
        <para>��������� getSystemLookAndFeelClassName());</para>
        <para>����� } catch(Exception e) {</para>
        <para>��������� e.printStackTrace(System.err);</para>
        <para>����� }</para>
        <para>��� } else if(args[0].equals(&quot;motif&quot;)) {</para>
        <para>����� try {</para>
        <para>������� UIManager.setLookAndFeel(&quot;com.sun.java.&quot;+</para>
        <para>��������� &quot;swing.plaf.motif.MotifLookAndFeel&quot;);</para>
        <para>����� } catch(Exception e) {</para>
        <para>��������� e.printStackTrace(System.err);</para>
        <para>����� }</para>
        <para>��� } else usageError();</para>
        <para>��� // Note the look &amp; feel must be set before</para>
        <para>��� // any components are created.</para>
        <para>��� Console.run(new LookAndFeel(), 300, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can see that one option is to explicitly specify a string for a look and feel, as seen with <emphasis role="bold">MotifLookAndFeel</emphasis>. However, that one and the default �metal� look and feel are the only ones that can legally be used on any platform; even though there are strings for Windows and Macintosh look and feels, those can only be used on their respective platforms (these are produced when you call <emphasis role="bold">getSystemLookAndFeelClassName( )</emphasis> and you�re on that particular platform).</para>
        <para>It is also possible to create a custom look and feel package, for example, if you are building a framework for a company that wants a distinctive appearance. This is a big job and is far beyond the scope of this book (in fact, you�ll discover it is beyond the scope of many dedicated Swing books!).</para>
      </section>
      <section>
        <title><anchor xreflabel="The clipboard" xml:id="_Toc481064830"/>The clipboard</title>
        <para>The JFC supports limited operations with the system clipboard (in the <emphasis role="bold">java.awt.datatransfer </emphasis>package). You can copy <emphasis role="bold">String</emphasis> objects to the clipboard as text, and you can paste text from the clipboard into <emphasis role="bold">String</emphasis> objects. Of course, the clipboard is designed to hold any type of data, but how this data is represented on the clipboard is up to the program doing the cutting and pasting. The Java clipboard API provides for extensibility through the concept of a �flavor.� When data comes off the clipboard, it has an associated set of flavors that it can be converted to (for example, a graph might be represented as a string of numbers or as an image) and you can see if that particular clipboard data supports the flavor you�re interested in.</para>
        <para>The following program is a simple demonstration of cut, copy, and paste with <emphasis role="bold">String</emphasis> data in a <emphasis role="bold">JTextArea</emphasis>. One thing you�ll notice is that the keyboard sequences you normally use for cutting, copying, and pasting also work. But if you look at any<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis> or<emphasis role="bold"> JText</emphasis><emphasis role="bold">Area</emphasis> in any other program you�ll find that they also automatically support the clipboard key sequences. This example simply adds programmatic control of the clipboard, and you could use these techniques if you want to capture clipboard text into something other than a <emphasis role="bold">JTextComponent</emphasis>.</para>
        <para>//: c13:CutAndPaste.java</para>
        <para>// Using the clipboard.</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.awt.datatransfer.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class CutAndPaste extends JFrame� {</para>
        <para>� JMenuBar mb = new JMenuBar();</para>
        <para>� JMenu edit = new JMenu(&quot;Edit&quot;);</para>
        <para>� JMenuItem</para>
        <para>��� cut = new JMenuItem(&quot;Cut&quot;),</para>
        <para>��� copy = new JMenuItem(&quot;Copy&quot;),</para>
        <para>��� paste = new JMenuItem(&quot;Paste&quot;);</para>
        <para>� JTextArea text = new JTextArea(20, 20);</para>
        <para>� Clipboard clipbd = </para>
        <para>��� getToolkit().getSystemClipboard();</para>
        <para>� public CutAndPaste()� {</para>
        <para>��� cut.addActionListener(new CutL());</para>
        <para>��� copy.addActionListener(new CopyL());</para>
        <para>��� paste.addActionListener(new PasteL());</para>
        <para>��� edit.add(cut);</para>
        <para>��� edit.add(copy);</para>
        <para>��� edit.add(paste);</para>
        <para>��� mb.add(edit);</para>
        <para>��� setJMenuBar(mb);</para>
        <para>��� getContentPane().add(text);</para>
        <para>� }</para>
        <para>� class CopyL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� String selection = text.getSelectedText();</para>
        <para>����� if (selection == null)</para>
        <para>������� return;</para>
        <para>����� StringSelection clipString =</para>
        <para>������� new StringSelection(selection);</para>
        <para>����� clipbd.setContents(clipString,clipString);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class CutL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� String selection = text.getSelectedText();</para>
        <para>����� if (selection == null)</para>
        <para>������� return;</para>
        <para>����� StringSelection clipString =</para>
        <para>������� new StringSelection(selection);</para>
        <para>����� clipbd.setContents(clipString, clipString);</para>
        <para>����� text.replaceRange(&quot;&quot;,</para>
        <para>������� text.getSelectionStart(),</para>
        <para>������� text.getSelectionEnd());</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class PasteL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� Transferable clipData =</para>
        <para>������� clipbd.getContents(CutAndPaste.this);</para>
        <para>����� try {</para>
        <para>������� String clipString =</para>
        <para>��������� (String)clipData.</para>
        <para>����������� getTransferData(</para>
        <para>������������� DataFlavor.stringFlavor);</para>
        <para>������� text.replaceRange(clipString,</para>
        <para>��������� text.getSelectionStart(),</para>
        <para>�������� �text.getSelectionEnd());</para>
        <para>����� } catch(Exception ex) {</para>
        <para>������� System.err.println(&quot;Not String flavor&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new CutAndPaste(), 300, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The creation and addition of the menu and<emphasis role="bold"> JText</emphasis><emphasis role="bold">Area</emphasis> should by now seem a pedestrian activity. What�s different is the creation of the <emphasis role="bold">Clipboard</emphasis> field <emphasis role="bold">clipbd</emphasis>, which is done through the <emphasis role="bold">Toolkit</emphasis>.</para>
        <para>All the action takes place in the listeners. The <emphasis role="bold">CopyL</emphasis> and <emphasis role="bold">CutL</emphasis> listeners are the same except for the last line of <emphasis role="bold">CutL</emphasis>, which erases the line that�s been copied. The special two lines are the creation of a <emphasis role="bold">StringSelection</emphasis> object from the <emphasis role="bold">String</emphasis> and the call to <emphasis role="bold">setContents( )</emphasis> with this <emphasis role="bold">StringSelection</emphasis>. That�s all there is to putting a <emphasis role="bold">String</emphasis> on the clipboard.</para>
        <para>In <emphasis role="bold">PasteL,</emphasis> data is pulled off the clipboard using <emphasis role="bold">getContents( )</emphasis>. What comes back is a fairly anonymous <emphasis role="bold">Transferable</emphasis> object, and you don�t really know what it contains. One way to find out is to call <emphasis role="bold">getTransferDataFlavors( )</emphasis>, which returns an array of <emphasis role="bold">DataFlavor</emphasis> objects indicating which flavors are supported by this particular object. You can also ask it directly with <emphasis role="bold">isDataFlavorSupported( )</emphasis>, passing in the flavor you�re interested in. Here, however, the bold approach is taken: <emphasis role="bold">getTransferData( )</emphasis> is called assuming that the contents supports the <emphasis role="bold">String</emphasis> flavor, and if it doesn�t the problem is sorted out in the exception handler.</para>
        <para>In the future you can expect more data flavors to be supported.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545469"/><anchor xreflabel="Packaging
an applet into a JAR file" xml:id="_Toc481064831"/>Packaging an applet into a JAR file</title>
      <para>An important use of the JAR utility is to optimize applet loading. In Java 1.0, people tended to try to cram all their code into a single applet class so the client would need only a single server hit to download the applet code. Not only did this result in messy, hard to read (and maintain) programs, but the <emphasis role="bold">.class</emphasis> file was still uncompressed so downloading wasn�t as fast as it could have been.</para>
      <para>JAR files solve the problem by compressing all of your <emphasis role="bold">.class</emphasis> files into a single file that is downloaded by the browser. Now you can create the right design without worrying about how many <emphasis role="bold">.class </emphasis>files it will generate, and the user will get a much faster download time.</para>
      <para>Consider <emphasis role="bold">TicTacToe.java</emphasis>. It looks like a single class, but in fact it contains five inner classes, so that�s six in all. Once you�ve compiled the program, you package it into a JAR file with the line:</para>
      <para>jar cf TicTacToe.jar *.class</para>
      <para> </para>
      <para>This assumes that the only <emphasis role="bold">.class</emphasis> files in the current directory are the ones from <emphasis role="bold">TicTacToe.</emphasis><emphasis role="bold">java</emphasis> (otherwise you�ll get extra baggage).</para>
      <para>Now you can create an HTML page with the new <emphasis role="bold">archive</emphasis> tag to indicate the name of the JAR file. Here is the tag using the old form of the HTML tag, as an illustration:</para>
      <para>&lt;head&gt;&lt;title&gt;<emphasis role="bold">TicTacToe</emphasis> Example Applet</para>
      <para>&lt;/title&gt;&lt;/head&gt;</para>
      <para>&lt;body&gt;</para>
      <para>&lt;applet code=<emphasis role="bold">TicTacToe</emphasis>.class</para>
      <para>������� archive=<emphasis role="bold">TicTacToe</emphasis>.jar</para>
      <para>������� width=200 height=100&gt;</para>
      <para>&lt;/applet&gt;</para>
      <para>&lt;/body&gt;</para>
      <para> </para>
      <para>You�ll need to put it into the new (messy, complicated) form shown earlier in the chapter in order to get it to work.</para>
    </section>
    <section>
      <title><anchor xreflabel="Programming techniques" xml:id="_Toc481064832"/>Programming techniques</title>
      <para>Because GUI programming in Java has been an evolving technology with some very significant changes between Java 1.0/1.1 and the Swing library in Java 2, there have been some old programming idioms that have seeped through to examples that you might see given for Swing. In addition, Swing allows you to program in more and better ways than were allowed by the old models. In this section, some of these issues will be demonstrated by introducing and examining some programming idioms.</para>
      <section>
        <title><anchor xreflabel="Binding events dynamically" xml:id="_Toc481064833"/>Binding events dynamically</title>
        <para>One of the benefits of the Swing event model is flexibility. You can add and remove event behavior with single method calls. The following example demonstrates this:</para>
        <para>//: c13:DynamicEvents.java</para>
        <para>// You can change event behavior dynamically.</para>
        <para>// Also shows multiple actions for an event.</para>
        <para>// &lt;applet code=DynamicEvents</para>
        <para>//� width=250 height=400&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class DynamicEvents extends JApplet {</para>
        <para>� ArrayList v = new ArrayList();</para>
        <para>� int i = 0;</para>
        <para>� JButton</para>
        <para>��� b1 = new JButton(&quot;Button1&quot;),</para>
        <para>��� b2 = new JButton(&quot;Button2&quot;);</para>
        <para>� JTextArea txt = new JTextArea();</para>
        <para>� class B implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� txt.append(&quot;A button was pressed\n&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class CountListener implements ActionListener {</para>
        <para>��� int index;</para>
        <para>��� public CountListener(int i) { index = i; }</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� txt.append(&quot;Counted Listener &quot;+index+&quot;\n&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class B1 implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� txt.append(&quot;Button 1 pressed\n&quot;);</para>
        <para>����� ActionListener a = new CountListener(i++);</para>
        <para>����� v.add(a);</para>
        <para>����� b2.addActionListener(a);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class B2 implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� txt.append(&quot;Button2 pressed\n&quot;);</para>
        <para>����� int end = v.size() - 1;</para>
        <para>����� if(end &gt;= 0) {</para>
        <para>������� b2.removeActionListener(</para>
        <para>��������� (ActionListener)v.get(end));</para>
        <para>������� v.remove(end);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� b1.addActionListener(new B());</para>
        <para>��� b1.addActionListener(new B1());</para>
        <para>��� b2.addActionListener(new B());</para>
        <para>��� b2.addActionListener(new B2());</para>
        <para>��� JPanel p = new JPanel();</para>
        <para>��� p.add(b1);</para>
        <para>��� p.add(b2);</para>
        <para>��� cp.add(BorderLayout.NORTH, p);</para>
        <para>��� cp.add(new JScrollPane(txt));</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new DynamicEvents(), 250, 400);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The new twists in this example are: </para>
        <para>There is more than one listener attached to each <emphasis role="bold">Button</emphasis>. Usually, components handle events as <emphasis role="italic">multicast</emphasis>, meaning that you can register many listeners for a single event. In the special components in which an event is handled as <emphasis role="italic">unicast</emphasis>, you�ll get a <emphasis role="bold">TooManyListenersException</emphasis>.</para>
        <para>92.      During the execution of the program, listeners are dynamically added and removed from the <emphasis role="bold">Button b2</emphasis>. Adding is accomplished in the way you�ve seen before, but each component also has a <emphasis role="bold">removeXXXListener( )</emphasis> method to remove each type of listener.</para>
        <para>This kind of flexibility provides much greater power in your programming.</para>
        <para>You should notice that event listeners are not guaranteed to be called in the order they are added (although most implementations do in fact work that way).</para>
      </section>
      <section>
        <title><anchor xreflabel="Separating business logic 
from UI logic" xml:id="_Toc481064834"/>Separating business logic   from UI logic</title>
        <para>In general you�ll want to design your classes so that each one does �only one thing.� This is particularly important when user-interface code is concerned, since it�s easy to tie up �what you�re doing� with �how you�re displaying it.� This kind of coupling prevents code reuse. It�s much more desirable to separate your �business logic� from the GUI. This way, you can not only reuse the business logic more easily, it�s also easier to reuse the GUI.</para>
        <para>Another issue is <emphasis role="italic">multitiered</emphasis> systems, where the �business objects� reside on a completely separate machine. This central location of the business rules allows changes to be instantly effective for all new transactions, and is thus a compelling way to set up a system. However, these business objects can be used in many different applications and so should not be tied to any particular mode of display. They should just perform the business operations and nothing more.</para>
        <para>The following example shows how easy it is to separate the business logic from the GUI code:</para>
        <para>//: c13:Separation.java</para>
        <para>// Separating GUI logic and business objects.</para>
        <para>// &lt;applet code=Separation</para>
        <para>// width=250 height=150&gt; &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import javax.swing.event.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.applet.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>class BusinessLogic {</para>
        <para>� private int modifier;</para>
        <para>� public BusinessLogic(int mod) {</para>
        <para>��� modifier = mod;</para>
        <para>� }</para>
        <para>� public void setModifier(int mod) {</para>
        <para>��� modifier = mod;</para>
        <para>� }</para>
        <para>� public int getModifier() {</para>
        <para>��� return modifier;</para>
        <para>� }</para>
        <para>� // Some business operations:</para>
        <para>� public int calculation1(int arg) {</para>
        <para>��� return arg * modifier;</para>
        <para>� }</para>
        <para>� public int calculation2(int arg) {</para>
        <para>��� return arg + modifier;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Separation extends JApplet {</para>
        <para>� JTextField </para>
        <para>��� t = new JTextField(15),</para>
        <para>��� mod = new JTextField(15);</para>
        <para>� BusinessLogic bl = new BusinessLogic(2);</para>
        <para>� JButton</para>
        <para>��� calc1 = new JButton(&quot;Calculation 1&quot;),</para>
        <para>��� calc2 = new JButton(&quot;Calculation 2&quot;);</para>
        <para>� static int getValue(JTextField tf) {</para>
        <para>��� try {</para>
        <para>����� return Integer.parseInt(tf.getText());</para>
        <para>��� } catch(NumberFormatException e) {</para>
        <para>����� return 0;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class Calc1L implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� t.setText(Integer.toString(</para>
        <para>������� bl.calculation1(getValue(t))));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class Calc2L implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� t.setText(Integer.toString(</para>
        <para>������� bl.calculation2(getValue(t))));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� // If you want something to happen whenever</para>
        <para>� // a JTextField changes, add this listener:</para>
        <para>� class ModL implements DocumentListener {</para>
        <para>��� public void changedUpdate(DocumentEvent e) {}</para>
        <para>��� public void insertUpdate(DocumentEvent e) {</para>
        <para>����� bl.setModifier(getValue(mod));</para>
        <para>��� }</para>
        <para>��� public void removeUpdate(DocumentEvent e) {</para>
        <para>����� bl.setModifier(getValue(mod));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(t);</para>
        <para>��� calc1.addActionListener(new Calc1L());</para>
        <para>��� calc2.addActionListener(new Calc2L());</para>
        <para>��� JPanel p1 = new JPanel();</para>
        <para>��� p1.add(calc1); </para>
        <para>��� p1.add(calc2);</para>
        <para>��� cp.add(p1);</para>
        <para>��� mod.getDocument().</para>
        <para>����� addDocumentListener(new ModL());</para>
        <para>��� JPanel p2 = new JPanel();</para>
        <para>��� p2.add(new JLabel(&quot;Modifier:&quot;));</para>
        <para>��� p2.add(mod);</para>
        <para>��� cp.add(p2);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Separation(), 250, 100);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can see that <emphasis role="bold">BusinessLogic</emphasis> is a straightforward class that performs its operations without even a hint that it might be used in a GUI environment. It just does its job.</para>
        <para><emphasis role="bold">Separation</emphasis> keeps track of all the UI details, and it talks to <emphasis role="bold">BusinessLogic</emphasis> only through its <emphasis role="bold">public</emphasis> interface. All the operations are centered around getting information back and forth through the UI and the <emphasis role="bold">BusinessLogic</emphasis> object. So <emphasis role="bold">Separation</emphasis>, in turn, just does its job. Since <emphasis role="bold">Separation</emphasis> knows only that it�s talking to a <emphasis role="bold">BusinessLogic</emphasis> object (that is, it isn�t highly coupled), it could be massaged into talking to other types of objects without much trouble.</para>
        <para>Thinking in terms of separating UI from business logic also makes life easier when you�re adapting legacy code to work with Java.</para>
      </section>
      <section>
        <title><anchor xreflabel="A canonical form" xml:id="_Toc481064835"/>A canonical form</title>
        <para>Inner classes, the Swing event model, and the fact that the old event model is still supported along with new library features that rely on old-style programming has added a new element of confusion to the code design process. Now there are even more different ways for people to write unpleasant code. </para>
        <para>Except in extenuating circumstances you can always use the simplest and clearest approach: listener classes (typically written as inner classes) to solve your event-handling needs. This is the form used in most of the examples in this chapter.</para>
        <para>By following this model you should be able to reduce the statements in your programs that say: �I wonder what caused this event.� Each piece of code is concerned with <emphasis role="italic">doing</emphasis>, not type-checking. This is the best way to write your code; not only is it easier to conceptualize, but much easier to read and maintain.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Visual programming 
and Beans" xml:id="_Toc481064836"/>Visual programming   and Beans</title>
      <para>So far in this book you�ve seen how valuable Java is for creating reusable pieces of code. The �most reusable� unit of code has been the class, since it comprises a cohesive unit of characteristics (fields) and behaviors (methods) that can be reused either directly via composition or through inheritance.</para>
      <para>Inheritance and polymorphism are essential parts of object-oriented programming, but in the majority of cases when you�re putting together an application, what you really want is components that do exactly what you need. You�d like to drop these parts into your design like the electronic engineer puts together chips on a circuit board. It seems, too, that there should be some way to accelerate this �modular assembly� style of programming.</para>
      <para>�Visual programming� first became successful�<emphasis role="italic">very</emphasis> successful�with Microsoft�s Visual Basic (VB), followed by a second-generation design in Borland�s Delphi (the primary inspiration for the JavaBeans design). With these programming tools the components are represented visually, which makes sense since they usually display some kind of visual component such as a button or a text field. The visual representation, in fact, is often exactly the way the component will look in the running program. So part of the process of visual programming involves dragging a component from a palette and dropping it onto your form. The application builder tool writes code as you do this, and that code will cause the component to be created in the running program.</para>
      <para>Simply dropping the component onto a form is usually not enough to complete the program. Often, you must change the characteristics of a component, such as what color it is, what text is on it, what database it�s connected to, etc. Characteristics that can be modified at design time are referred to as <emphasis role="italic">properties</emphasis>. You can manipulate the properties of your component inside the application builder tool, and when you create the program this configuration data is saved so that it can be rejuvenated when the program is started.</para>
      <para>By now you�re probably used to the idea that an object is more than characteristics; it�s also a set of behaviors. At design-time, the behaviors of a visual component are partially represented by <emphasis role="italic">events</emphasis>, meaning �Here�s something that can happen to the component.� Ordinarily, you decide what you want to happen when an event occurs by tying code to that event.</para>
      <para>Here�s the critical part: the application builder tool uses reflection to dynamically interrogate the component and find out which properties and events the component supports. Once it knows what they are, it can display the properties and allow you to change those (saving the state when you build the program), and also display the events. In general, you do something like double-clicking on an event and the application builder tool creates a code body and ties it to that particular event. All you have to do at that point is write the code that executes when the event occurs.</para>
      <para>All this adds up to a lot of work that�s done for you by the application builder tool. As a result you can focus on what the program looks like and what it is supposed to do, and rely on the application builder tool to manage the connection details for you. The reason that visual programming tools have been so successful is that they dramatically speed up the process of building an application�certainly the user interface, but often other portions of the application as well.</para>
      <section>
        <title><anchor xreflabel="What is a Bean?" xml:id="_Toc481064837"/>What is a Bean?</title>
        <para>After the dust settles, then, a component is really just a block of code, typically embodied in a class. The key issue is the ability for the application builder tool to discover the properties and events for that component. To create a VB component, the programmer had to write a fairly complicated piece of code following certain conventions to expose the properties and events. Delphi was a second-generation visual programming tool and the language was actively designed around visual programming so it is much easier to create a visual component. However, Java has brought the creation of visual components to its most advanced state with JavaBeans, because a Bean is just a class. You don�t have to write any extra code or use special language extensions in order to make something a Bean. The only thing you need to do, in fact, is slightly modify the way that you name your methods. It is the method name that tells the application builder tool whether this is a property, an event, or just an ordinary method.</para>
        <para>In the Java documentation, this naming convention is mistakenly termed a �design pattern.� This is unfortunate, since design patterns (see <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis>) are challenging enough without this sort of confusion. It�s not a design pattern, it�s just a naming convention and it�s fairly simple:</para>
        <para>For a property named <emphasis role="bold">xxx</emphasis>, you typically create two methods: <emphasis role="bold">getXxx( )</emphasis> and <emphasis role="bold">setXxx( )</emphasis>. Note that the first letter after �get� or �set� is automatically lowercased to produce the property name. The type produced by the �get� method is the same as the type of the argument to the �set� method. The name of the property and the type for the �get� and �set� are not related.</para>
        <para>93.      For a <emphasis role="bold">boolean</emphasis> property, you can use the �get� and �set� approach above, but you can also use �is� instead of �get.�</para>
        <para>94.      Ordinary methods of the Bean don�t conform to the above naming convention, but they�re <emphasis role="bold">public</emphasis>.</para>
        <para>95.      For events, you use the Swing �listener� approach. It�s exactly the same as you�ve been seeing: <emphasis role="bold">addFooBarListener(FooBarListener)</emphasis> and <emphasis role="bold">removeFooBarListener(FooBarListener)</emphasis> to handle a <emphasis role="bold">FooBarEvent</emphasis>. Most of the time the built-in events and listeners will satisfy your needs, but you can also create your own events and listener interfaces.</para>
        <para>Point 1 above answers a question about something you might have noticed when looking at older code vs. newer code: a number of method names have had small, apparently meaningless name changes. Now you can see that most of those changes had to do with adapting to the �get� and �set� naming conventions in order to make that particular component into a Bean.</para>
        <para>We can use these guidelines to create a simple Bean:</para>
        <para>//: frogbean:Frog.java</para>
        <para>// A trivial JavaBean.</para>
        <para>package frogbean;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para> </para>
        <para>class Spots {}</para>
        <para> </para>
        <para>public class Frog {</para>
        <para>� private int jumps;</para>
        <para>� private Color color;</para>
        <para>� private Spots spots;</para>
        <para>� private boolean jmpr;</para>
        <para>� public int getJumps() { return jumps; }</para>
        <para>� public void setJumps(int newJumps) { </para>
        <para>��� jumps = newJumps;</para>
        <para>� }</para>
        <para>� public Color getColor() { return color; }</para>
        <para>� public void setColor(Color newColor) { </para>
        <para>��� color = newColor; </para>
        <para>� }</para>
        <para>� public Spots getSpots() { return spots; }</para>
        <para>� public void setSpots(Spots newSpots) {</para>
        <para>��� spots = newSpots; </para>
        <para>� }</para>
        <para>� public boolean isJumper() { return jmpr; }</para>
        <para>� public void setJumper(boolean j) { jmpr = j; }</para>
        <para>� public void addActionListener(</para>
        <para>����� ActionListener l) {</para>
        <para>��� //...</para>
        <para>� }</para>
        <para>� public void removeActionListener(</para>
        <para>����� ActionListener l) {</para>
        <para>��� // ...</para>
        <para>� }</para>
        <para>� public void addKeyListener(KeyListener l) {</para>
        <para>��� // ...</para>
        <para>� }</para>
        <para>� public void removeKeyListener(KeyListener l) {</para>
        <para>��� // ...</para>
        <para>� }</para>
        <para>� // An &quot;ordinary&quot; public method:</para>
        <para>� public void croak() {</para>
        <para>��� System.out.println(&quot;Ribbet!&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>First, you can see that it�s just a class. Usually, all your fields will be <emphasis role="bold">private</emphasis>, and accessible only through methods. Following the naming convention, the properties are <emphasis role="bold">jumps</emphasis>, <emphasis role="bold">color</emphasis>, <emphasis role="bold">spots</emphasis>, and <emphasis role="bold">jumper</emphasis> (notice the case change of the first letter in the property name). Although the name of the internal identifier is the same as the name of the property in the first three cases, in <emphasis role="bold">jumper</emphasis> you can see that the property name does not force you to use any particular identifier for internal variables (or, indeed, to even <emphasis role="italic">have</emphasis> any internal variables for that property).</para>
        <para>The events this Bean handles are <emphasis role="bold">ActionEvent</emphasis> and <emphasis role="bold">KeyEvent</emphasis>, based on the naming of the �add� and �remove� methods for the associated listener. Finally, you can see that the ordinary method <emphasis role="bold">croak( )</emphasis> is still part of the Bean simply because it�s a <emphasis role="bold">public</emphasis> method, not because it conforms to any naming scheme.</para>
      </section>
      <section>
        <title><anchor xreflabel="Extracting BeanInfo
with the Introspector" xml:id="_Toc481064838"/>Extracting <emphasis role="bold">BeanInfo</emphasis>  with the <emphasis role="bold">Introspector</emphasis></title>
        <para>One of the most critical parts of the Bean scheme occurs when you drag a Bean off a palette and plop it onto a form. The application builder tool must be able to create the Bean (which it can do if there�s a default constructor) and then, without access to the Bean�s source code, extract all the necessary information to create the property sheet and event handlers.</para>
        <para>Part of the solution is already evident from the end of Chapter 12: Java <emphasis role="italic">reflection</emphasis> allows all the methods of an anonymous class to be discovered. This is perfect for solving the Bean problem without requiring you to use any extra language keywords like those required in other visual programming languages. In fact, one of the prime reasons that reflection was added to Java was to support Beans (although reflection also supports object serialization and remote method invocation). So you might expect that the creator of the application builder tool would have to reflect each Bean and hunt through its methods to find the properties and events for that Bean.</para>
        <para>This is certainly possible, but the Java designers wanted to provide a standard tool, not only to make Beans simpler to use but also to provide a standard gateway to the creation of more complex Beans. This tool is the <emphasis role="bold">Introspector</emphasis> class, and the most important method in this class is the <emphasis role="bold">static </emphasis><emphasis role="bold">getBeanInfo( )</emphasis>. You pass a <emphasis role="bold">Class</emphasis> reference to this method and it fully interrogates that class and returns a <emphasis role="bold">BeanInfo</emphasis> object that you can then dissect to find properties, methods, and events.</para>
        <para>Usually you won�t care about any of this�you�ll probably get most of your Beans off the shelf from vendors, and you don�t need to know all the magic that�s going on underneath. You�ll simply drag your Beans onto your form, then configure their properties and write handlers for the events you�re interested in. However, it�s an interesting and educational exercise to use the <emphasis role="bold">Introspector</emphasis> to display information about a Bean, so here�s a tool that does it:</para>
        <para>//: c13:BeanDumper.java</para>
        <para>// Introspecting a Bean.</para>
        <para>// &lt;applet code=BeanDumper width=600 height=500&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import java.beans.*;</para>
        <para>import java.lang.reflect.*;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class BeanDumper extends JApplet {</para>
        <para>� JTextField query = </para>
        <para>��� new JTextField(20);</para>
        <para>� JTextArea results = new JTextArea();</para>
        <para>� public void prt(String s) {</para>
        <para>��� results.append(s + &quot;\n&quot;);</para>
        <para>� }</para>
        <para>� public void dump(Class bean){</para>
        <para>��� results.setText(&quot;&quot;);</para>
        <para>��� BeanInfo bi = null;</para>
        <para>��� try {</para>
        <para>����� bi = Introspector.getBeanInfo(</para>
        <para>������� bean, java.lang.Object.class);</para>
        <para>��� } catch(IntrospectionException e) {</para>
        <para>����� prt(&quot;Couldn&apos;t introspect &quot; + </para>
        <para>������� bean.getName());</para>
        <para>����� return;</para>
        <para>��� }</para>
        <para>��� PropertyDescriptor[] properties = </para>
        <para>����� bi.getPropertyDescriptors();</para>
        <para>��� for(int i = 0; i &lt; properties.length; i++) {</para>
        <para>����� Class p = properties[i].getPropertyType();</para>
        <para>����� prt(&quot;Property type:\n� &quot; + p.getName() +</para>
        <para>������� &quot;Property name:\n� &quot; + </para>
        <para>������� properties[i].getName());</para>
        <para>����� Method readMethod = </para>
        <para>� ������properties[i].getReadMethod();</para>
        <para>����� if(readMethod != null)</para>
        <para>������� prt(&quot;Read method:\n� &quot; + readMethod);</para>
        <para>����� Method writeMethod = </para>
        <para>������� properties[i].getWriteMethod();</para>
        <para>����� if(writeMethod != null)</para>
        <para>������� prt(&quot;Write method:\n� &quot; + writeMethod);</para>
        <para>����� prt(&quot;====================&quot;);</para>
        <para>��� }</para>
        <para>��� prt(&quot;Public methods:&quot;);</para>
        <para>��� MethodDescriptor[] methods =</para>
        <para>����� bi.getMethodDescriptors();</para>
        <para>��� for(int i = 0; i &lt; methods.length; i++)</para>
        <para>����� prt(methods[i].getMethod().toString());</para>
        <para>��� prt(&quot;======================&quot;);</para>
        <para>��� prt(&quot;Event support:&quot;);</para>
        <para>��� EventSetDescriptor[] events = </para>
        <para>����� bi.getEventSetDescriptors();</para>
        <para>��� for(int i = 0; i &lt; events.length; i++) {</para>
        <para>����� prt(&quot;Listener type:\n� &quot; +</para>
        <para>������� events[i].getListenerType().getName());</para>
        <para>����� Method[] lm = </para>
        <para>����� ��events[i].getListenerMethods();</para>
        <para>����� for(int j = 0; j &lt; lm.length; j++)</para>
        <para>������� prt(&quot;Listener method:\n� &quot; +</para>
        <para>��������� lm[j].getName());</para>
        <para>����� MethodDescriptor[] lmd = </para>
        <para>������� events[i].getListenerMethodDescriptors();</para>
        <para>����� for(int j = 0; j &lt; lmd.length; j++)</para>
        <para>������� prt(&quot;Method descriptor:\n� &quot; +</para>
        <para>��������� lmd[j].getMethod());</para>
        <para>����� Method addListener = </para>
        <para>������� events[i].getAddListenerMethod();</para>
        <para>����� prt(&quot;Add Listener Method:\n� &quot; +</para>
        <para>��������� addListener);</para>
        <para>����� Method removeListener =</para>
        <para>������� events[i].getRemoveListenerMethod();</para>
        <para>����� prt(&quot;Remove Listener Method:\n� &quot; +</para>
        <para>������� removeListener);</para>
        <para>����� prt(&quot;====================&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class Dumper implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� String name = query.getText();</para>
        <para>����� Class c = null;</para>
        <para>����� try {</para>
        <para>������� c = Class.forName(name);</para>
        <para>����� } catch(ClassNotFoundException ex) {</para>
        <para>������� results.setText(&quot;Couldn&apos;t find &quot; + name);</para>
        <para>������� return;</para>
        <para>����� }</para>
        <para>����� dump(c);</para>
        <para>��� }</para>
        <para>� }����� </para>
        <para>� public void init() {</para>
        <para>�� �Container cp = getContentPane();</para>
        <para>��� JPanel p = new JPanel();</para>
        <para>��� p.setLayout(new FlowLayout());</para>
        <para>��� p.add(new JLabel(&quot;Qualified bean name:&quot;));</para>
        <para>��� p.add(query);</para>
        <para>��� cp.add(BorderLayout.NORTH, p);</para>
        <para>��� cp.add(new JScrollPane(results));</para>
        <para>��� Dumper dmpr = new Dumper();</para>
        <para>��� query.addActionListener(dmpr);</para>
        <para>��� query.setText(&quot;frogbean.Frog&quot;);</para>
        <para>��� // Force evaluation</para>
        <para>��� dmpr.actionPerformed(</para>
        <para>����� new ActionEvent(dmpr, 0, &quot;&quot;));</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new BeanDumper(), 600, 500);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">BeanDumper.dump( )</emphasis> is the method that does all the work. First it tries to create a <emphasis role="bold">BeanInfo</emphasis> object, and if successful calls the methods of <emphasis role="bold">BeanInfo</emphasis> that produce information about properties, methods, and events. In <emphasis role="bold">Introspector.getBeanInfo( )</emphasis>, you�ll see there is a second argument. This tells the <emphasis role="bold">Introspector</emphasis> where to stop in the inheritance hierarchy. Here, it stops before it parses all the methods from <emphasis role="bold">Object</emphasis>, since we�re not interested in seeing those.</para>
        <para>For properties, <emphasis role="bold">getPropertyDescriptors( )</emphasis> returns an array of <emphasis role="bold">PropertyDescriptor</emphasis>s. For each <emphasis role="bold">PropertyDescriptor</emphasis> you can call <emphasis role="bold">getPropertyType( )</emphasis> to find the class of object that is passed in and out via the property methods. Then, for each property you can get its pseudonym (extracted from the method names) with <emphasis role="bold">getName( )</emphasis>, the method for reading with <emphasis role="bold">getReadMethod( )</emphasis>, and the method for writing with <emphasis role="bold">getWriteMethod( )</emphasis>. These last two methods return a <emphasis role="bold">Method</emphasis> object that can actually be used to invoke the corresponding method on the object (this is part of reflection).</para>
        <para>For the <emphasis role="bold">public</emphasis> methods (including the property methods), <emphasis role="bold">getMethodDescriptors( )</emphasis> returns an array of <emphasis role="bold">MethodDescriptor</emphasis>s. For each one you can get the associated <emphasis role="bold">Method</emphasis> object and print its name.</para>
        <para>For the events, <emphasis role="bold">getEventSetDescriptors( )</emphasis> returns an array of (what else?) <emphasis role="bold">EventSetDescriptor</emphasis>s. Each of these can be queried to find out the class of the listener, the methods of that listener class, and the add- and remove-listener methods. The <emphasis role="bold">BeanDumper </emphasis>program prints out all of this information.</para>
        <para>Upon startup, the program forces the evaluation of <emphasis role="bold">frogbean.Frog</emphasis>. The output, after removing extra details that are unnecessary here, is:</para>
        <para>class name: Frog</para>
        <para>Property type:</para>
        <para>� Color</para>
        <para>Property name:</para>
        <para>� color</para>
        <para>Read method:</para>
        <para>� public Color getColor()</para>
        <para>Write method:</para>
        <para>� public void setColor(Color)</para>
        <para>====================</para>
        <para>Property type:</para>
        <para>� Spots</para>
        <para>Property name:</para>
        <para>� spots</para>
        <para>Read method:</para>
        <para>� public Spots getSpots()</para>
        <para>Write method:</para>
        <para>� public void setSpots(Spots)</para>
        <para>====================</para>
        <para>Property type:</para>
        <para>� boolean</para>
        <para>Property name:</para>
        <para>� jumper</para>
        <para>Read method:</para>
        <para>� public boolean isJumper()</para>
        <para>Write method:</para>
        <para>� public void setJumper(boolean)</para>
        <para>====================</para>
        <para>Property type:</para>
        <para>� int</para>
        <para>Property name:</para>
        <para>� jumps</para>
        <para>Read method:</para>
        <para>� public int getJumps()</para>
        <para>Write method:</para>
        <para>� public void setJumps(int)</para>
        <para>====================</para>
        <para>Public methods:</para>
        <para>public void setJumps(int)</para>
        <para>public void croak()</para>
        <para>public void removeActionListener(ActionListener)</para>
        <para>public void addActionListener(ActionListener)</para>
        <para>public int getJumps()</para>
        <para>public void setColor(Color)</para>
        <para>public void setSpots(Spots)</para>
        <para>public void setJumper(boolean)</para>
        <para>public boolean isJumper()</para>
        <para>public void addKeyListener(KeyListener)</para>
        <para>public Color getColor()</para>
        <para>public void removeKeyListener(KeyListener)</para>
        <para>public Spots getSpots()</para>
        <para>======================</para>
        <para>Event support:</para>
        <para>Listener type:</para>
        <para>� KeyListener</para>
        <para>Listener method:</para>
        <para>� keyTyped</para>
        <para>Listener method:</para>
        <para>� keyPressed</para>
        <para>Listener method:</para>
        <para>� keyReleased</para>
        <para>Method descriptor:</para>
        <para>� public void keyTyped(KeyEvent)</para>
        <para>Method descriptor:</para>
        <para>� public void keyPressed(KeyEvent)</para>
        <para>Method descriptor:</para>
        <para>� public void keyReleased(KeyEvent)</para>
        <para>Add Listener Method:</para>
        <para>� public void addKeyListener(KeyListener)</para>
        <para>Remove Listener Method:</para>
        <para>� public void removeKeyListener(KeyListener)</para>
        <para>====================</para>
        <para>Listener type:</para>
        <para>� ActionListener</para>
        <para>Listener method:</para>
        <para>� actionPerformed</para>
        <para>Method descriptor:</para>
        <para>� public void actionPerformed(ActionEvent)</para>
        <para>Add Listener Method:</para>
        <para>� public void addActionListener(ActionListener)</para>
        <para>Remove Listener Method:</para>
        <para>� public void removeActionListener(ActionListener)</para>
        <para>====================</para>
        <para> </para>
        <para>This reveals most of what the <emphasis role="bold">Introspector</emphasis> sees as it produces a <emphasis role="bold">BeanInfo</emphasis> object from your Bean. You can see that the type of the property and its name are independent. Notice the lowercasing of the property name. (The only time this doesn�t occur is when the property name begins with more than one capital letter in a row.) And remember that the method names you�re seeing here (such as the read and write methods) are actually produced from a <emphasis role="bold">Method</emphasis> object that can be used to invoke the associated method on the object.</para>
        <para>The <emphasis role="bold">public</emphasis> method list includes the methods that are not associated with a property or event, such as <emphasis role="bold">croak( )</emphasis>, as well as those that are. These are all the methods that you can call programmatically for a Bean, and the application builder tool can choose to list all of these while you�re making method calls, to ease your task.</para>
        <para>Finally, you can see that the events are fully parsed out into the listener, its methods, and the add- and remove-listener methods. Basically, once you have the <emphasis role="bold">BeanInfo</emphasis>, you can find out everything of importance for the Bean. You can also call the methods for that Bean, even though you don�t have any other information except the object (again, a feature of reflection).</para>
      </section>
      <section>
        <title><anchor xreflabel="A more sophisticated Bean" xml:id="_Toc481064839"/>A more sophisticated Bean</title>
        <para>This next example is slightly more sophisticated, albeit frivolous. It�s a <emphasis role="bold">JPanel</emphasis> that draws a little circle around the mouse whenever the mouse is moved. When you press the mouse, the word �Bang!� appears in the middle of the screen, and an action listener is fired.</para>
        <para>The properties you can change are the size of the circle as well as the color, size, and text of the word that is displayed when you press the mouse. A <emphasis role="bold">BangBean</emphasis> also has its own <emphasis role="bold">addActionListener( )</emphasis> and <emphasis role="bold">removeActionListener( )</emphasis> so you can attach your own listener that will be fired when the user clicks on the <emphasis role="bold">BangBean</emphasis>. You should be able to recognize the property and event support:</para>
        <para>//: bangbean:BangBean.java</para>
        <para>// A graphical Bean.</para>
        <para>package bangbean;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.io.*;</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class BangBean extends JPanel</para>
        <para>���� implements Serializable {</para>
        <para>��protected int xm, ym;</para>
        <para>� protected int cSize = 20; // Circle size</para>
        <para>� protected String text = &quot;Bang!&quot;;</para>
        <para>� protected int fontSize = 48;</para>
        <para>� protected Color tColor = Color.red;</para>
        <para>� protected ActionListener actionListener;</para>
        <para>� public BangBean() {</para>
        <para>��� addMouseListener(new ML());</para>
        <para>��� addMouseMotionListener(new MML());</para>
        <para>� }</para>
        <para>� public int getCircleSize() { return cSize; }</para>
        <para>� public void setCircleSize(int newSize) {</para>
        <para>��� cSize = newSize;</para>
        <para>� }</para>
        <para>� public String getBangText() { return text; }</para>
        <para>� public void setBangText(String newText) {</para>
        <para>��� text = newText;</para>
        <para>� }</para>
        <para>� public int getFontSize() { return fontSize; }</para>
        <para>� public void setFontSize(int newSize) {</para>
        <para>��� fontSize = newSize;</para>
        <para>� }</para>
        <para>� public Color getTextColor() { return tColor; }</para>
        <para>� public void setTextColor(Color newColor) {</para>
        <para>��� tColor = newColor;</para>
        <para>� }</para>
        <para>� public void paintComponent(Graphics g) {</para>
        <para>��� super.paintComponent(g);</para>
        <para>��� g.setColor(Color.black);</para>
        <para>��� g.drawOval(xm - cSize/2, ym - cSize/2, </para>
        <para>����� cSize, cSize);</para>
        <para>� }</para>
        <para>� // This is a unicast listener, which is</para>
        <para>� // the simplest form of listener management:</para>
        <para>� public void addActionListener (</para>
        <para>����� ActionListener l) </para>
        <para>������� throws TooManyListenersException {</para>
        <para>��� if(actionListener != null)</para>
        <para>����� throw new TooManyListenersException();</para>
        <para>��� actionListener = l;</para>
        <para>� }</para>
        <para>� public void removeActionListener(</para>
        <para>����� ActionListener l) {</para>
        <para>��� actionListener = null;</para>
        <para>� }</para>
        <para>� class ML extends MouseAdapter {</para>
        <para>��� public void mousePressed(MouseEvent e) {</para>
        <para>����� Graphics g = getGraphics();</para>
        <para>����� g.setColor(tColor);</para>
        <para>����� g.setFont(</para>
        <para>������� new Font(</para>
        <para>��������� &quot;TimesRoman&quot;, Font.BOLD, fontSize));</para>
        <para>����� int width = </para>
        <para>������� g.getFontMetrics().stringWidth(text);</para>
        <para>����� g.drawString(text, </para>
        <para>������� (getSize().width - width) /2,</para>
        <para>������� getSize().height/2);</para>
        <para>����� g.dispose();</para>
        <para>����� // Call the listener&apos;s method:</para>
        <para>����� if(actionListener != null)</para>
        <para>������� actionListener.actionPerformed(</para>
        <para>��������� new ActionEvent(BangBean.this,</para>
        <para>����������� ActionEvent.ACTION_PERFORMED, null));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class MML extends MouseMotionAdapter {</para>
        <para>��� public void mouseMoved(MouseEvent e) {</para>
        <para>����� xm = e.getX();</para>
        <para>����� ym = e.getY();</para>
        <para>����� repaint();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public Dimension getPreferredSize() {</para>
        <para>��� return new Dimension(200, 200);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The first thing you�ll notice is that <emphasis role="bold">BangBean</emphasis> implements the <emphasis role="bold">Serializable</emphasis> interface. This means that the application builder tool can �pickle� all the information for the <emphasis role="bold">BangBean</emphasis> using serialization after the program designer has adjusted the values of the properties. When the Bean is created as part of the running application, these �pickled� properties are restored so that you get exactly what you designed.</para>
        <para>You can see that all the fields are <emphasis role="bold">private</emphasis>, which is what you�ll usually do with a Bean�allow access only through methods, usually using the �property� scheme.</para>
        <para>When you look at the signature for <emphasis role="bold">addActionListener( )</emphasis>, you�ll see that it can throw a <emphasis role="bold">TooManyListenersException</emphasis>. This indicates that it is <emphasis role="italic">unicast</emphasis>, which means it notifies only one listener when the event occurs. Ordinarily, you�ll use <emphasis role="italic">multicast</emphasis> events so that many listeners can be notified of an event. However, that runs into issues that you won�t be ready for until the next chapter, so it will be revisited there (under the heading �JavaBeans revisited�). A unicast event sidesteps the problem.</para>
        <para>When you click the mouse, the text is put in the middle of the <emphasis role="bold">BangBean</emphasis>, and if the <emphasis role="bold">actionListener</emphasis> field is not <emphasis role="bold">null</emphasis>, its <emphasis role="bold">actionPerformed( )</emphasis> is called, creating a new <emphasis role="bold">ActionEvent </emphasis>object in the process. Whenever the mouse is moved, its new coordinates are captured and the canvas is repainted (erasing any text that�s on the canvas, as you�ll see).</para>
        <para>Here is the <emphasis role="bold">BangBeanTest</emphasis> class to allow you to test the bean as either an applet or an application:</para>
        <para>//: c13:BangBeanTest.java</para>
        <para>// &lt;applet code=BangBeanTest </para>
        <para>// width=400 height=500&gt;&lt;/applet&gt;</para>
        <para>import bangbean.*;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class BangBeanTest extends JApplet {</para>
        <para>� JTextField txt = new JTextField(20);</para>
        <para>� // During testing, report actions:</para>
        <para>� class BBL implements ActionListener {</para>
        <para>��� int count = 0;</para>
        <para>��� public void actionPerformed(ActionEvent e){</para>
        <para>����� txt.setText(&quot;BangBean action &quot;+ count++);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� BangBean bb = new BangBean();</para>
        <para>��� try {</para>
        <para>����� bb.addActionListener(new BBL());</para>
        <para>��� } catch(TooManyListenersException e) {</para>
        <para>����� txt.setText(&quot;Too many listeners&quot;);</para>
        <para>��� }</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(bb);</para>
        <para>��� cp.add(BorderLayout.SOUTH, txt);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new BangBeanTest(), 400, 500);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>When a Bean is in a development environment, this class will not be used, but it�s helpful to provide a rapid testing method for each of your Beans. <emphasis role="bold">BangBeanTest</emphasis> places a <emphasis role="bold">BangBean</emphasis> within the applet, attaching a simple <emphasis role="bold">ActionListener</emphasis> to the <emphasis role="bold">BangBean</emphasis> to print an event count to the <emphasis role="bold">JTextField </emphasis>whenever an <emphasis role="bold">ActionEvent</emphasis> occurs. Usually, of course, the application builder tool would create most of the code that uses the Bean.</para>
        <para>When you run the <emphasis role="bold">BangBean</emphasis> through <emphasis role="bold">BeanDumper</emphasis> or put the <emphasis role="bold">BangBean</emphasis> inside a Bean-enabled development environment, you�ll notice that there are many more properties and actions than are evident from the above code. That�s because <emphasis role="bold">BangBean</emphasis> is inherited from <emphasis role="bold">JPanel</emphasis>, and <emphasis role="bold">JPanel </emphasis>is also Bean, so you�re seeing its properties and events as well.</para>
      </section>
      <section>
        <title><anchor xreflabel="Packaging a Bean" xml:id="_Toc481064840"/>Packaging a Bean</title>
        <para>Before you can bring a Bean into a Bean-enabled visual builder tool, it must be put into the standard Bean container, which is a JAR file that includes all the Bean classes as well as a �manifest� file that says �This is a Bean.� A manifest file is simply a text file that follows a particular form. For the <emphasis role="bold">BangBean</emphasis>, the manifest file looks like this (without the first and last lines):</para>
        <para>//:! :BangBean.mf</para>
        <para>Manifest-Version: 1.0</para>
        <para> </para>
        <para>Name: bangbean/BangBean.class</para>
        <para>Java-Bean: True</para>
        <para>///:~</para>
        <para> </para>
        <para>The first line indicates the version of the manifest scheme, which until further notice from Sun is 1.0. The second line (empty lines are ignored) names the <emphasis role="bold">BangBean.class</emphasis> file, and the third says, �It�s a Bean.� Without the third line, the program builder tool will not recognize the class as a Bean.</para>
        <para>The only tricky part is that you must make sure that you get the proper path in the �Name:� field. If you look back at <emphasis role="bold">BangBean.java</emphasis>, you�ll see it�s in <emphasis role="bold">package bangbean </emphasis>(and thus in a subdirectory called �bangbean� that�s off of the classpath), and the name in the manifest file must include this package information. In addition, you must place the manifest file in the directory <emphasis role="italic">above</emphasis> the root of your package path, which in this case means placing the file in the directory above the �bangbean� subdirectory. Then you must invoke <emphasis role="bold">jar</emphasis> from the same directory as the manifest file, as follows:</para>
        <para>jar cfm BangBean.jar BangBean.mf bangbean</para>
        <para> </para>
        <para>This assumes that you want the resulting JAR file to be named <emphasis role="bold">BangBean.jar</emphasis> and that you�ve put the manifest in a file called <emphasis role="bold">BangBean.mf</emphasis>.</para>
        <para>You might wonder �What about all the other classes that were generated when I compiled <emphasis role="bold">BangBean.java</emphasis>?� Well, they all ended up inside the <emphasis role="bold">bangbean</emphasis> subdirectory, and you�ll see that the last argument for the above <emphasis role="bold">jar</emphasis> command line is the <emphasis role="bold">bangbean</emphasis> subdirectory. When you give <emphasis role="bold">jar</emphasis> the name of a subdirectory, it packages that entire subdirectory into the jar file (including, in this case, the original <emphasis role="bold">BangBean.java</emphasis> source-code file�you might not choose to include the source with your own Beans). In addition, if you turn around and unpack the JAR file you�ve just created, you�ll discover that your manifest file isn�t inside, but that <emphasis role="bold">jar</emphasis> has created its own manifest file (based partly on yours) called <emphasis role="bold">MANIFEST.MF </emphasis>and placed it inside the subdirectory <emphasis role="bold">META-INF</emphasis> (for �meta-information�). If you open this manifest file you�ll also notice that digital signature information has been added by <emphasis role="bold">jar </emphasis>for each file, of the form:</para>
        <para>Digest-Algorithms: SHA MD5 </para>
        <para>SHA-Digest: pDpEAG9NaeCx8aFtqPI4udSX/O0=</para>
        <para>MD5-Digest: O4NcS1hE3Smnzlp2hj6qeg==</para>
        <para> </para>
        <para>In general, you don�t need to worry about any of this, and if you make changes you can just modify your original manifest file and reinvoke <emphasis role="bold">jar</emphasis> to create a new JAR file for your Bean. You can also add other Beans to the JAR file simply by adding their information to your manifest.</para>
        <para>One thing to notice is that you�ll probably want to put each Bean in its own subdirectory, since when you create a JAR file you hand the <emphasis role="bold">jar</emphasis> utility the name of a subdirectory and it puts everything in that subdirectory into the JAR file. You can see that both <emphasis role="bold">Frog</emphasis> and <emphasis role="bold">BangBean</emphasis> are in their own subdirectories.</para>
        <para>Once you have your Bean properly inside a JAR file you can bring it into a Beans-enabled program-builder environment. The way you do this varies from one tool to the next, but Sun provides a freely available test bed for JavaBeans in their �Beans Development Kit� (BDK) called the �beanbox.� (Download the BDK from <emphasis role="italic">java.sun.com/beans</emphasis>.) To place your Bean in the beanbox, copy the JAR file into the BDK�s �jars� subdirectory before you start up the beanbox.</para>
      </section>
      <section>
        <title><anchor xreflabel="More complex Bean support" xml:id="_Toc481064841"/>More complex Bean support</title>
        <para>You can see how remarkably simple it is to make a Bean. But you aren�t limited to what you�ve seen here. The JavaBeans architecture provides a simple point of entry but can also scale to more complex situations. These situations are beyond the scope of this book, but they will be briefly introduced here. You can find more details at <emphasis role="italic">java.sun.com/beans</emphasis>.</para>
        <para>One place where you can add sophistication is with properties. The examples above have shown only single properties, but it�s also possible to represent multiple properties in an array. This is called an <emphasis role="italic">indexed property</emphasis>. You simply provide the appropriate methods (again following a naming convention for the method names) and the <emphasis role="bold">Introspector</emphasis> recognizes an indexed property so your application builder tool can respond appropriately.</para>
        <para>Properties can be <emphasis role="italic">bound</emphasis>, which means that they will notify other objects via a <emphasis role="bold">PropertyChangeEvent</emphasis>. The other objects can then choose to change themselves based on the change to the Bean.</para>
        <para>Properties can be <emphasis role="italic">constrained</emphasis>, which means that other objects can veto a change to that property if it is unacceptable. The other objects are notified using a <emphasis role="bold">PropertyChangeEvent</emphasis>, and they can throw a <emphasis role="bold">PropertyVetoException</emphasis> to prevent the change from happening and to restore the old values.</para>
        <para>You can also change the way your Bean is represented at design time:</para>
        <para>You can provide a custom property sheet for your particular Bean. The ordinary property sheet will be used for all other Beans, but yours is automatically invoked when your Bean is selected.</para>
        <para>96.      You can create a custom editor for a particular property, so the ordinary property sheet is used, but when your special property is being edited, your editor will automatically be invoked.</para>
        <para>97.      You can provide a custom <emphasis role="bold">BeanInfo</emphasis> class for your Bean that produces information that�s different from the default created by the <emphasis role="bold">Introspector</emphasis>.</para>
        <para>98.      It�s also possible to turn �expert� mode on and off in all <emphasis role="bold">FeatureDescriptor</emphasis>s to distinguish between basic features and more complicated ones.</para>
      </section>
      <section>
        <title><anchor xreflabel="More to Beans" xml:id="_Toc481064842"/>More to Beans</title>
        <para>There�s another issue that couldn�t be addressed here. Whenever you create a Bean, you should expect that it will be run in a multithreaded environment. This means that you must understand the issues of threading, which will be introduced in Chapter 14. You�ll find a section there called �JavaBeans revisited� that will look at the problem and its solution.</para>
        <para>There are a number of books about JavaBeans; for example, <emphasis role="italic">JavaBeans</emphasis> by Elliotte Rusty Harold (IDG, 1998).</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Summary" xml:id="_Toc481064843"/>Summary</title>
      <para>Of all the libraries in Java, the GUI library has seen the most dramatic changes from Java 1.0 to Java 2. The Java 1.0 AWT was roundly criticized as being one of the worst designs seen, and while it would allow you to create portable programs, the resulting GUI was �equally mediocre on all platforms.� It was also limiting, awkward, and unpleasant to use compared with the native application development tools available on a particular platform.</para>
      <para>When Java 1.1 introduced the new event model and JavaBeans, the stage was set�now it was possible to create GUI components that could be easily dragged and dropped inside visual application builder tools. In addition, the design of the event model and Beans clearly shows strong consideration for ease of programming and maintainable code (something that was not evident in the 1.0 AWT). But it wasn�t until the JFC/Swing classes appeared that the job was finished. With the Swing components, cross-platform GUI programming can be a civilized experience.</para>
      <para>Actually, the only thing that�s missing is the application builder tool, and this is where the real revolution lies. Microsoft�s Visual Basic and Visual C++ require Microsoft�s application builder tools, as does Borland�s Delphi and C++ Builder. If you want the application builder tool to get better, you have to cross your fingers and hope the vendor will give you what you want. But Java is an open environment, and so not only does it allow for competing application builder environments, it encourages them. And for these tools to be taken seriously, they must support JavaBeans. This means a leveled playing field: if a better application builder tool comes along, you�re not tied to the one you�ve been using�you can pick up and move to the new one and increase your productivity. This kind of competitive environment for GUI application builder tools has not been seen before, and the resulting marketplace can generate only positive results for the productivity of the programmer.</para>
      <para>This chapter was meant only to give you an introduction to the power of Swing and to get you started so you could see how relatively simple it is to feel your way through the libraries. What you�ve seen so far will probably suffice for a good portion of your UI design needs. However, there�s a lot more to Swing�it�s intended to be a fully powered UI design tool kit. There�s probably a way to accomplish just about everything you can imagine.</para>
      <para>If you don�t see what you need here, delve into the online documentation from Sun and search the Web, and if that�s not enough then find a dedicated Swing book�a good place to start is <emphasis role="italic">The JFC Swing Tutorial</emphasis>, by Walrath &amp; Campione (Addison Wesley, 1999). </para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064844"/><anchor xreflabel="Exercises" xml:id="_Toc375545470"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Create an applet/application using the <emphasis role="bold">Console</emphasis> class as shown in this chapter. Include a text field and three buttons. When you press each button, make some different text appear in the text field.</para>
      <para>  210.         Add a check box to the applet created in Exercise 1, capture the event, and insert different text into the text field.</para>
      <para>  211.         Create an applet/application using <emphasis role="bold">Console</emphasis>. In the HTML documentation from <emphasis role="italic">java.sun.com</emphasis>, find the <emphasis role="bold">JPasswordField</emphasis> and add this to the program. If the user types in the correct password, use <emphasis role="bold">Joptionpane</emphasis> to provide a success message to the user.</para>
      <para>  212.         Create an applet/application using <emphasis role="bold">Console</emphasis>, and add all the components that have an <emphasis role="bold">addActionListener( )</emphasis> method. (Look these up in the HTML documentation from <emphasis role="italic">java.sun.com</emphasis>. Hint: use the index.) Capture their events and display an appropriate message for each inside a text field.</para>
      <para>  213.         Create an applet/application using <emphasis role="bold">Console</emphasis>, with a <emphasis role="bold">JButton</emphasis> and a<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis>. Write and attach the appropriate listener so that if the button has the focus, characters typed into it will appear in the<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis>.</para>
      <para>  214.         Create an applet/application using <emphasis role="bold">Console</emphasis>. Add to the main frame all the components described in this chapter, including menus and a dialog box.</para>
      <para>  215.         Modify <emphasis role="bold">TextFields.java</emphasis> so that the characters in <emphasis role="bold">t2</emphasis> retain the original case that they were typed in, instead of automatically being forced to upper case.</para>
      <para>  216.         Locate and download one or more of the free GUI builder development environments available on the Internet, or buy a commercial product. Discover what is necessary to add <emphasis role="bold">BangBean</emphasis> to this environment and to use it.</para>
      <para>  217.         Add <emphasis role="bold">Frog.class</emphasis> to the manifest file as shown in this chapter and run <emphasis role="bold">jar</emphasis> to create a JAR file containing both <emphasis role="bold">Frog</emphasis> and <emphasis role="bold">BangBean</emphasis>. Now either download and install the BDK from Sun or use your own Beans-enabled program builder tool and add the JAR file to your environment so you can test the two Beans.</para>
      <para>  218.         Create your own JavaBean called <emphasis role="bold">Valve </emphasis>that contains two properties: a <emphasis role="bold">boolean</emphasis> called �on� and an <emphasis role="bold">int</emphasis> called �level.� Create a manifest file, use <emphasis role="bold">jar</emphasis> to package your Bean, then load it into the beanbox or into a Beans-enabled program builder tool so that you can test it.</para>
      <para>  219.         Modify <emphasis role="bold">MessageBoxes.java</emphasis> so that it has an individual <emphasis role="bold">ActionListener</emphasis> for each button (instead of matching the button text).</para>
      <para>  220.         Monitor a new type of event in <emphasis role="bold">TrackEvent.java</emphasis> by adding the new event handling code. You�ll need to discover on your own the type of event that you want to monitor.</para>
      <para>  221.         Inherit a new type of button from <emphasis role="bold">JButton</emphasis>. Each time you press this button, it should change its color to a randomly-selected value. See <emphasis role="bold">ColorBoxes.java</emphasis> in Chapter 14 for an example of how to generate a random color value.</para>
      <para>  222.         Modify <emphasis role="bold">TextPane.java</emphasis> to use a <emphasis role="bold">JTextArea</emphasis> instead of a <emphasis role="bold">JTextPane</emphasis>.</para>
      <para>  223.         Modify <emphasis role="bold">Menus.java</emphasis> to use radio buttons instead of check boxes on the menus.</para>
      <para>  224.         Simplify <emphasis role="bold">List.java</emphasis> by passing the array to the constructor and eliminating the dynamic addition of elements to the list.</para>
      <para>  225.         Modify <emphasis role="bold">SineWave.java </emphasis>to turn <emphasis role="bold">SineDraw</emphasis> into a JavaBean by adding �getter� and �setter� methods.</para>
      <para>  226.         Remember the �sketching box� toy with two knobs, one that controls the vertical movement of the drawing point, and one that controls the horizontal movement? Create one of those, using <emphasis role="bold">SineWave.java </emphasis>to get you started. Instead of knobs, use sliders. Add a button that will erase the entire sketch.</para>
      <para>  227.         Create an �asymptotic progress indicator� that gets slower and slower as it approaches the finish point. Add random erratic behavior so it will periodically look like it�s starting to speed up.</para>
      <para>  228.         Modify <emphasis role="bold">Progress.java</emphasis> so that it does not share models, but instead uses a listener to connect the slider and progress bar.</para>
      <para>  229.         Follow the instructions in the section titled �Packaging an applet into a JAR file� to place <emphasis role="bold">TicTacToe.java</emphasis> into a JAR file. Create an HTML page with the (messy, complicated) version of the applet tag, and modify it to use the archive tag so as to use the JAR file. (Hint: start with the HTML page for <emphasis role="bold">TicTacToe.java </emphasis>that comes with this book�s source-code distribution.)</para>
      <para>  230.         Create an applet/application using <emphasis role="bold">Console</emphasis>. This should have three sliders, one each for the red, green, and blue values in <emphasis role="bold">java.awt.Color</emphasis>. The rest of the form should be a <emphasis role="bold">JPanel</emphasis> that displays the color determined by the three sliders. Also include non-editable text fields that show the current RGB values.</para>
      <para>  231.         In the HTML documentation for <emphasis role="bold">javax.swing</emphasis>, look up the <emphasis role="bold">JColorChooser</emphasis>. Write a program with a button that brings up the color chooser as a dialog.</para>
      <para>  232.         Almost every Swing component is derived from <emphasis role="bold">Component</emphasis>, which has a <emphasis role="bold">setCursor( )</emphasis> method. Look this up in the Java HTML documentation. Create an applet and change the cursor to one of the stock cursors in the <emphasis role="bold">Cursor</emphasis> class.</para>
      <para>  233.         Starting with <emphasis role="bold">ShowAddListeners.java</emphasis>, create a program with the full functionality of <emphasis role="bold">ShowMethodsClean.java</emphasis> from Chapter 12.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064845"/><anchor xreflabel="" xml:id="_Toc477690734"/><anchor xreflabel="" xml:id="_Toc375545471"/><anchor xreflabel="" xml:id="Chapter_16"/>14: Multiple Threads</title>
    <para>Objects provide a way to divide a program into independent sections. Often, you also need to turn a program into separate, independently running subtasks.</para>
    <para>Each of these independent subtasks is called a <emphasis role="italic">thread</emphasis>, and you program as if each thread runs by itself and has the CPU to itself. Some underlying mechanism is actually dividing up the CPU time for you, but in general, you don�t have to think about it, which makes programming with multiple threads a much easier task.</para>
    <para>A <emphasis role="italic">process</emphasis> is a self-contained running program with its own address space. A <emphasis role="italic">multitasking</emphasis> operating system is capable of running more than one process (program) at a time, while making it look like each one is chugging along on its own, by periodically providing CPU cycles to each process. A thread is a single sequential flow of control within a process. A single process can thus have multiple concurrently executing threads.</para>
    <para>There are many possible uses for multithreading, but in general, you�ll have some part of your program tied to a particular event or resource, and you don�t want to hang up the rest of your program because of that. So you create a thread associated with that event or resource and let it run independently of the main program. A good example is a �quit� button�you don�t want to be forced to poll the quit button in every piece of code you write in your program and yet you want the quit button to be responsive, as if you <emphasis role="italic">were</emphasis> checking it regularly. In fact, one of the most immediately compelling reasons for multithreading is to produce a responsive user interface.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064846"/><anchor xreflabel="Responsive
user interfaces" xml:id="_Toc375545472"/>Responsive user interfaces</title>
      <para>As a starting point, consider a program that performs some CPU-intensive operation and thus ends up ignoring user input and being unresponsive. This one, a combined applet/application, will simply display the result of a running counter:</para>
      <para>//: c14:Counter1.java</para>
      <para>// A non-responsive user interface.</para>
      <para>// &lt;applet code=Counter1 width=300 height=100&gt;</para>
      <para>// &lt;/applet&gt;</para>
      <para>import javax.swing.*;</para>
      <para>import java.awt.event.*;</para>
      <para>import java.awt.*;</para>
      <para>import com.bruceeckel.swing.*;</para>
      <para> </para>
      <para>public class Counter1 extends JApplet {</para>
      <para>� private int count = 0;</para>
      <para>� private JButton</para>
      <para>��� start = new JButton(&quot;Start&quot;),</para>
      <para>��� onOff = new JButton(&quot;Toggle&quot;);</para>
      <para>� private JTextField t = new JTextField(10);</para>
      <para>� private boolean runFlag = true;</para>
      <para>� public void init() {</para>
      <para>��� Container cp = getContentPane();</para>
      <para>��� cp.setLayout(new FlowLayout());</para>
      <para>��� cp.add(t);</para>
      <para>��� start.addActionListener(new StartL());</para>
      <para>��� cp.add(start);</para>
      <para>��� onOff.addActionListener(new OnOffL());</para>
      <para>��� cp.add(onOff);</para>
      <para>� }</para>
      <para>� public void go() {</para>
      <para>��� while (true) {</para>
      <para>����� try {</para>
      <para>��� ����Thread.sleep(100);</para>
      <para>����� } catch(InterruptedException e) {</para>
      <para>������� System.err.println(&quot;Interrupted&quot;);</para>
      <para>����� }</para>
      <para>����� if (runFlag)</para>
      <para>������� t.setText(Integer.toString(count++));</para>
      <para>��� }</para>
      <para>� }</para>
      <para>� class StartL implements ActionListener {</para>
      <para>��� public void actionPerformed(ActionEvent e) {</para>
      <para>����� go();</para>
      <para>��� }</para>
      <para>� }</para>
      <para>� class OnOffL implements ActionListener {</para>
      <para>��� public void actionPerformed(ActionEvent e) {</para>
      <para>����� runFlag = !runFlag;</para>
      <para>��� }</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� Console.run(new Counter1(), 300, 100);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>At this point, the Swing and applet code should be reasonably familiar from Chapter 13. The <emphasis role="bold">go( )</emphasis> method is where the program stays busy: it puts the current value of <emphasis role="bold">count</emphasis> into the<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field t</emphasis>, then increments <emphasis role="bold">count</emphasis>.</para>
      <para>Part of the infinite loop inside <emphasis role="bold">go( )</emphasis> is to call <emphasis role="bold">sleep( )</emphasis>. <emphasis role="bold">sleep( )</emphasis> must be associated with a <emphasis role="bold">Thread</emphasis> object, and it turns out that every application has <emphasis role="italic">some</emphasis> thread associated with it. (Indeed, Java is based on threads and there are always some running along with your application.) So regardless of whether you�re explicitly using threads, you can produce the current thread used by your program with <emphasis role="bold">Thread </emphasis>and the static <emphasis role="bold">sleep( )</emphasis> method.</para>
      <para>Note that <emphasis role="bold">sleep( )</emphasis> can throw an <emphasis role="bold">InterruptedException</emphasis>, although throwing such an exception is considered a hostile way to break from a thread and should be discouraged. (Once again, exceptions are for exceptional conditions, not normal flow of control.) Interrupting a sleeping thread is included to support a future language feature.</para>
      <para>When the <emphasis role="bold">start</emphasis> button is pressed, <emphasis role="bold">go( )</emphasis> is invoked. On examining <emphasis role="bold">go( )</emphasis>, you might naively think (as I did) that it should allow multithreading because it goes to sleep. That is, while the method is asleep, it seems like the CPU could be busy monitoring other button presses. But it turns out that the real problem is that <emphasis role="bold">go( )</emphasis> never returns, since it�s in an infinite loop, and this means that <emphasis role="bold">actionPerformed( )</emphasis> never returns. Since you�re stuck inside <emphasis role="bold">actionPerformed( )</emphasis> for the first keypress, the program can�t handle any other events. (To get out, you must somehow kill the process; the easiest way to do this is to press Control-C in the console window, if you started it from the console. If you start it via the browser, you have to kill the browser window.)</para>
      <para>The basic problem here is that <emphasis role="bold">go( )</emphasis> needs to continue performing its operations, and at the same time it needs to return so that <emphasis role="bold">actionPerformed( )</emphasis> can complete and the user interface can continue responding to the user. But in a conventional method like <emphasis role="bold">go( )</emphasis> it cannot continue <emphasis role="italic">and</emphasis> at the same time return control to the rest of the program. This sounds like an impossible thing to accomplish, as if the CPU must be in two places at once, but this is precisely the illusion that threading provides. </para>
      <para>The thread model (and its programming support in Java) is a programming convenience to simplify juggling several operations at the same time within a single program. With threads, the CPU will pop around and give each thread some of its time. Each thread has the consciousness of constantly having the CPU to itself, but the CPU�s time is actually sliced between all the threads. The exception to this is if your program is running on multiple CPUs. But one of the great things about threading is that you are abstracted away from this layer, so your code does not need to know whether it is actually running on a single CPU or many. Thus, threads are a way to create transparently scalable programs.</para>
      <para>Threading reduces computing efficiency somewhat, but the net improvement in program design, resource balancing, and user convenience is often quite valuable. Of course, if you have more than one CPU, then the operating system can dedicate each CPU to a set of threads or even a single thread and the whole program can run much faster. Multitasking and multithreading tend to be the most reasonable ways to utilize multiprocessor systems.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064847"/><anchor xreflabel="Inheriting
from Thread" xml:id="_Toc375545473"/>Inheriting from <emphasis role="bold">Thread</emphasis></title>
        <para>The simplest way to create a thread is to inherit from class <emphasis role="bold">Thread</emphasis>, which has all the wiring necessary to create and run threads. The most important method for <emphasis role="bold">Thread</emphasis> is <emphasis role="bold">run( )</emphasis>, which you must override to make the thread do your bidding. Thus, <emphasis role="bold">run( )</emphasis> is the code that will be executed �simultaneously� with the other threads in a program.</para>
        <para>The following example creates any number of threads that it keeps track of by assigning each thread a unique number, generated with a <emphasis role="bold">static</emphasis> variable. The <emphasis role="bold">Thread</emphasis>�s <emphasis role="bold">run( )</emphasis> method is overridden to count down each time it passes through its loop and to finish when the count is zero (at the point when <emphasis role="bold">run( )</emphasis> returns, the thread is terminated).</para>
        <para>//: c14:SimpleThread.java</para>
        <para>// Very simple Threading example.</para>
        <para> </para>
        <para>public class SimpleThread extends Thread {</para>
        <para>� private int countDown = 5;</para>
        <para>� private static int threadCount = 0;</para>
        <para>� private int threadNumber = ++threadCount;</para>
        <para>� public SimpleThread() {</para>
        <para>��� System.out.println(&quot;Making &quot; + threadNumber);</para>
        <para>� }</para>
        <para>� public void run() {</para>
        <para>��� while(true) {</para>
        <para>����� System.out.println(&quot;Thread &quot; + </para>
        <para>������� threadNumber + &quot;(&quot; + countDown + &quot;)&quot;);</para>
        <para>����� if(--countDown == 0) return;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� for(int i = 0; i &lt; 5; i++)</para>
        <para>����� new SimpleThread().start();</para>
        <para>��� System.out.println(&quot;All Threads Started&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>A <emphasis role="bold">run( )</emphasis> method virtually always has some kind of loop that continues until the thread is no longer necessary, so you must establish the condition on which to break out of this loop (or, in the case above, simply <emphasis role="bold">return</emphasis> from <emphasis role="bold">run( )</emphasis>). Often, <emphasis role="bold">run( )</emphasis> is cast in the form of an infinite loop, which means that, barring some external factor that causes <emphasis role="bold">run( )</emphasis> to terminate, it will continue forever.</para>
        <para>In <emphasis role="bold">main( ) </emphasis>you can see a number of threads being created and run. The <emphasis role="bold">start( ) </emphasis>method in the <emphasis role="bold">Thread</emphasis> class performs special initialization for the thread and then calls <emphasis role="bold">run( )</emphasis>. So the steps are: the constructor is called to build the object, then <emphasis role="bold">start( )</emphasis> configures the thread and calls <emphasis role="bold">run( )</emphasis>. If you don�t call <emphasis role="bold">start( )</emphasis> (which you can do in the constructor, if that�s appropriate) the thread will never be started.</para>
        <para>The output for one run of this program (it will be different from one run to another) is:</para>
        <para>Making 1</para>
        <para>Making 2</para>
        <para>Making 3</para>
        <para>Making 4</para>
        <para>Making 5</para>
        <para>Thread 1(5)</para>
        <para>Thread 1(4)</para>
        <para>Thread 1(3)</para>
        <para>Thread 1(2)</para>
        <para>Thread 2(5)</para>
        <para>Thread 2(4)</para>
        <para>Thread 2(3)</para>
        <para>Thread 2(2)</para>
        <para>Thread 2(1)</para>
        <para>Thread 1(1)</para>
        <para>All Threads Started</para>
        <para>Thread 3(5)</para>
        <para>Thread 4(5)</para>
        <para>Thread 4(4)</para>
        <para>Thread 4(3)</para>
        <para>Thread 4(2)</para>
        <para>Thread 4(1)</para>
        <para>Thread 5(5)</para>
        <para>Thread 5(4)</para>
        <para>Thread 5(3)</para>
        <para>Thread 5(2)</para>
        <para>Thread 5(1)</para>
        <para>Thread 3(4)</para>
        <para>Thread 3(3)</para>
        <para>Thread 3(2)</para>
        <para>Thread 3(1)</para>
        <para> </para>
        <para>You�ll notice that nowhere in this example is <emphasis role="bold">sleep( )</emphasis> called, and yet the output indicates that each thread gets a portion of the CPU�s time in which to execute. This shows that <emphasis role="bold">sleep( )</emphasis>, while it relies on the existence of a thread in order to execute, is not involved with either enabling or disabling threading. It�s simply another method.</para>
        <para>You can also see that the threads are not run in the order that they�re created. In fact, the order that the CPU attends to an existing set of threads is indeterminate, unless you go in and adjust the priorities using <emphasis role="bold">Thread</emphasis>�s <emphasis role="bold">setPriority( )</emphasis> method.</para>
        <para>When <emphasis role="bold">main( )</emphasis> creates the <emphasis role="bold">Thread</emphasis> objects it isn�t capturing the references for any of them. An ordinary object would be fair game for garbage collection, but not a <emphasis role="bold">Thread</emphasis>. Each <emphasis role="bold">Thread</emphasis> �registers� itself so there is actually a reference to it someplace and the garbage collector can�t clean it up.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064848"/><anchor xreflabel="Threading
for a responsive interface" xml:id="_Toc375545474"/>Threading for a responsive interface</title>
        <para>Now it�s possible to solve the problem in <emphasis role="bold">Counter1.java </emphasis>with a thread. The trick is to place the subtask�that is, the loop that�s inside <emphasis role="bold">go( )</emphasis>�inside the <emphasis role="bold">run( )</emphasis> method of a thread. When the user presses the <emphasis role="bold">start</emphasis> button, the thread is started, but then the <emphasis role="italic">creation</emphasis> of the thread completes, so even though the thread is running, the main job of the program (watching for and responding to user-interface events) can continue. Here�s the solution:</para>
        <para>//: c14:Counter2.java</para>
        <para>// A responsive user interface with threads.</para>
        <para>// &lt;applet code=Counter2 width=300 height=100&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Counter2 extends JApplet {</para>
        <para>� private class SeparateSubTask extends Thread {</para>
        <para>��� private int count = 0;</para>
        <para>��� private boolean runFlag = true;</para>
        <para>��� SeparateSubTask() { start(); }</para>
        <para>��� void invertFlag() { runFlag = !runFlag; }</para>
        <para>��� public void run() {</para>
        <para>����� while (true) {</para>
        <para>��� ���try {</para>
        <para>������� sleep(100);</para>
        <para>����� } catch(InterruptedException e) {</para>
        <para>������� System.err.println(&quot;Interrupted&quot;);</para>
        <para>����� }</para>
        <para>������ if(runFlag) </para>
        <para>�������� t.setText(Integer.toString(count++));</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� } </para>
        <para>� private SeparateSubTask sp = null;</para>
        <para>� private JTextField t = new JTextField(10);</para>
        <para>� private JButton </para>
        <para>��� start = new JButton(&quot;Start&quot;),</para>
        <para>��� onOff = new JButton(&quot;Toggle&quot;);</para>
        <para>� class StartL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� if(sp == null)</para>
        <para>������� sp = new SeparateSubTask();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class OnOffL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� if(sp != null)</para>
        <para>������� sp.invertFlag();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(t);</para>
        <para>��� start.addActionListener(new StartL());</para>
        <para>��� cp.add(start);</para>
        <para>��� onOff.addActionListener(new OnOffL());</para>
        <para>��� cp.add(onOff);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Counter2 (), 300, 100);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">Counter2</emphasis> is a straightforward program, whose only job is to set up and maintain the user interface. But now, when the user presses the <emphasis role="bold">start</emphasis> button, the event-handling code does not call a method. Instead a thread of class <emphasis role="bold">SeparateSubTask</emphasis> is created, and then the <emphasis role="bold">Counter2</emphasis> event loop continues. </para>
        <para>The class <emphasis role="bold">SeparateSubTask</emphasis> is a simple extension of <emphasis role="bold">Thread</emphasis> with a constructor that runs the thread by calling <emphasis role="bold">start( )</emphasis>, and a <emphasis role="bold">run( )</emphasis> that essentially contains the �<emphasis role="bold">go( )</emphasis>� code from <emphasis role="bold">Counter1.java</emphasis>.</para>
        <para>Because <emphasis role="bold">SeparateSubTask</emphasis> is an inner class, it can directly access the <emphasis role="bold">JTextField t </emphasis>in <emphasis role="bold">Counter2</emphasis>; you can see this happening inside <emphasis role="bold">run( )</emphasis>. The <emphasis role="bold">t</emphasis> field in the outer class is <emphasis role="bold">private</emphasis> since <emphasis role="bold">SeparateSubTask</emphasis> can access it without getting any special permission�and it�s always good to make fields �as <emphasis role="bold">private</emphasis> as possible� so they cannot be accidentally changed by forces outside your class.</para>
        <para>When you press the <emphasis role="bold">onOff</emphasis> button it toggles the <emphasis role="bold">runFlag</emphasis> inside the <emphasis role="bold">SeparateSubTask</emphasis> object. That thread (when it looks at the flag) can then start and stop itself. Pressing the <emphasis role="bold">onOff</emphasis> button produces an apparently instant response. Of course, the response isn�t really instant, not like that of a system that�s driven by interrupts. The counter stops only when the thread has the CPU and notices that the flag has changed.</para>
        <para>You can see that the inner class <emphasis role="bold">SeparateSubTask</emphasis> is <emphasis role="bold">private</emphasis>, which means that its fields and methods can be given default access (except for <emphasis role="bold">run( )</emphasis>, which must be <emphasis role="bold">public</emphasis> since it is <emphasis role="bold">public</emphasis> in the base class). The <emphasis role="bold">private </emphasis>inner class is not accessible to anyone but <emphasis role="bold">Counter2</emphasis>, and the two classes are tightly coupled. Anytime you notice classes that appear to have high coupling with each other, consider the coding and maintenance improvements you might get by using inner classes.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064849"/><anchor xreflabel="Combining
the thread 
with the main class" xml:id="_Toc375545475"/>Combining the thread   with the main class</title>
        <para>In the example above you can see that the thread class is separate from the program�s main class. This makes a lot of sense and is relatively easy to understand. There is, however, an alternate form that you will often see used that is not so clear but is usually more concise (which probably accounts for its popularity). This form combines the main program class with the thread class by making the main program class a thread. Since for a GUI program the main program class must be inherited from either <emphasis role="bold">Frame</emphasis> or <emphasis role="bold">Applet</emphasis>, an interface must be used to paste on the additional functionality. This interface is called <emphasis role="bold">Runnable</emphasis>, and it contains the same basic method that <emphasis role="bold">Thread</emphasis> does. In fact, <emphasis role="bold">Thread</emphasis> also implements <emphasis role="bold">Runnable</emphasis>, which specifies only that there be a <emphasis role="bold">run( )</emphasis> method.</para>
        <para>The <emphasis role="italic">use</emphasis> of the combined program/thread is not quite so obvious. When you start the program, you create an object that�s <emphasis role="bold">Runnable</emphasis>, but you don�t start the thread. This must be done explicitly. You can see this in the following program, which reproduces the functionality of <emphasis role="bold">Counter2</emphasis>:</para>
        <para>//: c14:Counter3.java</para>
        <para>// Using the Runnable interface to turn the </para>
        <para>// main class into a thread.</para>
        <para>// &lt;applet code=Counter3 width=300 height=100&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Counter3 </para>
        <para>��� extends JApplet implements Runnable {</para>
        <para>� private int count = 0;</para>
        <para>� private boolean runFlag = true;</para>
        <para>� private Thread selfThread = null;</para>
        <para>� private JButton </para>
        <para>��� start = new JButton(&quot;Start&quot;),</para>
        <para>��� onOff = new JButton(&quot;Toggle&quot;);</para>
        <para>� private JTextField t = new JTextField(10);</para>
        <para>� public void run() {</para>
        <para>��� while (true) {</para>
        <para>����� try {</para>
        <para>������� selfThread.sleep(100);</para>
        <para>����� } catch(InterruptedException e) {</para>
        <para>������� System.err.println(&quot;Interrupted&quot;);</para>
        <para>����� }</para>
        <para>����� if(runFlag) </para>
        <para>������� t.setText(Integer.toString(count++));</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class StartL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� if(selfThread == null) {</para>
        <para>������� selfThread = new Thread(Counter3.this);</para>
        <para>������� selfThread.start();</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class OnOffL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� runFlag = !runFlag;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� cp.add(t);</para>
        <para>��� start.addActionListener(new StartL());</para>
        <para>��� cp.add(start);</para>
        <para>��� onOff.addActionListener(new OnOffL());</para>
        <para>��� cp.add(onOff);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Counter3(), 300, 100);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Now the <emphasis role="bold">run( )</emphasis> is inside the class, but it�s still dormant after <emphasis role="bold">init( )</emphasis> completes. When you press the <emphasis role="bold">start</emphasis> button, the thread is created (if it doesn�t already exist) in the somewhat obscure expression:</para>
        <para>new Thread(Counter3.this);</para>
        <para> </para>
        <para>When something has a <emphasis role="bold">Runnable</emphasis> interface, it simply means that it has a <emphasis role="bold">run( )</emphasis> method, but there�s nothing special about that�it doesn�t produce any innate threading abilities, like those of a class inherited from <emphasis role="bold">Thread</emphasis>. So to produce a thread from a <emphasis role="bold">Runnable</emphasis> object, you must create a separate <emphasis role="bold">Thread</emphasis> object as shown above, handing the <emphasis role="bold">Runnable</emphasis> object to the special <emphasis role="bold">Thread </emphasis>constructor. You can then call <emphasis role="bold">start( )</emphasis> for that thread:</para>
        <para>selfThread.start();</para>
        <para> </para>
        <para>This performs the usual initialization and then calls <emphasis role="bold">run( )</emphasis>.</para>
        <para>The convenient aspect about the <emphasis role="bold">Runnable interface</emphasis> is that everything belongs to the same class. If you need to access something, you simply do it without going through a separate object. However, as you saw in the previous example, this access is just as easy using an inner class<anchor xreflabel="[70]" xml:id="_ftnref70"/>[70].</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064850"/><anchor xreflabel="Making
many threads" xml:id="_Toc375545476"/>Making many threads</title>
        <para>Consider the creation of many different threads. You can�t do this with the previous example, so you must go back to having separate classes inherited from <emphasis role="bold">Thread</emphasis> to encapsulate the <emphasis role="bold">run( )</emphasis>. But this is a more general solution and easier to understand, so while the previous example shows a coding style you�ll often see, I can�t recommend it for most cases because it�s just a little bit more confusing and less flexible.</para>
        <para>The following example repeats the form of the examples above with counters and toggle buttons. But now all the information for a particular counter, including the button and text field, is inside its own object that is inherited from <emphasis role="bold">Thread</emphasis>. All the fields in <emphasis role="bold">Ticker</emphasis> are <emphasis role="bold">private</emphasis>, which means that the <emphasis role="bold">Ticker</emphasis> implementation can be changed at will, including the quantity and type of data components to acquire and display information. When a <emphasis role="bold">Ticker</emphasis> object is created, the constructor adds its visual components to the content pane of the outer object:</para>
        <para>//: c14:Counter4.java</para>
        <para>// By keeping your thread as a distinct class,</para>
        <para>// you can have as many threads as you want. </para>
        <para>// &lt;applet code=Counter4 width=200 height=600&gt;</para>
        <para>// &lt;param name=size value=&quot;12&quot;&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Counter4 extends JApplet {</para>
        <para>� private JButton start = new JButton(&quot;Start&quot;);</para>
        <para>� private boolean started = false;</para>
        <para>� private Ticker[] s;</para>
        <para>� private boolean isApplet = true;</para>
        <para>� private int size = 12;</para>
        <para>� class Ticker extends Thread {</para>
        <para>��� private JButton b = new JButton(&quot;Toggle&quot;);</para>
        <para>��� private JTextField t = new JTextField(10);</para>
        <para>��� private int count = 0;</para>
        <para>��� private boolean runFlag = true;</para>
        <para>��� public Ticker() {</para>
        <para>����� b.addActionListener(new ToggleL());</para>
        <para>����� JPanel p = new JPanel();</para>
        <para>����� p.add(t);</para>
        <para>����� p.add(b);</para>
        <para>����� // Calls JApplet.getContentPane().add():</para>
        <para>����� getContentPane().add(p); </para>
        <para>��� }</para>
        <para>��� class ToggleL implements ActionListener {</para>
        <para>����� public void actionPerformed(ActionEvent e) {</para>
        <para>������� runFlag = !runFlag;</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� public void run() {</para>
        <para>����� while (true) {</para>
        <para>������� if (runFlag)</para>
        <para>��������� t.setText(Integer.toString(count++));</para>
        <para>������� try {</para>
        <para>��������� sleep(100);</para>
        <para>������� } catch(InterruptedException e) {</para>
        <para>��������� System.err.println(&quot;Interrupted&quot;);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class StartL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� if(!started) {</para>
        <para>������� started = true;</para>
        <para>������� for (int i = 0; i &lt; s.length; i++)</para>
        <para>��������� s[i].start();</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� // Get parameter &quot;size&quot; from Web page:</para>
        <para>��� if (isApplet) {</para>
        <para>����� String sz = getParameter(&quot;size&quot;);</para>
        <para>����� if(sz != null)</para>
        <para>������� size = Integer.parseInt(sz);</para>
        <para>��� }</para>
        <para>��� s = new Ticker[size];</para>
        <para>��� for (int i = 0; i &lt; s.length; i++)</para>
        <para>����� s[i] = new Ticker();</para>
        <para>��� start.addActionListener(new StartL());</para>
        <para>��� cp.add(start);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Counter4 applet = new Counter4();</para>
        <para>��� // This isn&apos;t an applet, so set the flag and</para>
        <para>��� // produce the parameter values from args:</para>
        <para>��� applet.isApplet = false;</para>
        <para>��� if(args.length != 0)</para>
        <para>����� applet.size = Integer.parseInt(args[0]);</para>
        <para>��� Console.run(applet, 200, applet.size * 50);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">Ticker</emphasis> contains not only its threading equipment but also the way to control and display the thread. You can create as many threads as you want without explicitly creating the windowing components.</para>
        <para>In <emphasis role="bold">Counter4</emphasis> there�s an array of <emphasis role="bold">Ticker</emphasis> objects called <emphasis role="bold">s</emphasis>. For maximum flexibility, the size of this array is initialized by reaching out into the Web page using applet parameters. Here�s what the size parameter looks like on the page, embedded inside the applet tag:</para>
        <para>&lt;param name=size value=&quot;20&quot;&gt;</para>
        <para> </para>
        <para>The <emphasis role="bold">param</emphasis>, <emphasis role="bold">name</emphasis>, and <emphasis role="bold">value</emphasis> are all HTML keywords. <emphasis role="bold">name</emphasis> is what you�ll be referring to in your program, and <emphasis role="bold">value</emphasis> can be any string, not just something that resolves to a number.</para>
        <para>You�ll notice that the determination of the size of the array <emphasis role="bold">s</emphasis> is done inside <emphasis role="bold">init( )</emphasis>, and not as part of an inline definition of <emphasis role="bold">s</emphasis>. That is, you <emphasis role="italic">cannot</emphasis> say as part of the class definition (outside of any methods):</para>
        <para>int size = Integer.parseInt(getParameter(&quot;size&quot;));</para>
        <para>Ticker[] s = new Ticker[size];</para>
        <para> </para>
        <para>You can compile this, but you�ll get a strange �null-pointer exception� at run-time. It works fine if you move the <emphasis role="bold">getParameter( ) </emphasis>initialization inside of <emphasis role="bold">init( )</emphasis>. The applet framework performs the necessary startup to grab the parameters before entering <emphasis role="bold">init( )</emphasis>.</para>
        <para>In addition, this code is set up to be either an applet or an application. When it�s an application the <emphasis role="bold">size</emphasis> argument is extracted from the command line (or a default value is provided).</para>
        <para>Once the size of the array is established, new <emphasis role="bold">Ticker</emphasis> objects are created; as part of the <emphasis role="bold">Ticker</emphasis> constructor the button and text field for each <emphasis role="bold">Ticker </emphasis>is added to the applet.</para>
        <para>Pressing the <emphasis role="bold">start</emphasis> button means looping through the entire array of <emphasis role="bold">Ticker</emphasis>s and calling <emphasis role="bold">start( )</emphasis> for each one. Remember, <emphasis role="bold">start( )</emphasis> performs necessary thread initialization and then calls <emphasis role="bold">run( )</emphasis> for that thread.</para>
        <para>The <emphasis role="bold">ToggleL </emphasis>listener simply inverts the flag in <emphasis role="bold">Ticker</emphasis> and when the associated thread next takes note it can react accordingly.</para>
        <para>One value of this example is that it allows you to easily create large sets of independent subtasks and to monitor their behavior. In this case, you�ll see that as the number of subtasks gets larger, your machine will probably show more divergence in the displayed numbers because of the way that the threads are served.</para>
        <para>You can also experiment to discover how important the <emphasis role="bold">sleep(100)</emphasis> is inside <emphasis role="bold">Ticker.run( )</emphasis>. If you remove the <emphasis role="bold">sleep( )</emphasis>, things will work fine until you press a toggle button. Then that particular thread has a false <emphasis role="bold">runFlag</emphasis> and the <emphasis role="bold">run( )</emphasis> is just tied up in a tight infinite loop, which appears difficult to break during multithreading, so the responsiveness and speed of the program really bogs down.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064851"/><anchor xreflabel="Daemon
threads" xml:id="_Toc375545477"/>Daemon threads</title>
        <para>A �daemon� thread is one that is supposed to provide a general service in the background as long as the program is running, but is not part of the essence of the program. Thus, when all of the non-daemon threads complete, the program is terminated. Conversely, if there are any non-daemon threads still running, the program doesn�t terminate. (There is, for instance, a thread that runs <emphasis role="bold">main( )</emphasis>.)</para>
        <para>You can find out if a thread is a daemon by calling <emphasis role="bold">isDaemon( )</emphasis>, and you can turn the �daemonhood� of a thread on and off with <emphasis role="bold">setDaemon( )</emphasis>. If a thread is a daemon, then any threads it creates will automatically be daemons.</para>
        <para>The following example demonstrates daemon threads:</para>
        <para>//: c14:Daemons.java</para>
        <para>// Daemonic behavior.</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>class Daemon extends Thread {</para>
        <para>� private static final int SIZE = 10;</para>
        <para>� private Thread[] t = new Thread[SIZE];</para>
        <para>� public Daemon() { </para>
        <para>��� setDaemon(true);</para>
        <para>��� start();</para>
        <para>� }</para>
        <para>� public void run() {</para>
        <para>��� for(int i = 0; i &lt; SIZE; i++)</para>
        <para>����� t[i] = new DaemonSpawn(i);</para>
        <para>��� for(int i = 0; i &lt; SIZE; i++)</para>
        <para>����� System.out.println(</para>
        <para>������� &quot;t[&quot; + i + &quot;].isDaemon() = &quot; </para>
        <para>������� + t[i].isDaemon());</para>
        <para>��� while(true) </para>
        <para>����� yield();</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class DaemonSpawn extends Thread {</para>
        <para>� public DaemonSpawn(int i) {</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;DaemonSpawn &quot; + i + &quot; started&quot;);</para>
        <para>��� start();</para>
        <para>� }</para>
        <para>� public void run() {</para>
        <para>��� while(true) </para>
        <para>����� yield();</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Daemons {</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws IOException {</para>
        <para>��� Thread d = new Daemon();</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;d.isDaemon() = &quot; + d.isDaemon());</para>
        <para>��� // Allow the daemon threads to</para>
        <para>��� // finish their startup processes:</para>
        <para>��� System.out.println(&quot;Press any key&quot;);</para>
        <para>��� System.in.read();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">Daemon</emphasis> thread sets its daemon flag to �true� and then spawns a bunch of other threads to show that they are also daemons. Then it goes into an infinite loop that calls <emphasis role="bold">yield( )</emphasis> to give up control to the other processes. In an earlier version of this program, the infinite loops would increment <emphasis role="bold">int </emphasis>counters, but this seemed to bring the whole program to a stop. Using <emphasis role="bold">yield( )</emphasis> makes the program quite peppy.</para>
        <para>There�s nothing to keep the program from terminating once <emphasis role="bold">main( )</emphasis> finishes its job, since there are nothing but daemon threads running. So that you can see the results of starting all the daemon threads, <emphasis role="bold">System.in</emphasis> is set up to read so the program waits for a keypress before terminating. Without this you see only some of the results from the creation of the daemon threads. (Try replacing the <emphasis role="bold">read( )</emphasis> code with <emphasis role="bold">sleep( )</emphasis> calls of various lengths to see this behavior.)</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064852"/><anchor xreflabel="Sharing
limited resources" xml:id="_Toc375545478"/>Sharing limited resources</title>
      <para>You can think of a single-threaded program as one lonely entity moving around through your problem space and doing one thing at a time. Because there�s only one entity, you never have to think about the problem of two entities trying to use the same resource at the same time, like two people trying to park in the same space, walk through a door at the same time, or even talk at the same time.</para>
      <para>With multithreading, things aren�t lonely anymore, but you now have the possibility of two or more threads trying to use the same limited resource at once. Colliding over a resource must be prevented or else you�ll have two threads trying to access the same bank account at the same time, print to the same printer, or adjust the same valve, etc.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064853"/><anchor xreflabel="Improperly
accessing resources" xml:id="_Toc375545479"/>Improperly accessing resources</title>
        <para>Consider a variation on the counters that have been used so far in this chapter. In the following example, each thread contains two counters that are incremented and displayed inside <emphasis role="bold">run( )</emphasis>. In addition, there�s another thread of class <emphasis role="bold">Watcher</emphasis> that is watching the counters to see if they�re always equivalent. This seems like a needless activity, since looking at the code it appears obvious that the counters will always be the same. But that�s where the surprise comes in. Here�s the first version of the program:</para>
        <para>//: c14:Sharing1.java</para>
        <para>// Problems with resource sharing while threading.</para>
        <para>// &lt;applet code=Sharing1 width=350 height=500&gt;</para>
        <para>// &lt;param name=size value=&quot;12&quot;&gt;</para>
        <para>// &lt;param name=watchers value=&quot;15&quot;&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class Sharing1 extends JApplet {</para>
        <para>� private static int accessCount = 0;</para>
        <para>� private static JTextField aCount = </para>
        <para>��� new JTextField(&quot;0&quot;, 7);</para>
        <para>� public static void incrementAccess() {</para>
        <para>��� accessCount++;</para>
        <para>��� aCount.setText(Integer.toString(accessCount));</para>
        <para>� }</para>
        <para>� private JButton </para>
        <para>��� start = new JButton(&quot;Start&quot;),</para>
        <para>��� watcher = new JButton(&quot;Watch&quot;);</para>
        <para>� private boolean isApplet = true;</para>
        <para>� private int numCounters = 12;</para>
        <para>� private int numWatchers = 15;</para>
        <para>� private TwoCounter[] s;</para>
        <para>� class TwoCounter extends Thread {</para>
        <para>��� private boolean started = false;</para>
        <para>��� private JTextField </para>
        <para>����� t1 = new JTextField(5),</para>
        <para>����� t2 = new JTextField(5);</para>
        <para>��� private JLabel l = </para>
        <para>����� new JLabel(&quot;count1 == count2&quot;);</para>
        <para>��� private int count1 = 0, count2 = 0;</para>
        <para>��� // Add the display components as a panel:</para>
        <para>��� public TwoCounter() {</para>
        <para>����� JPanel p = new JPanel();</para>
        <para>����� p.add(t1);</para>
        <para>����� p.add(t2);</para>
        <para>����� p.add(l);</para>
        <para>����� getContentPane().add(p);</para>
        <para>��� }</para>
        <para>��� public void start() {</para>
        <para>����� if(!started) {</para>
        <para>������� started = true;</para>
        <para>������� super.start();</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� public void run() {</para>
        <para>����� while (true) {</para>
        <para>������� t1.setText(Integer.toString(count1++));</para>
        <para>������� t2.setText(Integer.toString(count2++));</para>
        <para>������� try {</para>
        <para>��������� sleep(500);</para>
        <para>������� } catch(InterruptedException e) {</para>
        <para>��������� System.err.println(&quot;Interrupted&quot;);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� public void synchTest() {</para>
        <para>����� Sharing1.incrementAccess();</para>
        <para>����� if(count1 != count2)</para>
        <para>������� l.setText(&quot;Unsynched&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class Watcher extends Thread {</para>
        <para>��� public Watcher() { start(); }</para>
        <para>��� public void run() {</para>
        <para>����� while(true) {</para>
        <para>������� for(int i = 0; i &lt; s.length; i++)</para>
        <para>��������� s[i].synchTest();</para>
        <para>������� try {</para>
        <para>��������� sleep(500);</para>
        <para>������� } catch(InterruptedException e) {</para>
        <para>��������� System.err.println(&quot;Interrupted&quot;);</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class StartL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� for(int i = 0; i &lt; s.length; i++)</para>
        <para>������� s[i].start();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class WatcherL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� for(int i = 0; i &lt; numWatchers; i++)</para>
        <para>������� new Watcher();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void init() {</para>
        <para>��� if(isApplet) {</para>
        <para>����� String counters = getParameter(&quot;size&quot;);</para>
        <para>����� if(counters != null)</para>
        <para>������� numCounters = Integer.parseInt(counters);</para>
        <para>����� String watchers = getParameter(&quot;watchers&quot;);</para>
        <para>����� if(watchers != null)</para>
        <para>������� numWatchers = Integer.parseInt(watchers);</para>
        <para>��� }</para>
        <para>��� s = new TwoCounter[numCounters];</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� for(int i = 0; i &lt; s.length; i++)</para>
        <para>����� s[i] = new TwoCounter();</para>
        <para>��� JPanel p = new JPanel();</para>
        <para>��� start.addActionListener(new StartL());</para>
        <para>��� p.add(start);</para>
        <para>��� watcher.addActionListener(new WatcherL());</para>
        <para>��� p.add(watcher);</para>
        <para>� ��p.add(new JLabel(&quot;Access Count&quot;));</para>
        <para>��� p.add(aCount);</para>
        <para>��� cp.add(p);</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Sharing1 applet = new Sharing1();</para>
        <para>��� // This isn&apos;t an applet, so set the flag and</para>
        <para>��� // produce the parameter values from args:</para>
        <para>��� applet.isApplet = false;</para>
        <para>��� applet.numCounters = </para>
        <para>����� (args.length == 0 ? 12 :</para>
        <para>������� Integer.parseInt(args[0]));</para>
        <para>��� applet.numWatchers =</para>
        <para>����� (args.length &lt; 2 ? 15 :</para>
        <para>������� Integer.parseInt(args[1]));</para>
        <para>��� Console.run(applet, 350, </para>
        <para>����� applet.numCounters * 50);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>As before, each counter contains its own display components: two text fields and a label that initially indicates that the counts are equivalent. These components are added to the content pane of the outer class object in the <emphasis role="bold">TwoCounter</emphasis> constructor. </para>
        <para>Because a <emphasis role="bold">TwoCounter </emphasis>thread is started via a keypress by the user, it�s possible that <emphasis role="bold">start( )</emphasis> could be called more than once. It�s illegal for <emphasis role="bold">Thread.start( )</emphasis> to be called more than once for a thread (an exception is thrown). You can see the machinery to prevent this in the <emphasis role="bold">started </emphasis>flag and the overridden <emphasis role="bold">start( )</emphasis> method.</para>
        <para>In <emphasis role="bold">run( )</emphasis>, <emphasis role="bold">count1</emphasis> and <emphasis role="bold">count2</emphasis> are incremented and displayed in a manner that would seem to keep them identical. Then <emphasis role="bold">sleep( )</emphasis> is called; without this call the program balks because it becomes hard for the CPU to swap tasks.</para>
        <para>The <emphasis role="bold">synchTest( )</emphasis> method performs the apparently useless activity of checking to see if <emphasis role="bold">count1</emphasis> is equivalent to <emphasis role="bold">count2</emphasis>; if they are not equivalent it sets the label to �Unsynched� to indicate this. But first, it calls a static member of the class <emphasis role="bold">Sharing1</emphasis> that increments and displays an access counter to show how many times this check has occurred successfully. (The reason for this will become apparent in later variations of this example.)</para>
        <para>The <emphasis role="bold">Watcher</emphasis> class is a thread whose job is to call <emphasis role="bold">synchTest( )</emphasis> for all of the <emphasis role="bold">TwoCounter</emphasis> objects that are active. It does this by stepping through the array that�s kept in the <emphasis role="bold">Sharing1</emphasis> object. You can think of the <emphasis role="bold">Watcher</emphasis> as constantly peeking over the shoulders of the <emphasis role="bold">TwoCounter</emphasis> objects.</para>
        <para><emphasis role="bold">Sharing1</emphasis> contains an array of <emphasis role="bold">TwoCounter</emphasis> objects that it initializes in <emphasis role="bold">init( )</emphasis> and starts as threads when you press the �start� button. Later, when you press the �Watch� button, one or more watchers are created and freed upon the unsuspecting <emphasis role="bold">TwoCounter </emphasis>threads.</para>
        <para>Note that to run this as an applet in a browser, your applet tag will need to contain the lines:</para>
        <para>&lt;param name=size value=&quot;20&quot;&gt;</para>
        <para>&lt;param name=watchers value=&quot;1&quot;&gt;</para>
        <para> </para>
        <para>You can experiment by changing the width, height, and parameters to suit your tastes. By changing the <emphasis role="bold">size</emphasis> and <emphasis role="bold">watchers</emphasis> you�ll change the behavior of the program. This program is set up to run as a stand-alone application by pulling the arguments from the command line (or providing defaults).</para>
        <para>Here�s the surprising part. In <emphasis role="bold">TwoCounter.run( )</emphasis>, the infinite loop is just repeatedly passing over the adjacent lines:</para>
        <para>t1.setText(Integer.toString(count1++));</para>
        <para>t2.setText(Integer.toString(count2++));</para>
        <para> </para>
        <para>(as well as sleeping, but that�s not important here). When you run the program, however, you�ll discover that <emphasis role="bold">count1</emphasis> and <emphasis role="bold">count2</emphasis> will be observed (by the <emphasis role="bold">Watcher</emphasis>s) to be unequal at times! This is because of the nature of threads�they can be suspended at any time. So at times, the suspension occurs <emphasis role="italic">between</emphasis> the execution of the above two lines, and the <emphasis role="bold">Watcher</emphasis> thread happens to come along and perform the comparison at just this moment, thus finding the two counters to be different.</para>
        <para>This example shows a fundamental problem with using threads. You never know when a thread might be run. Imagine sitting at a table with a fork, about to spear the last piece of food on your plate and as your fork reaches for it, the food suddenly vanishes (because your thread was suspended and another thread came in and stole the food). That�s the problem that you�re dealing with.</para>
        <para>Sometimes you don�t care if a resource is being accessed at the same time you�re trying to use it (the food is on some other plate). But for multithreading to work, you need some way to prevent two threads from accessing the same resource, at least during critical periods.</para>
        <para>Preventing this kind of collision is simply a matter of putting a lock on a resource when one thread is using it. The first thread that accesses a resource locks it, and then the other threads cannot access that resource until it is unlocked, at which time another thread locks and uses it, etc. If the front seat of the car is the limited resource, the child who shouts �Dibs!� asserts the lock.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064854"/><anchor xreflabel="How
Java shares resources" xml:id="_Toc375545480"/>How Java shares resources</title>
        <para>Java has built-in support to prevent collisions over one kind of resource: the memory in an object. Since you typically make the data elements of a class <emphasis role="bold">private</emphasis> and access that memory only through methods, you can prevent collisions by making a particular method <emphasis role="bold">synchronized</emphasis>. Only one thread at a time can call a <emphasis role="bold">synchronized</emphasis> method for a particular object (although that thread can call more than one of the object�s synchronized methods). Here are simple <emphasis role="bold">synchronized</emphasis> methods:</para>
        <para>synchronized void f() { /* ... */ }</para>
        <para>synchronized void g(){ /* ... */ }</para>
        <para> </para>
        <para>Each object contains a single lock (also called a <emphasis role="italic">monitor</emphasis>) that is automatically part of the object (you don�t have to write any special code). When you call any <emphasis role="bold">synchronized</emphasis> method, that object is locked and no other <emphasis role="bold">synchronized</emphasis> method of that object can be called until the first one finishes and releases the lock. In the example above, if <emphasis role="bold">f( )</emphasis> is called for an object, <emphasis role="bold">g( )</emphasis> cannot be called for the same object until <emphasis role="bold">f( )</emphasis> is completed and releases the lock. Thus, there�s a single lock that�s shared by all the <emphasis role="bold">synchronized</emphasis> methods of a particular object, and this lock prevents common memory from being written by more than one method at a time (i.e., more than one thread at a time).</para>
        <para>There�s also a single lock per class (as part of the <emphasis role="bold">Class</emphasis> object for the class), so that <emphasis role="bold">synchronized</emphasis><emphasis role="bold">static</emphasis> methods can lock each other out from simultaneous access of <emphasis role="bold">static </emphasis>data on a class-wide basis.</para>
        <para>Note that if you want to guard some other resource from simultaneous access by multiple threads, you can do so by forcing access to that resource through <emphasis role="bold">synchronized</emphasis> methods.</para>
        <section>
          <title>Synchronizing the counters</title>
          <para>Armed with this new keyword it appears that the solution is at hand: we�ll simply use the <emphasis role="bold">synchronized</emphasis> keyword for the methods in <emphasis role="bold">TwoCounter</emphasis>. The following example is the same as the previous one, with the addition of the new keyword:</para>
          <para>//: c14:Sharing2.java</para>
          <para>// Using the synchronized keyword to prevent</para>
          <para>// multiple access to a particular resource.</para>
          <para>// &lt;applet code=Sharing2 width=350 height=500&gt;</para>
          <para>// &lt;param name=size value=&quot;12&quot;&gt;</para>
          <para>// &lt;param name=watchers value=&quot;15&quot;&gt;</para>
          <para>// &lt;/applet&gt;</para>
          <para>import javax.swing.*;</para>
          <para>import java.awt.*;</para>
          <para>import java.awt.event.*;</para>
          <para>import com.bruceeckel.swing.*;</para>
          <para> </para>
          <para>public class Sharing2 extends JApplet {</para>
          <para>� TwoCounter[] s;</para>
          <para>� private static int accessCount = 0;</para>
          <para>� private static JTextField aCount = </para>
          <para>��� new JTextField(&quot;0&quot;, 7);</para>
          <para>� public static void incrementAccess() {</para>
          <para>��� accessCount++;</para>
          <para>��� aCount.setText(Integer.toString(accessCount));</para>
          <para>� }</para>
          <para>� private JButton </para>
          <para>��� start = new JButton(&quot;Start&quot;),</para>
          <para>��� watcher = new JButton(&quot;Watch&quot;);</para>
          <para>� private boolean isApplet = true;</para>
          <para>� private int numCounters = 12;</para>
          <para>� private int numWatchers = 15;</para>
          <para> </para>
          <para>� class TwoCounter extends Thread {</para>
          <para>��� private boolean started = false;</para>
          <para>��� private JTextField </para>
          <para>����� t1 = new JTextField(5),</para>
          <para>����� t2 = new JTextField(5);</para>
          <para>��� private JLabel l = </para>
          <para>����� new JLabel(&quot;count1 == count2&quot;);</para>
          <para>��� private int count1 = 0, count2 = 0;</para>
          <para>��� public TwoCounter() {</para>
          <para>����� JPanel p = new JPanel();</para>
          <para>����� p.add(t1);</para>
          <para>� ����p.add(t2);</para>
          <para>����� p.add(l);</para>
          <para>����� getContentPane().add(p);</para>
          <para>��� }��� </para>
          <para>��� public void start() {</para>
          <para>����� if(!started) {</para>
          <para>������� started = true;</para>
          <para>������� super.start();</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>��� public synchronized void run() {</para>
          <para>����� while (true) {</para>
          <para>������� t1.setText(Integer.toString(count1++));</para>
          <para>������� t2.setText(Integer.toString(count2++));</para>
          <para>������� try {</para>
          <para>��������� sleep(500);</para>
          <para>������� } catch(InterruptedException e) {</para>
          <para>��������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>������� }</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>��� public synchronized void synchTest() {</para>
          <para>����� Sharing2.incrementAccess();</para>
          <para>����� if(count1 != count2)</para>
          <para>������� l.setText(&quot;Unsynched&quot;);</para>
          <para>��� }</para>
          <para>� }</para>
          <para>� </para>
          <para>� class Watcher extends Thread {</para>
          <para>��� public Watcher() { start(); }</para>
          <para>��� public void run() {</para>
          <para>����� while(true) {</para>
          <para>������� for(int i = 0; i &lt; s.length; i++)</para>
          <para>��������� s[i].synchTest();</para>
          <para>������� try {</para>
          <para>��������� sleep(500);</para>
          <para>������� } catch(InterruptedException e) {</para>
          <para>��������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>������� }</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� }</para>
          <para>� class StartL implements ActionListener {</para>
          <para>��� public void actionPerformed(ActionEvent e) {</para>
          <para>����� for(int i = 0; i &lt; s.length; i++)</para>
          <para>������� s[i].start();</para>
          <para>��� }</para>
          <para>� }</para>
          <para>� class WatcherL implements ActionListener {</para>
          <para>��� public void actionPerformed(ActionEvent e) {</para>
          <para>����� for(int i = 0; i &lt; numWatchers; i++)</para>
          <para>������� new Watcher();</para>
          <para>��� }</para>
          <para>� }</para>
          <para>� public void init() {</para>
          <para>��� if(isApplet) {</para>
          <para>����� String counters = getParameter(&quot;size&quot;);</para>
          <para>����� if(counters != null)</para>
          <para>������� numCounters = Integer.parseInt(counters);</para>
          <para>����� String watchers = getParameter(&quot;watchers&quot;);</para>
          <para>����� if(watchers != null)</para>
          <para>������� numWatchers = Integer.parseInt(watchers);</para>
          <para>��� }</para>
          <para>��� s = new TwoCounter[numCounters];</para>
          <para>��� Container cp = getContentPane();</para>
          <para>��� cp.setLayout(new FlowLayout());</para>
          <para>��� for(int i = 0; i &lt; s.length; i++)</para>
          <para>����� s[i] = new TwoCounter();</para>
          <para>��� JPanel p = new JPanel();</para>
          <para>��� start.addActionListener(new StartL());</para>
          <para>��� p.add(start);</para>
          <para>��� watcher.addActionListener(new WatcherL());</para>
          <para>��� p.add(watcher);</para>
          <para>��� p.add(new Label(&quot;Access Count&quot;));</para>
          <para>��� p.add(aCount);</para>
          <para>��� cp.add(p);</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Sharing2 applet = new Sharing2();</para>
          <para>��� // This isn&apos;t an applet, so set the flag and</para>
          <para>��� // produce the parameter values from args:</para>
          <para>��� applet.isApplet = false;</para>
          <para>��� applet.numCounters = </para>
          <para>����� (args.length == 0 ? 12 :</para>
          <para>������� Integer.parseInt(args[0]));</para>
          <para>��� applet.numWatchers =</para>
          <para>����� (args.length &lt; 2 ? 15 :</para>
          <para>������� Integer.parseInt(args[1]));</para>
          <para>��� Console.run(applet, 350, </para>
          <para>����� applet.numCounters * 50);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>You�ll notice that <emphasis role="italic">both</emphasis><emphasis role="bold">run( )</emphasis> and <emphasis role="bold">synchTest( )</emphasis> are <emphasis role="bold">synchronized</emphasis>. If you synchronize only one of the methods, then the other is free to ignore the object lock and can be called with impunity. This is an important point: Every method that accesses a critical shared resource must be <emphasis role="bold">synchronized</emphasis> or it won�t work right.</para>
          <para>Now a new issue arises. The <emphasis role="bold">Watcher</emphasis> can never get a peek at what�s going on because the entire <emphasis role="bold">run( )</emphasis> method has been <emphasis role="bold">synchronized</emphasis>, and since <emphasis role="bold">run( )</emphasis> is always running for each object the lock is always tied up and <emphasis role="bold">synchTest( )</emphasis> can never be called. You can see this because the <emphasis role="bold">accessCount</emphasis> never changes.</para>
          <para>What we�d like for this example is a way to isolate only <emphasis role="italic">part</emphasis> of the code inside <emphasis role="bold">run( )</emphasis>. The section of code you want to isolate this way is called a <emphasis role="italic">critical section</emphasis> and you use the <emphasis role="bold">synchronized</emphasis> keyword in a different way to set up a critical section. Java supports critical sections with the <emphasis role="italic">synchronized block;</emphasis> this time <emphasis role="bold">synchronized </emphasis>is used to specify the object whose lock is being used to synchronize the enclosed code:</para>
          <para>synchronized(syncObject) {</para>
          <para>� // This code can be accessed </para>
          <para>� // by only one thread at a time</para>
          <para>}</para>
          <para> </para>
          <para>Before the synchronized block can be entered, the lock must be acquired on <emphasis role="bold">syncObject</emphasis>. If some other thread already has this lock, then the block cannot be entered until the lock is given up.</para>
          <para>The <emphasis role="bold">Sharing2</emphasis> example can be modified by removing the <emphasis role="bold">synchronized</emphasis> keyword from the entire <emphasis role="bold">run( )</emphasis> method and instead putting a <emphasis role="bold">synchronized</emphasis> block around the two critical lines. But what object should be used as the lock? The one that is already respected by <emphasis role="bold">synchTest( )</emphasis>, which is the current object (<emphasis role="bold">this</emphasis>)! So the modified <emphasis role="bold">run( )</emphasis> looks like this:</para>
          <para>� public void run() {</para>
          <para>��� while (true) {</para>
          <para>����� synchronized(this) {</para>
          <para>������� t1.setText(Integer.toString(count1++));</para>
          <para>������� t2.setText(Integer.toString(count2++));</para>
          <para>����� }</para>
          <para>����� try {</para>
          <para>������� sleep(500);</para>
          <para>����� } catch(InterruptedException e) {</para>
          <para>������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� }</para>
          <para> </para>
          <para>This is the only change that must be made to <emphasis role="bold">Sharing2.java</emphasis>, and you�ll see that while the two counters are never out of synch (according to when the <emphasis role="bold">Watcher</emphasis> is allowed to look at them), there is still adequate access provided to the <emphasis role="bold">Watcher</emphasis> during the execution of <emphasis role="bold">run( )</emphasis>.</para>
          <para>Of course, all synchronization depends on programmer diligence: every piece of code that can access a shared resource must be wrapped in an appropriate synchronized block. </para>
        </section>
        <section>
          <title>Synchronized efficiency</title>
          <para>Since having two methods write to the same piece of data <emphasis role="italic">never </emphasis>sounds like a particularly good idea, it might seem to make sense for all methods to be automatically <emphasis role="bold">synchronized</emphasis> and eliminate the <emphasis role="bold">synchronized</emphasis> keyword altogether. (Of course, the example with a <emphasis role="bold">synchronized run( )</emphasis> shows that this wouldn�t work either.) But it turns out that acquiring a lock is not a cheap operation�it multiplies the cost of a method call (that is, entering and exiting from the method, not executing the body of the method) by a minimum of four times, and could be much more depending on your implementation. So if you know that a particular method will not cause contention problems it is expedient to leave off the <emphasis role="bold">synchronized</emphasis> keyword. On the other hand, leaving off the <emphasis role="bold">synchronized</emphasis> keyword because you think it is a performance bottleneck, and hoping that there aren�t any collisions is an invitation to disaster.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="JavaBeans revisited" xml:id="_Toc481064855"/>JavaBeans revisited</title>
        <para>Now that you understand synchronization, you can take another look at JavaBeans. Whenever you create a Bean, you must assume that it will run in a multithreaded environment. This means that: </para>
        <para>Whenever possible, all the <emphasis role="bold">public</emphasis> methods of a Bean should be <emphasis role="bold">synchronized</emphasis>. Of course, this incurs the <emphasis role="bold">synchronized</emphasis> run-time overhead. If that�s a problem, methods that will not cause problems in critical sections can be left un-<emphasis role="bold">synchronized</emphasis>, but keep in mind that this is not always obvious. Methods that qualify tend to be small (such as <emphasis role="bold">getCircleSize( )</emphasis> in the following example) and/or �atomic,� that is, the method call executes in such a short amount of code that the object cannot be changed during execution. Making such methods un-<emphasis role="bold">synchronized </emphasis>might not have a significant effect on the execution speed of your program. You might as well make all <emphasis role="bold">public</emphasis> methods of a Bean <emphasis role="bold">synchronized</emphasis> and remove the <emphasis role="bold">synchronized</emphasis> keyword only when you know for sure that it�s necessary and that it makes a difference.</para>
        <para>99.      When firing a multicast event to a bunch of listeners interested in that event, you must assume that listeners might be added or removed while moving through the list.</para>
        <para>The first point is fairly easy to deal with, but the second point requires a little more thought. Consider the <emphasis role="bold">BangBean.java</emphasis> example presented in the last chapter. That ducked out of the multithreading question by ignoring the <emphasis role="bold">synchronized</emphasis> keyword (which hadn�t been introduced yet) and making the event unicast. Here�s that example modified to work in a multithreaded environment and to use multicasting for events:</para>
        <para>//: c14:BangBean2.java</para>
        <para>// You should write your Beans this way so they </para>
        <para>// can run in a multithreaded environment.</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.util.*;</para>
        <para>import java.io.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class BangBean2 extends JPanel </para>
        <para>��� implements Serializable {</para>
        <para>� private int xm, ym;</para>
        <para>� private int cSize = 20; // Circle size</para>
        <para>� private String text = &quot;Bang!&quot;;</para>
        <para>� private int fontSize = 48;</para>
        <para>� private Color tColor = Color.red;</para>
        <para>� private ArrayList actionListeners = </para>
        <para>��� new ArrayList();</para>
        <para>� public BangBean2() {</para>
        <para>��� addMouseListener(new ML());</para>
        <para>��� addMouseMotionListener(new MM());</para>
        <para>� }</para>
        <para>� public synchronized int getCircleSize() { </para>
        <para>��� return cSize; </para>
        <para>� }</para>
        <para>� public synchronized void </para>
        <para>� setCircleSize(int newSize) {</para>
        <para>��� cSize = newSize;</para>
        <para>� }</para>
        <para>� public synchronized String getBangText() { </para>
        <para>�� �return text; </para>
        <para>� }</para>
        <para>� public synchronized void </para>
        <para>� setBangText(String newText) {</para>
        <para>��� text = newText;</para>
        <para>� }</para>
        <para>� public synchronized int getFontSize() { </para>
        <para>��� return fontSize; </para>
        <para>� }</para>
        <para>� public synchronized void </para>
        <para>� setFontSize(int newSize) {</para>
        <para>��� fontSize = newSize;</para>
        <para>� }</para>
        <para>� public synchronized Color getTextColor() {</para>
        <para>��� return tColor; </para>
        <para>� }</para>
        <para>� public synchronized void </para>
        <para>� setTextColor(Color newColor) {</para>
        <para>��� tColor = newColor;</para>
        <para>� }</para>
        <para>� public void paintComponent(Graphics g) {</para>
        <para>��� super.paintComponent(g);</para>
        <para>��� g.setColor(Color.black);</para>
        <para>��� g.drawOval(xm - cSize/2, ym - cSize/2, </para>
        <para>����� cSize, cSize);</para>
        <para>� }</para>
        <para>� // This is a multicast listener, which is</para>
        <para>� // more typically used than the unicast</para>
        <para>� // approach taken in BangBean.java:</para>
        <para>� public synchronized void </para>
        <para>��� addActionListener(ActionListener l) {</para>
        <para>��� actionListeners.add(l);</para>
        <para>� }</para>
        <para>� public synchronized void </para>
        <para>��� removeActionListener(ActionListener l) {</para>
        <para>��� actionListeners.remove(l);</para>
        <para>� }</para>
        <para>� // Notice this isn&apos;t synchronized:</para>
        <para>� public void notifyListeners() {</para>
        <para>��� ActionEvent a =</para>
        <para>����� new ActionEvent(BangBean2.this,</para>
        <para>������� ActionEvent.ACTION_PERFORMED, null);</para>
        <para>��� ArrayList lv = null;</para>
        <para>��� // Make a shallow copy of the List in case </para>
        <para>��� // someone adds a listener while we&apos;re </para>
        <para>��� // calling listeners:</para>
        <para>��� synchronized(this) {</para>
        <para>����� lv = (ArrayList)actionListeners.clone();</para>
        <para>��� }</para>
        <para>��� // Call all the listener methods:</para>
        <para>��� for(int i = 0; i &lt; lv.size(); i++)</para>
        <para>����� ((ActionListener)lv.get(i))</para>
        <para>������� .actionPerformed(a);</para>
        <para>� }</para>
        <para>� class ML extends MouseAdapter {</para>
        <para>��� public void mousePressed(MouseEvent e) {</para>
        <para>����� Graphics g = getGraphics();</para>
        <para>����� g.setColor(tColor);</para>
        <para>����� g.setFont(</para>
        <para>������� new Font(</para>
        <para>��������� &quot;TimesRoman&quot;, Font.BOLD, fontSize));</para>
        <para>����� int width = </para>
        <para>������� g.getFontMetrics().stringWidth(text);</para>
        <para>����� g.drawString(text, </para>
        <para>������� (getSize().width - width) /2,</para>
        <para>������� getSize().height/2);</para>
        <para>����� g.dispose();</para>
        <para>����� notifyListeners();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class MM extends MouseMotionAdapter {</para>
        <para>��� public void mouseMoved(MouseEvent e) {</para>
        <para>����� xm = e.getX();</para>
        <para>����� ym = e.getY();</para>
        <para>����� repaint();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� BangBean2 bb = new BangBean2();</para>
        <para>��� bb.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� System.out.println(&quot;ActionEvent&quot; + e);</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� bb.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� System.out.println(&quot;BangBean2 action&quot;);</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� bb.addActionListener(new ActionListener() {</para>
        <para>����� public void actionPerformed(ActionEvent e){</para>
        <para>������� System.out.println(&quot;More action&quot;);</para>
        <para>����� }</para>
        <para>��� });</para>
        <para>��� Console.run(bb, 300, 300);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Adding <emphasis role="bold">synchronized</emphasis> to the methods is an easy change. However, notice in <emphasis role="bold">addActionListener( )</emphasis> and <emphasis role="bold">removeActionListener( )</emphasis> that the <emphasis role="bold">ActionListener</emphasis>s are now added to and removed from an <emphasis role="bold">ArrayList</emphasis>, so you can have as many as you want.</para>
        <para>You can see that the method <emphasis role="bold">notifyListeners( )</emphasis> is <emphasis role="italic">not</emphasis><emphasis role="bold">synchronized</emphasis>. It can be called from more than one thread at a time. It�s also possible for <emphasis role="bold">addActionListener( )</emphasis> or <emphasis role="bold">removeActionListener( )</emphasis> to be called in the middle of a call to <emphasis role="bold">notifyListeners( )</emphasis>, which is a problem since it traverses the <emphasis role="bold">ArrayList actionListeners</emphasis>. To alleviate the problem, the <emphasis role="bold">ArrayList</emphasis> is cloned inside a <emphasis role="bold">synchronized</emphasis> clause and the clone is traversed (see Appendix A for details of cloning). This way the original <emphasis role="bold">ArrayList</emphasis> can be manipulated without impact on <emphasis role="bold">notifyListeners( )</emphasis>.</para>
        <para>The <emphasis role="bold">paintComponent</emphasis><emphasis role="bold">( )</emphasis> method is also not <emphasis role="bold">synchronized</emphasis>. Deciding whether to synchronize overridden methods is not as clear as when you�re just adding your own methods. In this example it turns out that <emphasis role="bold">paint( )</emphasis> seems to work OK whether it�s <emphasis role="bold">synchronized</emphasis> or not. But the issues you must consider are: </para>
        <para>Does the method modify the state of �critical� variables within the object? To discover whether the variables are �critical� you must determine whether they will be read or set by other threads in the program. (In this case, the reading or setting is virtually always accomplished via <emphasis role="bold">synchronized</emphasis> methods, so you can just examine those.) In the case of <emphasis role="bold">paint( )</emphasis>, no modification takes place.</para>
        <para>100.   Does the method depend on the state of these �critical� variables? If a <emphasis role="bold">synchronized</emphasis> method modifies a variable that your method uses, then you might very well want to make your method <emphasis role="bold">synchronized</emphasis> as well. Based on this, you might observe that <emphasis role="bold">cSize</emphasis> is changed by <emphasis role="bold">synchronized</emphasis> methods and therefore <emphasis role="bold">paint( )</emphasis> should be <emphasis role="bold">synchronized</emphasis>. Here, however, you can ask �What�s the worst thing that will happen if <emphasis role="bold">cSize</emphasis> is changed during a <emphasis role="bold">paint( )</emphasis>?� When you see that it�s nothing too bad, and a transient effect at that, you can decide to leave <emphasis role="bold">paint( )</emphasis> un-<emphasis role="bold">synchronized</emphasis> to prevent the extra overhead from the <emphasis role="bold">synchronized</emphasis> method call.</para>
        <para>101.   A third clue is to notice whether the base-class version of <emphasis role="bold">paint( )</emphasis> is <emphasis role="bold">synchronized</emphasis>, which it isn�t. This isn�t an airtight argument, just a clue. In this case, for example, a field that <emphasis role="italic">is</emphasis> changed via <emphasis role="bold">synchronized</emphasis> methods (that is <emphasis role="bold">cSize</emphasis>) has been mixed into the <emphasis role="bold">paint( )</emphasis> formula and might have changed the situation. Notice, however, that <emphasis role="bold">synchronized</emphasis> doesn�t inherit�that is, if a method is <emphasis role="bold">synchronized</emphasis> in the base class then it <emphasis role="italic">is not</emphasis> automatically <emphasis role="bold">synchronized</emphasis> in the derived class overridden version.</para>
        <para>The test code in <emphasis role="bold">TestBangBean2</emphasis> has been modified from that in the previous chapter to demonstrate the multicast ability of <emphasis role="bold">BangBean2</emphasis> by adding extra listeners.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064856"/><anchor xreflabel="Blocking" xml:id="_Toc375545481"/>Blocking</title>
      <para>A thread can be in any one of four states: </para>
      <para><emphasis role="italic">New</emphasis>: The thread object has been created but it hasn�t been started yet so it cannot run.</para>
      <para>102.   <emphasis role="italic">Runnable</emphasis>: This means that a thread <emphasis role="italic">can</emphasis> be run when the time-slicing mechanism has CPU cycles available for the thread. Thus, the thread might or might not be running, but there�s nothing to prevent it from being run if the scheduler can arrange it; it�s not dead or blocked.</para>
      <para>103.   <emphasis role="italic">Dead</emphasis>: The normal way for a thread to die is by returning from its <emphasis role="bold">run( ) </emphasis>method. You can also call <emphasis role="bold">stop( )</emphasis>, but this throws an exception that�s a subclass of <emphasis role="bold">Error</emphasis> (which means you aren�t forced to put the call in a <emphasis role="bold">try</emphasis> block). Remember that throwing an exception should be a special event and not part of normal program execution; thus the use of <emphasis role="bold">stop( )</emphasis> is deprecated in Java 2. There�s also a <emphasis role="bold">destroy( )</emphasis> method (which has never been implemented) that you should never call if you can avoid it since it�s drastic and doesn�t release object locks.</para>
      <para>104.   <emphasis role="italic">Blocked</emphasis>: The thread could be run but there�s something that prevents it. While a thread is in the blocked state the scheduler will simply skip over it and not give it any CPU time. Until a thread reenters the runnable state it won�t perform any operations.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064857"/><anchor xreflabel="Becoming
blocked" xml:id="_Toc375545482"/>Becoming blocked</title>
        <para>The blocked state is the most interesting one, and is worth further examination. A thread can become blocked for five reasons: </para>
        <para>You�ve put the thread to sleep by calling <emphasis role="bold">sleep(milliseconds),</emphasis> in which case it will not be run for the specified time.</para>
        <para>105.   You�ve suspended the execution of the thread with <emphasis role="bold">suspend( )</emphasis>. It will not become runnable again until the thread gets the <emphasis role="bold">resume( )</emphasis> message (these are deprecated in Java 2, and will be examined further).</para>
        <para>106.   You�ve suspended the execution of the thread with <emphasis role="bold">wait( )</emphasis>. It will not become runnable again until the thread gets the <emphasis role="bold">notify( )</emphasis> or <emphasis role="bold">notifyAll( )</emphasis> message. (Yes, this looks just like number 2, but there�s a distinct difference that will be revealed.)</para>
        <para>107.   The thread is waiting for some I/O to complete.</para>
        <para>108.   The thread is trying to call a <emphasis role="bold">synchronized </emphasis>method on another object, and that object�s lock is not available.</para>
        <para>You can also call <emphasis role="bold">yield( )</emphasis> (a method of the <emphasis role="bold">Thread </emphasis>class) to voluntarily give up the CPU so that other threads can run. However, the same thing happens if the scheduler decides that your thread has had enough time and jumps to another thread. That is, nothing prevents the scheduler from moving your thread and giving time to some other thread. When a thread is blocked, there�s some reason that it cannot continue running.</para>
        <para>The following example shows all five ways of becoming blocked. It all exists in a single file called <emphasis role="bold">Blocking.java,</emphasis> but it will be examined here in discrete pieces. (You�ll notice the �Continued� and �Continuing� tags that allow the code extraction tool to piece everything together.) </para>
        <para>Because this example demonstrates some deprecated methods, you <emphasis role="italic">will </emphasis>get deprecation messages when it is compiled.</para>
        <para>First, the basic framework:</para>
        <para>//: c14:Blocking.java</para>
        <para>// Demonstrates the various ways a thread</para>
        <para>// can be blocked.</para>
        <para>// &lt;applet code=Blocking width=350 height=550&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.io.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>//////////// The basic framework ///////////</para>
        <para>class Blockable extends Thread {</para>
        <para>� private Peeker peeker;</para>
        <para>� protected JTextField state = new JTextField(30);</para>
        <para>� protected int i;</para>
        <para>� public Blockable(Container c) {</para>
        <para>��� c.add(state);</para>
        <para>��� peeker = new Peeker(this, c);</para>
        <para>� }</para>
        <para>� public synchronized int read() { return i; }</para>
        <para>� protected synchronized void update() {</para>
        <para>��� state.setText(getClass().getName()</para>
        <para>����� + &quot; state: i = &quot; + i);</para>
        <para>� }</para>
        <para>� public void stopPeeker() { </para>
        <para>��� // peeker.stop(); Deprecated in Java 1.2</para>
        <para>��� peeker.terminate(); // The preferred approach</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Peeker extends Thread {</para>
        <para>� private Blockable b;</para>
        <para>� private int session;</para>
        <para>� private JTextField status = new JTextField(30);</para>
        <para>� private boolean stop = false;</para>
        <para>� public Peeker(Blockable b, Container c) {</para>
        <para>��� c.add(status);</para>
        <para>��� this.b = b;</para>
        <para>��� start();</para>
        <para>� }</para>
        <para>� public void terminate() { stop = true; }</para>
        <para>� public void run() {</para>
        <para>��� while (!stop) {</para>
        <para>����� status.setText(b.getClass().getName()</para>
        <para>������� + &quot; Peeker &quot; + (++session)</para>
        <para>������� + &quot;; value = &quot; + b.read());</para>
        <para>������ try {</para>
        <para>�� �����sleep(100);</para>
        <para>����� } catch(InterruptedException e) {</para>
        <para>������� System.err.println(&quot;Interrupted&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:Continued</para>
        <para> </para>
        <para>The <emphasis role="bold">Blockable </emphasis>class is meant to be a base class for all the classes in this example that demonstrate blocking. A <emphasis role="bold">Blockable</emphasis> object contains a<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis> called <emphasis role="bold">state</emphasis> that is used to display information about the object. The method that displays this information is <emphasis role="bold">update( )</emphasis>. You can see it uses <emphasis role="bold">getClass( ).getName( )</emphasis> to produce the name of the class instead of just printing it out; this is because <emphasis role="bold">update( )</emphasis> cannot know the exact name of the class it is called for, since it will be a class derived from <emphasis role="bold">Blockable</emphasis>.</para>
        <para>The indicator of change in <emphasis role="bold">Blockable</emphasis> is an <emphasis role="bold">int i,</emphasis> which will be incremented by the <emphasis role="bold">run( )</emphasis> method of the derived class.</para>
        <para>There�s a thread of class <emphasis role="bold">Peeker</emphasis> that is started for each <emphasis role="bold">Blockable</emphasis> object, and the <emphasis role="bold">Peeker</emphasis>�s job is to watch its associated <emphasis role="bold">Blockable</emphasis> object to see changes in <emphasis role="bold">i </emphasis>by calling <emphasis role="bold">read( )</emphasis> and reporting them in its <emphasis role="bold">status JTextField</emphasis>. This is important: Note that <emphasis role="bold">read( )</emphasis> and <emphasis role="bold">update( )</emphasis> are both <emphasis role="bold">synchronized</emphasis>, which means they require that the object lock be free.</para>
        <section>
          <title>Sleeping</title>
          <para>The first test in this program is with <emphasis role="bold">sleep( ):</emphasis></para>
          <para>///:Continuing</para>
          <para>///////////// Blocking via sleep() ///////////</para>
          <para>class Sleeper1 extends Blockable {</para>
          <para>� public Sleeper1(Container c) { super(c); }</para>
          <para>� public synchronized void run() {</para>
          <para>��� while(true) {</para>
          <para>����� i++;</para>
          <para>����� update();</para>
          <para>������ try {</para>
          <para>������� sleep(1000);</para>
          <para>����� } catch(InterruptedException e) {</para>
          <para>������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� }</para>
          <para>}</para>
          <para>� </para>
          <para>class Sleeper2 extends Blockable {</para>
          <para>� public Sleeper2(Container c) { super(c); }</para>
          <para>� public void run() {</para>
          <para>��� while(true) {</para>
          <para>����� change();</para>
          <para>������ try {</para>
          <para>������� sleep(1000);</para>
          <para>����� } catch(InterruptedException e) {</para>
          <para>������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� }</para>
          <para>� public synchronized void change() {</para>
          <para>����� i++;</para>
          <para>����� update();</para>
          <para>� }</para>
          <para>} ///:Continued</para>
          <para> </para>
          <para>In <emphasis role="bold">Sleeper1</emphasis> the entire <emphasis role="bold">run( )</emphasis> method is <emphasis role="bold">synchronized</emphasis>. You�ll see that the <emphasis role="bold">Peeker</emphasis> associated with this object will run along merrily <emphasis role="italic">until</emphasis> you start the thread, and then the <emphasis role="bold">Peeker</emphasis> stops cold. This is one form of blocking: since <emphasis role="bold">Sleeper1.run( )</emphasis> is <emphasis role="bold">synchronized</emphasis>, and once the thread starts it�s always inside <emphasis role="bold">run( )</emphasis>, the method never gives up the object lock and the <emphasis role="bold">Peeker</emphasis> is blocked.</para>
          <para><emphasis role="bold">Sleeper2</emphasis> provides a solution by making <emphasis role="bold">run( )</emphasis> un-<emphasis role="bold">synchronized</emphasis>. Only the <emphasis role="bold">change( )</emphasis> method is <emphasis role="bold">synchronized</emphasis>, which means that while <emphasis role="bold">run( )</emphasis> is in <emphasis role="bold">sleep( )</emphasis>, the <emphasis role="bold">Peeker</emphasis> can access the <emphasis role="bold">synchronized</emphasis> method it needs, namely <emphasis role="bold">read( )</emphasis>. Here you�ll see that the <emphasis role="bold">Peeker</emphasis> continues running when you start the <emphasis role="bold">Sleeper2</emphasis> thread.</para>
        </section>
        <section>
          <title>Suspending and resuming</title>
          <para>The next part of the example introduces the concept of suspension. The <emphasis role="bold">Thread</emphasis> class has a method <emphasis role="bold">suspend( )</emphasis> to temporarily stop the thread and <emphasis role="bold">resume( )</emphasis> that restarts it at the point it was halted. <emphasis role="bold">resume( )</emphasis> must be called by some thread outside the suspended one, and in this case there�s a separate class called <emphasis role="bold">Resumer</emphasis> that does just that. Each of the classes demonstrating suspend/resume has an associated resumer:</para>
          <para>///:Continuing</para>
          <para>/////////// Blocking via suspend() ///////////</para>
          <para>class SuspendResume extends Blockable {</para>
          <para>� public SuspendResume(Container c) {</para>
          <para>��� super(c);��� </para>
          <para>��� new Resumer(this); </para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class SuspendResume1 extends SuspendResume {</para>
          <para>� public SuspendResume1(Container c) { super(c);}</para>
          <para>� public synchronized void run() {</para>
          <para>��� while(true) {</para>
          <para>����� i++;</para>
          <para>����� update();</para>
          <para>����� suspend(); // Deprecated in Java 1.2</para>
          <para>��� }</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class SuspendResume2 extends SuspendResume {</para>
          <para>� public SuspendResume2(Container c) { super(c);}</para>
          <para>� public void run() {</para>
          <para>��� while(true) {</para>
          <para>����� change();</para>
          <para>����� suspend(); // Deprecated in Java 1.2</para>
          <para>��� }</para>
          <para>� }</para>
          <para>� public synchronized void change() {</para>
          <para>����� i++;</para>
          <para>����� update();</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class Resumer extends Thread {</para>
          <para>� private SuspendResume sr;</para>
          <para>� public Resumer(SuspendResume sr) {</para>
          <para>��� this.sr = sr;</para>
          <para>��� start();</para>
          <para>� }</para>
          <para>� public void run() {</para>
          <para>��� while(true) {</para>
          <para>������ try {</para>
          <para>������� sleep(1000);</para>
          <para>����� } catch(InterruptedException e) {</para>
          <para>������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>����� }</para>
          <para>����� sr.resume(); // Deprecated in Java 1.2</para>
          <para>��� }</para>
          <para>� }</para>
          <para>} ///:Continued</para>
          <para> </para>
          <para><emphasis role="bold">SuspendResume1</emphasis> also has a <emphasis role="bold">synchronized run( )</emphasis> method. Again, when you start this thread you�ll see that its associated <emphasis role="bold">Peeker</emphasis> gets blocked waiting for the lock to become available, which never happens. This is fixed as before in <emphasis role="bold">SuspendResume2</emphasis>, which does not <emphasis role="bold">synchronize</emphasis> the entire <emphasis role="bold">run( )</emphasis> method but instead uses a separate <emphasis role="bold">synchronized</emphasis><emphasis role="bold">change( )</emphasis> method.</para>
          <para>You should be aware that Java 2 deprecates the use of <emphasis role="bold">suspend( )</emphasis> and <emphasis role="bold">resume( )</emphasis>, because <emphasis role="bold">suspend( )</emphasis> holds the object�s lock and is thus deadlock-prone. That is, you can easily get a number of locked objects waiting on each other, and this will cause your program to freeze. Although you might see them used in older programs you should not use <emphasis role="bold">suspend( )</emphasis> and <emphasis role="bold">resume( )</emphasis>. The proper solution is described later in this chapter.</para>
        </section>
        <section>
          <title>Wait and notify</title>
          <para>In the first two examples, it�s important to understand that both <emphasis role="bold">sleep( )</emphasis> and <emphasis role="bold">suspend( )</emphasis><emphasis role="italic">do not </emphasis>release the lock as they are called. You must be aware of this when working with locks. On the other hand, the method <emphasis role="bold">wait( )</emphasis><emphasis role="italic">does</emphasis> release the lock when it is called, which means that other <emphasis role="bold">synchronized</emphasis> methods in the thread object could be called during a <emphasis role="bold">wait( )</emphasis>. In the following two classes, you�ll see that the <emphasis role="bold">run( )</emphasis> method is fully <emphasis role="bold">synchronized</emphasis> in both cases, however, the <emphasis role="bold">Peeker</emphasis> still has full access to the <emphasis role="bold">synchronized</emphasis> methods during a <emphasis role="bold">wait( )</emphasis>. This is because <emphasis role="bold">wait( )</emphasis> releases the lock on the object as it suspends the method it�s called within.</para>
          <para>You�ll also see that there are two forms of <emphasis role="bold">wait( )</emphasis>. The first takes an argument in milliseconds that has the same meaning as in <emphasis role="bold">sleep( )</emphasis>: pause for this period of time. The difference is that in <emphasis role="bold">wait( )</emphasis>, the object lock is released <emphasis role="italic">and</emphasis> you can come out of the <emphasis role="bold">wait( )</emphasis> because of a <emphasis role="bold">notify( )</emphasis> as well as having the clock run out.</para>
          <para>The second form takes no arguments, and means that the <emphasis role="bold">wait( )</emphasis> will continue until a <emphasis role="bold">notify( )</emphasis> comes along and will not automatically terminate after a time.</para>
          <para>One fairly unique aspect of <emphasis role="bold">wait( )</emphasis> and <emphasis role="bold">notify( )</emphasis> is that both methods are part of the base class <emphasis role="bold">Object</emphasis> and not part of <emphasis role="bold">Thread</emphasis> as are <emphasis role="bold">sleep( )</emphasis>, <emphasis role="bold">suspend( )</emphasis>, and <emphasis role="bold">resume( )</emphasis>. Although this seems a bit strange at first�to have something that�s exclusively for threading as part of the universal base class�it�s essential because they manipulate the lock that�s also part of every object. As a result, you can put a <emphasis role="bold">wait( )</emphasis> inside any <emphasis role="bold">synchronized</emphasis> method, regardless of whether there�s any threading going on inside that particular class. In fact, the <emphasis role="italic">only</emphasis> place you can call <emphasis role="bold">wait( )</emphasis> is within a <emphasis role="bold">synchronized</emphasis> method or block. If you call <emphasis role="bold">wait( )</emphasis> or <emphasis role="bold">notify( )</emphasis> within a method that�s not <emphasis role="bold">synchronized,</emphasis> the program will compile, but when you run it you�ll get an <emphasis role="bold">IllegalMonitorStateException</emphasis> with the somewhat nonintuitive message �current thread not owner.� Note that <emphasis role="bold">sleep( )</emphasis>, <emphasis role="bold">suspend( ),</emphasis> and <emphasis role="bold">resume( )</emphasis> can all be called within non-<emphasis role="bold">synchronized</emphasis> methods since they don�t manipulate the lock.</para>
          <para>You can call <emphasis role="bold">wait( )</emphasis> or <emphasis role="bold">notify( )</emphasis> only for your own lock. Again, you can compile code that tries to use the wrong lock, but it will produce the same <emphasis role="bold">IllegalMonitorStateException</emphasis> message as before. You can�t fool with someone else�s lock, but you can ask another object to perform an operation that manipulates its own lock. So one approach is to create a <emphasis role="bold">synchronized</emphasis> method that calls <emphasis role="bold">notify( )</emphasis> for its own object. However, in <emphasis role="bold">Notifier</emphasis> you�ll see the <emphasis role="bold">notify( )</emphasis> call inside a <emphasis role="bold">synchronized</emphasis> block:</para>
          <para>synchronized(wn2) {</para>
          <para>� wn2.notify();</para>
          <para>}</para>
          <para> </para>
          <para>where <emphasis role="bold">wn2</emphasis> is the object of type <emphasis role="bold">WaitNotify2</emphasis>. This method, which is not part of <emphasis role="bold">WaitNotify2</emphasis>, acquires the lock on the <emphasis role="bold">wn2</emphasis> object, at which point it�s legal for it to call <emphasis role="bold">notify( )</emphasis> for <emphasis role="bold">wn2</emphasis> and you won�t get the <emphasis role="bold">IllegalMonitorStateException</emphasis>.</para>
          <para>///:Continuing</para>
          <para>/////////// Blocking via wait() ///////////</para>
          <para>class WaitNotify1 extends Blockable {</para>
          <para>� public WaitNotify1(Container c) { super(c); }</para>
          <para>� public synchronized void run() {</para>
          <para>��� while(true) {</para>
          <para>����� i++;</para>
          <para>����� update();</para>
          <para>������ try {</para>
          <para>������� wait(1000);</para>
          <para>����� } catch(InterruptedException e) {</para>
          <para>������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class WaitNotify2 extends Blockable {</para>
          <para>� public WaitNotify2(Container c) {</para>
          <para>��� super(c);</para>
          <para>��� new Notifier(this); </para>
          <para>� }</para>
          <para>� public synchronized void run() {</para>
          <para>��� while(true) {</para>
          <para>��� ��i++;</para>
          <para>����� update();</para>
          <para>������ try {</para>
          <para>������� wait();</para>
          <para>����� } catch(InterruptedException e) {</para>
          <para>������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class Notifier extends Thread {</para>
          <para>� private WaitNotify2 wn2;</para>
          <para>� public Notifier(WaitNotify2 wn2) {</para>
          <para>��� this.wn2 = wn2;</para>
          <para>��� start();</para>
          <para>� }</para>
          <para>� public void run() {</para>
          <para>��� while(true) {</para>
          <para>������ try {</para>
          <para>������� sleep(2000);</para>
          <para>����� } catch(InterruptedException e) {</para>
          <para>������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>����� }</para>
          <para>����� synchronized(wn2) {</para>
          <para>������� wn2.notify();</para>
          <para>����� }</para>
          <para>� ��}</para>
          <para>� }</para>
          <para>}� ///:Continued</para>
          <para> </para>
          <para><emphasis role="bold">wait( )</emphasis> is typically used when you�ve gotten to the point where you�re waiting for some other condition, under the control of forces outside your thread, to change and you don�t want to idly wait by inside the thread. So <emphasis role="bold">wait( )</emphasis> allows you to put the thread to sleep while waiting for the world to change, and only when a <emphasis role="bold">notify( )</emphasis> or <emphasis role="bold">notifyAll( ) </emphasis>occurs does the thread wake up and check for changes. Thus, it provides a way to synchronize between threads.</para>
        </section>
        <section>
          <title><anchor xreflabel="Blocking on I/O" xml:id="_Ref368085592"/>Blocking on I/O</title>
          <para>If a stream is waiting for some I/O activity, it will automatically block. In the following portion of the example, the two classes work with generic <emphasis role="bold">Reader</emphasis> and <emphasis role="bold">Writer</emphasis> objects, but in the test framework a piped stream will be set up to allow the two threads to safely pass data to each other (which is the purpose of piped streams).</para>
          <para>The <emphasis role="bold">Sender</emphasis> puts data into the <emphasis role="bold">Writer</emphasis> and sleeps for a random amount of time. However, <emphasis role="bold">Receiver</emphasis> has no <emphasis role="bold">sleep( )</emphasis>, <emphasis role="bold">suspend( )</emphasis>, or <emphasis role="bold">wait( )</emphasis>. But when it does a <emphasis role="bold">read( )</emphasis> it automatically blocks when there is no more data.</para>
          <para>///:Continuing</para>
          <para>class Sender extends Blockable { // send</para>
          <para>� private Writer out;</para>
          <para>� public Sender(Container c, Writer out) { </para>
          <para>��� super(c);</para>
          <para>��� this.out = out; </para>
          <para>� }</para>
          <para>� public void run() {</para>
          <para>��� while(true) {</para>
          <para>����� for(char c = &apos;A&apos;; c &lt;= &apos;z&apos;; c++) {</para>
          <para>������� try {</para>
          <para>��������� i++;</para>
          <para>��������� out.write(c);</para>
          <para>��������� state.setText(&quot;Sender sent: &quot; </para>
          <para>����������� + (char)c);</para>
          <para>��������� sleep((int)(3000 * Math.random()));</para>
          <para>������� } catch(InterruptedException e) {</para>
          <para>��������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>������� } catch(IOException e) {</para>
          <para>��������� System.err.println(&quot;IO problem&quot;);</para>
          <para>������� }</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>class Receiver extends Blockable {</para>
          <para>� private Reader in;</para>
          <para>� public Receiver(Container c, Reader in) { </para>
          <para>��� super(c);</para>
          <para>��� this.in = in; </para>
          <para>� }</para>
          <para>� public void run() {</para>
          <para>��� try {</para>
          <para>����� while(true) {</para>
          <para>������� i++; // Show peeker it&apos;s alive</para>
          <para>������� // Blocks until characters are there:</para>
          <para>������� state.setText(&quot;Receiver read: &quot;</para>
          <para>��������� + (char)in.read());</para>
          <para>����� }</para>
          <para>��� } catch(IOException e) {</para>
          <para>����� System.err.println(&quot;IO problem&quot;);</para>
          <para>��� }</para>
          <para>� }</para>
          <para>} ///:Continued</para>
          <para> </para>
          <para>Both classes also put information into their <emphasis role="bold">state</emphasis> fields and change <emphasis role="bold">i </emphasis>so the <emphasis role="bold">Peeker</emphasis> can see that the thread is running.</para>
        </section>
        <section>
          <title>Testing</title>
          <para>The main applet class is surprisingly simple because most of the work has been put into the <emphasis role="bold">Blockable</emphasis> framework. Basically, an array of <emphasis role="bold">Blockable</emphasis> objects is created, and since each one is a thread, they perform their own activities when you press the �start� button. There�s also a button and <emphasis role="bold">actionPerformed( )</emphasis> clause to stop all of the <emphasis role="bold">Peeker</emphasis> objects, which provides a demonstration of the alternative to the deprecated (in Java 2) <emphasis role="bold">stop( )</emphasis> method of <emphasis role="bold">Thread</emphasis>.</para>
          <para>To set up a connection between the <emphasis role="bold">Sender</emphasis> and <emphasis role="bold">Receiver</emphasis> objects, a <emphasis role="bold">PipedWriter</emphasis> and <emphasis role="bold">PipedReader</emphasis> are created. Note that the <emphasis role="bold">PipedReader</emphasis><emphasis role="bold">in </emphasis>must be connected to the <emphasis role="bold">PipedWriter</emphasis><emphasis role="bold">out </emphasis>via a constructor argument. After that, anything that�s placed in <emphasis role="bold">out</emphasis> can later be extracted from <emphasis role="bold">in</emphasis>, as if it passed through a pipe (hence the name). The <emphasis role="bold">in</emphasis> and <emphasis role="bold">out</emphasis> objects are then passed to the <emphasis role="bold">Receiver</emphasis> and <emphasis role="bold">Sender</emphasis> constructors, respectively, which treat them as <emphasis role="bold">Reader</emphasis> and <emphasis role="bold">Writer </emphasis>objects of any type (that is, they are upcast).</para>
          <para>The array of <emphasis role="bold">Blockable</emphasis> references <emphasis role="bold">b</emphasis> is not initialized at its point of definition because the piped streams cannot be set up before that definition takes place (the need for the <emphasis role="bold">try</emphasis> block prevents this). </para>
          <para>///:Continuing</para>
          <para>/////////// Testing Everything ///////////</para>
          <para>public class Blocking extends JApplet {</para>
          <para>� private JButton </para>
          <para>��� start = new JButton(&quot;Start&quot;),</para>
          <para>��� stopPeekers = new JButton(&quot;Stop Peekers&quot;);</para>
          <para>� private boolean started = false;</para>
          <para>� private Blockable[] b;</para>
          <para>� private PipedWriter out;</para>
          <para>� private PipedReader in;</para>
          <para>� class StartL implements ActionListener {</para>
          <para>��� public void actionPerformed(ActionEvent e) {</para>
          <para>����� if(!started) {</para>
          <para>������� started = true;</para>
          <para>������� for(int i = 0; i &lt; b.length; i++)</para>
          <para>��������� b[i].start();</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� }</para>
          <para>� class StopPeekersL implements ActionListener {</para>
          <para>��� public void actionPerformed(ActionEvent e) {</para>
          <para>����� // Demonstration of the preferred </para>
          <para>����� // alternative to Thread.stop():</para>
          <para>����� for(int i = 0; i &lt; b.length; i++)</para>
          <para>������� b[i].stopPeeker();</para>
          <para>��� }</para>
          <para>� }</para>
          <para>� public void init() {</para>
          <para>���� Container cp = getContentPane();</para>
          <para>���� cp.setLayout(new FlowLayout());</para>
          <para>���� out = new PipedWriter();</para>
          <para>��� try {</para>
          <para>����� in = new PipedReader(out);</para>
          <para>��� } catch(IOException e) {</para>
          <para>����� System.err.println(&quot;PipedReader problem&quot;);</para>
          <para>��� }</para>
          <para>��� b = new Blockable[] {</para>
          <para>����� new Sleeper1(cp),</para>
          <para>����� new Sleeper2(cp),</para>
          <para>����� new SuspendResume1(cp),</para>
          <para>����� new SuspendResume2(cp),</para>
          <para>����� new WaitNotify1(cp),</para>
          <para>����� new WaitNotify2(cp),</para>
          <para>����� new Sender(cp, out),</para>
          <para>����� new Receiver(cp, in)</para>
          <para>��� };</para>
          <para>��� start.addActionListener(new StartL());</para>
          <para>��� cp.add(start);</para>
          <para>��� stopPeekers.addActionListener(</para>
          <para>����� new StopPeekersL());</para>
          <para>��� cp.add(stopPeekers);</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Console.run(new Blocking(), 350, 550);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>In <emphasis role="bold">init( )</emphasis>, notice the loop that moves through the entire array and adds the <emphasis role="bold">state</emphasis> and <emphasis role="bold">peeker.status</emphasis> text fields to the page.</para>
          <para>When the <emphasis role="bold">Blockable </emphasis>threads are initially created, each one automatically creates and starts its own <emphasis role="bold">Peeker</emphasis>. So you�ll see the <emphasis role="bold">Peeker</emphasis>s running before the <emphasis role="bold">Blockable</emphasis> threads are started. This is important, as some of the <emphasis role="bold">Peeker</emphasis>s will get blocked and stop when the <emphasis role="bold">Blockable</emphasis> threads start, and it�s essential to see this to understand that particular aspect of blocking.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064858"/><anchor xreflabel="Deadlock" xml:id="_Toc375545483"/>Deadlock</title>
        <para>Because threads can become blocked <emphasis role="italic">and</emphasis> because objects can have <emphasis role="bold">synchronized</emphasis> methods that prevent threads from accessing that object until the synchronization lock is released, it�s possible for one thread to get stuck waiting for another thread, which in turn waits for another thread, etc., until the chain leads back to a thread waiting on the first one. You get a continuous loop of threads waiting on each other and no one can move. This is called <emphasis role="italic">deadlock</emphasis>. The claim is that it doesn�t happen that often, but when it happens to you it�s frustrating to debug. </para>
        <para>There is no language support to help prevent deadlock; it�s up to you to avoid it by careful design. These are not comforting words to the person who�s trying to debug a deadlocking program.</para>
        <section>
          <title>The deprecation of <emphasis role="bold">stop( )</emphasis>, <emphasis role="bold">suspend( )</emphasis>,  <emphasis role="bold">resume( ),</emphasis> and <emphasis role="bold">destroy( )</emphasis> in Java 2</title>
          <para>One change that has been made in Java 2 to reduce the possibility of deadlock is the deprecation of <emphasis role="bold">Thread</emphasis>�s <emphasis role="bold">stop( )</emphasis>, <emphasis role="bold">suspend( )</emphasis>, <emphasis role="bold">resume( )</emphasis>, and <emphasis role="bold">destroy( )</emphasis> methods. </para>
          <para>The reason that the <emphasis role="bold">stop( )</emphasis> method is deprecated is because it doesn�t release the locks that the thread has acquired, and if the objects are in an inconsistent state (�damaged�) other threads can view and modify them in that state. The resulting problems can be subtle and difficult to detect. Instead of using <emphasis role="bold">stop( )</emphasis>, you should follow the example in <emphasis role="bold">Blocking.java</emphasis> and use a flag to tell the thread when to terminate itself by exiting its <emphasis role="bold">run( )</emphasis> method.</para>
          <para>There are times when a thread blocks�such as when it is waiting for input�and it cannot poll a flag as it does in <emphasis role="bold">Blocking.java</emphasis>. In these cases, you still shouldn�t use <emphasis role="bold">stop( )</emphasis>, but instead you can use the <emphasis role="bold">interrupt( )</emphasis> method in <emphasis role="bold">Thread</emphasis> to break out of the blocked code:</para>
          <para>//: c14:Interrupt.java</para>
          <para>// The alternative approach to using </para>
          <para>// stop() when a thread is blocked.</para>
          <para>// &lt;applet code=Interrupt width=200 height=100&gt;</para>
          <para>// &lt;/applet&gt;</para>
          <para>import javax.swing.*;</para>
          <para>import java.awt.*;</para>
          <para>import java.awt.event.*;</para>
          <para>import com.bruceeckel.swing.*;</para>
          <para> </para>
          <para>class Blocked extends Thread {</para>
          <para>� public synchronized void run() {</para>
          <para>��� try {</para>
          <para>����� wait(); // Blocks</para>
          <para>��� } catch(InterruptedException e) {</para>
          <para>����� System.err.println(&quot;Interrupted&quot;);</para>
          <para>��� }</para>
          <para>��� System.out.println(&quot;Exiting run()&quot;);</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>public class Interrupt extends JApplet {</para>
          <para>� private JButton </para>
          <para>��� interrupt = new JButton(&quot;Interrupt&quot;);</para>
          <para>� private Blocked blocked = new Blocked();</para>
          <para>� public void init() {</para>
          <para>��� Container cp = getContentPane();</para>
          <para>��� cp.setLayout(new FlowLayout());</para>
          <para>��� cp.add(interrupt);</para>
          <para>��� interrupt.addActionListener(</para>
          <para>����� new ActionListener() {</para>
          <para>������� public </para>
          <para>������� void actionPerformed(ActionEvent e) {</para>
          <para>��������� System.out.println(&quot;Button pressed&quot;);</para>
          <para>��������� if(blocked == null) return;</para>
          <para>��������� Thread remove = blocked;</para>
          <para>��������� blocked = null; // to release it</para>
          <para>��������� remove.interrupt();</para>
          <para>������� }</para>
          <para>����� });</para>
          <para>��� blocked.start();</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Console.run(new Interrupt(), 200, 100);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The <emphasis role="bold">wait( )</emphasis> inside <emphasis role="bold">Blocked.run( )</emphasis> produces the blocked thread. When you press the button, the <emphasis role="bold">blocked</emphasis> reference is set to <emphasis role="bold">null</emphasis> so the garbage collector will clean it up, and then the object�s <emphasis role="bold">interrupt( )</emphasis> method is called. The first time you press the button you�ll see that the thread quits, but after that there�s no thread to kill so you just see that the button has been pressed.</para>
          <para>The <emphasis role="bold">suspend( )</emphasis> and <emphasis role="bold">resume( )</emphasis> methods turn out to be inherently deadlock-prone. When you call <emphasis role="bold">suspend( )</emphasis>, the target thread stops but it still holds any locks that it has acquired up to that point. So no other thread can access the locked resources until the thread is resumed. Any thread that wants to resume the target thread and also tries to use any of the locked resources produces deadlock. You should not use <emphasis role="bold">suspend( )</emphasis> and <emphasis role="bold">resume( )</emphasis>, but instead put a flag in your <emphasis role="bold">Thread</emphasis> class to indicate whether the thread should be active or suspended. If the flag indicates that the thread is suspended,�the thread goes into a wait using <emphasis role="bold">wait( )</emphasis>. When the flag indicates that the thread should be resumed the thread is restarted with <emphasis role="bold">notify( )</emphasis>. An example can be produced by modifying <emphasis role="bold">Counter2.java</emphasis>. Although the effect is similar, you�ll notice that the code organization is quite different�anonymous inner classes are used for all of the listeners and the <emphasis role="bold">Thread</emphasis> is an inner class, which makes programming slightly more convenient since it eliminates some of the extra bookkeeping necessary in <emphasis role="bold">Counter2.java</emphasis>:</para>
          <para>//: c14:Suspend.java</para>
          <para>// The alternative approach to using suspend()</para>
          <para>// and resume(), which are deprecated in Java 2.</para>
          <para>// &lt;applet code=Suspend width=300 height=100&gt;</para>
          <para>// &lt;/applet&gt;</para>
          <para>import javax.swing.*;</para>
          <para>import java.awt.*;</para>
          <para>import java.awt.event.*;</para>
          <para>import com.bruceeckel.swing.*;</para>
          <para> </para>
          <para>public class Suspend extends JApplet {</para>
          <para>� private JTextField t = new JTextField(10);</para>
          <para>� private JButton </para>
          <para>��� suspend = new JButton(&quot;Suspend&quot;),</para>
          <para>��� resume = new JButton(&quot;Resume&quot;);</para>
          <para>� private Suspendable ss = new Suspendable();</para>
          <para>� class Suspendable extends Thread {</para>
          <para>��� private int count = 0;</para>
          <para>��� private boolean suspended = false;</para>
          <para>��� public Suspendable() { start(); }</para>
          <para>��� public void fauxSuspend() { </para>
          <para>����� suspended = true;</para>
          <para>��� }</para>
          <para>��� public synchronized void fauxResume() {</para>
          <para>����� suspended = false;</para>
          <para>����� notify();</para>
          <para>��� }</para>
          <para>��� public void run() {</para>
          <para>����� while (true) {</para>
          <para>������� try {</para>
          <para>��������� sleep(100);</para>
          <para>��������� synchronized(this) {</para>
          <para>����������� while(suspended)</para>
          <para>������������� wait();</para>
          <para>��������� }</para>
          <para>������� } catch(InterruptedException e) {</para>
          <para>��������� System.err.println(&quot;Interrupted&quot;);</para>
          <para>������� }</para>
          <para>������� t.setText(Integer.toString(count++));</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� } </para>
          <para>� public void init() {</para>
          <para>��� Container cp = getContentPane();</para>
          <para>��� cp.setLayout(new FlowLayout());</para>
          <para>��� cp.add(t);</para>
          <para>� ��suspend.addActionListener(</para>
          <para>����� new ActionListener() {</para>
          <para>������� public </para>
          <para>������� void actionPerformed(ActionEvent e) {</para>
          <para>��������� ss.fauxSuspend();</para>
          <para>������� }</para>
          <para>����� });</para>
          <para>��� cp.add(suspend);</para>
          <para>��� resume.addActionListener(</para>
          <para>����� new ActionListener() {</para>
          <para>������� public </para>
          <para>������� void actionPerformed(ActionEvent e) {</para>
          <para>��������� ss.fauxResume();</para>
          <para>������� }</para>
          <para>����� });</para>
          <para>��� cp.add(resume);</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Console.run(new Suspend(), 300, 100);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The flag <emphasis role="bold">suspended</emphasis> inside <emphasis role="bold">Suspendable</emphasis> is used to turn suspension on and off. To suspend, the flag is set to <emphasis role="bold">true</emphasis> by calling <emphasis role="bold">fauxSuspend( ) </emphasis>and this is detected inside <emphasis role="bold">run( )</emphasis>. The <emphasis role="bold">wait( )</emphasis>, as described earlier in this chapter, must be <emphasis role="bold">synchronized</emphasis> so that it has the object lock. In <emphasis role="bold">fauxResume( )</emphasis>, the <emphasis role="bold">suspended</emphasis> flag is set to <emphasis role="bold">false</emphasis> and <emphasis role="bold">notify( )</emphasis> is called�since this wakes up <emphasis role="bold">wait( )</emphasis> inside a <emphasis role="bold">synchronized</emphasis> clause the <emphasis role="bold">fauxResume( )</emphasis> method must also be <emphasis role="bold">synchronized</emphasis> so that it acquires the lock before calling <emphasis role="bold">notify( )</emphasis> (thus the lock is available for the <emphasis role="bold">wait( )</emphasis> to wake up with). If you follow the style shown in this program you can avoid using <emphasis role="bold">suspend( )</emphasis> and <emphasis role="bold">resume( )</emphasis>.</para>
          <para>The <emphasis role="bold">destroy( )</emphasis> method of <emphasis role="bold">Thread </emphasis>has never been implemented; it�s like a <emphasis role="bold">suspend( )</emphasis> that cannot resume, so it has the same deadlock issues as <emphasis role="bold">suspend( )</emphasis>. However, this is not a deprecated method and it might be implemented in a future version of Java (after 2) for special situations in which the risk of a deadlock is acceptable.</para>
          <para>You might wonder why these methods, now deprecated, were included in Java in the first place. It seems an admission of a rather significant mistake to simply remove them outright (and pokes yet another hole in the arguments for Java�s exceptional design and infallibility touted by Sun marketing people). The heartening part about the change is that it clearly indicates that the technical people and not the marketing people are running the show�they discovered a problem and they are fixing it. I find this much more promising and hopeful than leaving the problem in because �fixing it would admit an error.� It means that Java will continue to improve, even if it means a little discomfort on the part of Java programmers. I�d rather deal with the discomfort than watch the language stagnate.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064859"/><anchor xreflabel="Priorities" xml:id="_Toc375545484"/>Priorities</title>
      <para>The <emphasis role="italic">priority</emphasis> of a thread tells the scheduler how important this thread is. If there are a number of threads blocked and waiting to be run, the scheduler will run the one with the highest priority first. However, this doesn�t mean that threads with lower priority don�t get run (that is, you can�t get deadlocked because of priorities). Lower priority threads just tend to run less often.</para>
      <para>Although priorities are interesting to know about and to play with, in practice you almost never need to set priorities yourself. So feel free to skip the rest of this section if priorities aren�t interesting to you.</para>
      <section>
        <title><anchor xreflabel="Reading and setting priorities" xml:id="_Toc481064860"/>Reading and setting priorities</title>
        <para>You can read the priority of a thread with <emphasis role="bold">getPriority( ) </emphasis>and change it with <emphasis role="bold">setPriority( )</emphasis>. The form of the prior �counter� examples can be used to show the effect of changing the priorities. In this applet you�ll see that the counters slow down as the associated threads have their priorities lowered:</para>
        <para>//: c14:Counter5.java</para>
        <para>// Adjusting the priorities of threads.</para>
        <para>// &lt;applet code=Counter5 width=450 height=600&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>class Ticker2 extends Thread {</para>
        <para>� private JButton</para>
        <para>��� b = new JButton(&quot;Toggle&quot;),</para>
        <para>��� incPriority = new JButton(&quot;up&quot;),</para>
        <para>��� decPriority = new JButton(&quot;down&quot;);</para>
        <para>� private JTextField</para>
        <para>��� t = new JTextField(10),</para>
        <para>��� pr = new JTextField(3); // Display priority</para>
        <para>� private int count = 0;</para>
        <para>� private boolean runFlag = true;</para>
        <para>� public Ticker2(Container c) {</para>
        <para>��� b.addActionListener(new ToggleL());</para>
        <para>��� incPriority.addActionListener(new UpL());</para>
        <para>��� decPriority.addActionListener(new DownL());</para>
        <para>��� JPanel p = new JPanel();</para>
        <para>��� p.add(t);</para>
        <para>��� p.add(pr);</para>
        <para>��� p.add(b);</para>
        <para>��� p.add(incPriority);</para>
        <para>��� p.add(decPriority);</para>
        <para>��� c.add(p);</para>
        <para>� }</para>
        <para>� class ToggleL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� runFlag = !runFlag;</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class UpL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� int newPriority = getPriority() + 1;</para>
        <para>����� if(newPriority &gt; Thread.MAX_PRIORITY)</para>
        <para>������� newPriority = Thread.MAX_PRIORITY;</para>
        <para>����� setPriority(newPriority);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class DownL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� int newPriority = getPriority() - 1;</para>
        <para>����� if(newPriority &lt; Thread.MIN_PRIORITY)</para>
        <para>������� newPriority = Thread.MIN_PRIORITY;</para>
        <para>����� setPriority(newPriority);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void run() {</para>
        <para>��� while (true) {</para>
        <para>����� if(runFlag) {</para>
        <para>������� t.setText(Integer.toString(count++));</para>
        <para>������� pr.setText(</para>
        <para>��������� Integer.toString(getPriority()));</para>
        <para>����� }</para>
        <para>����� yield();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Counter5 extends JApplet {</para>
        <para>� private JButton</para>
        <para>��� start = new JButton(&quot;Start&quot;),</para>
        <para>��� upMax = new JButton(&quot;Inc Max Priority&quot;),</para>
        <para>��� downMax = new JButton(&quot;Dec Max Priority&quot;);</para>
        <para>� private boolean started = false;</para>
        <para>� private static final int SIZE = 10;</para>
        <para>� private Ticker2[] s = new Ticker2[SIZE];</para>
        <para>� private<emphasis role="bold"/>JTextField mp = new<emphasis role="bold"/>JTextField(3);</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� for(int i = 0; i &lt; s.length; i++)</para>
        <para>����� s[i] = new Ticker2(cp);</para>
        <para>��� cp.add(new JLabel(</para>
        <para>����� &quot;MAX_PRIORITY = &quot; + Thread.MAX_PRIORITY));</para>
        <para>��� cp.add(new JLabel(&quot;MIN_PRIORITY = &quot;</para>
        <para>����� + Thread.MIN_PRIORITY));</para>
        <para>��� cp.add(new JLabel(&quot;Group Max Priority = &quot;));</para>
        <para>��� cp.add(mp);</para>
        <para>��� cp.add(start);</para>
        <para>��� cp.add(upMax);</para>
        <para>��� cp.add(downMax);</para>
        <para>��� start.addActionListener(new StartL());</para>
        <para>��� upMax.addActionListener(new UpMaxL());</para>
        <para>��� downMax.addActionListener(new DownMaxL());</para>
        <para>��� showMaxPriority();</para>
        <para>��� // Recursively display parent thread groups:</para>
        <para>��� ThreadGroup parent =</para>
        <para>����� s[0].getThreadGroup().getParent();</para>
        <para>��� while(parent != null) {</para>
        <para>����� cp.add(new Label(</para>
        <para>������� &quot;Parent threadgroup max priority = &quot;</para>
        <para>������� + parent.getMaxPriority()));</para>
        <para>����� parent = parent.getParent();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void showMaxPriority() {</para>
        <para>��� mp.setText(Integer.toString(</para>
        <para>����� s[0].getThreadGroup().getMaxPriority()));</para>
        <para>� }</para>
        <para>� class StartL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� if(!started) {</para>
        <para>������� started = true;</para>
        <para>������� for(int i = 0; i &lt; s.length; i++)</para>
        <para>��� ������s[i].start();</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class UpMaxL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� int maxp =</para>
        <para>������� s[0].getThreadGroup().getMaxPriority();</para>
        <para>����� if(++maxp &gt; Thread.MAX_PRIORITY)</para>
        <para>������� maxp = Thread.MAX_PRIORITY;</para>
        <para>����� s[0].getThreadGroup().setMaxPriority(maxp);</para>
        <para>����� showMaxPriority();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class DownMaxL implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent e) {</para>
        <para>����� int maxp =</para>
        <para>������� s[0].getThreadGroup().getMaxPriority();</para>
        <para>����� if(--maxp &lt; Thread.MIN_PRIORITY)</para>
        <para>������� maxp = Thread.MIN_PRIORITY;</para>
        <para>����� s[0].getThreadGroup().setMaxPriority(maxp);</para>
        <para>����� showMaxPriority();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new Counter5(), 450, 600);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">Ticker2</emphasis> follows the form established earlier in this chapter, but there�s an extra<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis> for displaying the priority of the thread and two more buttons for incrementing and decrementing the priority.</para>
        <para>Also notice the use of <emphasis role="bold">yield( )</emphasis>, which voluntarily hands control back to the scheduler. Without this the multithreading mechanism still works, but you�ll notice it runs slowly (try removing the call to <emphasis role="bold">yield( ) </emphasis>to see this). You could also call <emphasis role="bold">sleep( )</emphasis>, but then the rate of counting would be controlled by the <emphasis role="bold">sleep( )</emphasis> duration instead of the priority.</para>
        <para>The <emphasis role="bold">init( )</emphasis> in <emphasis role="bold">Counter5</emphasis> creates an array of ten <emphasis role="bold">Ticker2</emphasis>s; their buttons and fields are placed on the form by the <emphasis role="bold">Ticker2</emphasis> constructor. <emphasis role="bold">Counter5 </emphasis>adds buttons to start everything up as well as increment and decrement the maximum priority of the thread group. In addition, there are labels that display the maximum and minimum priorities possible for a thread and a<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis> to show the thread group�s maximum priority. (The next section will describe thread groups.) Finally, the priorities of the parent thread groups are also displayed as labels.</para>
        <para>When you press an �up� or �down� button, that <emphasis role="bold">Ticker2</emphasis>�s priority is fetched and incremented or decremented accordingly. </para>
        <para>When you run this program, you�ll notice several things. First of all, the thread group�s default priority is five. Even if you decrement the maximum priority below five before starting the threads (or before creating the threads, which requires a code change), each thread will have a default priority of five.</para>
        <para>The simple test is to take one counter and decrement its priority to one, and observe that it counts much slower. But now try to increment it again. You can get it back up to the thread group�s priority, but no higher. Now decrement the thread group�s priority a couple of times. The thread priorities are unchanged, but if you try to modify them either up or down you�ll see that they�ll automatically pop to the priority of the thread group. Also, new threads will still be given a default priority, even if that�s higher than the group priority. (Thus the group priority is not a way to prevent new threads from having higher priorities than existing ones.)</para>
        <para>Finally, try to increment the group maximum priority. It can�t be done. You can only reduce thread group maximum priorities, not increase them.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064861"/><anchor xreflabel="Thread
groups" xml:id="_Toc375545485"/>Thread groups</title>
        <para>All threads belong to a thread group. This can be either the default thread group or a group you explicitly specify when you create the thread. At creation, the thread is bound to a group and cannot change to a different group. Each application has at least one thread that belongs to the system thread group. If you create more threads without specifying a group, they will also belong to the system thread group. </para>
        <para>Thread groups must also belong to other thread groups. The thread group that a new one belongs to must be specified in the constructor. If you create a thread group without specifying a thread group for it to belong to, it will be placed under the system thread group. Thus, all thread groups in your application will ultimately have the system thread group as the parent.</para>
        <para>The reason for the existence of thread groups is hard to determine from the literature, which tends to be confusing on this subject. It�s often cited as �security reasons.� According to Arnold &amp; Gosling,<anchor xreflabel="[71]" xml:id="_ftnref71"/>[71] �Threads within a thread group can modify the other threads in the group, including any farther down the hierarchy. A thread cannot modify threads outside of its own group or contained groups.� It�s hard to know what �modify� is supposed to mean here. The following example shows a thread in a �leaf� subgroup modifying the priorities of all the threads in its tree of thread groups as well as calling a method for all the threads in its tree.</para>
        <para>//: c14:TestAccess.java</para>
        <para>// How threads can access other threads</para>
        <para>// in a parent thread group.</para>
        <para> </para>
        <para>public class TestAccess {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� ThreadGroup </para>
        <para>����� x = new ThreadGroup(&quot;x&quot;),</para>
        <para>����� y = new ThreadGroup(x, &quot;y&quot;),</para>
        <para>����� z = new ThreadGroup(y, &quot;z&quot;);</para>
        <para>��� Thread</para>
        <para>����� one = new TestThread1(x, &quot;one&quot;),</para>
        <para>����� two = new TestThread2(z, &quot;two&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class TestThread1 extends Thread {</para>
        <para>� private int i;</para>
        <para>� TestThread1(ThreadGroup g, String name) {</para>
        <para>��� super(g, name);</para>
        <para>� }</para>
        <para>� void f() {</para>
        <para>��� i++; // modify this thread</para>
        <para>��� System.out.println(getName() + &quot; f()&quot;);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class TestThread2 extends TestThread1 {</para>
        <para>� TestThread2(ThreadGroup g, String name) {</para>
        <para>��� super(g, name);</para>
        <para>��� start();</para>
        <para>� }</para>
        <para>� public void run() {</para>
        <para>��� ThreadGroup g =</para>
        <para>����� getThreadGroup().getParent().getParent();</para>
        <para>��� g.list();</para>
        <para>��� Thread[] gAll = new Thread[g.activeCount()];</para>
        <para>��� g.enumerate(gAll);</para>
        <para>��� for(int i = 0; i &lt; gAll.length; i++) {</para>
        <para>����� gAll[i].setPriority(Thread.MIN_PRIORITY);</para>
        <para>����� ((TestThread1)gAll[i]).f();</para>
        <para>��� }</para>
        <para>��� g.list();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In <emphasis role="bold">main( )</emphasis>, several <emphasis role="bold">ThreadGroup</emphasis>s are created, leafing off from each other: <emphasis role="bold">x</emphasis> has no argument but its name (a <emphasis role="bold">String</emphasis>), so it is automatically placed in the �system� thread group, while <emphasis role="bold">y</emphasis> is under <emphasis role="bold">x</emphasis> and <emphasis role="bold">z</emphasis> is under <emphasis role="bold">y</emphasis>. Note that initialization happens in textual order so this code is legal.</para>
        <para>Two threads are created and placed in different thread groups. <emphasis role="bold">TestThread1</emphasis> doesn�t have a <emphasis role="bold">run( )</emphasis> method but it does have an <emphasis role="bold">f( )</emphasis> that modifies the thread and prints something so you can see it was called. <emphasis role="bold">TestThread2</emphasis> is a subclass of <emphasis role="bold">TestThread1</emphasis> and its <emphasis role="bold">run( )</emphasis> is fairly elaborate. It first gets the thread group of the current thread, then moves up the heritage tree by two levels using <emphasis role="bold">getParent( )</emphasis>. (This is contrived since I purposely place the <emphasis role="bold">TestThread2</emphasis> object two levels down in the hierarchy.) At this point, an array of references to <emphasis role="bold">Thread</emphasis>s is created using the method <emphasis role="bold">activeCount( )</emphasis> to ask how many threads are in this thread group and all the child thread groups. The <emphasis role="bold">enumerate( )</emphasis> method places references to all of these threads in the array <emphasis role="bold">gAll</emphasis>, then I simply move through the entire array calling the <emphasis role="bold">f( )</emphasis> method for each thread, as well as modifying the priority. Thus, a thread in a �leaf� thread group modifies threads in parent thread groups.</para>
        <para>The debugging method <emphasis role="bold">list( )</emphasis> prints all the information about a thread group to standard output and is helpful when investigating thread group behavior. Here�s the output of the program:</para>
        <para>java.lang.ThreadGroup[name=x,maxpri=10]</para>
        <para>��� Thread[one,5,x]</para>
        <para>��� java.lang.ThreadGroup[name=y,maxpri=10]</para>
        <para>������� java.lang.ThreadGroup[name=z,maxpri=10]</para>
        <para>����������� Thread[two,5,z]</para>
        <para>one f()</para>
        <para>two f()</para>
        <para>java.lang.ThreadGroup[name=x,maxpri=10]</para>
        <para>��� Thread[one,1,x]</para>
        <para>��� java.lang.ThreadGroup[name=y,maxpri=10]</para>
        <para>������� java.lang.ThreadGroup[name=z,maxpri=10]</para>
        <para>����������� Thread[two,1,z]</para>
        <para> </para>
        <para>Not only does <emphasis role="bold">list( )</emphasis> print the class name of <emphasis role="bold">ThreadGroup</emphasis> or <emphasis role="bold">Thread</emphasis>, but it also prints the thread group name and its maximum priority. For threads, the thread name is printed, followed by the thread priority and the group that it belongs to. Note that <emphasis role="bold">list( )</emphasis> indents the threads and thread groups to indicate that they are children of the unindented thread group.</para>
        <para>You can see that <emphasis role="bold">f( )</emphasis> is called by the <emphasis role="bold">TestThread2</emphasis><emphasis role="bold">run( )</emphasis> method, so it�s obvious that all threads in a group are vulnerable. However, you can access only the threads that branch off from your own <emphasis role="bold">system</emphasis> thread group tree, and perhaps this is what is meant by �safety.� You cannot access anyone else�s system thread group tree.</para>
        <section>
          <title>Controlling thread groups</title>
          <para>Putting aside the safety issue, one thing thread groups seem to be useful for is control: you can perform certain operations on an entire thread group with a single command. The following example demonstrates this, and the restrictions on priorities within thread groups. The commented numbers in parentheses provide a reference to compare to the output.</para>
          <para>//: c14:ThreadGroup1.java</para>
          <para>// How thread groups control priorities</para>
          <para>// of the threads inside them.</para>
          <para> </para>
          <para>public class ThreadGroup1 {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� // Get the system thread &amp; print its Info:</para>
          <para>��� ThreadGroup sys = </para>
          <para>����� Thread.currentThread().getThreadGroup();</para>
          <para>��� sys.list(); // (1)</para>
          <para>��� // Reduce the system thread group priority:</para>
          <para>��� sys.setMaxPriority(Thread.MAX_PRIORITY - 1);</para>
          <para>��� // Increase the main thread priority:</para>
          <para>��� Thread curr = Thread.currentThread();</para>
          <para>��� curr.setPriority(curr.getPriority() + 1);</para>
          <para>��� sys.list(); // (2)</para>
          <para>��� // Attempt to set a new group to the max:</para>
          <para>��� ThreadGroup g1 = new ThreadGroup(&quot;g1&quot;);</para>
          <para>��� g1.setMaxPriority(Thread.MAX_PRIORITY);</para>
          <para>��� // Attempt to set a new thread to the max:</para>
          <para>��� Thread t = new Thread(g1, &quot;A&quot;);</para>
          <para>��� t.setPriority(Thread.MAX_PRIORITY);</para>
          <para>��� g1.list(); // (3)</para>
          <para>��� // Reduce g1&apos;s max priority, then attempt</para>
          <para>��� // to increase it:</para>
          <para>��� g1.setMaxPriority(Thread.MAX_PRIORITY - 2);</para>
          <para>��� g1.setMaxPriority(Thread.MAX_PRIORITY);</para>
          <para>��� g1.list(); // (4)</para>
          <para>��� // Attempt to set a new thread to the max:</para>
          <para>��� t = new Thread(g1, &quot;B&quot;);</para>
          <para>��� t.setPriority(Thread.MAX_PRIORITY);</para>
          <para>��� g1.list(); // (5)</para>
          <para>��� // Lower the max priority below the default</para>
          <para>��� // thread priority:</para>
          <para>��� g1.setMaxPriority(Thread.MIN_PRIORITY + 2);</para>
          <para>��� // Look at a new thread&apos;s priority before</para>
          <para>��� // and after changing it:</para>
          <para>��� t = new Thread(g1, &quot;C&quot;);</para>
          <para>��� g1.list(); // (6)</para>
          <para>��� t.setPriority(t.getPriority() -1);</para>
          <para>��� g1.list(); // (7)</para>
          <para>��� // Make g2 a child Threadgroup of g1 and</para>
          <para>��� // try to increase its priority:</para>
          <para>��� ThreadGroup g2 = new ThreadGroup(g1, &quot;g2&quot;);</para>
          <para>�� �g2.list(); // (8)</para>
          <para>��� g2.setMaxPriority(Thread.MAX_PRIORITY);</para>
          <para>��� g2.list(); // (9)</para>
          <para>��� // Add a bunch of new threads to g2:</para>
          <para>��� for (int i = 0; i &lt; 5; i++)</para>
          <para>����� new Thread(g2, Integer.toString(i));</para>
          <para>��� // Show information about all threadgroups</para>
          <para>��� // and threads:</para>
          <para>��� sys.list(); // (10)</para>
          <para>��� System.out.println(&quot;Starting all threads:&quot;);</para>
          <para>��� Thread[] all = new Thread[sys.activeCount()];</para>
          <para>��� sys.enumerate(all);</para>
          <para>��� for(int i = 0; i &lt; all.length; i++)</para>
          <para>����� if(!all[i].isAlive())</para>
          <para>������� all[i].start();</para>
          <para>��� // Suspends &amp; Stops all threads in </para>
          <para>��� // this group and its subgroups:</para>
          <para>��� System.out.println(&quot;All threads started&quot;);</para>
          <para>��� sys.suspend(); // Deprecated in Java 2</para>
          <para>��� // Never gets here...</para>
          <para>��� System.out.println(&quot;All threads suspended&quot;);</para>
          <para>��� sys.stop(); // Deprecated in Java 2</para>
          <para>��� System.out.println(&quot;All threads stopped&quot;);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The output that follows has been edited to allow it to fit on the page (the <emphasis role="bold">java.lang.</emphasis> has been removed) and to add numbers to correspond to the commented numbers in the listing above.</para>
          <para>(1) ThreadGroup[name=system,maxpri=10]</para>
          <para>����� Thread[main,5,system]</para>
          <para>(2) ThreadGroup[name=system,maxpri=9]</para>
          <para>����� Thread[main,6,system]</para>
          <para>(3) ThreadGroup[name=g1,maxpri=9]</para>
          <para>����� Thread[A,9,g1]</para>
          <para>(4) ThreadGroup[name=g1,maxpri=8]</para>
          <para>����� Thread[A,9,g1]</para>
          <para>(5) ThreadGroup[name=g1,maxpri=8]</para>
          <para>����� Thread[A,9,g1]</para>
          <para>����� Thread[B,8,g1]</para>
          <para>(6) ThreadGroup[name=g1,maxpri=3]</para>
          <para>����� Thread[A,9,g1]</para>
          <para>����� Thread[B,8,g1]</para>
          <para>����� Thread[C,6,g1]</para>
          <para>(7) ThreadGroup[name=g1,maxpri=3]</para>
          <para>����� Thread[A,9,g1]</para>
          <para>����� Thread[B,8,g1]</para>
          <para>����� Thread[C,3,g1]</para>
          <para>(8) ThreadGroup[name=g2,maxpri=3]</para>
          <para>(9) ThreadGroup[name=g2,maxpri=3]</para>
          <para>(10)ThreadGroup[name=system,maxpri=9]</para>
          <para>����� Thread[main,6,system]</para>
          <para>����� ThreadGroup[name=g1,maxpri=3]</para>
          <para>������� Thread[A,9,g1]</para>
          <para>������� Thread[B,8,g1]</para>
          <para>������� Thread[C,3,g1]</para>
          <para>����� ��ThreadGroup[name=g2,maxpri=3]</para>
          <para>��������� Thread[0,6,g2]</para>
          <para>��������� Thread[1,6,g2]</para>
          <para>��������� Thread[2,6,g2]</para>
          <para>��������� Thread[3,6,g2]</para>
          <para>��������� Thread[4,6,g2]</para>
          <para>Starting all threads:</para>
          <para>All threads started</para>
          <para> </para>
          <para>All programs have at least one thread running, and the first action in <emphasis role="bold">main( )</emphasis> is to call the <emphasis role="bold">static</emphasis> method of <emphasis role="bold">Thread</emphasis> called <emphasis role="bold">currentThread( )</emphasis>. From this thread, the thread group is produced and <emphasis role="bold">list( )</emphasis> is called for the result. The output is:</para>
          <para>(1) ThreadGroup[name=system,maxpri=10]</para>
          <para>����� Thread[main,5,system]</para>
          <para> </para>
          <para>You can see that the name of the main thread group is <emphasis role="bold">system</emphasis>, and the name of the main thread is <emphasis role="bold">main</emphasis>, and it belongs to the <emphasis role="bold">system</emphasis> thread group.</para>
          <para>The second exercise shows that the <emphasis role="bold">system</emphasis> group�s maximum priority can be reduced and the <emphasis role="bold">main</emphasis> thread can have its priority increased:</para>
          <para>(2) ThreadGroup[name=system,maxpri=9]</para>
          <para>����� Thread[main,6,system]</para>
          <para> </para>
          <para>The third exercise creates a new thread group, <emphasis role="bold">g1</emphasis>, which automatically belongs to the <emphasis role="bold">system</emphasis> thread group since it isn�t otherwise specified. A new thread <emphasis role="bold">A </emphasis>is placed in <emphasis role="bold">g1</emphasis>. After attempting to set this group�s maximum priority to the highest level and <emphasis role="bold">A</emphasis>�s priority to the highest level, the result is:</para>
          <para>(3) ThreadGroup[name=g1,maxpri=9]</para>
          <para>����� Thread[A,9,g1]</para>
          <para> </para>
          <para>Thus, it�s not possible to change the thread group�s maximum priority to be higher than its parent thread group.</para>
          <para>The fourth exercise reduces <emphasis role="bold">g1</emphasis>�s maximum priority by two and then tries to increase it up to <emphasis role="bold">Thread.MAX_PRIORITY</emphasis>. The result is:</para>
          <para>(4) ThreadGroup[name=g1,maxpri=8]</para>
          <para>����� Thread[A,9,g1]</para>
          <para> </para>
          <para>You can see that the increase in maximum priority didn�t work. You can only decrease a thread group�s maximum priority, not increase it. Also, notice that thread <emphasis role="bold">A</emphasis>�s priority didn�t change, and now it is higher than the thread group�s maximum priority. Changing a thread group�s maximum priority doesn�t affect existing threads.</para>
          <para>The fifth exercise attempts to set a new thread to maximum priority:</para>
          <para>(5) ThreadGroup[name=g1,maxpri=8]</para>
          <para>����� Thread[A,9,g1]</para>
          <para>����� Thread[B,8,g1]</para>
          <para> </para>
          <para>The new thread cannot be changed to anything higher than the maximum thread group priority.</para>
          <para>The default thread priority for this program is six; that�s the priority a new thread will be created at and where it will stay if you don�t manipulate the priority. Exercise 6 lowers the maximum thread group priority below the default thread priority to see what happens when you create a new thread under this condition:</para>
          <para>(6) ThreadGroup[name=g1,maxpri=3]</para>
          <para>����� Thread[A,9,g1]</para>
          <para>����� Thread[B,8,g1]</para>
          <para>����� Thread[C,6,g1]</para>
          <para> </para>
          <para>Even though the maximum priority of the thread group is three, the new thread is still created using the default priority of six. Thus, maximum thread group priority does not affect default priority. (In fact, there appears to be no way to set the default priority for new threads.)</para>
          <para>After changing the priority, attempting to decrement it by one, the result is:</para>
          <para>(7) ThreadGroup[name=g1,maxpri=3]</para>
          <para>����� Thread[A,9,g1]</para>
          <para>����� Thread[B,8,g1]</para>
          <para>����� Thread[C,3,g1]</para>
          <para> </para>
          <para>Only when you attempt to change the priority is the thread group�s maximum priority enforced.</para>
          <para>A similar experiment is performed in (8) and (9), in which a new thread group <emphasis role="bold">g2 </emphasis>is created as a child of <emphasis role="bold">g1</emphasis> and its maximum priority is changed. You can see that it�s impossible for <emphasis role="bold">g2</emphasis>�s maximum to go higher than <emphasis role="bold">g1</emphasis>�s:</para>
          <para>(8) ThreadGroup[name=g2,maxpri=3]</para>
          <para>(9) ThreadGroup[name=g2,maxpri=3]</para>
          <para> </para>
          <para>Also notice that <emphasis role="bold">g2</emphasis> is automatically set to the thread group maximum priority of <emphasis role="bold">g1</emphasis> as <emphasis role="bold">g2</emphasis> is created.</para>
          <para>After all of these experiments, the entire system of thread groups and threads is printed:</para>
          <para>(10)ThreadGroup[name=system,maxpri=9]</para>
          <para>����� Thread[main,6,system]</para>
          <para>����� ThreadGroup[name=g1,maxpri=3]</para>
          <para>������� Thread[A,9,g1]</para>
          <para>������� Thread[B,8,g1]</para>
          <para>������� Thread[C,3,g1]</para>
          <para>������� ThreadGroup[name=g2,maxpri=3]</para>
          <para>��������� Thread[0,6,g2]</para>
          <para>��������� Thread[1,6,g2]</para>
          <para>��������� Thread[2,6,g2]</para>
          <para>��������� Thread[3,6,g2]</para>
          <para>��������� Thread[4,6,g2]</para>
          <para> </para>
          <para>So because of the rules of thread groups, a child group must always have a maximum priority that�s less than or equal to its parent�s maximum priority.</para>
          <para>The last part of this program demonstrates methods for an entire group of threads. First the program moves through the entire tree of threads and starts each one that hasn�t been started. For drama, the <emphasis role="bold">system</emphasis> group is then suspended and finally stopped. (Although it�s interesting to see that <emphasis role="bold">suspend( )</emphasis> and <emphasis role="bold">stop( )</emphasis> work on entire thread groups, you should keep in mind that these methods are deprecated in Java 2.) But when you suspend the <emphasis role="bold">system</emphasis> group you also suspend the <emphasis role="bold">main</emphasis> thread and the whole program shuts down, so it never gets to the point where the threads are stopped. Actually, if you do stop the <emphasis role="bold">main</emphasis> thread it throws a <emphasis role="bold">ThreadDeath</emphasis> exception, so this is not a typical thing to do. Since <emphasis role="bold">ThreadGroup</emphasis> is inherited from <emphasis role="bold">Object,</emphasis> which contains the <emphasis role="bold">wait( )</emphasis> method, you can also choose to suspend the program for any number of seconds by calling <emphasis role="bold">wait(seconds * 1000)</emphasis>. This must acquire the lock inside a synchronized block, of course.</para>
          <para>The <emphasis role="bold">ThreadGroup</emphasis> class also has <emphasis role="bold">suspend( )</emphasis> and <emphasis role="bold">resume( )</emphasis> methods so you can stop and start an entire thread group and all of its threads and subgroups with a single command. (Again, <emphasis role="bold">suspend( )</emphasis> and <emphasis role="bold">resume( )</emphasis> are deprecated in Java 2.)</para>
          <para>Thread groups can seem a bit mysterious at first, but keep in mind that you probably won�t be using them directly very often.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064862"/><anchor xreflabel="Runnable revisited" xml:id="_Toc375545486"/><emphasis role="bold">Runnable</emphasis> revisited</title>
      <para>Earlier in this chapter, I suggested that you think carefully before making an applet or main <emphasis role="bold">Frame</emphasis> as an implementation of <emphasis role="bold">Runnable</emphasis>. Of course, if you must inherit from a class <emphasis role="italic">and</emphasis> you want to add threading behavior to the class, <emphasis role="bold">Runnable</emphasis> is the correct solution. The final example in this chapter exploits this by making a <emphasis role="bold">Runnable</emphasis><emphasis role="bold">JPanel</emphasis> class that paints different colors on itself. This application is set up to take values from the command line to determine how big the grid of colors is and how long to <emphasis role="bold">sleep( )</emphasis> between color changes. By playing with these values you�ll discover some interesting and possibly inexplicable features of threads:</para>
      <para>//: c14:ColorBoxes.java</para>
      <para>// Using the Runnable interface.</para>
      <para>// &lt;applet code=ColorBoxes width=500 height=400&gt;</para>
      <para>// &lt;param name=grid value=&quot;12&quot;&gt;</para>
      <para>// &lt;param name=pause value=&quot;50&quot;&gt;</para>
      <para>// &lt;/applet&gt;</para>
      <para>import javax.swing.*;</para>
      <para>import java.awt.*;</para>
      <para>import java.awt.event.*;</para>
      <para>import com.bruceeckel.swing.*;</para>
      <para> </para>
      <para>class CBox extends JPanel implements Runnable {</para>
      <para>� private Thread t;</para>
      <para>� private int pause;</para>
      <para>� private static final Color[] colors = { </para>
      <para>��� Color.black, Color.blue, Color.cyan, </para>
      <para>��� Color.darkGray, Color.gray, Color.green,</para>
      <para>��� Color.lightGray, Color.magenta, </para>
      <para>��� Color.orange, Color.pink, Color.red, </para>
      <para>��� Color.white, Color.yellow </para>
      <para>� };</para>
      <para>� private Color cColor = newColor();</para>
      <para>� private static final Color newColor() {</para>
      <para>��� return colors[</para>
      <para>����� (int)(Math.random() * colors.length)</para>
      <para>��� ];</para>
      <para>� }</para>
      <para>� public void paintComponent(Graphics� g) {</para>
      <para>��� super.paintComponent(g);</para>
      <para>��� g.setColor(cColor);</para>
      <para>��� Dimension s = getSize();</para>
      <para>��� g.fillRect(0, 0, s.width, s.height);</para>
      <para>� }</para>
      <para>� public CBox(int pause) {</para>
      <para>��� this.pause = pause;</para>
      <para>��� t = new Thread(this);</para>
      <para>��� t.start(); </para>
      <para>� }</para>
      <para>� public void run() {</para>
      <para>��� while(true) {</para>
      <para>����� cColor = newColor();</para>
      <para>����� repaint();</para>
      <para>����� try {</para>
      <para>������� t.sleep(pause);</para>
      <para>����� } catch(InterruptedException e) {</para>
      <para>������� System.err.println(&quot;Interrupted&quot;);</para>
      <para>����� }</para>
      <para>��� } </para>
      <para>� }</para>
      <para>} </para>
      <para> </para>
      <para>public class ColorBoxes extends JApplet {</para>
      <para>� private boolean isApplet = true;</para>
      <para>� private int grid = 12;</para>
      <para>� private int pause = 50;</para>
      <para>� public void init() {</para>
      <para>��� // Get parameters from Web page:</para>
      <para>��� if (isApplet) {</para>
      <para>����� String gsize = getParameter(&quot;grid&quot;);</para>
      <para>����� if(gsize != null)</para>
      <para>������� grid = Integer.parseInt(gsize);</para>
      <para>����� String pse = getParameter(&quot;pause&quot;);</para>
      <para>����� if(pse != null)</para>
      <para>������� pause = Integer.parseInt(pse);</para>
      <para>��� }</para>
      <para>��� Container cp = getContentPane();</para>
      <para>��� cp.setLayout(new GridLayout(grid, grid));</para>
      <para>��� for (int i = 0; i &lt; grid * grid; i++)</para>
      <para>����� cp.add(new CBox(pause));</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� ColorBoxes applet = new ColorBoxes();</para>
      <para>��� applet.isApplet = false;</para>
      <para>��� if(args.length &gt; 0)</para>
      <para>����� applet.grid = Integer.parseInt(args[0]);</para>
      <para>��� if(args.length &gt; 1) </para>
      <para>����� applet.pause = Integer.parseInt(args[1]);</para>
      <para>��� Console.run(applet, 500, 400);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para><emphasis role="bold">ColorBoxes</emphasis> is the usual applet/application with an <emphasis role="bold">init( ) </emphasis>that sets up the GUI. This sets up the <emphasis role="bold">GridLayout</emphasis> so that it has <emphasis role="bold">grid</emphasis> cells in each dimension. Then it adds the appropriate number of <emphasis role="bold">CBox</emphasis> objects to fill the grid, passing the <emphasis role="bold">pause</emphasis> value to each one. In <emphasis role="bold">main( )</emphasis> you can see how <emphasis role="bold">pause</emphasis> and <emphasis role="bold">grid</emphasis> have default values that can be changed if you pass in command-line arguments, or by using applet parameters.</para>
      <para><emphasis role="bold">CBox </emphasis>is where all the work takes place. This is inherited from <emphasis role="bold">JPanel</emphasis> and it implements the <emphasis role="bold">Runnable</emphasis> interface so each <emphasis role="bold">JPanel</emphasis> can also be a <emphasis role="bold">Thread</emphasis>. Remember that when you implement <emphasis role="bold">Runnable</emphasis>, you don�t make a <emphasis role="bold">Thread</emphasis> object, just a class that has a <emphasis role="bold">run( )</emphasis> method. Thus, you must explicitly create a <emphasis role="bold">Thread</emphasis> object and hand the <emphasis role="bold">Runnable</emphasis> object to the constructor, then call <emphasis role="bold">start( )</emphasis> (this happens in the constructor). In <emphasis role="bold">CBox</emphasis> this thread is called <emphasis role="bold">t</emphasis>.</para>
      <para>Notice the array <emphasis role="bold">colors</emphasis>, which is an enumeration of all the colors in class <emphasis role="bold">Color</emphasis>. This is used in <emphasis role="bold">newColor( )</emphasis> to produce a randomly selected color. The current cell color is <emphasis role="bold">cColor</emphasis>.</para>
      <para><emphasis role="bold">paintComponent</emphasis><emphasis role="bold">( )</emphasis> is quite simple�it just sets the color to <emphasis role="bold">cColor</emphasis> and fills the entire <emphasis role="bold">JPanel</emphasis> with that color.</para>
      <para>In <emphasis role="bold">run( )</emphasis>, you see the infinite loop that sets the <emphasis role="bold">cColor</emphasis> to a new random color and then calls <emphasis role="bold">repaint( )</emphasis> to show it. Then the thread goes to <emphasis role="bold">sleep( )</emphasis> for the amount of time specified on the command line.</para>
      <para>Precisely because this design is flexible and threading is tied to each <emphasis role="bold">JPanel</emphasis> element, you can experiment by making as many threads as you want. (In reality, there is a restriction imposed by the number of threads your JVM can comfortably handle.)</para>
      <para>This program also makes an interesting benchmark, since it can show dramatic performance differences between one JVM threading implementation and another.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064863"/><anchor xreflabel="Too
many threads" xml:id="_Toc375545487"/>Too many threads</title>
        <para>At some point, you�ll find that <emphasis role="bold">ColorBoxes</emphasis> bogs down. On my machine, this occurred somewhere after a 10 x 10 grid. Why does this happen? You�re naturally suspicious that Swing might have something to do with it, so here�s an example that tests that premise by making fewer threads. The following code is reorganized so that an <emphasis role="bold">ArrayList</emphasis><emphasis role="bold">implements Runnable</emphasis> and that <emphasis role="bold">ArrayList</emphasis> holds a number of color blocks and randomly chooses ones to update. Then a number of these <emphasis role="bold">ArrayList</emphasis> objects are created, depending roughly on the grid dimension you choose. As a result, you have far fewer threads than color blocks, so if there�s a speedup we�ll know it was because there were too many threads in the previous example:</para>
        <para>//: c14:ColorBoxes2.java</para>
        <para>// Balancing thread use.</para>
        <para>// &lt;applet code=ColorBoxes2 width=600 height=500&gt;</para>
        <para>// &lt;param name=grid value=&quot;12&quot;&gt;</para>
        <para>// &lt;param name=pause value=&quot;50&quot;&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.util.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>class CBox2 extends JPanel {</para>
        <para>� private static final Color[] colors = { </para>
        <para>��� Color.black, Color.blue, Color.cyan, </para>
        <para>��� Color.darkGray, Color.gray, Color.green,</para>
        <para>��� Color.lightGray, Color.magenta, </para>
        <para>��� Color.orange, Color.pink, Color.red, </para>
        <para>��� Color.white, Color.yellow </para>
        <para>� };</para>
        <para>� private Color cColor = newColor();</para>
        <para>� private static final Color newColor() {</para>
        <para>��� return colors[</para>
        <para>����� (int)(Math.random() * colors.length)</para>
        <para>��� ];</para>
        <para>� }</para>
        <para>� void nextColor() {</para>
        <para>��� cColor = newColor();</para>
        <para>��� repaint();</para>
        <para>� }</para>
        <para>� public void paintComponent(Graphics g) {</para>
        <para>��� super.paintComponent(g);</para>
        <para>��� g.setColor(cColor);</para>
        <para>��� Dimension s = getSize();</para>
        <para>��� g.fillRect(0, 0, s.width, s.height);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class CBoxList </para>
        <para>� extends ArrayList implements Runnable {</para>
        <para>� private Thread t;</para>
        <para>� private int pause;</para>
        <para>� public CBoxList(int pause) {</para>
        <para>��� this.pause = pause;</para>
        <para>��� t = new Thread(this);</para>
        <para>� }</para>
        <para>� public void go() { t.start(); }</para>
        <para>� public void run() {</para>
        <para>��� while(true) {</para>
        <para>����� int i = (int)(Math.random() * size());</para>
        <para>����� ((CBox2)get(i)).nextColor();</para>
        <para>����� try {</para>
        <para>������� t.sleep(pause);</para>
        <para>����� } catch(InterruptedException e) {</para>
        <para>������� System.err.println(&quot;Interrupted&quot;);</para>
        <para>����� }</para>
        <para>��� } </para>
        <para>� }</para>
        <para>� public Object last() { return get(size() - 1);}</para>
        <para>}</para>
        <para> </para>
        <para>public class ColorBoxes2 extends JApplet {</para>
        <para>� private boolean isApplet = true;</para>
        <para>� private int grid = 12;</para>
        <para>� // Shorter default pause than ColorBoxes:</para>
        <para>� private int pause = 50;</para>
        <para>� private CBoxList[] v;</para>
        <para>� public void init() {</para>
        <para>��� // Get parameters from Web page:</para>
        <para>��� if (isApplet) {</para>
        <para>����� String gsize = getParameter(&quot;grid&quot;);</para>
        <para>����� if(gsize != null)</para>
        <para>������� grid = Integer.parseInt(gsize);</para>
        <para>����� String pse = getParameter(&quot;pause&quot;);</para>
        <para>����� if(pse != null)</para>
        <para>������� pause = Integer.parseInt(pse);</para>
        <para>��� }</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new GridLayout(grid, grid));</para>
        <para>��� v = new CBoxList[grid];</para>
        <para>��� for(int i = 0; i &lt; grid; i++)</para>
        <para>����� v[i] = new CBoxList(pause);</para>
        <para>��� for (int i = 0; i &lt; grid * grid; i++) {</para>
        <para>����� v[i % grid].add(new CBox2());</para>
        <para>����� cp.add((CBox2)v[i % grid].last());</para>
        <para>��� }</para>
        <para>��� for(int i = 0; i &lt; grid; i++)</para>
        <para>����� v[i].go();</para>
        <para>� }�� </para>
        <para>� public static void main(String[] args) {</para>
        <para>��� ColorBoxes2 applet = new ColorBoxes2();</para>
        <para>��� applet.isApplet = false;</para>
        <para>��� if(args.length &gt; 0)</para>
        <para>����� applet.grid = Integer.parseInt(args[0]);</para>
        <para>��� if(args.length &gt; 1) </para>
        <para>����� applet.pause = Integer.parseInt(args[1]);</para>
        <para>��� Console.run(applet, 500, 400);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In <emphasis role="bold">ColorBoxes2</emphasis> an array of <emphasis role="bold">CBoxList</emphasis> is created and initialized to hold <emphasis role="bold">grid</emphasis><emphasis role="bold">CBoxList</emphasis>s, each of which knows how long to sleep. An equal number of <emphasis role="bold">CBox2</emphasis> objects is then added to each <emphasis role="bold">CBoxList</emphasis>, and each list is told to <emphasis role="bold">go( )</emphasis>, which starts its thread.</para>
        <para><emphasis role="bold">CBox2</emphasis> is similar to <emphasis role="bold">CBox</emphasis>: it paints itself with a randomly chosen color. But that�s <emphasis role="italic">all</emphasis> a <emphasis role="bold">CBox2</emphasis> does. All of the threading has been moved into <emphasis role="bold">CBoxList</emphasis>.</para>
        <para>The <emphasis role="bold">CBoxList</emphasis> could also have inherited <emphasis role="bold">Thread</emphasis> and had a member object of type <emphasis role="bold">ArrayList</emphasis>. That design has the advantage that the <emphasis role="bold">add( )</emphasis> and <emphasis role="bold">get( )</emphasis> methods could then be given specific argument and return value types instead of generic <emphasis role="bold">Object</emphasis>s. (Their names could also be changed to something shorter.) However, the design used here seemed at first glance to require less code. In addition, it automatically retains all the other behaviors of an <emphasis role="bold">ArrayList</emphasis>. With all the casting and parentheses necessary for <emphasis role="bold">get( )</emphasis>, this might not be the case as your body of code grows.</para>
        <para>As before, when you implement <emphasis role="bold">Runnable</emphasis> you don�t get all of the equipment that comes with <emphasis role="bold">Thread</emphasis>, so you have to create a new <emphasis role="bold">Thread</emphasis> and hand yourself to its constructor in order to have something to <emphasis role="bold">start( )</emphasis>, as you can see in the <emphasis role="bold">CBoxList</emphasis> constructor and in <emphasis role="bold">go( )</emphasis>. The <emphasis role="bold">run( )</emphasis> method simply chooses a random element number within the list and calls <emphasis role="bold">nextColor( )</emphasis> for that element to cause it to choose a new randomly selected color.</para>
        <para>Upon running this program, you see that it does indeed run faster and respond more quickly (for instance, when you interrupt it, it stops more quickly), and it doesn�t seem to bog down as much at higher grid sizes. Thus, a new factor is added into the threading equation: you must watch to see that you don�t have �too many threads� (whatever that turns out to mean for your particular program and platform�here, the slowdown in <emphasis role="bold">ColorBoxes</emphasis> appears to be caused by the fact that there�s only one thread that is responsible for all painting, and it gets bogged down by too many requests). If you have too many threads, you must try to use techniques like the one above to �balance� the number of threads in your program. If you see performance problems in a multithreaded program you now have a number of issues to examine:</para>
        <para>Do you have enough calls to <emphasis role="bold">sleep( )</emphasis>, <emphasis role="bold">yield( ),</emphasis> and/or <emphasis role="bold">wait( )</emphasis>?</para>
        <para>109.   Are calls to <emphasis role="bold">sleep( )</emphasis> long enough?</para>
        <para>110.   Are you running too many threads?</para>
        <para>111.   Have you tried different platforms and JVMs?</para>
        <para>Issues like this are one reason that multithreaded programming is often considered an art.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064864"/><anchor xreflabel="Summary" xml:id="_Toc375545489"/>Summary</title>
      <para>It is vital to learn when to use multithreading and when to avoid it. The main reason to use it is to manage a number of tasks whose intermingling will make more efficient use of the computer (including the ability to transparently distribute the tasks across multiple CPUs) or be more convenient for the user. The classic example of resource balancing is using the CPU during I/O waits. The classic example of user convenience is monitoring a �stop� button during long downloads.</para>
      <para>The main drawbacks to multithreading are: </para>
      <para>Slowdown while waiting for shared resources</para>
      <para>112.   Additional CPU overhead required to manage threads</para>
      <para>113.   Unrewarded complexity, such as the silly idea of having a separate thread to update each element of an array</para>
      <para>114.   Pathologies including starving, racing, and deadlock</para>
      <para>An additional advantage to threads is that they substitute �light� execution context switches (of the order of 100 instructions) for �heavy� process context switches (of the order of 1000s of instructions). Since all threads in a given process share the same memory space, a light context switch changes only program execution and local variables. On the other hand, a process change�the heavy context switch�must exchange the full memory space.</para>
      <para>Threading is like stepping into an entirely new world and learning a whole new programming language, or at least a new set of language concepts. With the appearance of thread support in most microcomputer operating systems, extensions for threads have also been appearing in programming languages or libraries. In all cases, thread programming (1) seems mysterious and requires a shift in the way you think about programming; and (2) looks similar to thread support in other languages, so when you understand threads, you understand a common tongue. And although support for threads can make Java seem like a more complicated language, don�t blame Java. Threads are tricky.</para>
      <para>One of the biggest difficulties with threads occurs because more than one thread might be sharing a resource�such as the memory in an object�and you must make sure that multiple threads don�t try to read and change that resource at the same time. This requires judicious use of the <emphasis role="bold">synchronized</emphasis> keyword, which is a helpful tool but must be understood thoroughly because it can quietly introduce deadlock situations.</para>
      <para>In addition, there�s a certain art to the application of threads. Java is designed to allow you to create as many objects as you need to solve your problem�at least in theory. (Creating millions of objects for an engineering finite-element analysis, for example, might not be practical in Java.) However, it seems that there is an upper bound to the number of threads you�ll want to create, because at some point a large number of threads seems to become unwieldy. This critical point is not in the many thousands as it might be with objects, but rather in the low hundreds, sometimes less than 100. As you often create only a handful of threads to solve a problem, this is typically not much of a limit, yet in a more general design it becomes a constraint.</para>
      <para>A significant nonintuitive issue in threading is that, because of thread scheduling, you can typically make your applications run <emphasis role="italic">faster</emphasis> by inserting calls to <emphasis role="bold">sleep( )</emphasis> inside <emphasis role="bold">run( )</emphasis>�s main loop. This definitely makes it feel like an art, in particular when the longer delays seem to speed up performance. Of course, the reason this happens is that shorter delays can cause the end-of-<emphasis role="bold">sleep( )</emphasis> scheduler interrupt to happen before the running thread is ready to go to sleep, forcing the scheduler to stop it and restart it later so it can finish what it was doing and then go to sleep. It takes extra thought to realize how messy things can get.</para>
      <para>One thing you might notice missing in this chapter is an animation example, which is one of the most popular things to do with applets. However, a complete solution (with sound) to this problem comes with the Java JDK (available at <emphasis role="italic">java.sun.com</emphasis>) in the demo section. In addition, we can expect better animation support to become part of future versions of Java, while completely different non-Java, non-programming solutions to animation for the Web are appearing that will probably be superior to traditional approaches. For explanations about how Java animation works, see <emphasis role="italic">Core Java 2</emphasis> by Horstmann &amp; Cornell, Prentice-Hall, 1997. For more advanced discussions of threading, see <emphasis role="italic">Concurrent Programming in Java</emphasis> by Doug Lea, Addison-Wesley, 1997, or <emphasis role="italic">Java Threads</emphasis> by Oaks &amp; Wong, O�Reilly, 1997.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064865"/><anchor xreflabel="Exercises" xml:id="_Toc375545490"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Inherit a class from <emphasis role="bold">Thread</emphasis> and override the <emphasis role="bold">run( )</emphasis> method. Inside <emphasis role="bold">run( )</emphasis>, print a message, and then call <emphasis role="bold">sleep( )</emphasis>. Repeat this three times, then return from <emphasis role="bold">run( )</emphasis>. Put a start-up message in the constructor and override <emphasis role="bold">finalize( )</emphasis> to print a shut-down message. Make a separate thread class that calls <emphasis role="bold">System.gc( )</emphasis> and <emphasis role="bold">System.runFinalization( ) </emphasis>inside <emphasis role="bold">run( )</emphasis>, printing a message as it does so. Make several thread objects of both types and run them to see what happens.</para>
      <para>  234.         Modify <emphasis role="bold">Sharing2.java</emphasis> to add a <emphasis role="bold">synchronized</emphasis> block inside the <emphasis role="bold">run( )</emphasis> method of <emphasis role="bold">TwoCounter</emphasis> instead of synchronizing the entire <emphasis role="bold">run( )</emphasis> method.</para>
      <para>  235.         Create two <emphasis role="bold">Thread</emphasis> subclasses, one with a <emphasis role="bold">run( )</emphasis> that starts up, captures the reference of the second <emphasis role="bold">Thread</emphasis> object and then calls <emphasis role="bold">wait( )</emphasis>. The other class� <emphasis role="bold">run( )</emphasis> should call <emphasis role="bold">notifyAll( )</emphasis> for the first thread after some number of seconds have passed, so the first thread can print a message.</para>
      <para>  236.         In <emphasis role="bold">Counter5.java</emphasis> inside <emphasis role="bold">Ticker2</emphasis>, remove the <emphasis role="bold">yield( )</emphasis> and explain the results. Replace the <emphasis role="bold">yield( )</emphasis> with a <emphasis role="bold">sleep( )</emphasis> and explain the results.</para>
      <para>  237.         In <emphasis role="bold">ThreadGroup1.java</emphasis>, replace the call to <emphasis role="bold">sys.suspend( )</emphasis> with a call to <emphasis role="bold">wait( )</emphasis> for the thread group, causing it to wait for two seconds. For this to work correctly you must acquire the lock for <emphasis role="bold">sys </emphasis>inside a <emphasis role="bold">synchronized</emphasis> block.</para>
      <para>  238.         Change <emphasis role="bold">Daemons.java</emphasis> so that <emphasis role="bold">main( )</emphasis> has a <emphasis role="bold">sleep( )</emphasis> instead of a <emphasis role="bold">readLine( )</emphasis>. Experiment with different sleep times to see what happens.</para>
      <para>  239.         In Chapter 8, locate the <emphasis role="bold">GreenhouseControls.java</emphasis> example, which consists of three files. In <emphasis role="bold">Event.java</emphasis>, the class <emphasis role="bold">Event</emphasis> is based on watching the time. Change <emphasis role="bold">Event</emphasis> so that it is a <emphasis role="bold">Thread</emphasis>, and change the rest of the design so that it works with this new <emphasis role="bold">Thread</emphasis>-based <emphasis role="bold">Event</emphasis>.</para>
      <para>  240.         Modify Exercise 7 so that the <emphasis role="bold">java.util.Timer</emphasis> class found in JDK 1.3 is used to run the system.</para>
      <para>  241.         Starting with <emphasis role="bold">SineWave.java</emphasis> from Chapter 13, create a program (an applet/application using the <emphasis role="bold">Console </emphasis>class) that draws an animated sine wave that appears to scrolls past the viewing window like an oscilloscope, driving the animation with a <emphasis role="bold">Thread</emphasis>. The speed of the animation should be controlled with a <emphasis role="bold">java.swing.JSlider</emphasis> control.</para>
      <para>  242.         Modify Exercise 9 so that multiple sine wave panels are created within the application. The number of sine wave panels should be controlled by HTML tags or command-line parameters.</para>
      <para>  243.         Modify Exercise 9 so that the <emphasis role="bold">java.swing.Timer</emphasis> class is used to drive the animation. Note the difference between this and <emphasis role="bold">java.util.Timer</emphasis>.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064866"/><anchor xreflabel="" xml:id="_Toc477690735"/><anchor xreflabel="" xml:id="_Toc375545491"/><anchor xreflabel="" xml:id="Chapter_17"/>15: Distributed Computing</title>
    <para>Historically, programming across multiple machines has been error-prone, difficult, and complex.</para>
    <para>The programmer had to know many details about the network and sometimes even the hardware. You usually needed to understand the various �layers� of the networking protocol, and there were a lot of different functions in each different networking library concerned with connecting, packing, and unpacking blocks of information; shipping those blocks back and forth; and handshaking. It was a daunting task.</para>
    <para>However, the basic idea of distributed computing is not so difficult, and is abstracted very nicely in the Java libraries. You want to:</para>
    <para>            Get some information from that machine over there and move it to this machine here, or vice versa. This is accomplished with basic network programming.</para>
    <para>            Connect to a database, which may live across a network. This is accomplished with <emphasis role="italic">Java DataBase Connectivity</emphasis> (JDBC), which is an abstraction away from the messy, platform-specific details of SQL (the <emphasis role="italic">structured query language</emphasis> used for most database transactions).</para>
    <para>            Provide services via a Web server. This is accomplished with Java�s <emphasis role="italic">servlets</emphasis> and <emphasis role="italic">Java Server Pages</emphasis> (JSPs).</para>
    <para>            Execute methods on Java objects that live on remote machines transparently, as if those objects were resident on local machines. This is accomplished with Java�s <emphasis role="italic">Remote Method Invocation</emphasis> (RMI).</para>
    <para>            Use code written in other languages, running on other architectures. This is accomplished using the <emphasis role="italic">Common Object Request Broker Architecture</emphasis> (CORBA), which is directly supported by Java.</para>
    <para>            Isolate business logic from connectivity issues, especially connections with databases including transaction management and security. This is accomplished using <emphasis role="italic">Enterprise JavaBeans </emphasis>(EJBs). EJBs are not actually a distributed architecture, but the resulting applications are usually used in a networked client-server system.</para>
    <para>            Easily, dynamically, add and remove devices from a network representing a local system. This is accomplished with Java�s Jini.</para>
    <para>Each topic will be given a light introduction in this chapter. Please note that each subject is voluminous and by itself the subject of entire books, so this chapter is only meant to familiarize you with the topics, not make you an expert (however, you can go a long way with the information presented here on network programming, servlets and JSPs). </para>
    <section>
      <title><anchor xreflabel="Network programming" xml:id="_Toc481064867"/>Network programming</title>
      <para><anchor xreflabel="" xml:id="_Toc375545492"/>One of Java�s great strengths is painless networking. The Java network library designers have made it quite similar to reading and writing files, except that the �file� exists on a remote machine and the remote machine can decide exactly what it wants to do about the information you�re requesting or sending. As much as possible, the underlying details of networking have been abstracted away and taken care of within the JVM and local machine installation of Java. The programming model you use is that of a file; in fact, you actually wrap the network connection (a �socket�) with stream objects, so you end up using the same method calls as you do with all other streams. In addition, Java�s built-in multithreading is exceptionally handy when dealing with another networking issue: handling multiple connections at once.</para>
      <para>This section introduces Java�s networking support using easy-to-understand examples.</para>
      <section>
        <title><anchor xreflabel="Identifying a machine" xml:id="_Toc481064868"/>Identifying a machine</title>
        <para>Of course, in order to tell one machine from another and to make sure that you are connected with a particular machine, there must be some way of uniquely identifying machines on a network. Early networks were satisfied to provide unique names for machines within the local network. However, Java works within the Internet, which requires a way to uniquely identify a machine from all the others <emphasis role="italic">in the world</emphasis>. This is accomplished with the IP (Internet Protocol) address which can exist in two forms:</para>
        <para>The familiar DNS (<emphasis role="italic">Domain Name System</emphasis>) form. My domain name is <emphasis role="bold">bruceeckel.com</emphasis>, and if I have a computer called <emphasis role="bold">Opus</emphasis> in my domain, its domain name would be <emphasis role="bold">Opus.bruceeckel.com</emphasis>. This is exactly the kind of name that you use when you send email to people, and is often incorporated into a World Wide Web address.</para>
        <para>115.   Alternatively, you can use the �dotted quad� form, which is four numbers separated by dots, such as <emphasis role="bold">123.255.28.120</emphasis>.</para>
        <para>In both cases, the IP address is represented internally as a 32-bit number<anchor xreflabel="[72]" xml:id="_ftnref72"/>[72] (so each of the quad numbers cannot exceed 255), and you can get a special Java object to represent this number from either of the forms above by using the <emphasis role="bold">static</emphasis><emphasis role="bold">InetAddress.getByName( )</emphasis> method that�s in <emphasis role="bold">java.net</emphasis>. The result is an object of type <emphasis role="bold">InetAddress</emphasis> that you can use to build a �socket,� as you will see later.</para>
        <para>As a simple example of using <emphasis role="bold">InetAddress.getByName( )</emphasis>, consider what happens if you have a dial-up Internet service provider (ISP). Each time you dial up, you are assigned a temporary IP address. But while you�re connected, your IP address has the same validity as any other IP address on the Internet. If someone connects to your machine using your IP address then they can connect to a Web server or FTP server that you have running on your machine. Of course, they need to know your IP address, and since a new one is assigned each time you dial up, how can you find out what it is?</para>
        <para>The following program uses <emphasis role="bold">InetAddress.getByName( )</emphasis> to produce your IP address. To use it, you must know the name of your computer. On Windows 95/98, go to �Settings,� �Control Panel,� �Network,� and then select the �Identification� tab. �Computer name� is the name to put on the command line.</para>
        <para>//: c15:WhoAmI.java</para>
        <para>// Finds out your network address when</para>
        <para>// you&apos;re connected to the Internet.</para>
        <para>import java.net.*;</para>
        <para> </para>
        <para>public class WhoAmI {</para>
        <para>� public static void main(String[] args) </para>
        <para>����� throws Exception {</para>
        <para>��� if(args.length != 1) {</para>
        <para>����� System.err.println(</para>
        <para>������� &quot;Usage: WhoAmI MachineName&quot;);</para>
        <para>����� System.exit(1);</para>
        <para>��� }</para>
        <para>��� InetAddress a = </para>
        <para>����� InetAddress.getByName(args[0]);</para>
        <para>��� System.out.println(a);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In this case, the machine is called �peppy.� So, once I�ve connected to my ISP I run the program:</para>
        <para>java WhoAmI peppy</para>
        <para> </para>
        <para>I get back a message like this (of course, the address is different each time):</para>
        <para>peppy/199.190.87.75</para>
        <para> </para>
        <para>If I tell my friend this address and I have a Web server running on my computer, he can connect to it by going to the URL <emphasis role="italic">http://199.190.87.75</emphasis> (only as long as I continue to stay connected during that session). This can sometimes be a handy way to distribute information to someone else, or to test out a Web site configuration before posting it to a �real� server.</para>
        <section>
          <title><anchor xreflabel="Servers and clients" xml:id="_Toc375545493"/>Servers and clients</title>
          <para>The whole point of a network is to allow two machines to connect and talk to each other. Once the two machines have found each other they can have a nice, two-way conversation. But how do they find each other? It�s like getting lost in an amusement park: one machine has to stay in one place and listen while the other machine says, �Hey, where are you?�</para>
          <para>The machine that �stays in one place� is called the <emphasis role="italic">server</emphasis>, and the one that seeks is called the <emphasis role="italic">client</emphasis>. This distinction is important only while the client is trying to connect to the server. Once they�ve connected, it becomes a two-way communication process and it doesn�t matter anymore that one happened to take the role of server and the other happened to take the role of the client.</para>
          <para>So the job of the server is to listen for a connection, and that�s performed by the special server object that you create. The job of the client is to try to make a connection to a server, and this is performed by the special client object you create. Once the connection is made, you�ll see that at both server and client ends, the connection is magically turned into an I/O stream object, and from then on you can treat the connection as if you were reading from and writing to a file. Thus, after the connection is made you will just use the familiar I/O commands from Chapter 11. This is one of the nice features of Java networking.</para>
        </section>
        <section>
          <title>Testing programs without a network</title>
          <para>For many reasons, you might not have a client machine, a server machine, and a network available to test your programs. You might be performing exercises in a classroom situation, or you could be writing programs that aren�t yet stable enough to put onto the network. The creators of the Internet Protocol were aware of this issue, and they created a special address called <emphasis role="bold">localhost</emphasis> to be the �local loopback� IP address for testing without a network. The generic way to produce this address in Java is:</para>
          <para>InetAddress addr = InetAddress.getByName(null);</para>
          <para> </para>
          <para>If you hand <emphasis role="bold">getByName( )</emphasis> a <emphasis role="bold">null</emphasis>, it defaults to using the <emphasis role="bold">localhost</emphasis>. The <emphasis role="bold">InetAddress</emphasis> is what you use to refer to the particular machine, and you must produce this before you can go any further. You can�t manipulate the contents of an <emphasis role="bold">InetAddress </emphasis>(but you can print them out, as you�ll see in the next example). The only way you can create an <emphasis role="bold">InetAddress</emphasis> is through one of that class�s overloaded <emphasis role="bold">static</emphasis> member methods <emphasis role="bold">getByName( )</emphasis> (which is what you�ll usually use), <emphasis role="bold">getAllByName( )</emphasis>, or <emphasis role="bold">getLocalHost( )</emphasis>.</para>
          <para>You can also produce the local loopback address by handing it the string <emphasis role="bold">localhost</emphasis>:</para>
          <para>InetAddress.getByName(&quot;localhost&quot;);</para>
          <para> </para>
          <para>(assuming �localhost� is configured in your machine�s �hosts� table), or by using its dotted quad form to name the reserved IP number for the loopback:</para>
          <para>InetAddress.getByName(&quot;127.0.0.1&quot;);</para>
          <para> </para>
          <para>All three forms produce the same result.</para>
        </section>
        <section>
          <title><anchor xreflabel="Port: a unique place 
within the machine" xml:id="_Toc375545494"/>Port: a unique place   within the machine</title>
          <para>An IP address isn�t enough to identify a unique server, since many servers can exist on one machine. Each IP machine also contains <emphasis role="italic">ports</emphasis>, and when you�re setting up a client or a server you must choose a port where both client and server agree to connect; if you�re meeting someone, the IP address is the neighborhood and the port is the bar.</para>
          <para>The port is not a physical location in a machine, but a software abstraction (mainly for bookkeeping purposes). The client program knows how to connect to the machine via its IP address, but how does it connect to a desired service (potentially one of many on that machine)? That�s where the port numbers come in as a second level of addressing. The idea is that if you ask for a particular port, you�re requesting the service that�s associated with the port number. The time of day is a simple example of a service. Typically, each service is associated with a unique port number on a given server machine. It�s up to the client to know ahead of time which port number the desired service is running on. </para>
          <para>The system services reserve the use of ports 1 through 1024, so you shouldn�t use those or any other port that you know to be in use. The first choice for examples in this book will be port 8080 (in memory of the venerable old 8-bit Intel 8080 chip in my first computer, a CP/M machine).</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064869"/><anchor xreflabel="Sockets" xml:id="_Toc375545495"/>Sockets</title>
        <para>The <emphasis role="italic">socket</emphasis> is the software abstraction used to represent the �terminals� of a connection between two machines. For a given connection, there�s a socket on each machine, and you can imagine a hypothetical �cable� running between the two machines with each end of the �cable� plugged into a socket. Of course, the physical hardware and cabling between machines is completely unknown. The whole point of the abstraction is that we don�t have to know more than is necessary.</para>
        <para>In Java, you create a socket to make the connection to the other machine, then you get an <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis> (or, with the appropriate converters, <emphasis role="bold">Reader</emphasis> and <emphasis role="bold">Writer</emphasis>)<emphasis role="bold"/>from the socket in order to be able to treat the connection as an I/O stream object. There are two stream-based socket classes: a <emphasis role="bold">ServerSocket</emphasis> that a server uses to �listen� for incoming connections and a <emphasis role="bold">Socket</emphasis> that a client uses in order to initiate a connection. Once a client makes a socket connection, the <emphasis role="bold">ServerSocket</emphasis> returns (via the <emphasis role="bold">accept( )</emphasis>method) a corresponding <emphasis role="bold">Socket</emphasis> through which communications will take place on the server side. From then on, you have a true <emphasis role="bold">Socket</emphasis> to <emphasis role="bold">Socket</emphasis> connection and you treat both ends the same way because they <emphasis role="italic">are</emphasis> the same. At this point, you use the methods <emphasis role="bold">getInputStream( )</emphasis> and <emphasis role="bold">getOutputStream( )</emphasis> to produce the corresponding <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis> objects from each <emphasis role="bold">Socket</emphasis>. These must be wrapped inside buffers and formatting classes just like any other stream object described in Chapter 11.</para>
        <para>The use of the term <emphasis role="bold">ServerSocket</emphasis> would seem to be another example of a confusing naming scheme in the Java libraries. You might think <emphasis role="bold">ServerSocket</emphasis> would be better named �ServerConnector� or something without the word �Socket� in it. You might also think that <emphasis role="bold">ServerSocket</emphasis> and <emphasis role="bold">Socket</emphasis> should both be inherited from some common base class. Indeed, the two classes do have several methods in common, but not enough to give them a common base class. Instead, <emphasis role="bold">ServerSocket</emphasis>�s job is to wait until some other machine connects to it, then to return an actual <emphasis role="bold">Socket</emphasis>. This is why <emphasis role="bold">ServerSocket</emphasis> seems to be a bit misnamed, since its job isn�t really to be a socket but instead to make a <emphasis role="bold">Socket</emphasis> object when someone else connects to it.</para>
        <para>However, the <emphasis role="bold">ServerSocket</emphasis> does create a physical �server� or listening socket on the host machine. This socket listens for incoming connections and then returns an �established� socket (with the local and remote endpoints defined) via the <emphasis role="bold">accept( )</emphasis> method. The confusing part is that both of these sockets (listening and established) are associated with the same server socket. The listening socket can accept only new connection requests and not data packets. So while <emphasis role="bold">ServerSocket</emphasis> doesn�t make much sense programmatically, it does �physically.�</para>
        <para>When you create a <emphasis role="bold">ServerSocket</emphasis>, you give it only a port number. You don�t have to give it an IP address because it�s already on the machine it represents. When you create a <emphasis role="bold">Socket</emphasis>, however, you must give both the IP address and the port number where you�re trying to connect. (However, the <emphasis role="bold">Socket</emphasis> that comes back from <emphasis role="bold">ServerSocket.accept( )</emphasis> already contains all this information.)</para>
        <section>
          <title><anchor xreflabel="A simple server and client" xml:id="_Toc375545496"/>A simple server and client</title>
          <para>This example makes the simplest use of servers and clients using sockets. All the server does is wait for a connection, then uses the <emphasis role="bold">Socket</emphasis> produced by that connection to create an <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis>. These are converted to a <emphasis role="bold">Reader</emphasis> and a <emphasis role="bold">Writer</emphasis>, then wrapped in a <emphasis role="bold">BufferedReader</emphasis> and a <emphasis role="bold">PrintWriter</emphasis>.<emphasis role="bold"/>After that, everything it reads from the <emphasis role="bold">BufferedReader</emphasis> it echoes to the <emphasis role="bold">PrintWriter</emphasis> until it receives the line �END,� at which time it closes the connection.</para>
          <para>The client makes the connection to the server, then creates an <emphasis role="bold">OutputStream </emphasis>and performs the same wrapping as in the server. Lines of text are sent through the resulting <emphasis role="bold">PrintWriter</emphasis>. The client also creates an <emphasis role="bold">InputStream</emphasis> (again, with appropriate conversions and wrapping) to hear what the server is saying (which, in this case, is just the words echoed back).</para>
          <para>Both the server and client use the same port number and the client uses the local loopback address to connect to the server on the same machine so you don�t have to test it over a network. (For some configurations, you might need to be <emphasis role="italic">connected</emphasis> to a network for the programs to work, even if you aren�t <emphasis role="italic">communicating</emphasis> over that network.)</para>
          <para>Here is the server:</para>
          <para>//: c15:JabberServer.java</para>
          <para>// Very simple server that just</para>
          <para>// echoes whatever the client sends.</para>
          <para>import java.io.*;</para>
          <para>import java.net.*;</para>
          <para> </para>
          <para>public class JabberServer {� </para>
          <para>� // Choose a port outside of the range 1-1024:</para>
          <para>� public static final int PORT = 8080;</para>
          <para>� public static void main(String[] args) </para>
          <para>����� throws IOException {</para>
          <para>��� ServerSocket s = new ServerSocket(PORT);</para>
          <para>��� System.out.println(&quot;Started: &quot; + s);</para>
          <para>��� try {</para>
          <para>����� // Blocks until a connection occurs:</para>
          <para>����� Socket socket = s.accept();</para>
          <para>����� try {</para>
          <para>������� System.out.println(</para>
          <para>��������� &quot;Connection accepted: &quot;+ socket);</para>
          <para>������� BufferedReader in = </para>
          <para>��������� new BufferedReader(</para>
          <para>����������� new InputStreamReader(</para>
          <para>������������� socket.getInputStream()));</para>
          <para>�� �����// Output is automatically flushed</para>
          <para>������� // by PrintWriter:</para>
          <para>������� PrintWriter out = </para>
          <para>��������� new PrintWriter(</para>
          <para>����������� new BufferedWriter(</para>
          <para>������������� new OutputStreamWriter(</para>
          <para>��������������� socket.getOutputStream())),true);</para>
          <para>������� while (true) {� </para>
          <para>��������� String str = in.readLine();</para>
          <para>��������� if (str.equals(&quot;END&quot;)) break;</para>
          <para>��������� System.out.println(&quot;Echoing: &quot; + str);</para>
          <para>��������� out.println(str);</para>
          <para>������� }</para>
          <para>����� // Always close the two sockets...</para>
          <para>����� } finally {</para>
          <para>������� System.out.println(&quot;closing...&quot;);</para>
          <para>������� socket.close();</para>
          <para>����� }</para>
          <para>��� } finally {</para>
          <para>����� s.close();</para>
          <para>��� }</para>
          <para>� } </para>
          <para>} ///:~</para>
          <para> </para>
          <para>You can see that the <emphasis role="bold">ServerSocket</emphasis> just needs a port number, not an IP address (since it�s running on <emphasis role="italic">this</emphasis> machine!). When you call <emphasis role="bold">accept( )</emphasis>, the method <emphasis role="italic">blocks</emphasis> until some client tries to connect to it. That is, it�s there waiting for a connection, but other processes can run (see Chapter 14). When a connection is made, <emphasis role="bold">accept( )</emphasis> returns with a <emphasis role="bold">Socket</emphasis> object representing that connection. </para>
          <para>The responsibility for cleaning up the sockets is crafted carefully here. If the <emphasis role="bold">ServerSocket</emphasis> constructor fails, the program just quits (notice we must assume that the constructor for <emphasis role="bold">ServerSocket</emphasis> doesn�t leave any open network sockets lying around if it fails). For this case, <emphasis role="bold">main( )</emphasis><emphasis role="bold">throws</emphasis><emphasis role="bold">IOException</emphasis> so a <emphasis role="bold">try</emphasis> block is not necessary. If the <emphasis role="bold">ServerSocket</emphasis> constructor is successful then all other method calls must be guarded in a <emphasis role="bold">try-finally</emphasis> block to ensure that, no matter how the block is left, the <emphasis role="bold">ServerSocket</emphasis> is properly closed.</para>
          <para>The same logic is used for the <emphasis role="bold">Socket</emphasis> returned by <emphasis role="bold">accept( )</emphasis>. If <emphasis role="bold">accept( )</emphasis> fails, then we must assume that the <emphasis role="bold">Socket</emphasis> doesn�t exist or hold any resources, so it doesn�t need to be cleaned up. If it�s successful, however, the following statements must be in a <emphasis role="bold">try-finally</emphasis> block so that if they fail the <emphasis role="bold">Socket</emphasis> will still be cleaned up. Care is required here because sockets use important nonmemory resources, so you must be diligent in order to clean them up (since there is no destructor in Java to do it for you).</para>
          <para>Both the <emphasis role="bold">ServerSocket</emphasis> and the <emphasis role="bold">Socket</emphasis> produced by <emphasis role="bold">accept( )</emphasis> are printed to <emphasis role="bold">System.out</emphasis>. This means that their <emphasis role="bold">toString( )</emphasis> methods are automatically called. These produce:</para>
          <para>ServerSocket[addr=0.0.0.0,PORT=0,localport=8080]</para>
          <para>Socket[addr=127.0.0.1,PORT=1077,localport=8080]</para>
          <para> </para>
          <para>Shortly, you�ll see how these fit together with what the client is doing.</para>
          <para>The next part of the program looks just like opening files for reading and writing except that the <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis> are created from the <emphasis role="bold">Socket</emphasis> object. Both the <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream </emphasis>objects are converted to <emphasis role="bold">Reader </emphasis>and <emphasis role="bold">Writer</emphasis> objects using the �converter� classes <emphasis role="bold">InputStreamReader</emphasis> and <emphasis role="bold">OutputStreamWriter</emphasis>, respectively. You could also have used the Java 1.0 <emphasis role="bold">InputStream</emphasis> and <emphasis role="bold">OutputStream</emphasis> classes directly, but with output there�s a distinct advantage to using the <emphasis role="bold">Writer</emphasis> approach. This appears with <emphasis role="bold">PrintWriter</emphasis>, which has an overloaded constructor that takes a second argument, a <emphasis role="bold">boolean </emphasis>flag that indicates whether to automatically flush the output at the end of each <emphasis role="bold">println( )</emphasis> (but <emphasis role="italic">not </emphasis><emphasis role="bold">print( )</emphasis>) statement. Every time you write to <emphasis role="bold">out</emphasis>, its buffer must be flushed so the information goes out over the network. Flushing is important for this particular example because the client and server each wait for a line from the other party before proceeding. If flushing doesn�t occur, the information will not be put onto the network until the buffer is full, which causes lots of problems in this example.</para>
          <para>When writing network programs you need to be careful about using automatic flushing. Every time you flush the buffer a packet must be created and sent. In this case, that�s exactly what we want, since if the packet containing the line isn�t sent then the handshaking back and forth between server and client will stop. Put another way, the end of a line is the end of a message. But in many cases, messages aren�t delimited by lines so it�s much more efficient to not use auto flushing and instead let the built-in buffering decide when to build and send a packet. This way, larger packets can be sent and the process will be faster.</para>
          <para>Note that, like virtually all streams you open, these are buffered. There�s an exercise at the end of this chapter to show you what happens if you don�t buffer the streams (things get slow).</para>
          <para>The infinite <emphasis role="bold">while</emphasis> loop reads lines from the<emphasis role="bold"> BufferedReader in </emphasis>and writes information to <emphasis role="bold">System.out</emphasis> and to the <emphasis role="bold">PrintWriter</emphasis><emphasis role="bold">out</emphasis>. Note that <emphasis role="bold">in</emphasis> and <emphasis role="bold">out</emphasis> could be any streams, they just happen to be connected to the network. </para>
          <para>When the client sends the line consisting of �END,� the program breaks out of the loop and closes the <emphasis role="bold">Socket</emphasis>. </para>
          <para>Here�s the client:</para>
          <para>//: c15:JabberClient.java</para>
          <para>// Very simple client that just sends</para>
          <para>// lines to the server and reads lines</para>
          <para>// that the server sends.</para>
          <para>import java.net.*;</para>
          <para>import java.io.*;</para>
          <para> </para>
          <para>public class JabberClient {</para>
          <para>� public static void main(String[] args) </para>
          <para>����� throws IOException {</para>
          <para>��� // Passing null to getByName() produces the</para>
          <para>��� // special &quot;Local Loopback&quot; IP address, for</para>
          <para>��� // testing on one machine w/o a network:</para>
          <para>��� InetAddress addr = </para>
          <para>����� InetAddress.getByName(null);</para>
          <para>��� // Alternatively, you can use </para>
          <para>��� // the address or name:</para>
          <para>��� // InetAddress addr = </para>
          <para>��� //��� InetAddress.getByName(&quot;127.0.0.1&quot;);</para>
          <para>��� // InetAddress addr = </para>
          <para>��� //��� InetAddress.getByName(&quot;localhost&quot;);</para>
          <para>��� System.out.println(&quot;addr = &quot; + addr);</para>
          <para>��� Socket socket = </para>
          <para>����� new Socket(addr, JabberServer.PORT);</para>
          <para>��� // Guard everything in a try-finally to make</para>
          <para>��� // sure that the socket is closed:</para>
          <para>� ��try {</para>
          <para>����� System.out.println(&quot;socket = &quot; + socket);</para>
          <para>����� BufferedReader in =</para>
          <para>������� new BufferedReader(</para>
          <para>��������� new InputStreamReader(</para>
          <para>����������� socket.getInputStream()));</para>
          <para>����� // Output is automatically flushed</para>
          <para>����� // by PrintWriter:</para>
          <para>����� PrintWriter out =</para>
          <para>������� new PrintWriter(</para>
          <para>��������� new BufferedWriter(</para>
          <para>����������� new OutputStreamWriter(</para>
          <para>������������� socket.getOutputStream())),true);</para>
          <para>����� for(int i = 0; i &lt; 10; i ++) {</para>
          <para>������� out.println(&quot;howdy &quot; + i);</para>
          <para>������� String str = in.readLine();</para>
          <para>������� System.out.println(str);</para>
          <para>����� }</para>
          <para>����� out.println(&quot;END&quot;);</para>
          <para>��� } finally {</para>
          <para>����� System.out.println(&quot;closing...&quot;);</para>
          <para>����� socket.close();</para>
          <para>��� }</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>In <emphasis role="bold">main( )</emphasis> you can see all three ways to produce the <emphasis role="bold">InetAddress</emphasis> of the local loopback IP address: using <emphasis role="bold">null</emphasis>, <emphasis role="bold">localhost</emphasis>, or the explicit reserved address <emphasis role="bold">127.0.0.1</emphasis>. Of course, if you want to connect to a machine across a network you substitute that machine�s IP address. When the <emphasis role="bold">InetAddress addr</emphasis> is printed (via the automatic call to its <emphasis role="bold">toString( )</emphasis> method) the result is:</para>
          <para>localhost/127.0.0.1</para>
          <para> </para>
          <para>By handing <emphasis role="bold">getByName( )</emphasis> a <emphasis role="bold">null</emphasis>, it defaulted to finding the <emphasis role="bold">localhost</emphasis>, and that produced the special address <emphasis role="bold">127.0.0.1</emphasis>.</para>
          <para>Note that the <emphasis role="bold">Socket</emphasis> called <emphasis role="bold">socket</emphasis> is created with both the <emphasis role="bold">InetAddress</emphasis> and the port number. To understand what it means when you print one of these <emphasis role="bold">Socket </emphasis>objects, remember that an Internet connection is determined uniquely by these four pieces of data: <emphasis role="bold">clientHost</emphasis>, <emphasis role="bold">clientPortNumber</emphasis>, <emphasis role="bold">serverHost</emphasis>, and <emphasis role="bold">serverPortNumber</emphasis>. When the server comes up, it takes up its assigned port (8080) on the localhost (127.0.0.1). When the client comes up, it is allocated to the next available port on its machine, 1077 in this case, which also happens to be on the same machine (127.0.0.1) as the server. Now, in order for data to move between the client and server, each side has to know where to send it. Therefore, during the process of connecting to the �known� server, the client sends a �return address� so the server knows where to send its data. This is what you see in the example output for the server side:</para>
          <para>Socket[addr=127.0.0.1,port=1077,localport=8080]</para>
          <para> </para>
          <para>This means that the server just accepted a connection from 127.0.0.1 on port 1077 while listening on its local port (8080). On the client side:</para>
          <para>Socket[addr=localhost/127.0.0.1,PORT=8080,localport=1077]</para>
          <para> </para>
          <para>which means that the client made a connection to 127.0.0.1 on port 8080 using the local port 1077.</para>
          <para>You�ll notice that every time you start up the client anew, the local port number is incremented. It starts at 1025 (one past the reserved block of ports) and keeps going up until you reboot the machine, at which point it starts at 1025 again. (On UNIX machines, once the upper limit of the socket range is reached, the numbers will wrap around to the lowest available number again.)</para>
          <para>Once the <emphasis role="bold">Socket</emphasis> object has been created, the process of turning it into a <emphasis role="bold">BufferedReader</emphasis> and <emphasis role="bold">PrintWriter</emphasis> is the same as in the server (again, in both cases you start with a <emphasis role="bold">Socket</emphasis>). Here, the client initiates the conversation by sending the string �howdy� followed by a number. Note that the buffer must again be flushed (which happens automatically via the second argument to the <emphasis role="bold">PrintWriter </emphasis>constructor). If the buffer isn�t flushed, the whole conversation will hang because the initial �howdy� will never get sent (the buffer isn�t full enough to cause the send to happen automatically). Each line that is sent back from the server is written to <emphasis role="bold">System.out</emphasis> to verify that everything is working correctly. To terminate the conversation, the agreed-upon �END� is sent. If the client simply hangs up, then the server throws an exception.</para>
          <para>You can see that the same care is taken here to ensure that the network resources represented by the <emphasis role="bold">Socket</emphasis> are properly cleaned up, using a <emphasis role="bold">try-finally</emphasis> block.</para>
          <para>Sockets produce a �dedicated� connection that persists until it is explicitly disconnected. (The dedicated connection can still be disconnected unexplicitly if one side, or an intermediary link, of the connection crashes.) This means the two parties are locked in communication and the connection is constantly open. This seems like a logical approach to networking, but it puts an extra load on the network. Later in this chapter you�ll see a different approach to networking, in which the connections are only temporary.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064870"/><anchor xreflabel="Serving
multiple clients" xml:id="_Toc375545497"/>Serving multiple clients</title>
        <para>The <emphasis role="bold">JabberServer</emphasis> works, but it can handle only one client at a time. In a typical server, you�ll want to be able to deal with many clients at once. The answer is multithreading, and in languages that don�t directly support multithreading this means all sorts of complications. In Chapter 14 you saw that multithreading in Java is about as simple as possible, considering that multithreading is a rather complex topic. Because threading in Java is reasonably straightforward, making a server that handles multiple clients is relatively easy.</para>
        <para>The basic scheme is to make a single <emphasis role="bold">ServerSocket</emphasis> in the server and call <emphasis role="bold">accept( )</emphasis> to wait for a new connection. When <emphasis role="bold">accept( )</emphasis> returns, you take the resulting <emphasis role="bold">Socket</emphasis> and use it to create a new thread whose job is to serve that particular client. Then you call <emphasis role="bold">accept( )</emphasis> again to wait for a new client.</para>
        <para>In the following server code, you can see that it looks similar to the <emphasis role="bold">JabberServer.java</emphasis> example except that all of the operations to serve a particular client have been moved inside a separate thread class:</para>
        <para>//: c15:MultiJabberServer.java</para>
        <para>// A server that uses multithreading </para>
        <para>// to handle any number of clients.</para>
        <para>import java.io.*;</para>
        <para>import java.net.*;</para>
        <para> </para>
        <para>class ServeOneJabber extends Thread {</para>
        <para>� private Socket socket;</para>
        <para>� private BufferedReader in;</para>
        <para>� private PrintWriter out;</para>
        <para>� public ServeOneJabber(Socket s) </para>
        <para>����� throws IOException {</para>
        <para>��� socket = s;</para>
        <para>��� in = </para>
        <para>����� new BufferedReader(</para>
        <para>������� new InputStreamReader(</para>
        <para>��������� socket.getInputStream()));</para>
        <para>��� // Enable auto-flush:</para>
        <para>��� out = </para>
        <para>����� new PrintWriter(</para>
        <para>������� new BufferedWriter(</para>
        <para>��������� new OutputStreamWriter(</para>
        <para>����������� socket.getOutputStream())), true);</para>
        <para>��� // If any of the above calls throw an </para>
        <para>��� // exception, the caller is responsible for</para>
        <para>��� // closing the socket. Otherwise the thread</para>
        <para>��� // will close it.</para>
        <para>��� start(); // Calls run()</para>
        <para>� }</para>
        <para>� public void run() {</para>
        <para>��� try {</para>
        <para>����� while (true) {� </para>
        <para>������� String str = in.readLine();</para>
        <para>������� if (str.equals(&quot;END&quot;)) break;</para>
        <para>������� System.out.println(&quot;Echoing: &quot; + str);</para>
        <para>������� out.println(str);</para>
        <para>����� }</para>
        <para>����� System.out.println(&quot;closing...&quot;);</para>
        <para>��� } catch(IOException e) {</para>
        <para>����� System.err.println(&quot;IO Exception&quot;);</para>
        <para>��� } finally {</para>
        <para>����� try {</para>
        <para>������� socket.close();</para>
        <para>����� } catch(IOException e) {</para>
        <para>������� System.err.println(&quot;Socket not closed&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class MultiJabberServer {� </para>
        <para>� static final int PORT = 8080;</para>
        <para>� public static void main(String[] args)</para>
        <para>����� throws IOException {</para>
        <para>��� ServerSocket s = new ServerSocket(PORT);</para>
        <para>��� System.out.println(&quot;Server Started&quot;);</para>
        <para>��� try {</para>
        <para>����� while(true) {</para>
        <para>������� // Blocks until a connection occurs:</para>
        <para>������� Socket socket = s.accept();</para>
        <para>������� try {</para>
        <para>��������� new ServeOneJabber(socket);</para>
        <para>������� } catch(IOException e) {</para>
        <para>��������� // If it fails, close the socket,</para>
        <para>��������� // otherwise the thread will close it:</para>
        <para>��������� socket.close();</para>
        <para>������� }</para>
        <para>����� }</para>
        <para>��� } finally {</para>
        <para>����� s.close();</para>
        <para>��� }</para>
        <para>� } </para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">ServeOneJabber </emphasis>thread takes the <emphasis role="bold">Socket</emphasis> object that�s produced by <emphasis role="bold">accept( )</emphasis> in <emphasis role="bold">main( )</emphasis> every time a new client makes a connection. Then, as before, it creates a <emphasis role="bold">BufferedReader</emphasis> and auto-flushed <emphasis role="bold">PrintWriter</emphasis> object using the <emphasis role="bold">Socket</emphasis>. Finally, it calls the special <emphasis role="bold">Thread</emphasis> method <emphasis role="bold">start( )</emphasis>, which performs thread initialization and then calls <emphasis role="bold">run( )</emphasis>. This performs the same kind of action as in the previous example: reading something from the socket and then echoing it back until it reads the special �END� signal.</para>
        <para>The responsibility for cleaning up the socket must again be carefully designed. In this case, the socket is created outside of the <emphasis role="bold">ServeOneJabber</emphasis> so the responsibility can be shared. If the <emphasis role="bold">ServeOneJabber</emphasis> constructor fails, it will just throw the exception to the caller, who will then clean up the thread. But if the constructor succeeds, then the <emphasis role="bold">ServeOneJabber</emphasis> object takes over responsibility for cleaning up the thread, in its <emphasis role="bold">run( )</emphasis>.</para>
        <para>Notice the simplicity of the <emphasis role="bold">MultiJabberServer</emphasis>. As before, a <emphasis role="bold">ServerSocket</emphasis> is created and <emphasis role="bold">accept( )</emphasis> is called to allow a new connection. But this time, the return value of <emphasis role="bold">accept( )</emphasis> (a <emphasis role="bold">Socket</emphasis>) is passed to the constructor for <emphasis role="bold">ServeOneJabber,</emphasis> which creates a new thread to handle that connection. When the connection is terminated, the thread simply goes away.</para>
        <para>If the creation of the <emphasis role="bold">ServerSocket</emphasis> fails, the exception is again thrown through <emphasis role="bold">main( )</emphasis>. But if the creation succeeds, the outer <emphasis role="bold">try-finally</emphasis> guarantees its cleanup. The inner <emphasis role="bold">try-catch</emphasis> guards only against the failure of the <emphasis role="bold">ServeOneJabber</emphasis> constructor; if the constructor succeeds, then the <emphasis role="bold">ServeOneJabber</emphasis> thread will close the associated socket.</para>
        <para>To test that the server really does handle multiple clients, the following program creates many clients (using threads) that connect to the same server. The maximum number of threads allowed is determined by the <emphasis role="bold">final int MAX_THREADS</emphasis>. </para>
        <para>//: c15:MultiJabberClient.java</para>
        <para>// Client that tests the MultiJabberServer</para>
        <para>// by starting up multiple clients.</para>
        <para>import java.net.*;</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>class JabberClientThread extends Thread {</para>
        <para>� private Socket socket;</para>
        <para>� private BufferedReader in;</para>
        <para>� private PrintWriter out;</para>
        <para>� private static int counter = 0;</para>
        <para>� private int id = counter++;</para>
        <para>� private static int threadcount = 0;</para>
        <para>� public static int threadCount() { </para>
        <para>��� return threadcount; </para>
        <para>� }</para>
        <para>� public JabberClientThread(InetAddress addr) {</para>
        <para>��� System.out.println(&quot;Making client &quot; + id);</para>
        <para>��� threadcount++;</para>
        <para>��� try {</para>
        <para>����� socket = </para>
        <para>������� new Socket(addr, MultiJabberServer.PORT);</para>
        <para>��� } catch(IOException e) {</para>
        <para>����� System.err.println(&quot;Socket failed&quot;);</para>
        <para>����� // If the creation of the socket fails, </para>
        <para>����� // nothing needs to be cleaned up.</para>
        <para>��� }</para>
        <para>��� try {��� </para>
        <para>����� in = </para>
        <para>������� new BufferedReader(</para>
        <para>��������� new InputStreamReader(</para>
        <para>����������� socket.getInputStream()));</para>
        <para>����� // Enable auto-flush:</para>
        <para>����� out = </para>
        <para>������� new PrintWriter(</para>
        <para>��������� new BufferedWriter(</para>
        <para>����������� new OutputStreamWriter(</para>
        <para>���� ���������socket.getOutputStream())), true);</para>
        <para>����� start();</para>
        <para>��� } catch(IOException e) {</para>
        <para>����� // The socket should be closed on any </para>
        <para>����� // failures other than the socket </para>
        <para>����� // constructor:</para>
        <para>����� try {</para>
        <para>������� socket.close();</para>
        <para>����� } catch(IOException e2) {</para>
        <para>������� System.err.println(&quot;Socket not closed&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� // Otherwise the socket will be closed by</para>
        <para>��� // the run() method of the thread.</para>
        <para>� }</para>
        <para>� public void run() {</para>
        <para>��� try {</para>
        <para>����� for(int i = 0; i &lt; 25; i++) {</para>
        <para>������� out.println(&quot;Client &quot; + id + &quot;: &quot; + i);</para>
        <para>������� String str = in.readLine();</para>
        <para>������� System.out.println(str);</para>
        <para>����� }</para>
        <para>����� out.println(&quot;END&quot;);</para>
        <para>��� } catch(IOException e) {</para>
        <para>����� System.err.println(&quot;IO Exception&quot;);</para>
        <para>��� } finally {</para>
        <para>����� // Always close it:</para>
        <para>����� try {</para>
        <para>������� socket.close();</para>
        <para>����� } catch(IOException e) {</para>
        <para>������� System.err.println(&quot;Socket not closed&quot;);</para>
        <para>����� }</para>
        <para>����� threadcount--; // Ending this thread</para>
        <para>��� }</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class MultiJabberClient {</para>
        <para>� static final int MAX_THREADS = 40;</para>
        <para>� public static void main(String[] args) </para>
        <para>����� throws IOException, InterruptedException {</para>
        <para>��� InetAddress addr = </para>
        <para>����� InetAddress.getByName(null);</para>
        <para>��� while(true) {</para>
        <para>����� if(JabberClientThread.threadCount() </para>
        <para>�������� &lt; MAX_THREADS)</para>
        <para>������� new JabberClientThread(addr);</para>
        <para>����� Thread.currentThread().sleep(100);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">JabberClientThread</emphasis> constructor takes an <emphasis role="bold">InetAddress</emphasis> and uses it to open a <emphasis role="bold">Socket</emphasis>. You�re probably starting to see the pattern: the <emphasis role="bold">Socket</emphasis> is always used to create some kind of <emphasis role="bold">Reader </emphasis>and/or <emphasis role="bold">Writer </emphasis>(or <emphasis role="bold">InputStream</emphasis> and/or <emphasis role="bold">OutputStream</emphasis>) object, which is the only way that the <emphasis role="bold">Socket</emphasis> can be used. (You can, of course, write a class or two to automate this process instead of doing all the typing if it becomes painful.) Again, <emphasis role="bold">start( )</emphasis> performs thread initialization and calls <emphasis role="bold">run( )</emphasis>. Here, messages are sent to the server and information from the server is echoed to the screen. However, the thread has a limited lifetime and eventually completes. Note that the socket is cleaned up if the constructor fails after the socket is created but before the constructor completes. Otherwise the responsibility for calling <emphasis role="bold">close( )</emphasis> for the socket is relegated to the <emphasis role="bold">run( )</emphasis> method.</para>
        <para>The <emphasis role="bold">threadcount</emphasis> keeps track of how many <emphasis role="bold">JabberClientThread</emphasis> objects currently exist. It is incremented as part of the constructor and decremented as <emphasis role="bold">run( )</emphasis> exits (which means the thread is terminating). In <emphasis role="bold">MultiJabberClient.main( ),</emphasis> you can see that the number of threads is tested, and if there are too many, no more are created. Then the method sleeps. This way, some threads will eventually terminate and more can be created. You can experiment with <emphasis role="bold">MAX_THREADS</emphasis> to see where your particular system begins to have trouble with too many connections.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545498"/><anchor xreflabel="Datagrams" xml:id="_Toc481064871"/>Datagrams</title>
        <para>The examples you�ve seen so far use the <emphasis role="italic">Transmission Control Protocol</emphasis> (TCP, also known as <emphasis role="italic">stream-based sockets</emphasis>), which is designed for ultimate reliability and guarantees that the data will get there. It allows retransmission of lost data, it provides multiple paths through different routers in case one goes down, and bytes are delivered in the order they are sent. All this control and reliability comes at a cost: TCP has a high overhead.</para>
        <para>There�s a second protocol, called <emphasis role="italic">User Datagram Protocol</emphasis> (UDP), which doesn�t guarantee that the packets will be delivered and doesn�t guarantee that they will arrive in the order they were sent. It�s called an �unreliable protocol� (TCP is a �reliable protocol�), which sounds bad, but because it�s much faster it can be useful. There are some applications, such as an audio signal, in which it isn�t so critical if a few packets are dropped here or there but speed is vital. Or consider a time-of-day server, where it really doesn�t matter if one of the messages is lost. Also, some applications might be able to fire off a UDP message to a server and can then assume, if there is no response in a reasonable period of time, that the message was lost.</para>
        <para>Typically, you�ll do most of your direct network programming with TCP, and only occasionally will you use UDP. There�s a more complete treatment of UDP, including an example, in the first edition of this book (available on the CD ROM bound into this book, or as a free download from <emphasis role="italic">www.BruceEckel.com</emphasis>).</para>
      </section>
      <section>
        <title><anchor xreflabel="Using URLs from within an applet" xml:id="_Toc481064872"/>Using URLs from within an applet</title>
        <para>It�s possible for an applet to cause the display of any URL through the Web browser the applet is running within. You can do this with the following line:</para>
        <para>getAppletContext().showDocument(u);</para>
        <para> </para>
        <para>in which <emphasis role="bold">u</emphasis> is the <emphasis role="bold">URL</emphasis> object. Here�s a simple example that redirects you to another Web page. Although you�re just redirected to an HTML page, you could also redirect to the output of a CGI program. </para>
        <para>//: c15:ShowHTML.java</para>
        <para>// &lt;applet code=ShowHTML width=100 height=50&gt;</para>
        <para>// &lt;/applet&gt;</para>
        <para>import javax.swing.*;</para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import java.net.*;</para>
        <para>import java.io.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class ShowHTML extends JApplet {</para>
        <para>� JButton send = new JButton(&quot;Go&quot;);</para>
        <para>� JLabel l = new JLabel();</para>
        <para>� public void init() {</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.setLayout(new FlowLayout());</para>
        <para>��� send.addActionListener(new Al());</para>
        <para>��� cp.add(send);</para>
        <para>��� cp.add(l);</para>
        <para>� }</para>
        <para>� class Al implements ActionListener {</para>
        <para>��� public void actionPerformed(ActionEvent ae) {</para>
        <para>����� try {</para>
        <para>������� // This could be a CGI program instead of</para>
        <para>������� // an HTML page.</para>
        <para>������� URL u = new URL(getDocumentBase(), </para>
        <para>��������� &quot;FetcherFrame.html&quot;);</para>
        <para>������� // Display the output of the URL using</para>
        <para>���� ���// the Web browser, as an ordinary page:</para>
        <para>������� getAppletContext().showDocument(u);</para>
        <para>����� } catch(Exception e) {</para>
        <para>������� l.setText(e.toString());</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new ShowHTML(), 100, 50);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The beauty of the <emphasis role="bold">URL</emphasis> class is how much it shields you from. You can connect to Web servers without knowing much at all about what�s going on under the covers.</para>
        <section>
          <title>Reading a file from the server</title>
          <para>A variation on the above program reads a file located on the server. In this case, the file is specified by the client:</para>
          <para>//: c15:Fetcher.java</para>
          <para>// &lt;applet code=Fetcher width=500 height=300&gt;</para>
          <para>// &lt;/applet&gt;</para>
          <para>import javax.swing.*;</para>
          <para>import java.awt.*;</para>
          <para>import java.awt.event.*;</para>
          <para>import java.net.*;</para>
          <para>import java.io.*;</para>
          <para>import com.bruceeckel.swing.*;</para>
          <para> </para>
          <para>public class Fetcher extends JApplet {</para>
          <para>� JButton fetchIt= new JButton(&quot;Fetch the Data&quot;);</para>
          <para>� JTextField f = </para>
          <para>��� new JTextField(&quot;Fetcher.java&quot;, 20);</para>
          <para>� JTextArea t = new JTextArea(10,40);</para>
          <para>� public void init() {</para>
          <para>��� Container cp = getContentPane();</para>
          <para>��� cp.setLayout(new FlowLayout());</para>
          <para>��� fetchIt.addActionListener(new FetchL());</para>
          <para>��� cp.add(new JScrollPane(t));</para>
          <para>��� cp.add(f); cp.add(fetchIt);</para>
          <para>� }</para>
          <para>� public class FetchL implements ActionListener {</para>
          <para>��� public void actionPerformed(ActionEvent e) {</para>
          <para>����� try {</para>
          <para>������� URL url = new URL(getDocumentBase(),</para>
          <para>��������� f.getText());</para>
          <para>������� t.setText(url + &quot;\n&quot;);</para>
          <para>������� InputStream is = url.openStream();</para>
          <para>������� BufferedReader in = new BufferedReader(</para>
          <para>�� �������new InputStreamReader(is));</para>
          <para>������� String line;</para>
          <para>������� while ((line = in.readLine()) != null)</para>
          <para>��������� t.append(line + &quot;\n&quot;);</para>
          <para>����� } catch(Exception ex) {</para>
          <para>������� t.append(ex.toString());</para>
          <para>����� }</para>
          <para>��� }</para>
          <para>� }</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� Console.run(new Fetcher(), 500, 300);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The creation of the <emphasis role="bold">URL</emphasis> object is similar to the previous example�<emphasis role="bold">getDocumentBase( )</emphasis> is the starting point as before, but this time the name of the file is read from the <emphasis role="bold">JTextField</emphasis>. Once the <emphasis role="bold">URL</emphasis> object is created, its <emphasis role="bold">String</emphasis> version is placed in the <emphasis role="bold">JTextArea</emphasis> so we can see what it looks like. Then an <emphasis role="bold">InputStream</emphasis> is procured from the <emphasis role="bold">URL</emphasis>, which in this case will simply produce a stream of the characters in the file. After converting to a <emphasis role="bold">Reader</emphasis> and buffering, each line is read and appended to the <emphasis role="bold">JTextArea</emphasis>. Note that the <emphasis role="bold">JTextArea</emphasis> has been placed inside a <emphasis role="bold">JScrollPane</emphasis> so that scrolling is handled automatically.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="More to networking" xml:id="_Toc481064873"/>More to networking</title>
        <para>There�s actually a lot more to networking than can be covered in this introductory treatment. Java networking also provides fairly extensive support for URLs, including protocol handlers for different types of content that can be discovered at an Internet site. You can find other Java networking features fully and carefully described in <emphasis role="italic">Java Network Programming</emphasis> by Elliotte Rusty Harold (O�Reilly, 1997).</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Java Database Connectivity (JDBC)" xml:id="_Toc481064874"/>Java Database Connectivity (JDBC)</title>
      <para>It has been estimated that half of all software development involves client/server operations. A great promise of Java has been the ability to build platform-independent client/server database applications. This has come to fruition with Java DataBase Connectivity (JDBC).</para>
      <para>One of the major problems with databases has been the feature wars between the database companies. There is a �standard� database language, Structured Query Language (SQL-92), but you must usually know which database vendor you�re working with despite the standard. JDBC is designed to be platform-independent, so you don�t need to worry about the database you�re using while you�re programming. However, it�s still possible to make vendor-specific calls from JDBC so you aren�t restricted from doing what you must.</para>
      <para>One place where programmers may need to use SQL type names is in the SQL TABLE CREATE statement when they are creating a new database table and defining the SQL type for each column. Unfortunately there are significant variations between SQL types supported by different database products. Different databases that support SQL types with the same semantics and structure may give those types different names. Most major databases support an SQL data type for large binary values: in Oracle this type is called a LONG RAW, Sybase calls it IMAGE, Informix calls it BYTE, and DB2 calls it LONG VARCHAR FOR BIT DATA. Therefore, if database portability is a goal you should try to use only generic SQL type identifiers.</para>
      <para>Portability is an issue when writing for a book where readers may be testing the examples with all kinds of unknown data stores. I have tried to write these examples to be as portable as possible. You should also notice that the database-specific code has been isolated in order to centralize any changes that you may need to perform to get the examples operational in your environment.</para>
      <para>JDBC, like many of the APIs in Java, is designed for simplicity. The method calls you make correspond to the logical operations you�d think of doing when gathering data from a database: connect to the database, create a statement and execute the query, and look at the result set.</para>
      <para>To allow this platform independence, JDBC provides a <emphasis role="italic">driver manager</emphasis> that dynamically maintains all the driver objects that your database queries will need. So if you have three different kinds of vendor databases to connect to, you�ll need three different driver objects. The driver objects register themselves with the driver manager at the time of loading, and you can force the loading using <emphasis role="bold">Class.forName( )</emphasis>.</para>
      <para>To open a database, you must create a �database URL� that specifies: </para>
      <para>That you�re using JDBC with �jdbc.�</para>
      <para>116.   The �subprotocol�: the name of the driver or the name of a database connectivity mechanism. Since the design of JDBC was inspired by ODBC, the first subprotocol available is the �jdbc-odbc bridge,� specified by �odbc.�</para>
      <para>117.   The database identifier. This varies with the database driver used, but it generally provides a logical name that is mapped by the database administration software to a physical directory where the database tables are located. For your database identifier to have any meaning, you must register the name using your database administration software. (The process of registration varies from platform to platform.)</para>
      <para>All this information is combined into one string, the �database URL.� For example, to connect through the ODBC subprotocol to a database identified as �people,� the database URL could be:</para>
      <para>String dbUrl = &quot;jdbc:odbc:people&quot;;</para>
      <para> </para>
      <para>If you�re connecting across a network, the database URL will contain the connection information identifying the remote machine and can become a bit intimidating. Here is an example of a CloudScape database being called from a remote client utilizing RMI:</para>
      <para>jdbc:rmi://192.168.170.27:1099/jdbc:cloudscape:db</para>
      <para> </para>
      <para>This database URL is really two jdbc calls in one. The first part �jdbc:rmi://192.168.170.27:1099/� uses RMI to make the connection to the remote database engine listening on port 1099 at IP Address 192.168.170.27. The second part of the URL, �jdbc:cloudscape:db� conveys the more typical settings using the subprotocol and database name but this will only happen after the first section has made the connection via RMI to the remote machine.</para>
      <para>When you�re ready to connect to the database, call the <emphasis role="bold">static</emphasis> method <emphasis role="bold">DriverManager.getConnection( )</emphasis> and pass it the database URL, the user name, and a password to get into the database. You get back a <emphasis role="bold">Connection</emphasis> object that you can then use to query and manipulate the database.</para>
      <para>The following example opens a database of contact information and looks for a person�s last name as given on the command line. It selects only the names of people that have email addresses, then prints out all the ones that match the given last name:</para>
      <para>//: c15:jdbc:Lookup.java</para>
      <para>// Looks up email addresses in a </para>
      <para>// local database using JDBC.</para>
      <para>import java.sql.*;</para>
      <para> </para>
      <para>public class Lookup {</para>
      <para>� public static void main(String[] args) </para>
      <para>� throws SQLException, ClassNotFoundException {</para>
      <para>��� String dbUrl = &quot;jdbc:odbc:people&quot;;</para>
      <para>��� String user = &quot;&quot;;</para>
      <para>��� String password = &quot;&quot;;</para>
      <para>��� // Load the driver (registers itself)</para>
      <para>��� Class.forName(</para>
      <para>����� &quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;);</para>
      <para>��� Connection c = DriverManager.getConnection(</para>
      <para>����� dbUrl, user, password);</para>
      <para>��� Statement s = c.createStatement();</para>
      <para>��� // SQL code:</para>
      <para>��� ResultSet r = </para>
      <para>����� s.executeQuery(</para>
      <para>������� &quot;SELECT FIRST, LAST, EMAIL &quot; +</para>
      <para>������� &quot;FROM people.csv people &quot; +</para>
      <para>������� &quot;WHERE &quot; +</para>
      <para>������� &quot;(LAST=&apos;&quot; + args[0] + &quot;&apos;) &quot; +</para>
      <para>������� &quot; AND (EMAIL Is Not Null) &quot; +</para>
      <para>������� &quot;ORDER BY FIRST&quot;);</para>
      <para>��� while(r.next()) {</para>
      <para>����� // Capitalization doesn&apos;t matter:</para>
      <para>����� System.out.println(</para>
      <para>������� r.getString(&quot;Last&quot;) + &quot;, &quot; </para>
      <para>������� + r.getString(&quot;fIRST&quot;)</para>
      <para>������� + &quot;: &quot; + r.getString(&quot;EMAIL&quot;) );</para>
      <para>��� }</para>
      <para>��� s.close(); // Also closes ResultSet</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>You can see the creation of the database URL as previously described. In this example, there is no password protection on the database so the user name and password are empty strings.</para>
      <para>Once the connection is made with <emphasis role="bold">DriverManager.getConnection( )</emphasis>, you can use the resulting <emphasis role="bold">Connection</emphasis> object to<emphasis role="bold"/>create a <emphasis role="bold">Statement</emphasis> object using the <emphasis role="bold">createStatement( )</emphasis> method. With the resulting <emphasis role="bold">Statement</emphasis>, you can call <emphasis role="bold">executeQuery( )</emphasis>, passing in a string containing an SQL-92 standard SQL statement. (You�ll see shortly how you can generate this statement automatically, so you don�t have to know much about SQL.) </para>
      <para>The <emphasis role="bold">executeQuery( ) </emphasis>method returns a <emphasis role="bold">ResultSet</emphasis> object, which is an iterator: the <emphasis role="bold">next( )</emphasis> method moves the iterator to the next record in the statement, or returns <emphasis role="bold">false</emphasis> if the end of the result set has been reached. You�ll always get a <emphasis role="bold">ResultSet</emphasis> object back from <emphasis role="bold">executeQuery( )</emphasis> even if a query results in an empty set (that is, an exception is not thrown). Note that you must call <emphasis role="bold">next( )</emphasis> once before trying to read any record data. If the result set is empty, this first call to <emphasis role="bold">next( )</emphasis> will return <emphasis role="bold">false</emphasis>. For each record in the result set, you can select the fields using (among other approaches) the field name as a string. Also note that the capitalization of the field name is ignored�it doesn�t matter with an SQL database. You determine the type you�ll get back by calling <emphasis role="bold">getInt( )</emphasis>, <emphasis role="bold">getString( )</emphasis>, <emphasis role="bold">getFloat( )</emphasis>, etc. At this point, you�ve got your database data in Java native format and can do whatever you want with it using ordinary Java code.</para>
      <section>
        <title><anchor xreflabel="Getting the example to work" xml:id="_Toc481064875"/>Getting the example to work</title>
        <para>With JDBC, understanding the code is relatively simple. The confusing part is making it work on your particular system. The reason this is confusing is that it requires you to figure out how to get your JDBC driver to load properly, and how to set up a database using your database administration software.</para>
        <para>Of course, this process can vary radically from machine to machine, but the process I used to make it work under 32-bit Windows might give you clues to help you attack your own situation.</para>
        <section>
          <title>Step 1: Find the JDBC Driver</title>
          <para>The program above contains the statement:</para>
          <para>Class.forName(&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;);</para>
          <para> </para>
          <para>This implies a directory structure, which is deceiving. With this particular installation of JDK 1.1, there was no file called <emphasis role="bold">JdbcOdbcDriver.class</emphasis>, so if you looked at this example and went searching for it you�d be frustrated. Other published examples use a pseudo name, such as �myDriver.ClassName,� which is less than helpful. In fact, the load statement above for the jdbc-odbc driver (the only one that actually comes with the JDK) appears in only a few places in the online documentation (in particular, a page labeled �JDBC-ODBC Bridge Driver�). If the load statement above doesn�t work, then the name might have been changed as part of a Java version change, so you should hunt through the documentation again.</para>
          <para>If the load statement is wrong, you�ll get an exception at this point. To test whether your driver load statement is working correctly, comment out the code after the statement and up to the <emphasis role="bold">catch</emphasis> clause; if the program throws no exceptions it means that the driver is loading properly.</para>
        </section>
        <section>
          <title>Step 2: Configure the database</title>
          <para>Again, this is specific to 32-bit Windows; you might need to do some research to figure it out for your own platform.</para>
          <para>First, open the control panel. You might find two icons that say �ODBC.� You must use the one that says �32bit ODBC,� since the other one is for backward compatibility with 16-bit ODBC software and will produce no results for JDBC. When you open the �32bit ODBC� icon, you�ll see a tabbed dialog with a number of tabs, including �User DSN,� �System DSN,� �File DSN,� etc., in which �DSN� means �Data Source Name.� It turns out that for the JDBC-ODBC bridge, the only place where it�s important to set up your database is �System DSN,� but you�ll also want to test your configuration and create queries, and for that you�ll also need to set up your database in �File DSN.� This will allow the Microsoft Query tool (that comes with Microsoft Office) to find the database. Note that other query tools are also available from other vendors.</para>
          <para>The most interesting database is one that you�re already using. Standard ODBC supports a number of different file formats including such venerable workhorses as DBase. However, it also includes the simple �comma-separated ASCII� format, which virtually every data tool has the ability to write. In my case, I just took my �people� database that I�ve been maintaining for years using various contact-management tools and exported it as a comma-separated ASCII file (these typically have an extension of <emphasis role="bold">.csv</emphasis>). In the �System DSN� section I chose �Add,� chose the text driver to handle my comma-separated ASCII file, and then un-checked �use current directory� to allow me to specify the directory where I exported the data file.</para>
          <para>You�ll notice when you do this that you don�t actually specify a file, only a directory. That�s because a database is typically represented as a collection of files under a single directory (although it could be represented in other forms as well). Each file usually contains a single table, and the SQL statements can produce results that are culled from multiple tables in the database (this is called a <emphasis role="italic">join</emphasis>). A database that contains only a single table (like my �people� database) is usually called a <emphasis role="italic">flat-file database</emphasis>. Most problems that go beyond the simple storage and retrieval of data generally require multiple tables that must be related by joins to produce the desired results, and these are called <emphasis role="italic">relational</emphasis> databases.</para>
        </section>
        <section>
          <title>Step 3: Test the configuration</title>
          <para>To test the configuration you�ll need a way to discover whether the database is visible from a program that queries it. Of course, you can simply run the JDBC program example above, up to and including the statement:</para>
          <para>Connection c = DriverManager.getConnection(</para>
          <para>� dbUrl, user, password);</para>
          <para> </para>
          <para>If an exception is thrown, your configuration was incorrect.</para>
          <para>However, it�s useful to get a query-generation tool involved at this point. I used Microsoft Query that came with Microsoft Office, but you might prefer something else. The query tool must know where the database is, and Microsoft Query required that I go to the ODBC Administrator�s �File DSN� tab and add a new entry there, again specifying the text driver and the directory where my database lives. You can name the entry anything you want, but it�s helpful to use the same name you used in �System DSN.�</para>
          <para>Once you�ve done this, you will see that your database is available when you create a new query using your query tool.</para>
        </section>
        <section>
          <title>Step 4: Generate your SQL query</title>
          <para>The query that I created using Microsoft Query not only showed me that my database was there and in good order, but it also automatically created the SQL code that I needed to insert into my Java program. I wanted a query that would search for records that had the last name that was typed on the command line when starting the Java program. So as a starting point, I searched for a specific last name, �Eckel.� I also wanted to display only those names that had email addresses associated with them. The steps I took to create this query were:</para>
          <para>Start a new query and use the Query Wizard. Select the �people� database. (This is the equivalent of opening the database connection using the appropriate database URL.)</para>
          <para>118.   Select the �people� table within the database. From within the table, choose the columns FIRST, LAST, and EMAIL.</para>
          <para>119.   Under �Filter Data,� choose LAST and select �equals� with an argument of �Eckel.� Click the �And� radio button.</para>
          <para>120.   Choose EMAIL and select �Is not Null.�</para>
          <para>121.   Under �Sort By,� choose FIRST.</para>
          <para>The result of this query will show you whether you�re getting what you want.</para>
          <para>Now you can press the SQL button and without any research on your part, up will pop the correct SQL code, ready for you to cut and paste. For this query, it looked like this:</para>
          <para>SELECT people.FIRST, people.LAST, people.EMAIL</para>
          <para>FROM people.csv people</para>
          <para>WHERE (people.LAST=&apos;Eckel&apos;) AND </para>
          <para>(people.EMAIL Is Not Null)</para>
          <para>ORDER BY people.FIRST</para>
          <para> </para>
          <para>Especially with more complicated queries it�s easy to get things wrong, but by using a query tool you can interactively test your queries and automatically generate the correct code. It�s hard to argue the case for doing this by hand.</para>
        </section>
        <section>
          <title>Step 5: Modify and paste in your query</title>
          <para>You�ll notice that the code above looks different from what�s used in the program. That�s because the query tool uses full qualification for all of the names, even when there�s only one table involved. (When more than one table is involved, the qualification prevents collisions between columns from different tables that have the same names.) Since this query involves only one table, you can optionally remove the �people� qualifier from most of the names, like this:</para>
          <para>SELECT FIRST, LAST, EMAIL</para>
          <para>FROM people.csv people</para>
          <para>WHERE (LAST=&apos;Eckel&apos;) AND </para>
          <para>(EMAIL Is Not Null)</para>
          <para>ORDER BY FIRST</para>
          <para> </para>
          <para>In addition, you don�t want this program to be hard coded to look for only one name. Instead, it should hunt for the name given as the command-line argument. Making these changes and turning the SQL statement into a dynamically-created <emphasis role="bold">String</emphasis> produces:</para>
          <para>&quot;SELECT FIRST, LAST, EMAIL &quot; +</para>
          <para>&quot;FROM people.csv people &quot; +</para>
          <para>&quot;WHERE &quot; +</para>
          <para>&quot;(LAST=&apos;&quot; + args[0] + &quot;&apos;) &quot; +</para>
          <para>&quot; AND (EMAIL Is Not Null) &quot; +</para>
          <para>&quot;ORDER BY FIRST&quot;);</para>
          <para> </para>
          <para>SQL has another way to insert names into a query called <emphasis role="italic">stored procedures</emphasis>, which is used for speed. But for much of your database experimentation and for your first cut, building your own query strings in Java is fine.</para>
          <para>You can see from this example that by using the tools currently available�in particular the query-building tool�database programming with SQL and JDBC can be quite straightforward.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="A GUI version of the lookup
program" xml:id="_Toc481064876"/>A GUI version of the lookup program</title>
        <para>It�s more useful to leave the lookup program running all the time and simply switch to it and type in a name whenever you want to look someone up. The following program creates the lookup program as an application/applet, and it also adds name completion so the data will show up without forcing you to type the entire last name:</para>
        <para>//: c15:jdbc:VLookup.java</para>
        <para>// GUI version of Lookup.java.</para>
        <para>// &lt;applet code=VLookup</para>
        <para>// width=500 height=200&gt;&lt;/applet&gt;</para>
        <para>import javax.swing.*; </para>
        <para>import java.awt.*;</para>
        <para>import java.awt.event.*;</para>
        <para>import javax.swing.event.*;</para>
        <para>import java.sql.*;</para>
        <para>import com.bruceeckel.swing.*;</para>
        <para> </para>
        <para>public class VLookup extends JApplet {</para>
        <para>� String dbUrl = &quot;jdbc:odbc:people&quot;;</para>
        <para>� String user = &quot;&quot;;</para>
        <para>� String password = &quot;&quot;;</para>
        <para>� Statement s;</para>
        <para>� JTextField searchFor = new JTextField(20);</para>
        <para>� JLabel completion = </para>
        <para>��� new JLabel(&quot;����������������������� &quot;);</para>
        <para>� JTextArea results = new JTextArea(40, 20);</para>
        <para>� public void init() {</para>
        <para>��� searchFor.getDocument().addDocumentListener(</para>
        <para>����� new SearchL());</para>
        <para>��� JPanel p = new JPanel();</para>
        <para>��� p.add(new Label(&quot;Last name to search for:&quot;));</para>
        <para>��� p.add(searchFor);</para>
        <para>��� p.add(completion);</para>
        <para>��� Container cp = getContentPane();</para>
        <para>��� cp.add(p, BorderLayout.NORTH);</para>
        <para>��� cp.add(results, BorderLayout.CENTER);</para>
        <para>��� try {</para>
        <para>����� // Load the driver (registers itself)</para>
        <para>����� Class.forName(</para>
        <para>������� &quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;);</para>
        <para>����� Connection c = DriverManager.getConnection(</para>
        <para>������� dbUrl, user, password);</para>
        <para>����� s = c.createStatement();</para>
        <para>��� } catch(Exception e) {</para>
        <para>����� results.setText(e.toString());</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� class SearchL implements DocumentListener {</para>
        <para>��� public void changedUpdate(DocumentEvent e){}</para>
        <para>��� public void insertUpdate(DocumentEvent e){</para>
        <para>����� textValueChanged();</para>
        <para>��� }</para>
        <para>��� public void removeUpdate(DocumentEvent e){</para>
        <para>����� textValueChanged();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public void textValueChanged() {</para>
        <para>��� ResultSet r;</para>
        <para>��� if(searchFor.getText().length() == 0) {</para>
        <para>����� completion.setText(&quot;&quot;);</para>
        <para>����� results.setText(&quot;&quot;);</para>
        <para>����� return;</para>
        <para>��� }</para>
        <para>��� try {</para>
        <para>����� // Name completion:</para>
        <para>����� r = s.executeQuery(</para>
        <para>������� &quot;SELECT LAST FROM people.csv people &quot; +</para>
        <para>������� &quot;WHERE (LAST Like &apos;&quot; +</para>
        <para>������� searchFor.getText()� + </para>
        <para>������� &quot;%&apos;) ORDER BY LAST&quot;);</para>
        <para>����� if(r.next()) </para>
        <para>������� completion.setText(</para>
        <para>����� ����r.getString(&quot;last&quot;));</para>
        <para>����� r = s.executeQuery(</para>
        <para>������� &quot;SELECT FIRST, LAST, EMAIL &quot; +</para>
        <para>������� &quot;FROM people.csv people &quot; +</para>
        <para>������� &quot;WHERE (LAST=&apos;&quot; + </para>
        <para>������� completion.getText() +</para>
        <para>������� &quot;&apos;) AND (EMAIL Is Not Null) &quot; +</para>
        <para>������� &quot;ORDER BY FIRST&quot;);</para>
        <para>��� } catch(Exception e) {</para>
        <para>����� results.setText(</para>
        <para>������� searchFor.getText() + &quot;\n&quot;);</para>
        <para>����� results.append(e.toString());</para>
        <para>����� return; </para>
        <para>��� }</para>
        <para>��� results.setText(&quot;&quot;);</para>
        <para>��� try {</para>
        <para>����� while(r.next()) {</para>
        <para>������� results.append(</para>
        <para>��������� r.getString(&quot;Last&quot;) + &quot;, &quot; </para>
        <para>��������� + r.getString(&quot;fIRST&quot;) + </para>
        <para>��������� &quot;: &quot; + r.getString(&quot;EMAIL&quot;) + &quot;\n&quot;);</para>
        <para>����� }</para>
        <para>��� } catch(Exception e) {</para>
        <para>����� results.setText(e.toString());</para>
        <para>��� }</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Console.run(new VLookup(), 500, 200);</para>
        <para>��}</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Much of the database logic is the same, but you can see that a <emphasis role="bold">DocumentListener</emphasis> is added to listen to the<emphasis role="bold"> JText</emphasis><emphasis role="bold">Field</emphasis> (see the <emphasis role="bold">javax.swing.JTextField</emphasis> entry in the Java HTML documentation from <emphasis role="italic">java.sun.com</emphasis> for details), so that whenever you type a new character it first tries to do a name completion by looking up the last name in the database and using the first one that shows up. (It places it in the <emphasis role="bold">completion</emphasis><emphasis role="bold">JLabel</emphasis>, and uses that as the lookup text.) This way, as soon as you�ve typed enough characters for the program to uniquely find the name you�re looking for, you can stop.</para>
      </section>
      <section>
        <title><anchor xreflabel="Why the JDBC API 
seems so complex" xml:id="_Toc481064877"/>Why the JDBC API   seems so complex</title>
        <para>When you browse the online documentation for JDBC it can seem daunting. In particular, in the <emphasis role="bold">DatabaseMetaData</emphasis> interface�which is just huge, contrary to most of the interfaces you see in Java�there are methods such as <emphasis role="bold">dataDefinitionCausesTransactionCommit( )</emphasis>, <emphasis role="bold">getMaxColumnNameLength( )</emphasis>, <emphasis role="bold">getMaxStatementLength( )</emphasis>, <emphasis role="bold">storesMixedCaseQuotedIdentifiers( )</emphasis>, <emphasis role="bold">supportsANSI92IntermediateSQL( )</emphasis>, <emphasis role="bold">supportsLimitedOuterJoins( )</emphasis>, and so on. What�s this all about?</para>
        <para>As mentioned earlier, databases have seemed from their inception to be in a constant state of turmoil, primarily because the demand for database applications, and thus database tools, is so great. Only recently has there been any convergence on the common language of SQL (and there are plenty of other database languages in common use). But even with an SQL �standard� there are so many variations on that theme that JDBC must provide the large <emphasis role="bold">DatabaseMetaData</emphasis> interface so that your code can discover the capabilities of the particular �standard� SQL database that it�s currently connected to. In short, you can write simple, transportable SQL, but if you want to optimize speed your coding will multiply tremendously as you investigate the capabilities of a particular vendor�s database.</para>
        <para>This, of course, is not Java�s fault. The discrepancies between database products are just something that JDBC tries to help compensate for. But bear in mind that your life will be easier if you can either write generic queries and not worry quite as much about performance, or, if you must tune for performance, know the platform you�re writing for so you don�t need to write all that investigation code.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc463665181"/><anchor xreflabel="A more
sophisticated example" xml:id="_Toc481064878"/>A more sophisticated example</title>
        <para>A more interesting example<anchor xreflabel="[73]" xml:id="_ftnref73"/>[73] involves a multitable database that resides on a server. Here, the database is meant to provide a repository for community activities and to allow people to sign up for these events, so it is called the <emphasis role="italic">Community Interests Database </emphasis>(CID). This example will only provide an overview of the database and its implementation, and is not intended to be an in-depth tutorial on database development. There are numerous books, seminars, and software packages that will help you in the design and development of a database.</para>
        <para>In addition, this example presumes the prior installation of an SQL database on a server (although it could also be run on a local machine), and the interrogation and discovery of an appropriate JDBC driver for that database. Several free SQL databases are available, and some are even automatically installed with various flavors of Linux. You are responsible for making the choice of database and locating the JDBC driver; the example here is based on an SQL database system called �Cloudscape.�</para>
        <para>To keep changes in the connection information simple, the database driver, database URL, user name, and password are placed in a separate class:</para>
        <para>//: c15:jdbc:CIDConnect.java</para>
        <para>// Database connection information for</para>
        <para>// the community interests database (CID).</para>
        <para> </para>
        <para>public class CIDConnect {</para>
        <para>� // All the information specific to CloudScape:</para>
        <para>� public static String dbDriver = </para>
        <para>��� &quot;COM.cloudscape.core.JDBCDriver&quot;;</para>
        <para>� public static String dbURL =</para>
        <para>��� &quot;jdbc:cloudscape:d:/docs/_work/JSapienDB&quot;;</para>
        <para>� public static String user = &quot;&quot;;</para>
        <para>� public static String password = &quot;&quot;;</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In this example, there is no password protection on the database so the user name and password are empty strings. </para>
        <para>The database consists of a set of tables that have a structure as shown here: </para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="308" contentwidth="289" fileref="./TIJ2_files/image031.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image031.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para>�Members� contains community member information, �Events� and �Locations� contain information about the activities and where they take place, and �Evtmems� connects events and members that would like to attend that event. You can see that a data member in one table produces a key in another table.</para>
        <para>The following class contains the SQL strings that will create these database tables (refer to an SQL guide for an explanation of the SQL code):</para>
        <para>//: c15:jdbc:CIDSQL.java</para>
        <para>// SQL strings to create the tables for the CID.</para>
        <para> </para>
        <para>public class CIDSQL {</para>
        <para>� public static String[] sql = {</para>
        <para>��� // Create the MEMBERS table:</para>
        <para>��� &quot;drop table MEMBERS&quot;,</para>
        <para>��� &quot;create table MEMBERS &quot; +</para>
        <para>��� &quot;(MEM_ID INTEGER primary key, &quot; +</para>
        <para>��� &quot;MEM_UNAME VARCHAR(12) not null unique, &quot;+</para>
        <para>��� &quot;MEM_LNAME VARCHAR(40), &quot; +</para>
        <para>��� &quot;MEM_FNAME VARCHAR(20), &quot; +</para>
        <para>��� &quot;ADDRESS VARCHAR(40), &quot; +</para>
        <para>��� &quot;CITY VARCHAR(20), &quot; +</para>
        <para>��� &quot;STATE CHAR(4), &quot; +</para>
        <para>��� &quot;ZIP CHAR(5), &quot; +</para>
        <para>��� &quot;PHONE CHAR(12), &quot; +</para>
        <para>��� &quot;EMAIL VARCHAR(30))&quot;,</para>
        <para>��� &quot;create unique index &quot; +</para>
        <para>��� &quot;LNAME_IDX on MEMBERS(MEM_LNAME)&quot;,</para>
        <para>��� // Create the EVENTS table</para>
        <para>��� &quot;drop table EVENTS&quot;,</para>
        <para>��� &quot;create table EVENTS &quot; +</para>
        <para>��� &quot;(EVT_ID INTEGER primary key, &quot; +</para>
        <para>��� &quot;EVT_TITLE VARCHAR(30) not null, &quot; +</para>
        <para>��� &quot;EVT_TYPE VARCHAR(20), &quot; +</para>
        <para>��� &quot;LOC_ID INTEGER, &quot; +</para>
        <para>��� &quot;PRICE DECIMAL, &quot; +</para>
        <para>��� &quot;DATETIME TIMESTAMP)&quot;,</para>
        <para>��� &quot;create unique index &quot; +</para>
        <para>��� &quot;TITLE_IDX on EVENTS(EVT_TITLE)&quot;,</para>
        <para>��� // Create the EVTMEMS table</para>
        <para>��� &quot;drop table EVTMEMS&quot;,</para>
        <para>��� &quot;create table EVTMEMS &quot; +</para>
        <para>��� &quot;(MEM_ID INTEGER not null, &quot; +</para>
        <para>��� &quot;EVT_ID INTEGER not null, &quot; +</para>
        <para>��� &quot;MEM_ORD INTEGER)&quot;,</para>
        <para>��� &quot;create unique index &quot; +</para>
        <para>��� &quot;EVTMEM_IDX on EVTMEMS(MEM_ID, EVT_ID)&quot;,</para>
        <para>��� // Create the LOCATIONS table</para>
        <para>��� &quot;drop table LOCATIONS&quot;,</para>
        <para>��� &quot;create table LOCATIONS &quot; +</para>
        <para>��� &quot;(LOC_ID INTEGER primary key, &quot; +</para>
        <para>��� &quot;LOC_NAME VARCHAR(30) not null, &quot; +</para>
        <para>��� &quot;CONTACT VARCHAR(50), &quot; +</para>
        <para>��� &quot;ADDRESS VARCHAR(40), &quot; +</para>
        <para>��� &quot;CITY VARCHAR(20), &quot; +</para>
        <para>��� &quot;STATE VARCHAR(4), &quot; +</para>
        <para>��� &quot;ZIP VARCHAR(5), &quot; +</para>
        <para>��� &quot;PHONE CHAR(12), &quot; +</para>
        <para>��� &quot;DIRECTIONS VARCHAR(4096))&quot;,</para>
        <para>��� &quot;create unique index &quot; +</para>
        <para>��� &quot;NAME_IDX on LOCATIONS(LOC_NAME)&quot;,</para>
        <para>� };</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The following program uses the <emphasis role="bold">CIDConnect </emphasis>�and <emphasis role="bold">CIDSQL</emphasis> information to load the JDBC driver, make a connection to the database, and then create the table structure diagrammed above. To connect with the database, you call the <emphasis role="bold">static</emphasis> method <emphasis role="bold">DriverManager.getConnection( )</emphasis>, passing it the database URL, the user name, and a password to get into the database. You get back a <emphasis role="bold">Connection</emphasis> object that you can use to query and manipulate the database. Once the connection is made you can simply push the SQL to the database, in this case by marching through the <emphasis role="bold">CIDSQL</emphasis> array. However, the first time this program is run, the �drop table� command will fail, causing an exception, which is caught, reported, and then ignored. The reason for the �drop table� command is to allow easy experimentation: you can modify the SQL that defines the tables and then rerun the program, causing the old tables to be replaced by the new.</para>
        <para>In this example, it makes sense to let the exceptions be thrown out to the console:</para>
        <para>//: c15:jdbc:CIDCreateTables.java</para>
        <para>// Creates database tables for the</para>
        <para>// community interests database.</para>
        <para>import java.sql.*;</para>
        <para> </para>
        <para>public class CIDCreateTables {</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws SQLException, ClassNotFoundException,</para>
        <para>� IllegalAccessException {</para>
        <para>��� // Load the driver (registers itself)</para>
        <para>��� Class.forName(CIDConnect.dbDriver);</para>
        <para>��� Connection c = DriverManager.getConnection(</para>
        <para>����� CIDConnect.dbURL, CIDConnect.user, </para>
        <para>����� CIDConnect.password);</para>
        <para>��� Statement s = c.createStatement();</para>
        <para>��� for(int i = 0; i &lt; CIDSQL.sql.length; i++) {</para>
        <para>����� System.out.println(CIDSQL.sql[i]);</para>
        <para>����� try {</para>
        <para>������� s.executeUpdate(CIDSQL.sql[i]);</para>
        <para>����� } catch(SQLException sqlEx) {</para>
        <para>������� System.err.println(</para>
        <para>��������� &quot;Probably a &apos;drop table&apos; failed&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� s.close();</para>
        <para>��� c.close();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Note that all changes in the database can be controlled by changing <emphasis role="bold">String</emphasis>s in the <emphasis role="bold">CIDSQL</emphasis> table, without modifying <emphasis role="bold">CIDCreateTables</emphasis>.</para>
        <para><emphasis role="bold">executeUpdate( )</emphasis> will usually return the number of rows that were affected by the SQL statement. <emphasis role="bold">executeUpdate( )</emphasis> is more commonly used to execute INSERT, UPDATE, or DELETE statements that modify one or more rows. For statements such as CREATE TABLE, DROP TABLE, and CREATE INDEX, <emphasis role="bold">executeUpdate( )</emphasis> always returns zero.</para>
        <para>To test the database, it is loaded with some sample data. This requires a series of INSERTs followed by a SELECT to produce result set. To make additions and changes to the test data easy, the test data is set up as a two-dimensional array of <emphasis role="bold">Object</emphasis>s, and the <emphasis role="bold">executeInsert( )</emphasis> method can then use the information in one row of the table to create the appropriate SQL command.</para>
        <para>//: c15:jdbc:LoadDB.java</para>
        <para>// Loads and tests the database.</para>
        <para>import java.sql.*;</para>
        <para> </para>
        <para>class TestSet {</para>
        <para>� Object[][] data = {</para>
        <para>��� { &quot;MEMBERS&quot;, new Integer(1),</para>
        <para>����� &quot;dbartlett&quot;, &quot;Bartlett&quot;, &quot;David&quot;,</para>
        <para>����� &quot;123 Mockingbird Lane&quot;,</para>
        <para>����� &quot;Gettysburg&quot;, &quot;PA&quot;, &quot;19312&quot;,</para>
        <para>����� &quot;123.456.7890&quot;,� &quot;bart@you.net&quot; },</para>
        <para>��� { &quot;MEMBERS&quot;, new Integer(2),</para>
        <para>����� &quot;beckel&quot;, &quot;Eckel&quot;, &quot;Bruce&quot;,</para>
        <para>����� &quot;123 Over Rainbow Lane&quot;,</para>
        <para>����� &quot;Crested Butte&quot;, &quot;CO&quot;, &quot;81224&quot;,</para>
        <para>����� &quot;123.456.7890&quot;, &quot;beckel@you.net&quot; },</para>
        <para>��� { &quot;MEMBERS&quot;, new Integer(3),</para>
        <para>����� &quot;rcastaneda&quot;, &quot;Castaneda&quot;, &quot;Robert&quot;,</para>
        <para>����� &quot;123 Downunder Lane&quot;,</para>
        <para>����� &quot;Sydney&quot;, &quot;NSW&quot;, &quot;12345&quot;,</para>
        <para>����� &quot;123.456.7890&quot;, &quot;rcastaneda@you.net&quot; },</para>
        <para>��� { &quot;LOCATIONS&quot;, new Integer(1),</para>
        <para>����� &quot;Center for Arts&quot;,</para>
        <para>����� &quot;Betty Wright&quot;, &quot;123 Elk Ave.&quot;,</para>
        <para>����� &quot;Crested Butte&quot;, &quot;CO&quot;, &quot;81224&quot;,</para>
        <para>����� &quot;123.456.7890&quot;,</para>
        <para>����� &quot;Go this way then that.&quot; },</para>
        <para>��� { &quot;LOCATIONS&quot;, new Integer(2),</para>
        <para>����� &quot;Witts End Conference Center&quot;,</para>
        <para>����� &quot;John Wittig&quot;, &quot;123 Music Drive&quot;,</para>
        <para>����� &quot;Zoneville&quot;, &quot;PA&quot;, &quot;19123&quot;,</para>
        <para>����� &quot;123.456.7890&quot;,</para>
        <para>����� &quot;Go that way then this.&quot; },</para>
        <para>��� { &quot;EVENTS&quot;, new Integer(1),</para>
        <para>����� &quot;Project Management Myths&quot;,</para>
        <para>����� &quot;Software Development&quot;,</para>
        <para>����� new Integer(1), new Float(2.50),</para>
        <para>����� &quot;2000-07-17 19:30:00&quot; },</para>
        <para>��� { &quot;EVENTS&quot;, new Integer(2),</para>
        <para>����� &quot;Life of the Crested Dog&quot;,</para>
        <para>����� &quot;Archeology&quot;,</para>
        <para>����� new Integer(2), new Float(0.00),</para>
        <para>����� &quot;2000-07-19 19:00:00&quot; },</para>
        <para>��� // Match some people with events</para>
        <para>��� {� &quot;EVTMEMS&quot;, </para>
        <para>����� new Integer(1),� // Dave is going to</para>
        <para>����� new Integer(1),� // the Software event.</para>
        <para>����� new Integer(0) },</para>
        <para>��� { &quot;EVTMEMS&quot;, </para>
        <para>����� new Integer(2),� // Bruce is going to</para>
        <para>����� new Integer(2),� // the Archeology event.</para>
        <para>����� new Integer(0) },</para>
        <para>��� { &quot;EVTMEMS&quot;, </para>
        <para>����� new Integer(3),� // Robert is going to</para>
        <para>����� new Integer(1),� // the Software event.</para>
        <para>����� new Integer(1) },</para>
        <para>��� { &quot;EVTMEMS&quot;, </para>
        <para>����� new Integer(3), // ... and </para>
        <para>����� new Integer(2), // the Archeology event.</para>
        <para>����� new Integer(1) },</para>
        <para>� };</para>
        <para>� // Use the default data set:</para>
        <para>� public TestSet() {}</para>
        <para>� // Use a different data set:</para>
        <para>� public TestSet(Object[][] dat) { data = dat; }</para>
        <para>}</para>
        <para> </para>
        <para>public class LoadDB {</para>
        <para>� Statement statement;</para>
        <para>� Connection connection;</para>
        <para>� TestSet tset;</para>
        <para>� public LoadDB(TestSet t) throws SQLException {</para>
        <para>��� tset = t;</para>
        <para>��� try {</para>
        <para>����� // Load the driver (registers itself)</para>
        <para>����� Class.forName(CIDConnect.dbDriver);</para>
        <para>��� } catch(java.lang.ClassNotFoundException e) {</para>
        <para>����� e.printStackTrace(System.err);</para>
        <para>��� }</para>
        <para>��� connection = DriverManager.getConnection(</para>
        <para>����� CIDConnect.dbURL, CIDConnect.user, </para>
        <para>����� CIDConnect.password);</para>
        <para>��� statement = connection.createStatement();</para>
        <para>� }</para>
        <para>� public void cleanup() throws SQLException {</para>
        <para>��� statement.close();</para>
        <para>��� connection.close();</para>
        <para>� }</para>
        <para>� public void executeInsert(Object[] data) {</para>
        <para>��� String sql = &quot;insert into &quot; </para>
        <para>����� + data[0] + &quot; values(&quot;;</para>
        <para>��� for(int i = 1; i &lt; data.length; i++) {</para>
        <para>����� if(data[i] instanceof String)</para>
        <para>������� sql += &quot;&apos;&quot; + data[i] + &quot;&apos;&quot;;</para>
        <para>����� else</para>
        <para>������� sql += data[i];</para>
        <para>����� if(i &lt; data.length - 1)</para>
        <para>������� sql += &quot;, &quot;;</para>
        <para>��� }</para>
        <para>��� sql += &apos;)&apos;;</para>
        <para>��� System.out.println(sql);</para>
        <para>��� try {</para>
        <para>����� statement.executeUpdate(sql);</para>
        <para>��� } catch(SQLException sqlEx) {</para>
        <para>����� System.err.println(&quot;Insert failed.&quot;);</para>
        <para>����� while (sqlEx != null) {</para>
        <para>������� System.err.println(sqlEx.toString());</para>
        <para>������� sqlEx = sqlEx.getNextException();</para>
        <para>����� }</para>
        <para>��� } </para>
        <para>� }</para>
        <para>� public void load() {</para>
        <para>��� for(int i = 0; i&lt; tset.data.length; i++)</para>
        <para>����� executeInsert(tset.data[i]);</para>
        <para>� }</para>
        <para>� // Throw exceptions out to console:</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws SQLException {</para>
        <para>��� LoadDB db = new LoadDB(new TestSet());</para>
        <para>��� db.load();</para>
        <para>��� try {</para>
        <para>����� // Get a ResultSet from the loaded database:</para>
        <para>����� ResultSet rs = db.statement.executeQuery(</para>
        <para>������� &quot;select &quot; +</para>
        <para>������� &quot;e.EVT_TITLE, m.MEM_LNAME, m.MEM_FNAME &quot;+</para>
        <para>������� &quot;from EVENTS e, MEMBERS m, EVTMEMS em &quot; +</para>
        <para>������� &quot;where em.EVT_ID = 2 &quot; +</para>
        <para>������� &quot;and e.EVT_ID = em.EVT_ID &quot; +</para>
        <para>������� &quot;and m.MEM_ID = em.MEM_ID&quot;);</para>
        <para>����� while (rs.next())</para>
        <para>������� System.out.println(</para>
        <para>��������� rs.getString(1) + &quot;� &quot; + </para>
        <para>��������� rs.getString(2) + &quot;, &quot; +</para>
        <para>��������� rs.getString(3));</para>
        <para>��� } finally {</para>
        <para>����� db.cleanup();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">TestSet</emphasis> class contains a default set of data that is produced if you use the default constructor; however, you can also create a <emphasis role="bold">TestSet</emphasis> object using an alternate data set with the second constructor. The set of data is held in a two-dimensional array of <emphasis role="bold">Object</emphasis> because it can be any type, including <emphasis role="bold">String</emphasis> or numerical types. The <emphasis role="bold">executeInsert( )</emphasis> method uses RTTI to distinguish between <emphasis role="bold">String</emphasis> data (which must be quoted) and non-<emphasis role="bold">String</emphasis> data as it builds the SQL command from the data. After printing this command to the console, <emphasis role="bold">executeUpdate( )</emphasis> is used to send it to the database.</para>
        <para>The constructor for <emphasis role="bold">LoadDB</emphasis> makes the connection, and <emphasis role="bold">load( )</emphasis> steps through the data and calls <emphasis role="bold">executeInsert( )</emphasis> for each record. <emphasis role="bold">cleanup( )</emphasis>� closes the statement and the connection; to guarantee that this is called, it is placed inside a finally clause.</para>
        <para>Once the database is loaded, an <emphasis role="bold">executeQuery( )</emphasis> statement produces a sample result set. Since the query combines several tables, it is an example of a join.</para>
        <para>There is more JDBC information available in the electronic documents that come as part of the Java distribution from Sun. In addition, you can find more in the book <emphasis role="italic">JDBC Database Access with Java </emphasis>(Hamilton, Cattel, and Fisher, Addison-Wesley, 1997). Other JDBC books appear regularly.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Servlets" xml:id="_Toc481064879"/>Servlets</title>
      <para><anchor xreflabel="" xml:id="_Toc463665192"/>Client access from the Internet or corporate intranets is a sure way to allow many users to access data and resources easily<anchor xreflabel="[74]" xml:id="_ftnref74"/>[74]. This type of access is based on clients using the World Wide Web standards of Hypertext Markup Language (HTML) and Hypertext Transfer Protocol (HTTP). The Servlet API set abstracts a common solution framework for responding to HTTP requests. </para>
      <para>Traditionally, the way to handle a problem such as allowing an Internet client to update a database is to create an HTML page with text fields and a �submit� button. The user types the appropriate information into the text fields and presses the �submit� button. The data is submitted along with a URL that tells the server what to do with the data by specifying the location of a Common Gateway Interface (CGI) program that the server runs, providing the program with the data as it is invoked. The CGI program is typically written in Perl, Python, C, C++, or any language that can read from standard input and write to standard output. That�s all that is provided by the Web server: the CGI program is invoked, and standard streams (or, optionally for input, an environment variable) are used for input and output. The CGI program is responsible for everything else. First it looks at the data and decides whether the format is correct. If not, the CGI program must produce HTML to describe the problem; this page is handed to the Web server (via standard output from the CGI program), which sends it back to the user. The user must usually back up a page and try again. If the data is correct, the CGI program processes the data in an appropriate way, perhaps adding it to a database. It must then produce an appropriate HTML page for the Web server to return to the user.</para>
      <para>It would be ideal to go to a completely Java-based solution to this problem�an applet on the client side to validate and send the data, and a servlet on the server side to receive and process the data. Unfortunately, although applets are a proven technology with plenty of support, they have been problematic to use on the Web because you cannot rely on a particular version of Java being available on a client�s Web browser; in fact, you can�t rely on a Web browser supporting Java at all! In an intranet, you can require that certain support be available, which allows a lot more flexibility in what you can do, but on the Web the safest approach is to handle all the processing on the server side and deliver plain HTML to the client. That way, no client will be denied the use of your site because they do not have the proper software installed.</para>
      <para>Because servlets provide an excellent solution for server-side programming support, they are one of the most popular reasons for moving to Java. Not only do they provide a framework that replaces CGI programming (and eliminates a number of thorny CGI problems), but all your code has the platform portability gained from using Java, and you have access to all the Java APIs (except, of course, the ones that produce GUIs, like Swing).</para>
      <section>
        <title><anchor xreflabel="The basic servlet" xml:id="_Toc481064880"/>The basic servlet</title>
        <para>The architecture of the servlet API is that of a classic service provider with a <emphasis role="bold">service( )</emphasis> method through which all client requests will be sent by the servlet container software, and life cycle methods <emphasis role="bold">init( ) </emphasis>and <emphasis role="bold">destroy( )</emphasis>, which are called only when the servlet is loaded and unloaded (this happens rarely).</para>
        <para>public interface Servlet {</para>
        <para>� public void init(ServletConfig config)</para>
        <para>��� throws ServletException;</para>
        <para>� public ServletConfig getServletConfig();</para>
        <para>� public void service(ServletRequest req,</para>
        <para>��� ServletResponse res) </para>
        <para>��� throws ServletException, IOException;</para>
        <para>� public String getServletInfo();</para>
        <para>� public void destroy();</para>
        <para>}</para>
        <para> </para>
        <para><emphasis role="bold">getServletConfig( )</emphasis>�s sole purpose is to return a <emphasis role="bold">ServletConfig</emphasis> object that contains initialization and startup parameters for this servlet. <emphasis role="bold">getServletInfo( )</emphasis> returns a string containing information about the servlet, such as author, version, and copyright.</para>
        <para>The <emphasis role="bold">GenericServlet</emphasis> class is a shell implementation of this interface and is typically not used. The <emphasis role="bold">HttpServlet</emphasis> class is an extension of <emphasis role="bold">GenericServlet</emphasis> and is designed specifically to handle the HTTP protocol�<emphasis role="bold"> HttpServlet</emphasis> is the one that you�ll use most of the time.</para>
        <para>The most convenient attribute of the servlet API is the auxiliary objects that come along with the HttpServlet class to support it. If you look at the <emphasis role="bold">service( ) </emphasis>method in the <emphasis role="bold">Servlet</emphasis> interface, you�ll see it has two parameters: <emphasis role="bold">ServletRequest</emphasis> and <emphasis role="bold">ServletResponse</emphasis>. With the <emphasis role="bold">HttpServlet</emphasis> class these two object are extended for HTTP: <emphasis role="bold">HttpServletRequest</emphasis> and <emphasis role="bold">HttpServletResponse</emphasis>. Here�s a simple example that shows the use of <emphasis role="bold">HttpServletResponse</emphasis>:</para>
        <para>//: c15:servlets:ServletsRule.java</para>
        <para>import javax.servlet.*;</para>
        <para>import javax.servlet.http.*;</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>public class ServletsRule extends HttpServlet {</para>
        <para>� int i = 0; // Servlet &quot;persistence&quot;</para>
        <para>� public void service(HttpServletRequest req, </para>
        <para>� HttpServletResponse res) throws IOException {</para>
        <para>��� res.setContentType(&quot;text/html&quot;);</para>
        <para>��� PrintWriter out = res.getWriter();</para>
        <para>��� out.print(&quot;&lt;HEAD&gt;&lt;TITLE&gt;&quot;);</para>
        <para>��� out.print(&quot;A server-side strategy&quot;);</para>
        <para>��� out.print(&quot;&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&quot;);</para>
        <para>��� out.print(&quot;&lt;h1&gt;Servlets Rule! &quot; + i++);</para>
        <para>��� out.print(&quot;&lt;/h1&gt;&lt;/BODY&gt;&quot;);� </para>
        <para>��� out.close();��� </para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">ServletsRule</emphasis> is about as simple as a servlet can get. The servlet is initialized only once by calling its <emphasis role="bold">init( ) </emphasis>method, on loading the servlet after the servlet container is first booted up. When a client makes a request to a URL that happens to represent a servlet, the servlet container intercepts this request and makes a call to the <emphasis role="bold">service( )</emphasis> method, after setting up the <emphasis role="bold">HttpServletRequest</emphasis> and <emphasis role="bold">HttpServletResponse</emphasis> objects. </para>
        <para>The main responsibility of the <emphasis role="bold">service( )</emphasis> method is to interact with the HTTP request that the client has sent, and to build an HTTP response based on the attributes contained within the request. <emphasis role="bold">ServletsRule</emphasis> only manipulates the response object without looking at what the client may have sent. </para>
        <para>After setting the content type of the response (which must always be done before the <emphasis role="bold">Writer </emphasis>or <emphasis role="bold">OutputStream </emphasis>is procured), the <emphasis role="bold">getWriter( )</emphasis> method of the response object produces a <emphasis role="bold">PrintWriter</emphasis> object, which is used for writing character-based response data (alternatively, <emphasis role="bold">getOutputStream( )</emphasis> produces an <emphasis role="bold">OutputStream</emphasis>, used for binary response, which is only utilized in more specialized solutions).</para>
        <para>The rest of the program simply sends HTML back to the client (it�s assumed you understand HTML, so that part is not explained) as a sequence of <emphasis role="bold">String</emphasis>s. However, notice the inclusion of the �hit counter� represented by the variable <emphasis role="bold">i</emphasis>. This is automatically converted to a <emphasis role="bold">String</emphasis> in the <emphasis role="bold">print( )</emphasis> statement.</para>
        <para>When you run the program, you�ll notice that the value of <emphasis role="bold">i</emphasis> is retained between requests to the servlet. This is an essential property of servlets: since only one servlet of a particular class is loaded into the container, and it is never unloaded (unless the servlet container is terminated, which is something that only normally happens if you reboot the server computer), any fields of that servlet class effectively become persistent objects! This means that you can effortlessly maintain values between servlet requests, whereas with CGI you had to write values to disk in order to preserve them, which required a fair amount of fooling around to get it right, and resulted in a non-cross-platform solution.</para>
        <para>Of course, sometimes the Web server, and thus the servlet container, must be rebooted as part of maintenance or during a power failure. To avoid losing any persistent information, the servlet�s <emphasis role="bold">init( )</emphasis> and <emphasis role="bold">destroy( )</emphasis> methods are automatically called whenever the servlet is loaded or unloaded, giving you the opportunity to save data during shutdown, and restore it after rebooting. The servlet container calls the <emphasis role="bold">destroy( )</emphasis> method as it is terminating itself, so you always get an opportunity to save valuable data as long as the server machine is configured in an intelligent way.</para>
        <para>There�s one other issue when using <emphasis role="bold">HttpServlet</emphasis>. This class provides <emphasis role="bold">doGet( )</emphasis> and <emphasis role="bold">doPost( )</emphasis> methods that differentiate between a CGI �GET� submission from the client, and a CGI �POST.� GET and POST vary only in the details of the way that they submit the data, which is something that I personally would prefer to ignore. However, most published information that I�ve seen seems to favor the creation of separate <emphasis role="bold">doGet( )</emphasis> and <emphasis role="bold">doPost( )</emphasis> methods instead of a single generic <emphasis role="bold">service( )</emphasis> method, which handles both cases. This favoritism seems quite common, but I�ve never seen it explained in a fashion that leads me to believe that it�s anything more than inertia from CGI programmers who are used to paying attention to whether a GET or POST is being used. So in the spirit of �doing the simplest thing that could possibly work,�<anchor xreflabel="[75]" xml:id="_ftnref75"/>[75] I will just use the <emphasis role="bold">service( )</emphasis> method in these examples, and let it care about GETs vs. POSTs. However, keep in mind that I might have missed something and so there may in fact be a good reason to use <emphasis role="bold">doGet( )</emphasis> and <emphasis role="bold">doPost( )</emphasis> instead.</para>
        <para>Whenever a form is submitted to a servlet, the <emphasis role="bold">HttpServletRequest</emphasis> comes preloaded with all the form data, stored as key-value pairs. If you know the names of the fields, you can just use them directly with the <emphasis role="bold">getParameter( )</emphasis> method to look up the values. You can also get an <emphasis role="bold">Enumeration</emphasis> (the old form of the <emphasis role="bold">Iterator</emphasis>) to the field names, as is shown in the following example. This example also demonstrates how a single servlet can be used to produce the page that contains the form, and to respond to the page (a better solution will be seen later, with JSPs). If the <emphasis role="bold">Enumeration</emphasis> is empty, there are no fields; this means no form was submitted. In this case, the form is produced, and the submit button will re-call the same servlet. If fields do exist, however, they are displayed.</para>
        <para>//: c15:servlets:EchoForm.java</para>
        <para>// Dumps the name-value pairs of any HTML form</para>
        <para>import javax.servlet.*;</para>
        <para>import javax.servlet.http.*;</para>
        <para>import java.io.*;</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>public class EchoForm extends HttpServlet {</para>
        <para>� public void service(HttpServletRequest req, </para>
        <para>��� HttpServletResponse res) throws IOException {</para>
        <para>��� res.setContentType(&quot;text/html&quot;);</para>
        <para>��� PrintWriter out = res.getWriter();</para>
        <para>��� Enumeration flds = req.getParameterNames();</para>
        <para>��� if(!flds.hasMoreElements()) {</para>
        <para>����� // No form submitted -- create one:</para>
        <para>����� out.print(&quot;&lt;html&gt;&quot;);</para>
        <para>����� out.print(&quot;&lt;form method=\&quot;POST\&quot;&quot; + </para>
        <para>������� &quot; action=\&quot;EchoForm\&quot;&gt;&quot;);</para>
        <para>����� for(int i = 0; i &lt; 10; i++)</para>
        <para>������� out.print(&quot;&lt;b&gt;Field&quot; + i + &quot;&lt;/b&gt; &quot; +</para>
        <para>��������� &quot;&lt;input type=\&quot;text\&quot;&quot;+</para>
        <para>��������� &quot; size=\&quot;20\&quot; name=\&quot;Field&quot; + i + </para>
        <para>���� �����&quot;\&quot; value=\&quot;Value&quot; + i + &quot;\&quot;&gt;&lt;br&gt;&quot;);</para>
        <para>����� out.print(&quot;&lt;INPUT TYPE=submit name=submit&quot;+</para>
        <para>����� &quot; Value=\&quot;Submit\&quot;&gt;&lt;/form&gt;&lt;/html&gt;&quot;);</para>
        <para>��� } else {</para>
        <para>����� out.print(&quot;&lt;h1&gt;Your form contained:&lt;/h1&gt;&quot;);</para>
        <para>����� while(flds.hasMoreElements()) {</para>
        <para>������� String field= (String)flds.nextElement();</para>
        <para>������� String value= req.getParameter(field);</para>
        <para>������� out.print(field + &quot; = &quot; + value+ &quot;&lt;br&gt;&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� out.close();��� </para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>One drawback you�ll notice here is that Java does not seem to be designed with string processing in mind�the formatting of the return page is painful because of line breaks, escaping quote marks, and the �+� signs necessary to build <emphasis role="bold">String</emphasis> objects. With a larger HTML page it becomes unreasonable to code it directly into Java. One solution is to keep the page as a separate text file, then open it and hand it to the Web server. If you have to perform any kind of substitution to the contents of the page, it�s not much better since Java has treated string processing so poorly. In these cases you�re probably better off using a more appropriate solution (Python would be my choice; there�s a version that embeds itself in Java called JPython) to generate the response page.</para>
      </section>
      <section>
        <title><anchor xreflabel="Servlets and multithreading" xml:id="_Toc481064881"/>Servlets and multithreading</title>
        <para>The servlet container has a pool of threads that it will dispatch to handle client requests. It is quite likely that two clients arriving at the same time could be processing through your <emphasis role="bold">service( )</emphasis> at the same time. Therefore the <emphasis role="bold">service( )</emphasis> method must written in a thread-safe manner. Any access to common resources (files, databases) will need to be guarded by using the <emphasis role="bold">synchronized</emphasis> keyword.</para>
        <para>The following simple example puts a <emphasis role="bold">synchronized </emphasis>clause around the thread�s <emphasis role="bold">sleep( )</emphasis> method. This will block all other threads until the allotted time (five seconds) is all used up. When testing this you should start several browser instances and hit this servlet as quickly as possible in each one�you�ll see that each one has to wait until its turn comes up. </para>
        <para>//: c15:servlets:ThreadServlet.java</para>
        <para>import javax.servlet.*;</para>
        <para>import javax.servlet.http.*;</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>public class ThreadServlet extends HttpServlet {</para>
        <para>� int i;</para>
        <para>� public void service(HttpServletRequest req, </para>
        <para>��� HttpServletResponse res) throws IOException {</para>
        <para>��� res.setContentType(&quot;text/html&quot;);</para>
        <para>��� PrintWriter out = res.getWriter();</para>
        <para>��� synchronized(this) {</para>
        <para>����� try {</para>
        <para>������� Thread.currentThread().sleep(5000);</para>
        <para>����� } catch(InterruptedException e) {</para>
        <para>������� System.err.println(&quot;Interrupted&quot;);</para>
        <para>����� }</para>
        <para>��� }</para>
        <para>��� out.print(&quot;&lt;h1&gt;Finished &quot; + i++ + &quot;&lt;/h1&gt;&quot;);</para>
        <para>��� out.close();��� </para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>It is also possible to synchronize the entire servlet by putting the <emphasis role="bold">synchronized</emphasis> keyword in front of the <emphasis role="bold">service( )</emphasis> method. In fact, the only reason to use the <emphasis role="bold">synchronized</emphasis> clause instead is if the critical section is in an execution path that might not get executed. In that case, you might as well avoid the overhead of synchronizing every time by using a <emphasis role="bold">synchronized</emphasis> clause. Otherwise, all the threads will have to wait anyway so you might as well <emphasis role="bold">synchronize</emphasis> the whole method.</para>
      </section>
      <section>
        <title><anchor xreflabel="Handling sessions with servlets" xml:id="_Toc481064882"/>Handling sessions with servlets</title>
        <para>HTTP is a �sessionless� protocol, so you cannot tell from one server hit to another if you�ve got the same person repeatedly querying your site, or if it is a completely different person.� A great deal of effort has gone into mechanisms that will allow Web developers to track sessions. Companies could not do e-commerce without keeping track of a client and the items they have put into their shopping cart, for example.</para>
        <para>There are several methods of session tracking, but the most common method is with persistent �cookies,� which are an integral part of the Internet standards. The HTTP Working Group of the Internet Engineering Task Force has written cookies into the official standard in RFC 2109 (<emphasis role="italic">ds.internic.net/rfc/rfc2109.txt</emphasis> or check <emphasis role="italic">www.cookiecentral.com</emphasis>).</para>
        <para>A cookie is nothing more than a small piece of information sent by a Web server to a browser. The browser stores the cookie on the local disk, and whenever another call is made to the URL that the cookie is associated with, the cookie is quietly sent along with the call, thus providing the desired information back to that server (generally, providing some way that the server can be told that it�s you calling). Clients can, however, turn off the browser�s ability to accept cookies. If your site must track a client who has turned off cookies, then another method of session tracking (URL rewriting or hidden form fields) must be incorporated by hand, since the session tracking capabilities built into the servlet API are designed around cookies.</para>
        <section>
          <title>The <emphasis role="bold">Cookie</emphasis> class</title>
          <para>The servlet API (version 2.0 and up) provides the <emphasis role="bold">Cookie</emphasis> class. This class incorporates all the HTTP header details and allows the setting of various cookie attributes. Using the cookie is simply a matter of adding it to the response object. The constructor takes a cookie name as the first argument and a value as the second. Cookies are added to the response object before you send any content.</para>
          <para>Cookie oreo = new Cookie(&quot;TIJava&quot;, &quot;2000&quot;);</para>
          <para>res.addCookie(cookie);</para>
          <para> </para>
          <para>Cookies are recovered by calling the <emphasis role="bold">getCookies( )</emphasis> method of the <emphasis role="bold">HttpServletRequest</emphasis> object, which returns an array of cookie objects.</para>
          <para>Cookie[] cookies = req.getCookies();</para>
          <para> </para>
          <para>You can then call <emphasis role="bold">getValue( )</emphasis> for each cookie, to produce a <emphasis role="bold">String</emphasis> containing the cookie contents. In the above example, <emphasis role="bold">getValue(&quot;TIJava&quot;) </emphasis>will produce a <emphasis role="bold">String</emphasis> containing �2000.�</para>
        </section>
        <section>
          <title>The <emphasis role="bold">Session</emphasis> class</title>
          <para>A session is one or more page requests by a client to a Web site during a defined period of time. If you buy groceries online, for example, you want a session to be confined to the period from when you first add an item to �my shopping cart� to the point where you check out. Each item you add to the shopping cart will result in a new HTTP connection, which has no knowledge of previous connections or items in the shopping cart. To compensate for this lack of information, the mechanics supplied by the cookie specification allow your servlet to perform session tracking. </para>
          <para>A servlet <emphasis role="bold">Session</emphasis> object lives on the server side of the communication channel; its goal is to capture useful data about this client as the client moves through and interacts with your Web site. This data may be pertinent for the present session, such as items in the shopping cart, or it may be data such as authentication information that was entered when the client first entered your Web site, and which should not have to be reentered during a particular set of transactions.</para>
          <para>The <emphasis role="bold">Session</emphasis> class of the servlet API uses the <emphasis role="bold">Cookie</emphasis> class to do its work. However, all the <emphasis role="bold">Session</emphasis> object needs is some kind of unique identifier stored on the client and passed to the server. Web sites may also use the other types of session tracking but these mechanisms will be more difficult to implement as they are not encapsulated into the servlet API (that is, you must write them by hand to deal with the situation when the client has disabled cookies).</para>
          <para>Here�s an example that� implements session tracking with the servlet API:</para>
          <para>//: c15:servlets:SessionPeek.java</para>
          <para>// Using the HttpSession class.</para>
          <para>import java.io.*;</para>
          <para>import java.util.*;</para>
          <para>import javax.servlet.*;</para>
          <para>import javax.servlet.http.*;</para>
          <para> </para>
          <para>public class SessionPeek extends HttpServlet { </para>
          <para>� public void service(HttpServletRequest req, </para>
          <para>� HttpServletResponse res)</para>
          <para>� throws ServletException, IOException {</para>
          <para>��� // Retrieve Session Object before any</para>
          <para>��� // output is sent to the client.</para>
          <para>��� HttpSession session = req.getSession();</para>
          <para>��� res.setContentType(&quot;text/html&quot;);</para>
          <para>��� PrintWriter out = res.getWriter();</para>
          <para>��� out.println(&quot;&lt;HEAD&gt;&lt;TITLE&gt; SessionPeek &quot;);</para>
          <para>��� out.println(&quot; &lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&quot;);</para>
          <para>��� out.println(&quot;&lt;h1&gt; SessionPeek &lt;/h1&gt;&quot;);</para>
          <para>��� // A simple hit counter for this session.</para>
          <para>��� Integer ival = (Integer) </para>
          <para>����� session.getAttribute(&quot;sesspeek.cntr&quot;);</para>
          <para>��� if(ival==null) </para>
          <para>����� ival = new Integer(1);</para>
          <para>��� else </para>
          <para>����� ival = new Integer(ival.intValue() + 1);</para>
          <para>��� session.setAttribute(&quot;sesspeek.cntr&quot;, ival);</para>
          <para>��� out.println(&quot;You have hit this page &lt;b&gt;&quot;</para>
          <para>����� + ival + &quot;&lt;/b&gt; times.&lt;p&gt;&quot;);</para>
          <para>��� out.println(&quot;&lt;h2&gt;&quot;);</para>
          <para>��� out.println(&quot;Saved Session Data &lt;/h2&gt;&quot;);</para>
          <para>��� // Loop through all data in the session:</para>
          <para>��� Enumeration sesNames = </para>
          <para>����� session.getAttributeNames();</para>
          <para>��� while(sesNames.hasMoreElements()) {</para>
          <para>����� String name = </para>
          <para>������� sesNames.nextElement().toString();</para>
          <para>����� Object value = session.getAttribute(name);</para>
          <para>����� out.println(name + &quot; = &quot; + value + &quot;&lt;br&gt;&quot;);</para>
          <para>��� }</para>
          <para>��� out.println(&quot;&lt;h3&gt; Session Statistics &lt;/h3&gt;&quot;);</para>
          <para>��� out.println(&quot;Session ID: &quot; </para>
          <para>����� + session.getId() + &quot;&lt;br&gt;&quot;);</para>
          <para>��� out.println(&quot;New Session: &quot; + session.isNew()</para>
          <para>����� + &quot;&lt;br&gt;&quot;);</para>
          <para>��� out.println(&quot;Creation Time: &quot;</para>
          <para>����� + session.getCreationTime());</para>
          <para>��� out.println(&quot;&lt;I&gt;(&quot; + </para>
          <para>����� new Date(session.getCreationTime())</para>
          <para>� ����+ &quot;)&lt;/I&gt;&lt;br&gt;&quot;);</para>
          <para>��� out.println(&quot;Last Accessed Time: &quot; +</para>
          <para>����� session.getLastAccessedTime());</para>
          <para>��� out.println(&quot;&lt;I&gt;(&quot; +</para>
          <para>����� new Date(session.getLastAccessedTime())</para>
          <para>����� + &quot;)&lt;/I&gt;&lt;br&gt;&quot;);</para>
          <para>��� out.println(&quot;Session Inactive Interval: &quot;</para>
          <para>����� + session.getMaxInactiveInterval());</para>
          <para>��� out.println(&quot;Session ID in Request: &quot;</para>
          <para>����� + req.getRequestedSessionId() + &quot;&lt;br&gt;&quot;);</para>
          <para>��� out.println(&quot;Is session id from Cookie: &quot;</para>
          <para>����� + req.isRequestedSessionIdFromCookie()</para>
          <para>����� + &quot;&lt;br&gt;&quot;);</para>
          <para>��� out.println(&quot;Is session id from URL: &quot;</para>
          <para>����� + req.isRequestedSessionIdFromURL()</para>
          <para>����� + &quot;&lt;br&gt;&quot;);</para>
          <para>��� out.println(&quot;Is session id valid: &quot;</para>
          <para>����� + req.isRequestedSessionIdValid()</para>
          <para>����� + &quot;&lt;br&gt;&quot;);</para>
          <para>��� out.println(&quot;&lt;/BODY&gt;&quot;);</para>
          <para>��� out.close();</para>
          <para>� }</para>
          <para>� public String getServletInfo() {</para>
          <para>��� return &quot;A session tracking servlet&quot;;</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>Inside the <emphasis role="bold">service( )</emphasis> method, <emphasis role="bold">getSession( )</emphasis> is called for the request object, which returns the <emphasis role="bold">Session</emphasis> object associated with this request. The <emphasis role="bold">Session</emphasis> object does not travel across the network, but instead it lives on the server and is associated with a client and its requests.</para>
          <para><emphasis role="bold">getSession( )</emphasis> comes in two versions: no parameter, as used here, and <emphasis role="bold">getSession(boolean)</emphasis>. <emphasis role="bold">getSession(true)</emphasis> is equivalent to <emphasis role="bold">getSession( )</emphasis>. The only reason for the <emphasis role="bold">boolean</emphasis> is to state whether you want the session object created if it is not found. <emphasis role="bold">getSession(true)</emphasis> is the most likely call, hence <emphasis role="bold">getSession( )</emphasis>.</para>
          <para>The <emphasis role="bold">Session</emphasis> object, if it is not new, will give us details about the client from previous visits. If the <emphasis role="bold">Session</emphasis> object is new then the program will start to gather information about this client�s activities on this visit. Capturing this client information is done through the <emphasis role="bold">setAttribute( )</emphasis> and <emphasis role="bold">getAttribute( )</emphasis> methods of the session object.</para>
          <para>java.lang.Object getAttribute(java.lang.String)</para>
          <para>void setAttribute(java.lang.String name,</para>
          <para>����������������� java.lang.Object value)</para>
          <para> </para>
          <para>The <emphasis role="bold">Session</emphasis> object uses a simple name-value pairing for loading information. The name is a <emphasis role="bold">String</emphasis>, and the value can be any object derived from <emphasis role="bold">java.lang.Object</emphasis>. <emphasis role="bold">SessionPeek</emphasis> keeps track of how many times the client has been back during this session. This is done with an <emphasis role="bold">Integer</emphasis> object named <emphasis role="bold">sesspeek.cntr</emphasis>. If the name is not found an <emphasis role="bold">Integer</emphasis> is created with value of one, otherwise an <emphasis role="bold">Integer</emphasis> is created with the incremented value of the previously held <emphasis role="bold">Integer</emphasis>. The new <emphasis role="bold">Integer</emphasis> is placed into the <emphasis role="bold">Session</emphasis> object. If you use same key in a <emphasis role="bold">setAttribute( )</emphasis> call, then the new object overwrites the old one. The incremented counter is used to display the number of times that the client has visited during this session. </para>
          <para><emphasis role="bold">getAttributeNames( ) </emphasis>is related to <emphasis role="bold">getAttribute( )</emphasis> and <emphasis role="bold">setAttribute( )</emphasis>; it returns an enumeration of the names of the objects that are bound to the <emphasis role="bold">Session</emphasis> object. A <emphasis role="bold">while</emphasis> loop in <emphasis role="bold">SessionPeek</emphasis> shows this method in action.</para>
          <para>You may wonder how long a <emphasis role="bold">Session</emphasis> object hangs around. The answer depends on the servlet container you are using; they usually default to 30 minutes (1800 seconds), which is what you should see from the <emphasis role="bold">ServletPeek</emphasis> call to <emphasis role="bold">getMaxInactiveInterval( )</emphasis>. Tests seem to produce mixed results between servlet containers. Sometimes the <emphasis role="bold">Session</emphasis> object can hang around overnight, but I have never seen a case where the <emphasis role="bold">Session</emphasis> object disappears in less than the time specified by the inactive interval. You can try this by setting the inactive interval with <emphasis role="bold">setMaxInactiveInterval( )</emphasis> to 5 seconds and see if your <emphasis role="bold">Session</emphasis> object hangs around or if it is cleaned up at the appropriate time. This may be an attribute you will want to investigate while choosing a servlet container.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Running the servlet examples" xml:id="_Toc481064883"/>Running the servlet examples</title>
        <para>If you are not already working with an application server that handles Sun�s servlet and JSP technologies for you, you may download the Tomcat implementation of Java servlets and JSPs, which is a free, open-source implementation of servlets, and is the official reference implementation sanctioned by Sun. It can be found at <emphasis role="italic">jakarta.apache.org</emphasis>.</para>
        <para>Follow the instructions for installing the Tomcat implementation, then edit the <emphasis role="bold">server.xml </emphasis>file to point to the location in your directory tree where your servlets will be placed. Once you start up the Tomcat program you can test your servlet programs.</para>
        <para>This has only been a brief introduction to servlets; there are entire books on the subject. However, this introduction should give you enough ideas to get you started. In addition, many of the ideas in the next section are backward compatible with servlets.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064884"/><anchor xreflabel="Java
Server Pages" xml:id="_Toc463665186"/>Java Server Pages</title>
      <para>Java Server Pages (JSP) is a standard Java extension that is defined on top of the servlet Extensions. The goal of JSPs is the simplified creation and management of dynamic Web pages.</para>
      <para>The previously mentioned, freely available Tomcat reference implementation from <emphasis role="italic">jakarta.apache.org</emphasis> automatically supports JSPs.</para>
      <para>JSPs allow you to combine the HTML of a Web page with pieces of Java code in the same document. The Java code is surrounded by special tags that tell the JSP container that it should use the code to generate a servlet, or part of one. The benefit of JSPs is that you can maintain a single document that represents both the page and the Java code that enables it. The downside is that the maintainer of the JSP page must be skilled in both HTML and Java (however, GUI builder environments for JSPs should be forthcoming).</para>
      <para>The first time a JSP is loaded by the JSP container (which is typically associated with, or even part of, a Web server), the servlet code necessary to fulfill the JSP tags is automatically generated, compiled, and loaded into the servlet container. The static portions of the HTML page are produced by sending static <emphasis role="bold">String </emphasis>objects to <emphasis role="bold">write( )</emphasis>. The dynamic portions are included directly into the servlet.</para>
      <para>From then on, as long as the JSP source for the page is not modified, it behaves as if it were a static HTML page with associated servlets (all the HTML code is actually generated by the servlet, however). If you modify the source code for the JSP, it is automatically recompiled and reloaded the next time that page is requested. Of course, because of all this dynamism you�ll see a slow response for the first-time access to a JSP. However, since a JSP is usually used much more than it is changed, you will normally not be affected by this delay.</para>
      <para>The structure of a JSP page is a cross between a servlet and an HTML page. The JSP tags begin and end with angle brackets, just like HTML tags, but the tags also include percent signs, so all JSP tags are denoted by</para>
      <para>&lt;% JSP code here %&gt;</para>
      <para> </para>
      <para>The leading percent sign may be followed by other characters that determine the precise type of JSP code in the tag.</para>
      <para>Here�s an extremely simple JSP example that uses a standard Java library call to get the current time in milliseconds, which is then divided by 1000 to produce the time in seconds. Since a <emphasis role="italic">JSP expression</emphasis> (the <emphasis role="bold">&lt;%=</emphasis> ) is used, the result of the calculation is coerced into a <emphasis role="bold">String</emphasis> and placed on the generated Web page:</para>
      <para>//:! c15:jsp:ShowSeconds.jsp</para>
      <para>&lt;html&gt;&lt;body&gt;</para>
      <para>&lt;H1&gt;The time in seconds is: </para>
      <para>&lt;%= System.currentTimeMillis()/1000 %&gt;&lt;/H1&gt;</para>
      <para>&lt;/body&gt;&lt;/html&gt;</para>
      <para>///:~</para>
      <para> </para>
      <para>In the JSP examples in this book, the first and last lines are not included in the actual code file that is extracted and placed in the book�s source-code tree.</para>
      <para>When the client creates a request for the JSP page, the Web server must have been configured to relay the request to the JSP container, which then invokes the page. As mentioned above, the first time the page is invoked, the components specified by the page are generated and compiled by the JSP container as one or more servlets. In the above example, the servlet will contain code to configure the <emphasis role="bold">HttpServletResponse</emphasis> object, produce a <emphasis role="bold">PrintWriter</emphasis> object (which is always named <emphasis role="bold">out</emphasis>), and then turn the time calculation into a <emphasis role="bold">String</emphasis> which is sent to <emphasis role="bold">out</emphasis>. As you can see, all this is accomplished with a very succinct statement, but the average HTML programmer/Web designer will not have the skills to write such code.</para>
      <section>
        <title><anchor xreflabel="Implicit objects" xml:id="_Toc481064885"/>Implicit objects</title>
        <para>Servlets include classes that provide convenient utilities, such as <emphasis role="bold">HttpServletRequest</emphasis>, <emphasis role="bold">HttpServletResponse</emphasis>, <emphasis role="bold">Session</emphasis>, etc. Objects of these classes are built into the JSP specification and automatically available for use in your JSP without writing any extra lines of code. The implicit objects in a JSP are detailed in the table below. </para>
        <informaltable frame="all">
          <tgroup cols="4">
            <colspec colname="c1" colwidth="10*"/>
            <colspec colname="c2" colwidth="16*"/>
            <colspec colname="c3" colwidth="15*"/>
            <colspec colname="c4" colwidth="6*"/>
            <tbody>
              <row>
                <entry valign="top"><para> Implicit variable</para></entry>
                <entry valign="top"><para> Of Type (javax.servlet)</para></entry>
                <entry valign="top"><para> Description</para></entry>
                <entry valign="top"><para> Scope</para></entry>
              </row>
              <row>
                <entry valign="top"><para> request</para></entry>
                <entry valign="top"><para> protocol dependent subtype of� HttpServletRequest</para></entry>
                <entry valign="top"><para> The request that triggers the service invocation.</para></entry>
                <entry valign="top"><para> request</para></entry>
              </row>
              <row>
                <entry valign="top"><para> response</para></entry>
                <entry valign="top"><para> protocol dependent subtype of HttpServletResponse</para></entry>
                <entry valign="top"><para> The response to the request.</para></entry>
                <entry valign="top"><para> page</para></entry>
              </row>
              <row>
                <entry valign="top"><para> pageContext</para></entry>
                <entry valign="top"><para> jsp.PageContext</para></entry>
                <entry valign="top"><para> The page context encapsulates implementation-dependent features and provides convenience methods and namespace access for this JSP.</para></entry>
                <entry valign="top"><para> page</para></entry>
              </row>
              <row>
                <entry valign="top"><para> session</para></entry>
                <entry valign="top"><para> Protocol dependent subtype of http.HttpSession</para></entry>
                <entry valign="top"><para> The session object created for the requesting client. See servlet Session object.</para></entry>
                <entry valign="top"><para> session</para></entry>
              </row>
              <row>
                <entry valign="top"><para> application</para></entry>
                <entry valign="top"><para> ServletContext</para></entry>
                <entry valign="top"><para> The servlet context obtained from the servlet configuration object (e.g., getServletConfig(),getContext( ).</para></entry>
                <entry valign="top"><para> app</para></entry>
              </row>
              <row>
                <entry valign="top"><para> out</para></entry>
                <entry valign="top"><para> jsp.JspWriter</para></entry>
                <entry valign="top"><para> The object that writes into the output stream.</para></entry>
                <entry valign="top"><para> page</para></entry>
              </row>
              <row>
                <entry valign="top"><para> config</para></entry>
                <entry valign="top"><para> ServletConfig</para></entry>
                <entry valign="top"><para> The ServletConfig for this JSP.</para></entry>
                <entry valign="top"><para> page</para></entry>
              </row>
              <row>
                <entry valign="top"><para> page</para></entry>
                <entry valign="top"><para> java.lang.Object</para></entry>
                <entry valign="top"><para> The instance of this page�s implementation class processing the current request.</para></entry>
                <entry valign="top"><para> page</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>The scope of each object can vary significantly. For example, the <emphasis role="bold">session</emphasis> object has a scope which exceeds that of a page, as it many span several client requests and pages. The <emphasis role="bold">application</emphasis> object can provide services to a group of JSP pages that together represent a Web application.</para>
      </section>
      <section>
        <title><anchor xreflabel="JSP directives" xml:id="_Toc481064886"/>JSP directives</title>
        <para>Directives are messages to the JSP container and are denoted by the �<emphasis role="bold">@</emphasis>�:</para>
        <para>&lt;%@ directive {attr=&quot;value&quot;}* %&gt;</para>
        <para> </para>
        <para>Directives do not send anything to the <emphasis role="bold">out</emphasis> stream, but they are important in setting up your JSP page�s attributes and dependencies with the JSP container. For example, the line:</para>
        <para>&lt;%@ page language=&quot;java&quot; %&gt;</para>
        <para> </para>
        <para>says that the scripting language being used within the JSP page is Java. In fact, the JSP specification <emphasis role="italic">only</emphasis> describes the semantics of scripts for the language attribute equal to �Java.� The intent of this directive is to build flexibility into the JSP technology. In the future, if you were to choose another language, say Python (a good scripting choice), then that language would have to support the Java Run-time Environment by exposing the Java technology object model to the scripting environment, especially the implicit variables defined above, JavaBeans properties, and public methods.</para>
        <para>The most important directive is the page directive. It defines a number of page dependent attributes and communicates these attributes to the JSP container. These attributes include: <emphasis role="bold">language</emphasis>, <emphasis role="bold">extends</emphasis>, <emphasis role="bold">import</emphasis>, <emphasis role="bold">session</emphasis>, <emphasis role="bold">buffer</emphasis>, <emphasis role="bold">autoFlush</emphasis>, <emphasis role="bold">isThreadSafe</emphasis>, <emphasis role="bold">info</emphasis> and <emphasis role="bold">errorPage</emphasis>. For example:</para>
        <para>&lt;%@ page session=�true� import=�java.util.*� %&gt;</para>
        <para> </para>
        <para>This line first indicates that the page requires participation in an HTTP session.� Since we have not set the language directive the JSP container defaults to using Java and the implicit script language variable named <emphasis role="bold">session</emphasis> is of type <emphasis role="bold">javax.servlet.http.HttpSession</emphasis>. If the directive had been false then the implicit variable <emphasis role="bold">session</emphasis> would be unavailable. If the <emphasis role="bold">session</emphasis> variable is not specified, then it defaults to �true.�</para>
        <para>The <emphasis role="bold">import</emphasis> attribute describes the types that are available to the scripting environment. This attribute is used just as it would be in the Java programming language, i.e., a comma-separated list of ordinary <emphasis role="bold">import</emphasis> expressions. This list is imported by the translated JSP page implementation and is available to the scripting environment. Again, this is currently only defined when the value of the language directive is �java.�</para>
      </section>
      <section>
        <title><anchor xreflabel="JSP scripting elements" xml:id="_Toc481064887"/>JSP scripting elements</title>
        <para>Once the directives have been used to set up the scripting environment you can utilize the scripting language elements. JSP 1.1 has three scripting language elements�<emphasis role="italic">declarations</emphasis>, <emphasis role="italic">scriptlets</emphasis>, and <emphasis role="italic">expressions</emphasis>. A declaration will declare elements, a scriptlet is a statement fragment, and an expression is a complete language expression. In JSP each scripting element begins with a �<emphasis role="bold">&lt;%</emphasis>�. The syntax for each is:</para>
        <para>&lt;%! declaration %&gt;</para>
        <para>&lt;%� scriptlet�� %&gt;</para>
        <para>&lt;%= expression� %&gt;</para>
        <para> </para>
        <para>White space is optional after �&lt;%!�, �&lt;%�, �&lt;%=�, and before �%&gt;.�</para>
        <para>All these tags are based upon XML; you could even say that a JSP page can be mapped to a XML document. The XML equivalent syntax for the scripting elements above would be:</para>
        <para>&lt;jsp:declaration&gt; declaration &lt;/jsp:declaration&gt;</para>
        <para>&lt;jsp:scriptlet&gt;�� scriptlet�� &lt;/jsp:scriptlet&gt;</para>
        <para>&lt;jsp:expression&gt;� expression� &lt;/jsp:expression&gt;</para>
        <para> </para>
        <para>In addition, there are two types of comments:</para>
        <para>&lt;%-- jsp comment --%&gt;</para>
        <para>&lt;!-- html comment --&gt;</para>
        <para> </para>
        <para>The first form allows you to add comments to JSP source pages that will not appear in any form in the HTML that is sent to the client. Of course, the second form of comment is not specific to JSPs�it�s just an ordinary HTML comment. What�s interesting is that you can insert JSP code inside an HTML comment and the comment will be produced in the resulting page, including the result from the JSP code.</para>
        <para>Declarations are used to declare variables and methods in the scripting language (currently Java only) used in a JSP page. The declaration must be a complete Java statement and cannot produce any output in the <emphasis role="bold">out</emphasis> stream. In the <emphasis role="bold">Hello.jsp </emphasis>example below, the declarations for the variables <emphasis role="bold">loadTime</emphasis>, <emphasis role="bold">loadDate</emphasis> and <emphasis role="bold">hitCount</emphasis> are all complete Java statements that declare and initialize new variables.</para>
        <para>//:! c15:jsp:Hello.jsp</para>
        <para>&lt;%-- This JSP comment will not appear in the</para>
        <para>generated html --%&gt;</para>
        <para>&lt;%-- This is a JSP directive: --%&gt;</para>
        <para>&lt;%@ page import=&quot;java.util.*&quot; %&gt;</para>
        <para>&lt;%-- These are declarations: --%&gt;</para>
        <para>&lt;%!</para>
        <para>��� long loadTime= System.currentTimeMillis();</para>
        <para>��� Date loadDate = new Date();</para>
        <para>��� int hitCount = 0;</para>
        <para>%&gt;</para>
        <para>&lt;html&gt;&lt;body&gt;</para>
        <para>&lt;%-- The next several lines are the result of a </para>
        <para>JSP expression inserted in the generated html;</para>
        <para>the &apos;=&apos; indicates a JSP expression --%&gt;</para>
        <para>&lt;H1&gt;This page was loaded at &lt;%= loadDate %&gt; &lt;/H1&gt;</para>
        <para>&lt;H1&gt;Hello, world! It&apos;s &lt;%= new Date() %&gt;&lt;/H1&gt;</para>
        <para>&lt;H2&gt;Here&apos;s an object: &lt;%= new Object() %&gt;&lt;/H2&gt;</para>
        <para>&lt;H2&gt;This page has been up </para>
        <para>&lt;%= (System.currentTimeMillis()-loadTime)/1000 %&gt;</para>
        <para>seconds&lt;/H2&gt;</para>
        <para>&lt;H3&gt;Page has been accessed &lt;%= ++hitCount %&gt; </para>
        <para>times since &lt;%= loadDate %&gt;&lt;/H3&gt;</para>
        <para>&lt;%-- A &quot;scriptlet&quot; that writes to the server</para>
        <para>console and to the client page. </para>
        <para>Note that the &apos;;&apos; is required: --%&gt;</para>
        <para>&lt;%</para>
        <para>�� System.out.println(&quot;Goodbye&quot;);</para>
        <para>�� out.println(&quot;Cheerio&quot;);</para>
        <para>%&gt;</para>
        <para>&lt;/body&gt;&lt;/html&gt;</para>
        <para>///:~</para>
        <para> </para>
        <para>When you run this program you�ll see that the variables <emphasis role="bold">loadTime</emphasis>, <emphasis role="bold">loadDate</emphasis> and <emphasis role="bold">hitCount</emphasis> hold their values between hits to the page, so they are clearly fields and not local variables.</para>
        <para>At the end of the example is a scriptlet that writes �Goodbye� to the Web server console and �Cheerio� to the implicit <emphasis role="bold">JspWriter </emphasis>object<emphasis role="bold"> out</emphasis>. Scriptlets can contain any code fragments that are valid Java statements. Scriptlets are executed at request-processing time. When all the scriptlet fragments in a given JSP are combined in the order they appear in the JSP page, they should yield a valid statement as defined by the Java programming language. Whether or not they produce any output into the <emphasis role="bold">out</emphasis> stream depends upon the code in the scriptlet. You should be aware that scriptlets can produce side effects by modifying the objects that are visible to them.</para>
        <para>JSP expressions can found intermingled with the HTML in the middle section of <emphasis role="bold">Hello.jsp</emphasis>. Expressions must be complete Java statements, which are evaluated, coerced to a <emphasis role="bold">String</emphasis>, and sent to <emphasis role="bold">out</emphasis>. If the result of the expression cannot be coerced to a <emphasis role="bold">String</emphasis> then a <emphasis role="bold">ClassCastException</emphasis> is thrown.</para>
      </section>
      <section>
        <title><anchor xreflabel="Extracting fields and values" xml:id="_Toc481064888"/>Extracting fields and values</title>
        <para>The following example is similar to one shown earlier in the servlet section. The first time you hit the page it detects that you have no fields and returns a page containing a form, using the same code as in the servlet example, but in JSP format. When you submit the form with the filled-in fields to the same JSP URL, it detects the fields and displays them. This is a nice technique because it allows you to have both the page containing the form for the user to fill out and the response code for that page in a single file, thus making it easier to create and maintain.</para>
        <para>//:! c15:jsp:DisplayFormData.jsp</para>
        <para>&lt;%-- Fetching the data from an HTML form. --%&gt;</para>
        <para>&lt;%-- This JSP also generates the form. --%&gt;</para>
        <para>&lt;%@ page import=&quot;java.util.*&quot; %&gt;</para>
        <para>&lt;html&gt;&lt;body&gt;</para>
        <para>&lt;H1&gt;DisplayFormData&lt;/H1&gt;&lt;H3&gt;</para>
        <para>&lt;%</para>
        <para>� Enumeration flds = request.getParameterNames();</para>
        <para>� if(!flds.hasMoreElements()) { // No fields %&gt;</para>
        <para>��� &lt;form method=&quot;POST&quot; </para>
        <para>��� action=&quot;DisplayFormData.jsp&quot;&gt;</para>
        <para>&lt;%� for(int i = 0; i &lt; 10; i++) {� %&gt;</para>
        <para>����� Field&lt;%=i%&gt;: &lt;input type=&quot;text&quot; size=&quot;20&quot;</para>
        <para>����� name=&quot;Field&lt;%=i%&gt;&quot; value=&quot;Value&lt;%=i%&gt;&quot;&gt;&lt;br&gt;</para>
        <para>&lt;%� } %&gt;</para>
        <para>��� &lt;INPUT TYPE=submit name=submit </para>
        <para>��� value=&quot;Submit&quot;&gt;&lt;/form&gt;</para>
        <para>&lt;%} else { </para>
        <para>��� while(flds.hasMoreElements()) {</para>
        <para>����� String field = (String)flds.nextElement();</para>
        <para>����� String value = request.getParameter(field);</para>
        <para>%&gt;</para>
        <para>����� &lt;li&gt;&lt;%= field %&gt; = &lt;%= value %&gt;&lt;/li&gt;</para>
        <para>&lt;%� }</para>
        <para>� } %&gt;</para>
        <para>&lt;/H3&gt;&lt;/body&gt;&lt;/html&gt;</para>
        <para>///:~</para>
        <para> </para>
        <para>The most interesting feature of this example is that it demonstrates how scriptlet code can be intermixed with HTML code, even to the point of generating HTML within a Java <emphasis role="bold">for</emphasis> loop. This is especially convenient for building any kind of form where repetitive HTML code would otherwise be required.</para>
      </section>
      <section>
        <title><anchor xreflabel="JSP page attributes and scope" xml:id="_Toc481064889"/>JSP page attributes and scope</title>
        <para><anchor xreflabel="" xml:id="AAA"/>By poking around in the HTML documentation for servlets and JSPs, you will find features that report information about the servlet or JSP that is currently running. The following example displays a few of these pieces of data.</para>
        <para>//:! c15:jsp:PageContext.jsp</para>
        <para>&lt;%--Viewing the attributes in the pageContext--%&gt;</para>
        <para>&lt;%-- Note that you can include any amount of code</para>
        <para>inside the scriptlet tags --%&gt;</para>
        <para>&lt;%@ page import=&quot;java.util.*&quot; %&gt;</para>
        <para>&lt;html&gt;&lt;body&gt;</para>
        <para>Servlet Name: &lt;%= config.getServletName() %&gt;&lt;br&gt;</para>
        <para>Servlet container supports servlet version:</para>
        <para>&lt;% out.print(application.getMajorVersion() + &quot;.&quot;</para>
        <para>+ application.getMinorVersion()); %&gt;&lt;br&gt;</para>
        <para>&lt;%</para>
        <para>� session.setAttribute(&quot;My dog&quot;, &quot;Ralph&quot;);</para>
        <para>� for(int scope = 1; scope &lt;= 4; scope++) {� %&gt;</para>
        <para>��� &lt;H3&gt;Scope: &lt;%= scope %&gt; &lt;/H3&gt;</para>
        <para>&lt;%� Enumeration e =</para>
        <para>����� pageContext.getAttributeNamesInScope(scope);</para>
        <para>��� while(e.hasMoreElements()) {</para>
        <para>����� out.println(&quot;\t&lt;li&gt;&quot; + </para>
        <para>������� e.nextElement() + &quot;&lt;/li&gt;&quot;);</para>
        <para>��� }</para>
        <para>� }</para>
        <para>%&gt;</para>
        <para>&lt;/body&gt;&lt;/html&gt;</para>
        <para>///:~</para>
        <para> </para>
        <para>This example also shows the use of both embedded HTML and writing to <emphasis role="bold">out</emphasis> in order to output to the resulting HTML page.</para>
        <para>The first piece of information produced is the name of the servlet, which will probably just be �JSP� but it depends on your implementation. You can also discover the current version of the servlet container by using the application object. Finally, after setting a session attribute, the �attribute names� in a particular scope are displayed. You don�t use the scopes very much in most JSP programming; they were just shown here to add interest to the example. There are four attribute scopes, as follows: The <emphasis role="italic">page scope</emphasis> (scope 1), the <emphasis role="italic">request scope</emphasis> (scope 2), the <emphasis role="italic">session scope</emphasis> (scope 3�here, the only element available in session scope is �My dog,� added right before the <emphasis role="bold">for</emphasis> loop), and the <emphasis role="italic">application scope</emphasis> (scope 4), based upon the <emphasis role="bold">ServletContext</emphasis> object. There is one <emphasis role="bold">ServletContext</emphasis> per �Web application� per Java Virtual Machine. (A �Web application� is a collection of servlets and content installed under a specific subset of the server�s URL namespace such as /catalog.� This is generally set up using a configuration file.) At the application scope you will see objects that represent paths for the working directory and temporary directory.</para>
      </section>
      <section>
        <title><anchor xreflabel="Manipulating sessions in JSP" xml:id="_Toc481064890"/>Manipulating sessions in JSP</title>
        <para>Sessions were introduced in the prior section on servlets, and are also available within JSPs. The following example exercises the <emphasis role="bold">session</emphasis> object and allows you to manipulate the amount of time before the session becomes invalid. </para>
        <para>//:! c15:jsp:SessionObject.jsp</para>
        <para>&lt;%--Getting and setting session object values--%&gt;</para>
        <para>&lt;html&gt;&lt;body&gt;</para>
        <para>&lt;H1&gt;Session id: &lt;%= session.getId() %&gt;&lt;/H1&gt;</para>
        <para>&lt;H3&gt;&lt;li&gt;This session was created at </para>
        <para>&lt;%= session.getCreationTime() %&gt;&lt;/li&gt;&lt;/H1&gt;</para>
        <para>&lt;H3&gt;&lt;li&gt;Old MaxInactiveInterval = </para>
        <para>� &lt;%= session.getMaxInactiveInterval() %&gt;&lt;/li&gt;</para>
        <para>&lt;% session.setMaxInactiveInterval(5); %&gt;</para>
        <para>&lt;li&gt;New MaxInactiveInterval= </para>
        <para>� &lt;%= session.getMaxInactiveInterval() %&gt;&lt;/li&gt;</para>
        <para>&lt;/H3&gt;</para>
        <para>&lt;H2&gt;If the session object &quot;My dog&quot; is </para>
        <para>still around, this value will be non-null:&lt;H2&gt;</para>
        <para>&lt;H3&gt;&lt;li&gt;Session value for &quot;My dog&quot; =� </para>
        <para>&lt;%= session.getAttribute(&quot;My dog&quot;) %&gt;&lt;/li&gt;&lt;/H3&gt;</para>
        <para>&lt;%-- Now add the session object &quot;My dog&quot; --%&gt;</para>
        <para>&lt;% session.setAttribute(&quot;My dog&quot;, </para>
        <para>������������������� new String(&quot;Ralph&quot;)); %&gt;</para>
        <para>&lt;H1&gt;My dog&apos;s name is </para>
        <para>&lt;%= session.getAttribute(&quot;My dog&quot;) %&gt;&lt;/H1&gt;</para>
        <para>&lt;%-- See if &quot;My dog&quot; wanders to another form --%&gt;</para>
        <para>&lt;FORM TYPE=POST ACTION=SessionObject2.jsp&gt;</para>
        <para>&lt;INPUT TYPE=submit name=submit </para>
        <para>Value=&quot;Invalidate&quot;&gt;&lt;/FORM&gt;</para>
        <para>&lt;FORM TYPE=POST ACTION=SessionObject3.jsp&gt;</para>
        <para>&lt;INPUT TYPE=submit name=submit </para>
        <para>Value=&quot;Keep Around&quot;&gt;&lt;/FORM&gt;</para>
        <para>&lt;/body&gt;&lt;/html&gt;</para>
        <para>///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">session </emphasis>object is provided by default so it is available without any extra coding. The calls to <emphasis role="bold">getID( )</emphasis>, <emphasis role="bold">getCreationTime( )</emphasis> and <emphasis role="bold">getMaxInactiveInterval( )</emphasis> are used to display information about this session object. </para>
        <para>When you first bring up this session you will see a <emphasis role="bold">MaxInactiveInterval</emphasis> of, for example, 1800 seconds (30 minutes). This will depend on the way your JSP/servlet container is configured. The <emphasis role="bold">MaxInactiveInterval</emphasis> is shortened to 5 seconds to make things interesting. If you refresh the page before the 5 second interval expires, then you�ll see:</para>
        <para>Session value for &quot;My dog&quot; = Ralph</para>
        <para> </para>
        <para>But if you wait longer than that, �Ralph� will become <emphasis role="bold">null</emphasis>.</para>
        <para>To see how the session information can be carried through to other pages, and also to see the effect of invalidating a session object versus just letting it expire, two other JSPs are created. The first one (reached by pressing the �invalidate� button in <emphasis role="bold">SessionObject.jsp</emphasis>) reads the session information and then explicitly invalidates that session:</para>
        <para>//:! c15:jsp:SessionObject2.jsp</para>
        <para>&lt;%--The session object carries through--%&gt;</para>
        <para>&lt;html&gt;&lt;body&gt;</para>
        <para>&lt;H1&gt;Session id: &lt;%= session.getId() %&gt;&lt;/H1&gt;</para>
        <para>&lt;H1&gt;Session value for &quot;My dog&quot; </para>
        <para>&lt;%= session.getValue(&quot;My dog&quot;) %&gt;&lt;/H1&gt;</para>
        <para>&lt;% session.invalidate(); %&gt;</para>
        <para>&lt;/body&gt;&lt;/html&gt;</para>
        <para>///:~</para>
        <para> </para>
        <para>To experiment with this, refresh <emphasis role="bold">SessionObject.jsp</emphasis>, then immediately click the �invalidate� button to bring you to <emphasis role="bold">SessionObject2.jsp</emphasis>. At this point you will still see �Ralph,� and right away (before the 5-second interval has expired), refresh <emphasis role="bold">SessionObject2.jsp</emphasis> to see that the session has been forcefully invalidated and �Ralph� has disappeared.</para>
        <para>If you go back to <emphasis role="bold">SessionObject.jsp</emphasis>, refresh the page so you have a new 5-second interval, then press the �Keep Around� button, it will take you to the following page, <emphasis role="bold">SessionObject3.jsp</emphasis>, which does NOT invalidate the session: </para>
        <para>//:! c15:jsp:SessionObject3.jsp</para>
        <para>&lt;%--The session object carries through--%&gt;</para>
        <para>&lt;html&gt;&lt;body&gt;</para>
        <para>&lt;H1&gt;Session id: &lt;%= session.getId() %&gt;&lt;/H1&gt;</para>
        <para>&lt;H1&gt;Session value for &quot;My dog&quot; </para>
        <para>&lt;%= session.getValue(&quot;My dog&quot;) %&gt;&lt;/H1&gt;</para>
        <para>&lt;FORM TYPE=POST ACTION=SessionObject.jsp&gt;</para>
        <para>&lt;INPUT TYPE=submit name=submit Value=&quot;Return&quot;&gt;</para>
        <para>&lt;/FORM&gt;</para>
        <para>&lt;/body&gt;&lt;/html&gt;</para>
        <para>///:~</para>
        <para> </para>
        <para>Because this page doesn�t invalidate the session, �Ralph� will hang around as long as you keep refreshing the page before the 5 second time interval expires. This is not unlike a �Tomagotchi� pet�as long as you play with �Ralph� he will stick around, otherwise he expires.</para>
      </section>
      <section>
        <title><anchor xreflabel="Creating and modifying cookies" xml:id="_Toc481064891"/>Creating and modifying cookies</title>
        <para>Cookies were introduced in the prior section on servlets. Once again, the brevity of JSPs makes playing with cookies much simpler here than when using servlets. The following example shows this by fetching the cookies that come with the request, reading and modifying their maximum ages (expiration dates) and attaching a new cookie to the outgoing response:</para>
        <para>//:! c15:jsp:Cookies.jsp</para>
        <para>&lt;%--This program has different behaviors under</para>
        <para>�different browsers! --%&gt;</para>
        <para>&lt;html&gt;&lt;body&gt;</para>
        <para>&lt;H1&gt;Session id: &lt;%= session.getId() %&gt;&lt;/H1&gt;</para>
        <para>&lt;%</para>
        <para>Cookie[] cookies = request.getCookies();</para>
        <para>for(int i = 0; i &lt; cookies.length; i++) { %&gt;</para>
        <para>� Cookie name: &lt;%= cookies[i].getName() %&gt; &lt;br&gt;</para>
        <para>� value: &lt;%= cookies[i].getValue() %&gt;&lt;br&gt;</para>
        <para>� Old max age in seconds: </para>
        <para>� &lt;%= cookies[i].getMaxAge() %&gt;&lt;br&gt;</para>
        <para>� &lt;% cookies[i].setMaxAge(5); %&gt;</para>
        <para>� New max age in seconds: </para>
        <para>� &lt;%= cookies[i].getMaxAge() %&gt;&lt;br&gt;</para>
        <para>&lt;% } %&gt;</para>
        <para>&lt;%! int count = 0; int dcount = 0; %&gt;</para>
        <para>&lt;% response.addCookie(new Cookie(</para>
        <para>��� &quot;Bob&quot; + count++, &quot;Dog&quot; + dcount++)); %&gt;</para>
        <para>&lt;/body&gt;&lt;/html&gt;</para>
        <para>///:~</para>
        <para> </para>
        <para>Since each browser stores cookies in its own way, you may see different behaviors with different browsers (not reassuring, but it might be some kind of bug that could be fixed by the time you read this). Also, you may experience different results if you shut down the browser and restart it, rather than just visiting a different page and then returning to <emphasis role="bold">Cookies.jsp</emphasis>. Note that using session objects seems to be more robust than directly using cookies.</para>
        <para>After displaying the session identifier, each cookie in the array of cookies that comes in with the <emphasis role="bold">request </emphasis>object is displayed, along with its maximum age. The maximum age is changed and displayed again to verify the new value, then a new cookie is added to the response. However, your browser may seem to ignore the maximum age; it�s worth playing with this program and modifying the maximum age value to see the behavior under different browsers.</para>
      </section>
      <section>
        <title><anchor xreflabel="JSP summary" xml:id="_Toc481064892"/>JSP summary</title>
        <para>This section has only been a brief coverage of JSPs, and yet even with what was covered here (along with the Java you�ve learned in the rest of the book, and your own knowledge of HTML) you can begin to write sophisticated web pages via JSPs. The JSP syntax isn�t meant to be particularly deep or complicated, so if you understand what was presented in this section you�re ready to be productive with JSPs. You can find further information in most current books on servlets, or at <emphasis role="italic">java.sun.com</emphasis>.</para>
        <para>It�s especially nice to have JSPs available, even if your goal is only to produce servlets. You�ll discover that if you have a question about the behavior of a servlet feature, it�s much easier and faster to write a JSP test program to answer that question than it is to write a servlet. Part of the benefit comes from having to write less code and being able to mix the display HTML in with the Java code, but the leverage becomes especially obvious when you see that the JSP Container handles all the recompilation and reloading of the JSP for you whenever the source is changed.</para>
        <para>As terrific as JSPs are, however, it�s worth keeping in mind that JSP creation requires a higher level of skill than just programming in Java or just creating Web pages. In addition, debugging a broken JSP page is not as easy as debugging a Java program, as (currently) the error messages are more obscure. This should change as development systems improve, but we may also see other technologies built on top of Java and the Web that are better adapted to the skills of the web site designer.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="RMI (Remote Method Invocation)" xml:id="_Toc481064893"/>RMI (Remote Method Invocation)</title>
      <para>Traditional approaches to executing code on other machines across a network have been confusing as well as tedious and error-prone to implement. The nicest way to think about this problem is that some object happens to live on another machine, and that you can send a message to the remote object and get a result as if the object lived on your local machine. This simplification is exactly what Java <emphasis role="italic">Remote Method Invocation</emphasis> (RMI) allows you to do. This section walks you through the steps necessary to create your own RMI objects.</para>
      <section>
        <title><anchor xreflabel="Remote interfaces" xml:id="_Toc481064894"/>Remote interfaces</title>
        <para>RMI makes heavy use of interfaces. When you want to create a remote object, you mask the underlying implementation by passing around an interface. Thus, when the client gets a reference to a remote object, what they really get is an interface reference, which <emphasis role="italic">happens</emphasis> to connect to some local stub code that talks across the network. But you don�t think about this, you just send messages via your interface reference.</para>
        <para>When you create a remote interface, you must follow these guidelines:</para>
        <para>The remote interface must be <emphasis role="bold">public</emphasis> (it cannot have �package access,� that is, it cannot be �friendly�). Otherwise, a client will get an error when attempting to load a remote object that implements the remote interface. </para>
        <para>122.   The remote interface must extend the interface <emphasis role="bold">java.rmi.Remote</emphasis>. </para>
        <para>123.   Each method in the remote interface must declare <emphasis role="bold">java.rmi.RemoteException</emphasis> in its <emphasis role="bold">throws</emphasis> clause in addition to any application-specific exceptions. </para>
        <para>124.   A remote object passed as an argument or return value (either directly or embedded within a local object) must be declared as the remote interface, not the implementation class.</para>
        <para>Here�s a simple remote interface that represents an accurate time service:</para>
        <para>//: c15:rmi:PerfectTimeI.java</para>
        <para>// The PerfectTime remote interface.</para>
        <para>package c15.rmi;</para>
        <para>import java.rmi.*;</para>
        <para> </para>
        <para>interface PerfectTimeI extends Remote {</para>
        <para>� long getPerfectTime() throws RemoteException;</para>
        <para>} ///:~</para>
        <para> </para>
        <para>It looks like any other interface except that it extends <emphasis role="bold">Remote</emphasis> and all of its methods throw <emphasis role="bold">RemoteException</emphasis>. Remember that an <emphasis role="bold">interface</emphasis> and all of its methods are automatically <emphasis role="bold">public</emphasis>.</para>
      </section>
      <section>
        <title><anchor xreflabel="Implementing the remote interface" xml:id="_Toc481064895"/>Implementing the remote interface</title>
        <para>The server must contain a class that extends <emphasis role="bold">UnicastRemoteObject</emphasis> and implements the remote interface. This class can also have additional methods, but only the methods in the remote interface are available to the client, of course, since the client will get only a reference to the interface, not the class that implements it.</para>
        <para>You must explicitly define the constructor for the remote object even if you�re only defining a default constructor that calls the base-class constructor. You must write it out since it must throw <emphasis role="bold">RemoteException</emphasis>.</para>
        <para>Here�s the implementation of the remote interface <emphasis role="bold">PerfectTimeI</emphasis>:</para>
        <para>//: c15:rmi:PerfectTime.java</para>
        <para>// The implementation of </para>
        <para>// the PerfectTime remote object.</para>
        <para>package c15.rmi;</para>
        <para>import java.rmi.*;</para>
        <para>import java.rmi.server.*;</para>
        <para>import java.rmi.registry.*;</para>
        <para>import java.net.*;</para>
        <para> </para>
        <para>public class PerfectTime </para>
        <para>��� extends UnicastRemoteObject</para>
        <para>��� implements PerfectTimeI {</para>
        <para>� // Implementation of the interface:</para>
        <para>� public long getPerfectTime() </para>
        <para>����� throws RemoteException {</para>
        <para>��� return System.currentTimeMillis();</para>
        <para>� }</para>
        <para>� // Must implement constructor </para>
        <para>� // to throw RemoteException:</para>
        <para>� public PerfectTime() throws RemoteException {</para>
        <para>��� // super(); // Called automatically</para>
        <para>� }</para>
        <para>� // Registration for RMI serving. Throw </para>
        <para>� // exceptions out to the console.</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws Exception {</para>
        <para>��� System.setSecurityManager(</para>
        <para>��� new RMISecurityManager());</para>
        <para>��� PerfectTime pt = new PerfectTime();</para>
        <para>��� Naming.bind(</para>
        <para>����� &quot;//peppy:2005/PerfectTime&quot;, pt);</para>
        <para>��� System.out.println(&quot;Ready to do time&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Here, <emphasis role="bold">main( )</emphasis> handles all the details of setting up the server. When you�re serving RMI objects, at some point in your program you must:</para>
        <para>Create and install a security manager that supports RMI. The only one available for RMI as part of the Java distribution is <emphasis role="bold">RMISecurityManager</emphasis>.</para>
        <para>125.   Create one or more instances of a remote object. Here, you can see the creation of the <emphasis role="bold">PerfectTime</emphasis> object.</para>
        <para>126.   Register at least one of the remote objects with the RMI remote object registry for bootstrapping purposes. One remote object can have methods that produce references to other remote objects. This allows you to set it up so the client must go to the registry only once, to get the first remote object.</para>
        <section>
          <title>Setting up the registry</title>
          <para>Here, you see a call to the <emphasis role="bold">static</emphasis> method <emphasis role="bold">Naming.bind( )</emphasis>. However, this call requires that the registry be running as a separate process on the computer. The name of the registry server is <emphasis role="bold">rmiregistry</emphasis>, and under 32-bit Windows you say:</para>
          <para>start rmiregistry</para>
          <para> </para>
          <para>to start it in the background. On Unix, the command is:</para>
          <para>rmiregistry &amp;</para>
          <para> </para>
          <para>Like many network programs, the <emphasis role="bold">rmiregistry</emphasis> is located at the IP address of whatever machine started it up, but it must also be listening at a port. If you invoke the <emphasis role="bold">rmiregistry</emphasis> as above, with no argument, the registry�s port will default to 1099. If you want it to be at some other port, you add an argument on the command line to specify the port. For this example, the port is located at 2005, so the <emphasis role="bold">rmiregistry</emphasis> should be started like this under 32-bit Windows:</para>
          <para>start rmiregistry 2005</para>
          <para> </para>
          <para>or for Unix:</para>
          <para>rmiregistry 2005 &amp;</para>
          <para> </para>
          <para>The information about the port must also be given to the <emphasis role="bold">bind( )</emphasis> command, as well as the IP address of the machine where the registry is located. But this brings up what can be a frustrating problem if you�re expecting to test RMI programs locally the way the network programs have been tested so far in this chapter. In the JDK 1.1.1 release, there are a couple of problems:<anchor xreflabel="[76]" xml:id="_ftnref76"/>[76]</para>
          <para><emphasis role="bold">localhost </emphasis>does not work with RMI. Thus, to experiment with RMI on a single machine, you must provide the name of the machine. To find out the name of your machine under 32-bit Windows, go to the control panel and select �Network.� Select the �Identification� tab, and you�ll see your computer name. In my case, I called my computer �Peppy.� It appears that capitalization is ignored.</para>
          <para>127.   RMI will not work unless your computer has an active TCP/IP connection, even if all your components are just talking to each other on the local machine. This means that you must connect to your Internet service provider before trying to run the program or you�ll get some obscure exception messages.</para>
          <para>With all this in mind, the <emphasis role="bold">bind( )</emphasis> command becomes:</para>
          <para>Naming.bind(&quot;//peppy:2005/PerfectTime&quot;, pt);</para>
          <para> </para>
          <para>If you are using the default port 1099, you don�t need to specify a port, so you could say:</para>
          <para>Naming.bind(&quot;//peppy/PerfectTime&quot;, pt);</para>
          <para> </para>
          <para>You should be able to perform local testing by leaving off the IP address and using only the identifier:</para>
          <para>Naming.bind(&quot;PerfectTime&quot;, pt);</para>
          <para> </para>
          <para>The name for the service is arbitrary; it happens to be PerfectTime here, just like the name of the class, but you could call it anything you want. The important thing is that it�s a unique name in the registry that the client knows to look for to procure the remote object. If the name is already in the registry, you�ll get an <emphasis role="bold">AlreadyBoundException</emphasis>. To prevent this, you can always use <emphasis role="bold">rebind( )</emphasis> instead of <emphasis role="bold">bind( )</emphasis>, since <emphasis role="bold">rebind( )</emphasis> either adds a new entry or replaces the one that�s already there.</para>
          <para>Even though <emphasis role="bold">main( )</emphasis> exits, your object has been created and registered so it�s kept alive by the registry, waiting for a client to come along and request it. As long as the <emphasis role="bold">rmiregistry</emphasis> is running and you don�t call <emphasis role="bold">Naming.unbind( )</emphasis>on your name, the object will be there. For this reason, when you�re developing your code you need to shut down the <emphasis role="bold">rmiregistry</emphasis> and restart it when you compile a new version of your remote object.</para>
          <para>You aren�t forced to start up <emphasis role="bold">rmiregistry</emphasis> as an external process. If you know that your application is the only one that�s going to use the registry, you can start it up inside your program with the line:</para>
          <para>LocateRegistry.createRegistry(2005);</para>
          <para> </para>
          <para>Like before, 2005 is the port number we happen to be using in this example. This is the equivalent of running <emphasis role="bold">rmiregistry 2005</emphasis> from a command line, but it can often be more convenient when you�re developing RMI code since it eliminates the extra steps of starting and stopping the registry. Once you�ve executed this code, you can <emphasis role="bold">bind( )</emphasis> using <emphasis role="bold">Naming</emphasis> as before.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Creating stubs and skeletons" xml:id="_Toc481064896"/>Creating stubs and skeletons</title>
        <para>If you compile and run <emphasis role="bold">PerfectTime.java</emphasis>, it won�t work even if you have the <emphasis role="bold">rmiregistry</emphasis> running correctly. That�s because the framework for RMI isn�t all there yet. You must first create the stubs and skeletons that provide the network connection operations and allow you to pretend that the remote object is just another local object on your machine.</para>
        <para>What�s going on behind the scenes is complex. Any objects that you pass into or return from a remote object must <emphasis role="bold">implement </emphasis><emphasis role="bold">Serializable</emphasis> (if you want to pass remote references instead of the entire objects, the object arguments can <emphasis role="bold">implement Remote</emphasis>), so you can imagine that the stubs and skeletons are automatically performing serialization and deserialization as they �marshal� all of the arguments across the network and return the result. Fortunately, you don�t have to know any of this, but you <emphasis role="italic">do</emphasis> have to create the stubs and skeletons. This is a simple process: you invoke the <emphasis role="bold">rmic</emphasis> tool on your compiled code, and it creates the necessary files. So the only requirement is that another step be added to your compilation process.</para>
        <para>The <emphasis role="bold">rmic</emphasis> tool is particular about packages and classpaths, however. <emphasis role="bold">PerfectTime.java</emphasis> is in the <emphasis role="bold">package c15.rmi</emphasis>, and even if you invoke <emphasis role="bold">rmic</emphasis> in the same directory in which <emphasis role="bold">PerfectTime.class</emphasis> is located, <emphasis role="bold">rmic</emphasis> won�t find the file, since it searches the classpath. So you must specify the location off the class path, like so:</para>
        <para>rmic c15.rmi.PerfectTime</para>
        <para> </para>
        <para>You don�t have to be in the directory containing <emphasis role="bold">PerfectTime.class</emphasis> when you execute this command, but the results will be placed in the current directory.</para>
        <para>When <emphasis role="bold">rmic</emphasis> runs successfully, you�ll have two new classes in the directory:</para>
        <para>PerfectTime_Stub.class</para>
        <para>PerfectTime_Skel.class</para>
        <para> </para>
        <para>corresponding to the stub and skeleton. Now you�re ready to get the server and client to talk to each other.</para>
      </section>
      <section>
        <title><anchor xreflabel="Using the remote object" xml:id="_Toc481064897"/>Using the remote object</title>
        <para>The whole point of RMI is to make the use of remote objects simple. The only extra thing that you must do in your client program is to look up and fetch the remote interface from the server. From then on, it�s just regular Java programming: sending messages to objects. Here�s the program that uses <emphasis role="bold">PerfectTime</emphasis>:</para>
        <para>//: c15:rmi:DisplayPerfectTime.java</para>
        <para>// Uses remote object PerfectTime.</para>
        <para>package c15.rmi;</para>
        <para>import java.rmi.*;</para>
        <para>import java.rmi.registry.*;</para>
        <para> </para>
        <para>public class DisplayPerfectTime {</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws Exception {</para>
        <para>��� System.setSecurityManager(</para>
        <para>����� new RMISecurityManager());</para>
        <para>��� PerfectTimeI t = </para>
        <para>����� (PerfectTimeI)Naming.lookup(</para>
        <para>������� &quot;//peppy:2005/PerfectTime&quot;);</para>
        <para>��� for(int i = 0; i &lt; 10; i++)</para>
        <para>����� System.out.println(&quot;Perfect time = &quot; +</para>
        <para>������� t.getPerfectTime());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The ID string is the same as the one used to register the object with <emphasis role="bold">Naming</emphasis>, and the first part represents the URL and port number. Since you�re using a URL, you can also specify a machine on the Internet.</para>
        <para>What comes back from <emphasis role="bold">Naming.lookup( )</emphasis> must be cast to the remote interface, <emphasis role="italic">not</emphasis> to the class. If you use the class instead, you�ll get an exception.</para>
        <para>You can see in the method call</para>
        <para>t.getPerfectTime()</para>
        <para> </para>
        <para>that once you have a reference to the remote object, programming with it is indistinguishable from programming with a local object (with one difference: remote methods throw <emphasis role="bold">RemoteException</emphasis>).</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc375545499"/><anchor xreflabel="CORBA" xml:id="_Toc481064898"/>CORBA</title>
      <para>In large, distributed applications, your needs might not be satisfied by the preceding approaches. For example, you might want to interface with legacy data stores, or you might need services from a server object regardless of its physical location. These situations require some form of Remote Procedure Call (RPC), and possibly language independence. This is where CORBA can help.</para>
      <para>CORBA is not a language feature; it�s an integration technology. It�s a specification that vendors can follow to implement CORBA-compliant integration products. CORBA is part of the OMG�s effort to define a standard framework for distributed, language-independent object interoperability.</para>
      <para>CORBA supplies the ability to make remote procedure calls into Java objects and non-Java objects, and to interface with legacy systems in a location-transparent way. Java adds networking support and a nice object-oriented language for building graphical and non-graphical applications. The Java and OMG object model map nicely to each other; for example, both Java and CORBA implement the interface concept and a reference object model.</para>
      <section>
        <title><anchor xreflabel="CORBA fundamentals" xml:id="_Toc481064899"/>CORBA fundamentals</title>
        <para>The object interoperability specification developed by the OMG is commonly referred to as the Object Management Architecture (OMA). The OMA defines two components: the Core Object Model and the OMA Reference Architecture. The Core Object Model states the basic concepts of object, interface, operation, and so on. (CORBA is a refinement of the Core Object Model.) The OMA Reference Architecture defines an underlying infrastructure of services and mechanisms that allow objects to interoperate. The OMA Reference Architecture includes the Object Request Broker (ORB), Object Services (also known as CORBA services), and common facilities.</para>
        <para>The ORB is the communication bus by which objects can request services from other objects, regardless of their physical location. This means that what looks like a method call in the client code is actually a complex operation. First, a connection with the server object must exist, and to create a connection the ORB must know where the server implementation code resides. Once the connection is established, the method arguments must be marshaled, i.e. converted in a binary stream to be sent across a network. Other information that must be sent are the server machine name, the server process, and the identity of the server object inside that process. Finally, this information is sent through a low-level wire protocol, the information is decoded on the server side, and the call is executed. The ORB hides all of this complexity from the programmer and makes the operation almost as simple as calling a method on local object.</para>
        <para>There is no specification for how an ORB Core should be implemented, but to provide a basic compatibility among different vendors� ORBs, the OMG defines a set of services that are accessible through standard interfaces.</para>
        <section>
          <title>CORBA Interface Definition Language (IDL)</title>
          <para>CORBA is designed for language transparency: a client object can call methods on a server object of different class, regardless of the language they are implemented with. Of course, the client object must know the names and signatures of methods that the server object exposes. This is where IDL comes in. The CORBA IDL is a language-neutral way to specify data types, attributes, operations, interfaces, and more. The IDL syntax is similar to the C++ or Java syntax. The following table shows the correspondence between some of the concepts common to three languages that can be specified through CORBA IDL:</para>
          <informaltable frame="all">
            <tgroup cols="3">
              <colspec colname="c1" colwidth="11*"/>
              <colspec colname="c2" colwidth="8*"/>
              <colspec colname="c3" colwidth="14*"/>
              <tbody>
                <row>
                  <entry valign="top"><para> CORBA IDL</para></entry>
                  <entry valign="top"><para> Java</para></entry>
                  <entry valign="top"><para> C++</para></entry>
                </row>
                <row>
                  <entry valign="top"><para> Module</para></entry>
                  <entry valign="top"><para> Package</para></entry>
                  <entry valign="top"><para> Namespace</para></entry>
                </row>
                <row>
                  <entry valign="top"><para> Interface</para></entry>
                  <entry valign="top"><para> Interface</para></entry>
                  <entry valign="top"><para> Pure abstract class</para></entry>
                </row>
                <row>
                  <entry valign="top"><para> Method</para></entry>
                  <entry valign="top"><para> Method</para></entry>
                  <entry valign="top"><para> Member function</para></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>The inheritance concept is supported as well, using the colon operator as in C++. The programmer writes an IDL description of the attributes, methods, and interfaces that are implemented and used by the server and clients. The IDL is then compiled by a vendor-provided IDL/Java compiler, which reads the IDL source and generates Java code.</para>
          <para>The IDL compiler is an extremely useful tool: it doesn�t just generate a Java source equivalent of the IDL, it also generates the code that will be used to marshal method arguments and to make remote calls. This code, called the stub and skeleton code, is organized in multiple Java source files and is usually part of the same Java package. </para>
        </section>
        <section>
          <title>The naming service</title>
          <para>The naming service is one of the fundamental CORBA services. A CORBA object is accessed through a reference, a piece of information that�s not meaningful for the human reader. But references can be assigned programmer-defined, string names. This operation is known as <emphasis role="italic">stringifying the reference</emphasis>, and one of the OMA components, the Naming Service, is devoted to performing string-to-object and object-to-string conversion and mapping. Since the Naming Service acts as a telephone directory that both servers and clients can consult and manipulate, it runs as a separate process. Creating an object-to-string mapping is called <emphasis role="italic">binding an object</emphasis>, and removing the mapping is called <emphasis role="italic">unbinding</emphasis>. Getting an object reference passing a string is called <emphasis role="italic">resolving the name</emphasis>.</para>
          <para>For example, on startup, a server application could create a server object, bind the object into the name service, and then wait for clients to make requests. A client first obtains a server object reference, resolving the string name, and then can make calls into the server using the reference.</para>
          <para>Again, the Naming Service specification is part of CORBA, but the application that implements it is provided by the ORB vendor. The way you get access to the Naming Service functionality can vary from vendor to vendor. </para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="An example" xml:id="_Toc481064900"/>An example</title>
        <para>The code shown here will not be elaborate because different ORBs have different ways to access CORBA services, so examples are vendor specific. (The example below uses JavaIDL, a free product from Sun that comes with a light-weight ORB, a naming service, and an IDL-to-Java compiler.) In addition, since Java is young and still evolving, not all CORBA features are present in the various Java/CORBA products.</para>
        <para>We want to implement a server, running on some machine, that can be queried for the exact time. We also want to implement a client that asks for the exact time. In this case we�ll be implementing both programs in Java, but we could also use two different languages (which often happens in real situations).</para>
        <section>
          <title>Writing the IDL source</title>
          <para>The first step is to write an IDL description of the services provided. This is usually done by the server programmer, who is then free to implement the server in any language in which a CORBA IDL compiler exists. The IDL file is distributed to the client side programmer and becomes the bridge between languages.</para>
          <para>The example below shows the IDL description of our <emphasis role="bold">ExactTime</emphasis> server:</para>
          <para>//: c15:corba:ExactTime.idl</para>
          <para>//# You must install idltojava.exe from </para>
          <para>//# java.sun.com and adjust the settings to use</para>
          <para>//# your local C preprocessor in order to compile</para>
          <para>//# This file. See docs at java.sun.com.</para>
          <para>module remotetime {</para>
          <para>�� interface ExactTime {</para>
          <para>����� string getTime();</para>
          <para>�� };</para>
          <para>}; ///:~</para>
          <para> </para>
          <para>This is a declaration of the <emphasis role="bold">ExactTime</emphasis> interface inside the <emphasis role="bold">remotetime</emphasis> namespace. The interface is made up of one single method that gives back the current time in <emphasis role="bold">string</emphasis> format.</para>
        </section>
        <section>
          <title>Creating stubs and skeletons</title>
          <para>The second step is to compile the IDL to create the Java stub and skeleton code that we�ll use for implementing the client and the server. The tool that comes with the JavaIDL product is <emphasis role="bold">idltojava</emphasis>: </para>
          <para>idltojava remotetime.idl</para>
          <para> </para>
          <para>This will automatically generate code for both the stub and the skeleton. <emphasis role="bold">Idltojava</emphasis> generates a Java <emphasis role="bold">package</emphasis> named after the IDL module, <emphasis role="bold">remotetime</emphasis>, and the generated Java files are put in the <emphasis role="bold">remotetime</emphasis> subdirectory. <emphasis role="bold">_ExactTimeImplBase.java </emphasis>is the skeleton that we�ll use to implement the server object, and <emphasis role="bold">_ExactTimeStub.java</emphasis> will be used for the client. There are Java representations of the IDL interface in <emphasis role="bold">ExactTime.java</emphasis> and a couple of other support files used, for example, to facilitate access to the naming service operations.</para>
        </section>
        <section>
          <title>Implementing the server and the client</title>
          <para>Below you can see the code for the server side. The server object implementation is in the <emphasis role="bold">ExactTimeServer</emphasis> class. The <emphasis role="bold">RemoteTimeServer</emphasis> is the application that creates a server object, registers it with the ORB, gives a name to the object reference, and then sits quietly waiting for client requests.</para>
          <para>//: c15:corba:RemoteTimeServer.java</para>
          <para>import remotetime.*;</para>
          <para>import org.omg.CosNaming.*;</para>
          <para>import org.omg.CosNaming.NamingContextPackage.*;</para>
          <para>import org.omg.CORBA.*;</para>
          <para>import java.util.*;</para>
          <para>import java.text.*;</para>
          <para> </para>
          <para>// Server object implementation</para>
          <para>class ExactTimeServer extends _ExactTimeImplBase {</para>
          <para>� public String getTime(){</para>
          <para>��� return DateFormat.</para>
          <para>������� getTimeInstance(DateFormat.FULL).</para>
          <para>��������� format(new Date(</para>
          <para>������������� System.currentTimeMillis()));</para>
          <para>� }</para>
          <para>}</para>
          <para> </para>
          <para>// Remote application implementation</para>
          <para>public class RemoteTimeServer {</para>
          <para>� // Throw exceptions to console:</para>
          <para>� public static void main(String[] args) </para>
          <para>� throws Exception {</para>
          <para>��� // ORB creation and initialization:</para>
          <para>��� ORB orb = ORB.init(args, null);</para>
          <para>��� // Create the server object and register it:</para>
          <para>��� ExactTimeServer timeServerObjRef = </para>
          <para>����� new ExactTimeServer();</para>
          <para>��� orb.connect(timeServerObjRef);</para>
          <para>��� // Get the root naming context:</para>
          <para>��� org.omg.CORBA.Object objRef = </para>
          <para>����� orb.resolve_initial_references(</para>
          <para>������� &quot;NameService&quot;);</para>
          <para>��� NamingContext ncRef = </para>
          <para>����� NamingContextHelper.narrow(objRef);</para>
          <para>��� // Assign a string name to the </para>
          <para>��� // object reference (binding):</para>
          <para>��� NameComponent nc = </para>
          <para>����� new NameComponent(&quot;ExactTime&quot;, &quot;&quot;);</para>
          <para>��� NameComponent[] path = { nc };</para>
          <para>��� ncRef.rebind(path, timeServerObjRef);</para>
          <para>��� // Wait for client requests:</para>
          <para>��� java.lang.Object sync =</para>
          <para>����� new java.lang.Object();</para>
          <para>��� synchronized(sync){</para>
          <para>����� sync.wait();</para>
          <para>��� }</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>As you can see, implementing the server object is simple; it�s a regular Java class that inherits from the skeleton code generated by the IDL compiler. Things get a bit more complicated when it comes to interacting with the ORB and other CORBA services.</para>
        </section>
        <section>
          <title>Some CORBA services</title>
          <para>This is a short description of what the JavaIDL-related code is doing (primarily ignoring the part of the CORBA code that is vendor dependent). The first line in <emphasis role="bold">main( )</emphasis> starts up the ORB, and of course, this is because our server object will need to interact with it. Right after the ORB initialization, a server object is created. Actually, the right term would be a <emphasis role="italic">transient servant object</emphasis>: an object that receives requests from clients, and whose lifetime is the same as the process that creates it. Once the transient servant object is created, it is registered with the ORB, which means that the ORB knows of its existence and can now forward requests to it.</para>
          <para>Up to this point, all we have is <emphasis role="bold">timeServerObjRef</emphasis>, an object reference that is known only inside the current server process. The next step will be to assign a stringified name to this servant object; clients will use that name to locate the servant object. We accomplish this operation using the Naming Service. First, we need an object reference to the Naming Service; the call to <emphasis role="bold">resolve_initial_references( )</emphasis> takes the stringified object reference of the Naming Service that is �NameService,� in JavaIDL, and returns an object reference. This is cast to a specific <emphasis role="bold">NamingContext</emphasis> reference using the <emphasis role="bold">narrow( )</emphasis> method. We can use now the naming services.</para>
          <para>To bind the servant object with a stringified object reference, we first create a <emphasis role="bold">NameComponent</emphasis> object, initialized with �ExactTime,� the name string we want to bind to the servant object. Then, using the <emphasis role="bold">rebind( )</emphasis> method, the stringified reference is bound to the object reference. We use <emphasis role="bold">rebind( )</emphasis> to assign a reference, even if it already exists, whereas <emphasis role="bold">bind( )</emphasis> raises an exception if the reference already exists. A name is made up in CORBA by a sequence of NameContexts�that�s why we use an array to bind the name to the object reference.</para>
          <para>The servant object is finally ready for use by clients. At this point, the server process enters a wait state. Again, this is because it is a transient servant, so its lifetime is confined to the server process. JavaIDL does not currently support persistent objects�objects that survive the execution of the process that creates them.</para>
          <para>Now that we have an idea of what the server code is doing, let�s look at the client code:</para>
          <para>//: c15:corba:RemoteTimeClient.java</para>
          <para>import remotetime.*;</para>
          <para>import org.omg.CosNaming.*;</para>
          <para>import org.omg.CORBA.*;</para>
          <para> </para>
          <para>public class RemoteTimeClient {</para>
          <para>� // Throw exceptions to console:</para>
          <para>� public static void main(String[] args) </para>
          <para>� throws Exception {</para>
          <para>��� // ORB creation and initialization:</para>
          <para>��� ORB orb = ORB.init(args, null);</para>
          <para>��� // Get the root naming context:</para>
          <para>��� org.omg.CORBA.Object objRef = </para>
          <para>����� orb.resolve_initial_references(</para>
          <para>������� &quot;NameService&quot;);</para>
          <para>��� NamingContext ncRef = </para>
          <para>����� NamingContextHelper.narrow(objRef);</para>
          <para>��� // Get (resolve) the stringified object </para>
          <para>��� // reference for the time server:</para>
          <para>��� NameComponent nc = </para>
          <para>����� new NameComponent(&quot;ExactTime&quot;, &quot;&quot;);</para>
          <para>��� NameComponent[] path = { nc };</para>
          <para>��� ExactTime timeObjRef = </para>
          <para>����� ExactTimeHelper.narrow(</para>
          <para>������� ncRef.resolve(path));</para>
          <para>��� // Make requests to the server object:</para>
          <para>��� String exactTime = timeObjRef.getTime();</para>
          <para>��� System.out.println(exactTime);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>The first few lines do the same as they do in the server process: the ORB is initialized and a reference to the naming service server is resolved. Next, we need an object reference for the servant object, so we pass the stringified object reference to the <emphasis role="bold">resolve( )</emphasis> method, and we cast the result into an <emphasis role="bold">ExactTime</emphasis> interface reference using the <emphasis role="bold">narrow( )</emphasis> method. Finally, we call <emphasis role="bold">getTime( )</emphasis>. </para>
        </section>
        <section>
          <title>Activating the name service process</title>
          <para>Finally we have a server and a client application ready to interoperate. You�ve seen that both need the naming service to bind and resolve stringified object references. You must start the naming service process before running either the server or the client. In JavaIDL, the naming service is a Java application that comes with the product package, but it can be different with other products. The JavaIDL naming service runs inside an instance of the JVM and listens by default to network port 900.</para>
        </section>
        <section>
          <title>Activating the server and the client</title>
          <para>Now you are ready to start your server and client application (in this order, since our server is transient). If everything is set up correctly, what you�ll get is a single output line on the client console window, giving you the current time. Of course, this might be not very exciting by itself, but you should take one thing into account: even if they are on the same physical machine, the client and the server application are running inside different virtual machines and they can communicate via an underlying integration layer, the ORB and the Naming Service.</para>
          <para>This is a simple example, designed to work without a network, but an ORB is usually configured for location transparency. When the server and the client are on different machines, the ORB can resolve remote stringified references using a component known as the <emphasis role="italic">Implementation Repository</emphasis>. Although the Implementation Repository is part of CORBA, there is almost no specification, so it differs from vendor to vendor.</para>
          <para>As you can see, there is much more to CORBA than what has been covered here, but you should get the basic idea. If you want more information about CORBA, the place to start is the OMG Web site, at <emphasis role="italic">www.omg.org</emphasis>. There you�ll find documentation, white papers, proceedings, and references to other CORBA sources and products.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="Java Applets and CORBA" xml:id="_Toc481064901"/>Java Applets and CORBA</title>
        <para>Java applets can act as CORBA clients. This way, an applet can access remote information and services exposed as CORBA objects. But an applet can connect only with the server from which it was downloaded, so all the CORBA objects the applet interacts with must be on that server. This is the opposite of what CORBA tries to do: give you complete location transparency.</para>
        <para>This is an issue of network security. If you�re on an intranet, one solution is to loosen the security restrictions on the browser. Or, set up a firewall policy for connecting with external servers.</para>
        <para>Some Java ORB products offer proprietary solutions to this problem. For example, some implement what is called HTTP Tunneling, while others have their special firewall features.</para>
        <para>This is too complex a topic to be covered in an appendix, but it is definitely something you should be aware of.</para>
      </section>
      <section>
        <title><anchor xreflabel="CORBA vs. RMI" xml:id="_Toc481064902"/>CORBA vs. RMI</title>
        <para>You saw that one of the main CORBA features is RPC support, which allows your local objects to call methods in remote objects. Of course, there already is a native Java feature that does exactly the same thing: RMI (see Chapter 15). While RMI makes RPC possible between Java objects, CORBA makes RPC possible between objects implemented in any language. It�s a big difference.</para>
        <para>However, RMI can be used to call services on remote, non-Java code. All you need is some kind of wrapper Java object around the non-Java code on the server side. The wrapper object connects externally to Java clients via RMI, and internally connects to the non-Java code using one of the techniques shown above, such as JNI or J/Direct.</para>
        <para>This approach requires you to write a kind of integration layer, which is exactly what CORBA does for you, but then you don�t need a third-party ORB.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Enterprise JavaBeans" xml:id="_Toc481064903"/>Enterprise JavaBeans</title>
      <para>Suppose<anchor xreflabel="[77]" xml:id="_ftnref77"/>[77] you need to develop a multi-tiered application to view and update records in a database through a Web interface. You can write a database application using JDBC, a Web interface using JSP/servlets, and a distributed system using CORBA/RMI. But what extra considerations must you make when developing a distributed object system rather than just knowing API�s? Here are the issues:</para>
      <para><emphasis role="bold"><emphasis role="italic">Performance:</emphasis></emphasis> The distributed objects you create must perform well, as they could potentially service many clients at a time. You�ll need to use optimization techniques such as caching as well as pooling resources like database connections. You�ll also have to manage the lifecycle of your distributed objects.</para>
      <para><emphasis role="bold"><emphasis role="italic">Scalability</emphasis></emphasis>: The distributed objects must also be scalable. Scalability in a distributed application means that the number of instances of your distributed objects can be increased and moved onto additional machines without modifying any code.</para>
      <para><emphasis role="bold"><emphasis role="italic">Security:</emphasis></emphasis> A distributed object must often manage the authorization of the clients that access it. Ideally, you can add new users and roles to it without recompilation.</para>
      <para><emphasis role="bold"><emphasis role="italic">Distributed Transactions:</emphasis></emphasis> A distributed object should be able to reference distributed transactions transparently. For example, if you are working with two separated databases, you should be able to update them simultaneously within the same transaction and roll them both back if a certain criteria is not met.</para>
      <para><emphasis role="bold"><emphasis role="italic">Reusability:</emphasis></emphasis> The ideal distributed object can be effortlessly moved onto another vendors� application server. It would be nice if you could resell a distributed object component without making special modifications, or buy someone else�s component and use it without having to recompile or rewrite it.</para>
      <para><emphasis role="bold"><emphasis role="italic">Availability:</emphasis></emphasis> If one of the machines in the system goes down, clients should automatically fail-over to backup copies of the objects running on other machines.</para>
      <para>These considerations, in addition the business problem that you set out to solve, can make for a daunting development project. However, all the issues <emphasis role="italic">except</emphasis> for your business problem are redundant�solutions must be reinvented for every distributed business application.</para>
      <para>Sun, along with other leading distributed object vendors, realized that sooner or later every development team would be reinventing these particular solutions, so they created the Enterprise JavaBeans specification (EJB). EJB describes a server-side component model that tackles all of the considerations mentioned above using a standard approach that allows developers to create business components called EJBs that are isolated from low-level �plumbing� code and that focus solely on providing business logic. Because EJB�s are defined in a standard way, they can vendor independent.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064904"/><anchor xreflabel="JavaBeans" xml:id="_Toc466527406"/>JavaBeans vs. EJBs</title>
        <para>Because of the similarity in names, there is much confusion about the relationship between the JavaBeans component model and the Enterprise JavaBeans specification. While both the JavaBeans and Enterprise JavaBeans specifications share the same objectives in promoting reuse and portability of Java code between development and deployment tools with the use of standard design patterns, the motives behind each specification are geared to solve different problems.</para>
        <para>The standards defined in the JavaBeans component model are designed for creating reusable components that are typically used in IDE development tools and are commonly, although not exclusively, visual components.</para>
        <para>The Enterprise JavaBeans specification defines a component model for developing server side java code. Because EJBs can potentially run on many different server-side platforms�including mainframes that do not have visual displays�An EJB cannot make use of graphical libraries such as AWT or Swing.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064905"/><anchor xreflabel="The
EJB specification" xml:id="_Toc466527392"/>The EJB specification</title>
        <para>The Enterprise JavaBeans specification describes a server-side component model. It defines six roles that are used to perform the tasks in development and deployment as well as defining the components of the system. These roles are used in the development, deployment and running of a distributed system. Vendors, administrators and developers play the various roles, to allow the partitioning of technical and domain knowledge. The vendor provides a technically sound framework and the developers create domain-specific components; for example, an �accounting� component. The same party can perform one or many roles. The roles defined in the EJB specification are summarized in the following table:</para>
        <informaltable frame="all">
          <tgroup cols="2">
            <colspec colname="c1" colwidth="14*"/>
            <colspec colname="c2" colwidth="33*"/>
            <tbody>
              <row>
                <entry valign="top"><para> Role</para></entry>
                <entry valign="top"><para> Responsibility</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Enterprise Bean Provider</para></entry>
                <entry valign="top"><para> The developer responsible for creating reusable EJB components. These components are packaged into a special jar file (ejb-jar file).</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Application Assembler</para></entry>
                <entry valign="top"><para> Creates and assembles applications from a collection of ejb-jar files. This includes writing applications that utilize the collection of EJBs (e.g., servlets, JSP, Swing etc. etc.).</para></entry>
              </row>
              <row>
                <entry valign="top"><para> Deployer</para></entry>
                <entry valign="top"><para> Takes the collection of ejb-jar files from the Assembler and/or Bean Provider and deploys them into a run-time environment: one or more EJB Containers. </para></entry>
              </row>
              <row>
                <entry valign="top"><para> EJB Container/Server Provider </para></entry>
                <entry valign="top"><para> Provides a run-time environment and tools that are used to deploy, administer, and run EJB components.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> System Administrator</para></entry>
                <entry valign="top"><para> Manages the different components and services so that they are configured and they interact correctly, as well as ensuring that the system is up and running.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para> </para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064906"/><anchor xreflabel="EJB
components" xml:id="_Toc466527394"/>EJB components</title>
        <para>EJB components are elements of reusable business logic that adhere to strict standards and design patterns as defined in the EJB specification. This allows the components to be portable. It also allows other services�such as security, caching and distributed transactions�to be performed on behalf of the components. An Enterprise Bean Provider is responsible for developing EJB components.</para>
        <section>
          <title>EJB Container &amp; Server</title>
          <para>The <emphasis role="italic">EJB Container</emphasis> is a run-time environment that contains and runs EJB components and provides a set of standard services to those components. The EJB Container�s responsibilities are tightly defined by the specification to allow for vendor neutrality. The EJB container provides the low-level �plumbing� of EJB, including distributed transactions, security, lifecycle management of beans, caching, threading and session management. The EJB Container Provider is responsible for providing an EJB Container.</para>
          <para>An <emphasis role="italic">EJB Server</emphasis> is defined as an Application Server that contains and runs one or more EJB Containers. The EJB Server Provider is responsible for providing an EJB Server. You can generally assume that the EJB Container and EJB Server are the same. </para>
        </section>
        <section>
          <title>Java Naming and Directory Interface (JNDI)</title>
          <para>Java Naming and Directory Interface (JNDI) is used in Enterprise JavaBeans as the naming service for EJB Components on the network and other container services such as transactions. JNDI maps very closely to other naming and directory standards such as CORBA CosNaming and can actually be implemeted as a wrapper on top of it. </para>
        </section>
        <section>
          <title>Java Transaction API/Java Transaction Service (JTA/JTS)</title>
          <para>JTA/JTS is used in Enterprise JavaBeans as the transactional API. An Enterprise Bean Provider can use the JTS to create transaction code, although the EJB Container commonly implements transactions in EJB on the EJB components� behalf. The deployer can define the transactional attributes of an EJB component at deployment time. The EJB Container is responsible for handling the transaction whether it is local or distributed. The JTS specification is the Java mapping to the CORBA OTS (Object Transaction Service)</para>
        </section>
        <section>
          <title>CORBA and RMI/IIOP</title>
          <para>The EJB specification defines interoperability with CORBA through compatibility with CORBA protocols. This is achieved by mapping EJB services such as JTS and JNDI to corresponding CORBA services and the implementation of RMI on top of the CORBA protocol IIOP. </para>
          <para>Use of CORBA and RMI/IIOP in Enterprise JavaBeans is implemented in the EJB Container and is the responsibility of the EJB Container provider. Use of CORBA and RMI/IIOP in the EJB Container is hidden from the EJB Component itself. This means that the Enterprise Bean Provider can write their EJB Component and deploy it into any EJB Container without any regard of which communication protocol is being used.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064907"/><anchor xreflabel="The
pieces of an EJB component" xml:id="_Toc466527395"/>The pieces of an EJB component</title>
        <para>An EJB consists of a number of pieces, including the Bean itself, the implementation of some interfaces, and an information file. Everything is packaged together into a special jar file.</para>
        <section>
          <title><anchor xreflabel="Enterprise Bean" xml:id="_Toc466527396"/>Enterprise Bean</title>
          <para>The Enterprise Bean is a Java class that the Enterprise Bean Provider develops. It implements an Enterprise Bean interface and provides the implementation of the business methods that the component is to perform. The class does not implement any authorization, authentication, multithreading, or transactional code.</para>
        </section>
        <section>
          <title><anchor xreflabel="Home interface" xml:id="_Toc466527397"/>Home interface</title>
          <para>Every Enterprise Bean that is created must have an associated Home interface. The Home interface is used as a factory for your EJB. Clients use the Home interface to find an instance of your EJB or create a new instance of your EJB.</para>
        </section>
        <section>
          <title><anchor xreflabel="Remote interface" xml:id="_Toc466527398"/>Remote interface</title>
          <para>The Remote interface is a Java Interface that reflects the methods of your Enterprise Bean that you wish to expose to the outside world. The Remote interface plays a similar role to a CORBA IDL interface. </para>
        </section>
        <section>
          <title><anchor xreflabel="Deployment descriptor" xml:id="_Toc466527399"/>Deployment descriptor</title>
          <para>The deployment descriptor is an XML file that contains information about your EJB. Using XML allows the deployer to easily change attributes about your EJB. The configurable attributes defined in the deployment descriptor include: </para>
          <para>The Home and Remote interface names that are required by your EJB</para>
          <para>The name to publish into JNDI for your EJBs Home interface</para>
          <para>Transactional attributes for each method of your EJB</para>
          <para>Access Control Lists for authentication</para>
        </section>
        <section>
          <title><anchor xreflabel="EJB-Jar file" xml:id="_Toc466527400"/>EJB-Jar file</title>
          <para>The EJB-Jar file is a normal java jar file that contains your EJB, Home and Remote interfaces, as well as the deployment descriptor.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064908"/><anchor xreflabel="EJB " xml:id="_Toc466527401"/>EJB operation</title>
        <para>Once you have an EJB-Jar file containing the Bean, the Home and Remote interfaces, and the deployment descriptor, you can fit all of the pieces together and in the process understand why the Home and Remote interfaces are needed and how the EJB Container uses them.</para>
        <para>The EJB Container implements the Home and Remote interfaces that are in the EJB-Jar file. As mentioned earlier, the Home interface provides methods to create and find your EJB. This means that the EJB Container is responsible for the lifecycle management of your EJB. This level of indirection allows for optimizations to occur. For example, 5 clients might simultaneously request the creation of an EJB through a Home Interface, and the EJB Container would respond by creating only one EJB and sharing it between all 5 clients. This is achieved through the Remote Interface, which is also implemented by the EJB Container. The implemented Remote object plays the role of a proxy object to the EJB.</para>
        <para>All calls to the EJB are �proxied� through the EJB Container via the Home and Remote interfaces. This indirection is the reason why the EJB container can control security and transactional behavior.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064909"/><anchor xreflabel="Types
of EJBs" xml:id="_Toc466527403"/>Types of EJBs</title>
        <para>The Enterprise JavaBeans specification defines different types of EJBs that have different characteristics and behaviors. Two categories of EJBs have been defined in the specification: <emphasis role="italic">Session Beans</emphasis> and <emphasis role="italic">Entity Beans</emphasis>, and each categoriy has variations.</para>
        <section>
          <title><anchor xreflabel="Session Beans" xml:id="_Toc466527404"/>Session Beans</title>
          <para>Session Beans are used to represent Use-Cases or Workflow on behalf of a client. They represent operations on persistent data, but not the persistent data itself. There are two types of Session Beans, <emphasis role="italic">Stateless</emphasis> and <emphasis role="italic">Stateful</emphasis>. All Session Beans must implement the <emphasis role="bold">javax.ejb.SessionBean</emphasis> interface. The EJB Container governs the life of a Session Bean.</para>
          <para><emphasis role="bold">Stateless Session Beans </emphasis>are the simplest type of EJB component to implement. They do not maintain any conversational state with clients between method invocations so they are easily reusable on the server side and because they can be cached, they scale well on demand. When using Stateless Session Beans, all state must be stored outside of the EJB.</para>
          <para><emphasis role="bold">Stateful Session Beans </emphasis>maintain state between invocations. They have a one-to-one logical mapping to a client and can maintain state within themselves. The EJB Container is responsible for pooling and caching of Stateful Session Beans, which is achieved through <emphasis role="italic">Passivation</emphasis> and <emphasis role="italic">Activation</emphasis>. If the EJB Container crashes, data for all Stateful Session Beans could be lost. Some high-end EJB Containers provide recovery for Stateful Session Beans.</para>
        </section>
        <section>
          <title><anchor xreflabel="Entity Beans" xml:id="_Toc466527405"/>Entity Beans</title>
          <para>Entity Beans are components that represent persistent data and behavior of this data. Entity Beans can be shared among multiple clients, the same way that data in a database can be shared. The EJB Container is responsible for caching Entity Beans and for maintaining the integrity of the Entity Beans. The life of an Entity Bean outlives the EJB Container, so if an EJB Container crashes, the Entity Bean is still expected to be available when the EJB Container again becomes available.</para>
          <para>There are two types of Entity Beans: those with Container Managed persistence and those with Bean-Managed persistence.</para>
          <para><emphasis role="bold">Container Managed Persistence (CMP)</emphasis>. A CMP Entity Bean has its persistence implemented on its behalf by the EJB Container. Through attributes specified in the deployment descriptor, the EJB Container will map the Entity Bean�s attributes to some persistent store (usually�but not always�a database). CMP reduces the development time for the EJB, as well as dramatically reducing the amount of code required.</para>
          <para><emphasis role="bold">Bean Managed Persistence (BMP)</emphasis>. A BMP Entity Bean has its persistence implemented by the Enterprise Bean Provider. The Enterprise Bean Provider is responsible for implementing the logic required to create a new EJB, update some attributes of the EJBS, delete an EJB and find an EJB from persistent store. This usually involves writing JDBC code to interact with a database or other persistent store. With BMP, the developer is in full control of how the Entity Bean persistence is managed.</para>
          <para>BMP also gives flexibility where a CMP implementation may not be available. For example, if you wanted to create an EJB that wrapped some code on an existing mainframe system, you could write your persistence using CORBA.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064910"/><anchor xreflabel="Developing
an " xml:id="_Toc476631340"/>Developing an EJB</title>
        <para>As an example, the �Perfect Time� example from the previous RMI section will be implemented as an EJB component. The example will be a simple Stateless Session Bean. </para>
        <para>As mentioned earlier, EJB components consist of at least one class (the EJB) and two interfaces: the Remote and Home interfaces. When you create a Remote interface for an EJB , you must follow these guidelines:</para>
        <para>The remote interface must be <emphasis role="bold">public</emphasis>. </para>
        <para>128.   The remote interface must extend the interface <emphasis role="bold">javax.ejb.EJBObject</emphasis>. </para>
        <para>129.   Each method in the remote interface must declare <emphasis role="bold">java.rmi.RemoteException</emphasis> in its <emphasis role="bold">throws</emphasis> clause in addition to any application-specific exceptions. </para>
        <para>130.   Any object passed as an argument or return value (either directly or embedded within a local object) must be a valid RMI-IIOP data type (this includes other EJB objects).</para>
        <para>Here is the simple remote interface for the PerfectTime EJB:</para>
        <para>//: c15:ejb:PerfectTime.java</para>
        <para>//# You must install the J2EE Java Enterprise </para>
        <para>//# Edition from java.sun.com and add j2ee.jar</para>
        <para>//# to your CLASSPATH in order to compile</para>
        <para>//# this file. See details at java.sun.com.</para>
        <para>// Remote Interface of PerfectTimeBean</para>
        <para>import java.rmi.*;</para>
        <para>import javax.ejb.*;</para>
        <para> </para>
        <para>public interface PerfectTime extends EJBObject {</para>
        <para>� public long getPerfectTime() </para>
        <para>��� throws RemoteException;</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The Home interface is the factory where the component will be created. It can define <emphasis role="italic">create</emphasis> methods, to create instances of EJBs, or <emphasis role="italic">finder</emphasis> methods, which locate existing EJBs and are used for Entity Beans only. When you create a Home interface for an EJB , you must follow these guidelines:</para>
        <para>The Home interface must be <emphasis role="bold">public</emphasis>. </para>
        <para>131.   The Home interface must extend the interface <emphasis role="bold">javax.ejb.EJBHome</emphasis>. </para>
        <para>132.   Each <emphasis role="italic">create</emphasis> method in the Home interface must declare <emphasis role="bold">java.rmi.RemoteException</emphasis> in its <emphasis role="bold">throws</emphasis> clause as well as a <emphasis role="bold">javax.ejb.CreateException</emphasis>.</para>
        <para>133.   The return value of a <emphasis role="italic">create</emphasis> method must be a Remote Interface.</para>
        <para>134.   The return value of a <emphasis role="italic">finder</emphasis> method (Entity Beans only) must be a Remote Interface or <emphasis role="bold">java.util.Enumeration</emphasis> or <emphasis role="bold">java.util.Collection</emphasis>.</para>
        <para>135.   Any object passed as an argument (either directly or embedded within a local object) must be a valid RMI-IIOP data type (this includes other EJB objects)</para>
        <para>The standard naming convention for Home interfaces is to take the Remote interface name and append �Home� to the end. Here is the Home interface for the PerfectTime EJB:</para>
        <para>//: c15:ejb:PerfectTimeHome.java</para>
        <para>// Home Interface of PerfectTimeBean.</para>
        <para>import java.rmi.*;</para>
        <para>import javax.ejb.*;</para>
        <para> </para>
        <para>public interface PerfectTimeHome extends EJBHome {</para>
        <para>� public PerfectTime create() </para>
        <para>��� throws CreateException, RemoteException;</para>
        <para>} ///:~</para>
        <para> </para>
        <para>You can now implement the business logic. When you create your EJB implementation class, you must follow these guidelines, (note that you should consult the EJB specification for a complete list of guidelines when developing Enterprise JavaBeans):</para>
        <para>The class must be <emphasis role="bold">public</emphasis>. </para>
        <para>136.   The class must implement an EJB interface (either <emphasis role="bold">javax.ejb.SessionBean </emphasis>or<emphasis role="bold"> javax.ejb.EntityBean</emphasis>). </para>
        <para>137.   The class should define methods that map directly to the methods in the Remote interface. Note that the class does not implement the Remote interface; it mirrors the methods in the Remote interface but does <emphasis role="italic">not</emphasis> throw <emphasis role="bold">java.rmi.RemoteException</emphasis>.</para>
        <para>138.   Define one or more <emphasis role="bold">ejbCreate( )</emphasis> methods to initialize your EJB.</para>
        <para>139.   The return value and arguments of all methods must be valid RMI-IIOP data types.</para>
        <para>//: c15:ejb:PerfectTimeBean.java</para>
        <para>// Simple Stateless Session Bean </para>
        <para>// that returns current system time.</para>
        <para>import java.rmi.*;</para>
        <para>import javax.ejb.*;</para>
        <para> </para>
        <para>public class PerfectTimeBean </para>
        <para>� implements SessionBean {</para>
        <para>� private SessionContext sessionContext;</para>
        <para>� //return current time</para>
        <para>� public long getPerfectTime() { </para>
        <para>���� return System.currentTimeMillis();</para>
        <para>� }</para>
        <para>� // EJB methods</para>
        <para>� public void ejbCreate() </para>
        <para>� throws CreateException {}</para>
        <para>� public void ejbRemove() {}</para>
        <para>� public void ejbActivate() {}</para>
        <para>� public void ejbPassivate() {}</para>
        <para>� public void </para>
        <para>� setSessionContext(SessionContext ctx) {</para>
        <para>��� sessionContext = ctx;</para>
        <para>� }</para>
        <para>}///:~</para>
        <para> </para>
        <para>Because this is a simple example, the EJB methods (<emphasis role="bold">ejbCreate( )</emphasis>, <emphasis role="bold">ejbRemove( )</emphasis>, <emphasis role="bold">ejbActivate( )</emphasis>, <emphasis role="bold">ejbPassivate( )</emphasis> ) are all empty. These methods are invoked by the EJB Container and are used to control the state of the component. The <emphasis role="bold">setSessionContext( )</emphasis> method passes a <emphasis role="bold">javax.ejb.SessionContext</emphasis> object which contains information about the component�s context, such as the current transaction and security information.</para>
        <para>After we have created the Enterprise JavaBean, we then need to create a deployment descriptor. The deployment descriptor is an XML file that describes the EJB component. The deployment descriptor should be stored in a file called <emphasis role="bold">ejb-jar.xml</emphasis>.</para>
        <para>//:! c15:ejb:ejb-jar.xml</para>
        <para>&lt;?xml version=&quot;1.0&quot; encoding=&quot;Cp1252&quot;?&gt;</para>
        <para>&lt;!DOCTYPE ejb-jar PUBLIC &apos;-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN&apos;&apos;http://java.sun.com/j2ee/dtds/ejb-jar_1_1.dtd&apos;&gt;</para>
        <para> </para>
        <para>&lt;ejb-jar&gt;</para>
        <para>� &lt;description&gt;Example for Chapter 15&lt;/description&gt;</para>
        <para>� &lt;display-name&gt;&lt;/display-name&gt;</para>
        <para>� &lt;small-icon&gt;&lt;/small-icon&gt;</para>
        <para>� &lt;large-icon&gt;&lt;/large-icon&gt;</para>
        <para>� &lt;enterprise-beans&gt;</para>
        <para>��� &lt;session&gt;</para>
        <para>����� &lt;ejb-name&gt;PerfectTime&lt;/ejb-name&gt;</para>
        <para>��� ��&lt;home&gt;PerfectTimeHome&lt;/home&gt;</para>
        <para>����� &lt;remote&gt;PerfectTime&lt;/remote&gt;</para>
        <para>����� &lt;ejb-class&gt;PerfectTimeBean&lt;/ejb-class&gt;</para>
        <para>����� &lt;session-type&gt;Stateless&lt;/session-type&gt;</para>
        <para>����� &lt;transaction-type&gt;Container&lt;/transaction-type&gt;</para>
        <para>��� &lt;/session&gt;</para>
        <para>� &lt;/enterprise-beans&gt;</para>
        <para>� &lt;ejb-client-jar&gt;&lt;/ejb-client-jar&gt;</para>
        <para>&lt;/ejb-jar&gt;</para>
        <para>///:~</para>
        <para> </para>
        <para>You can see the Component, the Remote interface and the Home interface defined inside the <emphasis role="bold">&lt;session&gt; </emphasis>tag of this deployment descriptor. Deployment descriptors may be automatically generated using EJB development tools.</para>
        <para>Along with the standard <emphasis role="bold">ejb-jar.xml </emphasis>deployment descriptor, the EJB specification states that any vendor specific tags should be stored in a separate file. This is to achieve high portability between components and different brands of EJB containers.</para>
        <para>The files must be archived inside a standard Java Archive (JAR) file. The deployment descriptors should be placed inside the <emphasis role="bold">/META-INF </emphasis>sub-directory of the Jar file.</para>
        <para>Once the EJB component is defined in the deployment descriptor, the deployer should then deploy the EJB component into the EJB Container. At the time of this writing, the deployment process was quite �GUI intensive� and specific to each individual EJB Container, so this overview does not document that process. Every EJB Container, however will have a documented process for deploying an EJB.</para>
        <para>Because an EJB component is a distributed object, the deployment process should also create some client stubs for calling the EJB component. These classes should be placed on the classpath of the client application. Because EJB components can be implemented on top of RMI-IIOP (CORBA) or RMI-JRMP, the stubs generated could vary between EJB Containers; nevertheless they are generated classes.</para>
        <para>When a client program wishes to invoke an EJB, it must look up the EJB component inside JNDI and obtain a reference to the home interface of the EJB component. The Home interface is used to create an instance of the EJB. </para>
        <para>In this example the client program is a simple Java program, but you should remember that it could just as easily be a servlet, a JSP or even a CORBA or RMI distributed object.</para>
        <para>//: c15:ejb:PerfectTimeClient.java</para>
        <para>// Client program for PerfectTimeBean</para>
        <para> </para>
        <para>public class PerfectTimeClient {</para>
        <para>public static void main(String[] args) </para>
        <para>throws Exception {</para>
        <para>� // Get a JNDI context using </para>
        <para>� // the JNDI Naming service:</para>
        <para>� javax.naming.Context context = </para>
        <para>��� new javax.naming.InitialContext();</para>
        <para>� // Look up the home interface in the </para>
        <para>� // JNDI Naming service:</para>
        <para>� Object ref = context.lookup(&quot;perfectTime&quot;);</para>
        <para>� // Cast the remote object to the home interface:</para>
        <para>� PerfectTimeHome home = (PerfectTimeHome)</para>
        <para>��� javax.rmi.PortableRemoteObject.narrow(</para>
        <para>����� ref, PerfectTimeHome.class);</para>
        <para>� // Create a remote object from the home interface:</para>
        <para>� PerfectTime pt = home.create();</para>
        <para>� // Invoke� getPerfectTime()</para>
        <para>� System.out.println(</para>
        <para>��� &quot;Perfect Time EJB invoked, time is: &quot; + </para>
        <para>��� pt.getPerfectTime() );</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The sequence of the example is explained in the comments. Note the use of the <emphasis role="bold">narrow( )</emphasis> method to perform a kind of casting of the object before a Java cast is performed. This is very similar to what happens in CORBA. Also note that the Home object becomes a factory for <emphasis role="bold">PerfectTime</emphasis> objects.</para>
      </section>
      <section>
        <title><anchor xreflabel="EJB summary" xml:id="_Toc481064911"/>EJB summary</title>
        <para>The Enterprise JavaBeans specification is a dramatic step forward in the standardization and simplification of distributed object computing. It is a major piece of the Java 2 Enterprise Edition (J2EE) platform and is receiving much support from the distributed object community. Many tools are currently available or will be available in the near future to help accelerate the development of EJB components.</para>
        <para>This overview was only a brief tour of EJBs. For more information about the EJB specification you should see the official Enterprise JavaBeans home page at <emphasis role="italic">java.sun.com/products/ejb/,</emphasis> where you can download the latest specification and the J2EE reference implementation. These can be used to develop and deploy your own EJB components.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Jini: distributed services" xml:id="_Toc481064912"/>Jini: distributed services</title>
      <para>This section<anchor xreflabel="[78]" xml:id="_ftnref78"/>[78] gives an overview of Sun Microsystems�s Jini technology. It describes some Jini nuts and bolts and shows how Jini�s architecture helps to raise the level of abstraction in distributed systems programming, effectively turning network programming into object-oriented programming. </para>
      <section>
        <title><anchor xreflabel="Jini in context" xml:id="_Toc481064913"/>Jini in context</title>
        <para>Traditionally, operating systems have been designed with the assumption that a computer will have a processor, some memory, and a disk. When you boot a computer, the first thing it does is look for a disk. If it doesn�t find a disk, it can�t function as a computer. Increasingly, however, computers are appearing in a different guise: as embedded devices that have a processor, some memory, and a network connection�but no disk. The first thing a cell phone does when you boot it up, for example, is look for the telephone network. If it doesn�t find the network, it can�t function as a cell phone. This trend in the hardware environment, from disk-centric to network-centric, will affect how we organize the software�and that�s where Jini comes in. </para>
        <para>Jini is an attempt to rethink computer architecture, given the rising importance of the network and the proliferation of processors in devices that have no disk drive. These devices, which will come from many different vendors, will need to interact over a network. The network itself will be very dynamic�devices and services will be added and removed regularly. Jini provides mechanisms to enable smooth adding, removal, and finding of devices and services on the network. In addition, Jini provides a programming model that makes it easier for programmers to get their devices talking to each other. </para>
        <para>Building on top of Java, object serialization, and RMI (which together enable objects to move around the network from virtual machine to virtual machine) Jini attempts to extend the benefits of object-oriented programming to the network. Instead of requiring device vendors to agree on the network protocols through which their devices can interact, Jini enables the devices to talk to each other through interfaces to objects.</para>
      </section>
      <section>
        <title><anchor xreflabel="What is Jini?" xml:id="_Toc481064914"/>What is Jini?</title>
        <para>Jini is a set of APIs and network protocols that can help you build and deploy distributed systems that are organized as <emphasis role="italic">federations of services</emphasis>. A <emphasis role="italic">service</emphasis> can be anything that sits on the network and is ready to perform a useful function. Hardware devices, software, communications channels�even human users themselves�can be services. A Jini-enabled disk drive, for example, could offer a �storage� service. A Jini-enabled printer could offer a �printing� service. A federation of services, then, is a set of services, currently available on the network, that a client (meaning a program, service, or user) can bring together to help it accomplish some goal. </para>
        <para>To perform a task, a client enlists the help of services. For example, a client program might upload pictures from the image storage service in a digital camera, download the pictures to a persistent storage service offered by a disk drive, and send a page of thumbnail-sized versions of the images to the printing service of a color printer. In this example, the client program builds a distributed system consisting of itself, the image storage service, the persistent storage service, and the color-printing service. The client and services of this distributed system work together to perform the task: to offload and store images from a digital camera and print a page of thumbnails. </para>
        <para>The idea behind the word <emphasis role="italic">federation </emphasis>is that the Jini view of the network doesn�t involve a central controlling authority. Because no one service is in charge, the set of all services available on the network form a federation�a group composed of equal peers. Instead of a central authority, Jini�s run-time infrastructure merely provides a way for clients and services to find each other (via a lookup service, which stores a directory of currently available services). After services locate each other, they are on their own. The client and its enlisted services perform their task independently of the Jini run-time infrastructure. If the Jini lookup service crashes, any distributed systems brought together via the lookup service before it crashed can continue their work. Jini even includes a network protocol that clients can use to find services in the absence of a lookup service. </para>
      </section>
      <section>
        <title><anchor xreflabel="How Jini works" xml:id="_Toc481064915"/>How Jini works</title>
        <para>Jini defines a <emphasis role="italic">run-time infrastructure </emphasis>that resides on the network and provides mechanisms that enable you to add, remove, locate, and access services. The run-time infrastructure resides in three places: in lookup services that sit on the network, in the service providers (such as Jini-enabled devices), and in clients. <emphasis role="italic">Lookup services </emphasis>are the central organizing mechanism for Jini-based systems. When new services become available on the network, they register themselves with a lookup service. When clients wish to locate a service to assist with some task, they consult a lookup service. </para>
        <para>The run-time infrastructure uses one network-level protocol, called <emphasis role="italic">discovery</emphasis>, and two object-level protocols, called <emphasis role="italic">join </emphasis>and <emphasis role="italic">lookup</emphasis>. Discovery enables clients and services to locate lookup services. Join enables a service to register itself in a lookup service. Lookup enables a client to query for services that can help accomplish its goals. </para>
      </section>
      <section>
        <title><anchor xreflabel="The discovery process" xml:id="_Toc481064916"/>The discovery process</title>
        <para>Discovery works like this: Imagine you have a Jini-enabled disk drive that offers a persistent storage service. As soon as you connect the drive to the network, it broadcasts a <emphasis role="italic">presence announcement </emphasis>by dropping a multicast packet onto a well-known port. Included in the presence announcement is an IP address and port number where the disk drive can be contacted by a lookup service. </para>
        <para>Lookup services monitor the well-known port for presence announcement packets. When a lookup service receives a presence announcement, it opens and inspects the packet. The packet contains information that enables the lookup service to determine whether or not it should contact the sender of the packet. If so, it contacts the sender directly by making a TCP connection to the IP address and port number extracted from the packet. Using RMI, the lookup service sends an object, called a <emphasis role="italic">service registrar</emphasis>, across the network to the originator of the packet. The purpose of the service registrar object is to facilitate further communication with the lookup service. By invoking methods on this object, the sender of the announcement packet can perform join and lookup on the lookup service. In the case of the disk drive, the lookup service would make a TCP connection to the disk drive and would send it a service registrar object, through which the disk drive would then register its persistent storage service via the join process.</para>
      </section>
      <section>
        <title><anchor xreflabel="The join process" xml:id="_Toc481064917"/>The join process</title>
        <para>Once a service provider has a service registrar object, the end product of discovery, it is ready to do a join�to become part of the federation of services that are registered in the lookup service. To do a join, the service provider invokes the <emphasis role="bold">register( ) </emphasis>method on the service registrar object, passing as a parameter an object called a service item, a bundle of objects that describe the service. The <emphasis role="bold">register( )</emphasis> method sends a copy of the service item up to the lookup service, where the service item is stored. Once this has completed, the service provider has finished the join process: its service has become registered in the lookup service. </para>
        <para>The service item is a container for several objects, including an object called a <emphasis role="italic">service object</emphasis>, which clients can use to interact with the service. The service item can also include any number of <emphasis role="italic">attributes</emphasis>, which can be any object. Some potential attributes are icons, classes that provide GUIs for the service, and objects that give more information about the service. </para>
        <para>Service objects usually implement one or more interfaces through which clients interact with the service. For example, a lookup service is a Jini service, and its service object is the service registrar. The <emphasis role="bold">register( )</emphasis> method invoked by service providers during join is declared in the <emphasis role="bold">ServiceRegistrar</emphasis> interface (a member of the <emphasis role="bold">net.jini.core.lookup</emphasis> package), which all service registrar objects implement. Clients and service providers talk to the lookup service through the service registrar object by invoking methods declared in the <emphasis role="bold">ServiceRegistrar</emphasis> interface. Likewise, a disk drive would provide a service object that implemented some well-known storage service interface. Clients would look up and interact with the disk drive by this storage service interface. </para>
      </section>
      <section>
        <title><anchor xreflabel="The lookup process" xml:id="_Toc481064918"/>The lookup process</title>
        <para>Once a service has registered with a lookup service via the join process, that service is available for use by clients who query that lookup service. To build a distributed system of services that will work together to perform some task, a client must locate and enlist the help of the individual services. To find a service, clients query lookup services via a process called <emphasis role="italic">lookup</emphasis>. </para>
        <para>To perform a lookup, a client invokes the <emphasis role="bold">lookup</emphasis>( ) method on a service registrar object. (A client, like a service provider, gets a service registrar through the previously-described process of discovery.) The client passes as an argument to <emphasis role="bold">lookup( )</emphasis> a <emphasis role="italic">service template</emphasis>, an object that serves as search criteria for the query. The service template can include a reference to an array of <emphasis role="bold">Class</emphasis> objects. These <emphasis role="bold">Class</emphasis> objects indicate to the lookup service the Java type (or types) of the service object desired by the client. The service template can also include a <emphasis role="italic">service ID</emphasis>, which uniquely identifies a service, and attributes, which must exactly match the attributes uploaded by the service provider in the service item. The service template can also contain wildcards for any of these fields. A wildcard in the service ID field, for example, will match any service ID. The <emphasis role="bold">lookup( ) </emphasis>method sends the service template to the lookup service, which performs the query and sends back zero to any matching service objects. The client gets a reference to the matching service objects as the return value of the <emphasis role="bold">lookup( )</emphasis> method. </para>
        <para>In the general case, a client looks up a service by Java type, usually an interface. For example, if a client needed to use a printer, it would compose a service template that included a <emphasis role="bold">Class </emphasis>object for a well-known interface to printer services. All printer services would implement this well-known interface. The lookup service would return a service object (or objects) that implemented this interface. Attributes can be included in the service template to narrow the number of matches for such a type-based search. The client would use the printer service by invoking methods from the well-known printer service interface on the service object. </para>
      </section>
      <section>
        <title><anchor xreflabel="Separation of interface and
implementation" xml:id="_Toc481064919"/>Separation of interface and implementation</title>
        <para>Jini�s architecture brings object-oriented programming to the network by enabling network services to take advantage of one of the fundamentals of objects: the separation of interface and implementation. For example, a service object can grant clients access to the service in many ways. The object can actually represent the entire service, which is downloaded to the client during lookup and then executed locally. Alternatively, the service object can serve merely as a proxy to a remote server. Then when the client invokes methods on the service object, it sends the requests across the network to the server, which does the real work. A third option is for the local service object and a remote server to each do part of the work. </para>
        <para>One important consequence of Jini�s architecture is that the network protocol used to communicate between a proxy service object and a remote server does not need to be known to the client. As illustrated in the figure below, the network protocol is part of the service�s implementation. This protocol is a private matter decided upon by the developer of the service. The client can communicate with the service via this private protocol because the service injects some of its own code (the service object) into the client�s address space. The injected service object could communicate with the service via RMI, CORBA, DCOM, some home-brewed protocol built on top of sockets and streams, or anything else. The client simply doesn�t need to care about network protocols, because it can talk to the well-known interface that the service object implements. The service object takes care of any necessary communication on the network. </para>
        <para><inlinemediaobject><imageobject role="html">
              <imagedata contentdepth="165" contentwidth="471" fileref="./TIJ2_files/image032.png" format="PNG" scalefit="1"/>
            </imageobject>
<imageobject role="fo">
              <imagedata contentdepth="100%" fileref="./TIJ2_files/image032.png" format="PNG" scalefit="1" width="100%"/>
            </imageobject>
</inlinemediaobject></para>
        <para><emphasis role="bold">The client talks to the service through a well-known interface</emphasis></para>
        <para>Different implementations of the same service interface can use completely different approaches and network protocols. A service can use specialized hardware to fulfill client requests, or it can do all its work in software. In fact, the implementation approach taken by a single service can evolve over time. The client can be sure it has a service object that understands the current implementation of the service, because the client receives the service object (by way of the lookup service) from the service provider itself. To the client, a service looks like the well-known interface, regardless of how the service is implemented. </para>
      </section>
      <section>
        <title><anchor xreflabel="Abstracting distributed systems" xml:id="_Toc481064920"/>Abstracting distributed systems</title>
        <para>Jini attempts to raise the level of abstraction for distributed systems programming, from the network protocol level to the object interface level. In the emerging proliferation of embedded devices connected to networks, many pieces of a distributed system may come from different vendors. Jini makes it unnecessary for vendors of devices to agree on network level protocols that allow their devices to interact. Instead, vendors must agree on Java interfaces through which their devices can interact. The processes of discovery, join, and lookup, provided by the Jini run-time infrastructure, enable devices to locate each other on the network. Once they locate each other, devices can communicate with each other through Java interfaces.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Summary" xml:id="_Toc481064921"/>Summary</title>
      <para>Along with Jini for local device networks, this chapter has introduced some, but not all, of the components that Sun refers to as J2EE: the <emphasis role="italic">Java 2 Enterprise Edition</emphasis>. The goal of J2EE is to build a set of tools that allows the Java developer to build server-based applications much more quickly, and in a platform-independent way. It�s not only difficult and time-consuming to build such applications, but it�s especially hard to build them so that they can be easily ported to other platforms, and also to keep the business logic separated from the underlying details of the implementation. J2EE provides a framework to assist in creating server-based applications; these applications are in demand now, and that demand appears to be increasing.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064922"/><anchor xreflabel="Exercises" xml:id="_Toc375545500"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Compile and run the <emphasis role="bold">JabberServer</emphasis> and <emphasis role="bold">JabberClient</emphasis> programs in this chapter. Now edit the files to remove all of the buffering for the input and output, then compile and run them again to observe the results.</para>
      <para>  244.         Create a server that asks for a password, then opens a file and sends the file over the network connection. Create a client that connects to this server, gives the appropriate password, then captures and saves the file. Test the pair of programs on your machine using the <emphasis role="bold">localhost</emphasis> (the local loopback IP address <emphasis role="bold">127.0.0.1</emphasis> produced by calling <emphasis role="bold">InetAddress.getByName(null)</emphasis>).</para>
      <para>  245.         Modify the server in Exercise 2 so that it uses multithreading to handle multiple clients.</para>
      <para>  246.         Modify <emphasis role="bold">JabberClient.java</emphasis> so that output flushing doesn�t occur and observe the effect. </para>
      <para>  247.         Modify <emphasis role="bold">MultiJabberServer</emphasis> so that it uses <emphasis role="italic">thread pooling</emphasis>. Instead of throwing away a thread each time a client disconnects, the thread should put itself into an �available pool� of threads. When a new client wants to connect, the server will look in the available pool for a thread to handle the request, and if one isn�t available, make a new one. This way the number of threads necessary will naturally grow to the required quantity. The value of thread pooling is that it doesn�t require the overhead of creating and destroying a new thread for each new client.</para>
      <para>  248.         Starting with <emphasis role="bold">ShowHTML.java</emphasis>, create an applet that is a password-protected gateway to a particular portion of your Web site.</para>
      <para>  249.         Modify <emphasis role="bold">CIDCreateTables.java</emphasis> so that it reads the SQL strings from a text file instead of <emphasis role="bold">CIDSQL</emphasis>.</para>
      <para>  250.         Configure your system so that you can successfully execute <emphasis role="bold">CIDCreateTables.java</emphasis> and <emphasis role="bold">LoadDB.java</emphasis>.</para>
      <para>  251.         Modify <emphasis role="bold">ServletsRule.java</emphasis> by overriding the <emphasis role="bold">destroy( )</emphasis> method to save the value of <emphasis role="bold">i</emphasis> to a file, and and the <emphasis role="bold">init( )</emphasis> method to restore the value. Demonstrate that it works by rebooting the servlet container. If you do not have an existing servlet container, you will need to download, install, and run Tomcat from <anchor xreflabel="" xml:id="BBB"/><emphasis role="italic">jakarta.apache.org</emphasis> in order to run servlets.</para>
      <para>  252.         Create a servlet that adds a cookie to the response object, thereby storing it on the client�s site. Add code to the servlet that retrieves and displays the cookie. If you do not have an existing servlet container, you will need to download, install, and run Tomcat from <emphasis role="italic">jakarta.apache.org</emphasis> in order to run servlets.</para>
      <para>  253.         Create a servlet that uses a <emphasis role="bold">Session</emphasis> object to store session information of your choosing. In the same servlet, retrieve and display that session information. If you do not have an existing servlet container, you will need to download, install, and run Tomcat from <emphasis role="italic">jakarta.apache.org</emphasis> in order to run servlets.</para>
      <para>  254.         Create a servlet that changes the inactive interval of a session to 5 seconds by calling <emphasis role="bold">getMaxInactiveInterval( )</emphasis>. Test to see that the session does indeed expire after 5 seconds. If you do not have an existing servlet container, you will need to download, install, and run Tomcat from <emphasis role="italic">jakarta.apache.org</emphasis> in order to run servlets.</para>
      <para>  255.         Create a JSP page that prints a line of text using the &lt;H1&gt; tag. Set the color of this text randomly, using Java code embedded in the JSP page. If you do not have an existing JSP container, you will need to download, install, and run Tomcat from <emphasis role="italic">jakarta.apache.org</emphasis> in order to run JSPs.</para>
      <para>  256.         Modify the maximum age value in <emphasis role="bold">Cookies.jsp</emphasis> and observe the behavior under two different browsers. Also note the difference between just re-visiting the page, and shutting down and restarting the browser. If you do not have an existing JSP container, you will need to download, install, and run Tomcat from <emphasis role="italic">jakarta.apache.org</emphasis> in order to run JSPs.</para>
      <para>  257.         Create a JSP with a field that allows the user to enter the session expiration time and and a second field that holds data that is stored in the session. The submit button refreshes the page and fetches the current expiration time and session data and puts them in as default values of the aforementioned fields. If you do not have an existing JSP container, you will need to download, install, and run Tomcat from <emphasis role="italic">jakarta.apache.org</emphasis> in order to run JSPs.</para>
      <para>  258.         (More challenging) Take the <emphasis role="bold">VLookup.java</emphasis> program and modify it so that when you click on the resulting name it automatically takes that name and copies it to the clipboard (so you can simply paste it into your email). You�ll need to look back at Chapter 13 to remember how to use the clipboard in JFC.<anchor xreflabel="" xml:id="Chapter_13"/></para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc375545505"/><anchor xreflabel="" xml:id="_Toc481064923"/><anchor xreflabel="" xml:id="_Toc477690736"/><anchor xreflabel="" xml:id="_Toc375545421"/><anchor xreflabel="" xml:id="Appendix_A"/>A: Passing &amp; Returning Objects</title>
    <para>By now you should be reasonably comfortable with the idea that when you�re �passing� an object, you�re actually passing a reference.</para>
    <para>In many programming languages you can use that language�s �regular� way to pass objects around, and most of the time everything works fine. But it always seems that there comes a point at which you must do something irregular and suddenly things get a bit more complicated (or in the case of C++, quite complicated). Java is no exception, and it�s important that you understand exactly what�s happening as you pass objects around and manipulate them. This appendix will provide that insight.</para>
    <para>Another way to pose the question of this appendix, if you�re coming from a programming language so equipped, is �Does Java have pointers?� Some have claimed that pointers are hard and dangerous and therefore bad, and since Java is all goodness and light and will lift your earthly programming burdens, it cannot possibly contain such things. However, it�s more accurate to say that Java has pointers; indeed, every object identifier in Java (except for primitives) is one of these pointers, but their use is restricted and guarded not only by the compiler but by the run-time system. Or to put it another way, Java has pointers, but no pointer arithmetic. These are what I�ve been calling �references,� and you can think of them as �safety pointers,� not unlike the safety scissors of elementary school�they aren�t sharp, so you cannot hurt yourself without great effort, but they can sometimes be slow and tedious.</para>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064924"/><anchor xreflabel="Passing
references around" xml:id="_Toc375545422"/>Passing references around</title>
      <para>When you pass a reference into a method, you�re still pointing to the same object. A simple experiment demonstrates this:</para>
      <para>//: appendixa:PassReferences.java</para>
      <para>// Passing references around.</para>
      <para> </para>
      <para>public class PassReferences {</para>
      <para>� static void f(PassReferences h) {</para>
      <para>��� System.out.println(&quot;h inside f(): &quot; + h);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� PassReferences p = new PassReferences();</para>
      <para>��� System.out.println(&quot;p inside main(): &quot; + p);</para>
      <para>��� f(p);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The method <emphasis role="bold">toString( )</emphasis> is automatically invoked in the print statements, and <emphasis role="bold">PassReferences</emphasis> inherits directly from <emphasis role="bold">Object</emphasis> with no redefinition of <emphasis role="bold">toString( )</emphasis>. Thus, <emphasis role="bold">Object</emphasis>�s version of <emphasis role="bold">toString( ) </emphasis>is used, which prints out the class of the object followed by the address where that object is located (not the reference, but the actual object storage). The output looks like this:</para>
      <para>p inside main(): PassReferences@1653748</para>
      <para>h inside f(): PassReferences@1653748</para>
      <para> </para>
      <para>You can see that both <emphasis role="bold">p</emphasis> and <emphasis role="bold">h</emphasis> refer to the same object. This is far more efficient than duplicating a new <emphasis role="bold">PassReferences</emphasis> object just so that you can send an argument to a method. But it brings up an important issue.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064925"/><anchor xreflabel="Aliasing" xml:id="_Toc375545423"/>Aliasing</title>
        <para>Aliasing means that more than one reference is tied to the same object, as in the above example. The problem with aliasing occurs when someone <emphasis role="italic">writes</emphasis> to that object. If the owners of the other references aren�t expecting that object to change, they�ll be surprised. This can be demonstrated with a simple example:</para>
        <para>//: appendixa:Alias1.java</para>
        <para>// Aliasing two references to one object.</para>
        <para> </para>
        <para>public class Alias1 {</para>
        <para>� int i;</para>
        <para>� Alias1(int ii) { i = ii; }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Alias1 x = new Alias1(7);</para>
        <para>��� Alias1 y = x; // Assign the reference</para>
        <para>��� System.out.println(&quot;x: &quot; + x.i);</para>
        <para>��� System.out.println(&quot;y: &quot; + y.i);</para>
        <para>��� System.out.println(&quot;Incrementing x&quot;);</para>
        <para>��� x.i++;</para>
        <para>��� System.out.println(&quot;x: &quot; + x.i);</para>
        <para>��� System.out.println(&quot;y: &quot; + y.i);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>In the line:</para>
        <para>Alias1 y = x; // Assign the reference</para>
        <para> </para>
        <para>a new <emphasis role="bold">Alias1</emphasis> reference is created, but instead of being assigned to a fresh object created with <emphasis role="bold">new</emphasis>, it�s assigned to an existing reference. So the contents of reference <emphasis role="bold">x</emphasis>, which is the address of the object <emphasis role="bold">x</emphasis> is pointing to, is assigned to <emphasis role="bold">y</emphasis>, and thus both <emphasis role="bold">x</emphasis> and <emphasis role="bold">y</emphasis> are attached to the same object. So when <emphasis role="bold">x</emphasis>�s <emphasis role="bold">i</emphasis> is incremented in the statement:</para>
        <para>x.i++;</para>
        <para> </para>
        <para><emphasis role="bold">y</emphasis>�s <emphasis role="bold">i </emphasis>will be affected as well. This can be seen in the output:</para>
        <para>x: 7</para>
        <para>y: 7</para>
        <para>Incrementing x</para>
        <para>x: 8</para>
        <para>y: 8</para>
        <para> </para>
        <para>One good solution in this case is to simply not do it: don�t consciously alias more than one reference to an object at the same scope. Your code will be much easier to understand and debug. However, when you�re passing a reference in as an argument�which is the way Java is supposed to work�you automatically alias because the local reference that�s created can modify the �outside object� (the object that was created outside the scope of the method). Here�s an example:</para>
        <para>//: appendixa:Alias2.java</para>
        <para>// Method calls implicitly alias their</para>
        <para>// arguments.</para>
        <para> </para>
        <para>public class Alias2 {</para>
        <para>� int i;</para>
        <para>� Alias2(int ii) { i = ii; }</para>
        <para>� static void f(Alias2 reference) {</para>
        <para>��� reference.i++;</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Alias2 x = new Alias2(7);</para>
        <para>��� System.out.println(&quot;x: &quot; + x.i);</para>
        <para>��� System.out.println(&quot;Calling f(x)&quot;);</para>
        <para>��� f(x);</para>
        <para>��� System.out.println(&quot;x: &quot; + x.i);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The output is:</para>
        <para>x: 7</para>
        <para>Calling f(x)</para>
        <para>x: 8</para>
        <para> </para>
        <para>The method is changing its argument, the outside object. When this kind of situation arises, you must decide whether it makes sense, whether the user expects it, and whether it�s going to cause problems.</para>
        <para>In general, you call a method in order to produce a return value and/or a change of state in the object <emphasis role="italic">that the method is called for</emphasis>. (A method is how you �send a message� to that object.) It�s much less common to call a method in order to manipulate its arguments; this is referred to as �calling a method for its <emphasis role="italic">side effects</emphasis>.� Thus, when you create a method that modifies its arguments the user must be clearly instructed and warned about the use of that method and its potential surprises. Because of the confusion and pitfalls, it�s much better to avoid changing the argument.</para>
        <para>If you need to modify an argument during a method call and you don�t intend to modify the outside argument, then you should protect that argument by making a copy inside your method. That�s the subject of much of this appendix.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Making local copies" xml:id="_Toc481064926"/>Making local copies</title>
      <para>To review: All argument passing in Java is performed by passing references. That is, when you pass �an object,� you�re really passing only a reference to an object that lives outside the method, so if you perform any modifications with that reference, you modify the outside object. In addition:</para>
      <para>�       Aliasing happens automatically during argument passing.</para>
      <para>�       There are no local objects, only local references.</para>
      <para>�       References have scopes, objects do not.</para>
      <para>�       Object lifetime is never an issue in Java.</para>
      <para>�       There is no language support (e.g., �const�) to prevent objects from being modified (that is, to prevent the negative effects of aliasing).</para>
      <para>If you�re only reading information from an object and not modifying it, passing a reference is the most efficient form of argument passing. This is nice; the default way of doing things is also the most efficient. However, sometimes it�s necessary to be able to treat the object as if it were �local� so that changes you make affect only a local copy and do not modify the outside object. Many programming languages support the ability to automatically make a local copy of the outside object, inside the method<anchor xreflabel="[79]" xml:id="_ftnref79"/>[79]. Java does not, but it allows you to produce this effect.</para>
      <section>
        <title><anchor xreflabel="Pass by value" xml:id="_Toc481064927"/>Pass by value</title>
        <para>This brings up the terminology issue, which always seems good for an argument. The term is �pass by value,� and the meaning depends on how you perceive the operation of the program. The general meaning is that you get a local copy of whatever you�re passing, but the real question is how you think about what you�re passing. When it comes to the meaning of �pass by value,� there are two fairly distinct camps:</para>
        <para>Java passes everything by value. When you�re passing primitives into a method, you get a distinct copy of the primitive. When you�re passing a reference into a method, you get a copy of the reference. Ergo, everything is pass-by-value. Of course, the assumption is that you�re always thinking (and caring) that references are being passed, but it seems like the Java design has gone a long way toward allowing you to ignore (most of the time) that you�re working with a reference. That is, it seems to allow you to think of the reference as �the object,� since it implicitly dereferences it whenever you make a method call.</para>
        <para>140.   Java passes primitives by value (no argument there), but objects are passed by reference. This is the world view that the reference is an alias for the object, so you <emphasis role="italic">don�t</emphasis> think about passing references, but instead say �I�m passing the object.� Since you don�t get a local copy of the object when you pass it into a method, objects are clearly not passed by value. There appears to be some support for this view within Sun, since one of the �reserved but not implemented� keywords was <emphasis role="bold">byvalue</emphasis>. (There�s no knowing, however, whether that keyword will ever see the light of day.)</para>
        <para>Having given both camps a good airing, and after saying �It depends on how you think of a reference,� I will attempt to sidestep the issue. In the end, it isn�t <emphasis role="italic">that</emphasis> important�what is important is that you understand that passing a reference allows the caller�s object to be changed unexpectedly.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064928"/><anchor xreflabel="Cloning
objects" xml:id="_Toc375545425"/>Cloning objects</title>
        <para>The most likely reason for making a local copy of an object is if you�re going to modify that object and you don�t want to modify the caller�s object. If you decide that you want to make a local copy, you simply use the <emphasis role="bold">clone( )</emphasis> method to perform the operation. This is a method that�s defined as <emphasis role="bold">protected </emphasis>in the base class <emphasis role="bold">Object</emphasis>, and which you must override as <emphasis role="bold">public </emphasis>in any derived classes that you want to clone. For example, the standard library class <emphasis role="bold">ArrayList</emphasis> overrides <emphasis role="bold">clone( )</emphasis>, so we can call <emphasis role="bold">clone( )</emphasis> for <emphasis role="bold">ArrayList</emphasis>:</para>
        <para>//: appendixa:Cloning.java</para>
        <para>// The clone() operation works for only a few</para>
        <para>// items in the standard Java library.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Int {</para>
        <para>� private int i;</para>
        <para>� public Int(int ii) { i = ii; }</para>
        <para>� public void increment() { i++; }</para>
        <para>� public String toString() { </para>
        <para>��� return Integer.toString(i); </para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Cloning {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� ArrayList v = new ArrayList();</para>
        <para>��� for(int i = 0; i &lt; 10; i++ )</para>
        <para>����� v.add(new Int(i));</para>
        <para>��� System.out.println(&quot;v: &quot; + v);</para>
        <para>��� ArrayList v2 = (ArrayList)v.clone();</para>
        <para>��� // Increment all v2&apos;s elements:</para>
        <para>��� for(Iterator e = v2.iterator();</para>
        <para>������� e.hasNext(); )</para>
        <para>����� ((Int)e.next()).increment();</para>
        <para>��� // See if it changed v&apos;s elements:</para>
        <para>��� System.out.println(&quot;v: &quot; + v);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The <emphasis role="bold">clone( )</emphasis> method produces an <emphasis role="bold">Object</emphasis>, which must then be recast to the proper type. This example shows how <emphasis role="bold">ArrayList</emphasis>�s<emphasis role="bold"> clone( )</emphasis> method <emphasis role="italic">does not</emphasis> automatically try to clone each of the objects that the <emphasis role="bold">ArrayList</emphasis> contains�the old <emphasis role="bold">ArrayList</emphasis> and the cloned <emphasis role="bold">ArrayList</emphasis> are aliased to the same objects. This is often called a <emphasis role="italic">shallow copy,</emphasis> since it�s copying only the �surface� portion of an object. The actual object consists of this �surface,� plus all the objects that the references are pointing to, plus all the objects <emphasis role="italic">those </emphasis>objects are pointing to, etc. This is often referred to as the �web of objects.� Copying the entire mess is called a <emphasis role="italic">deep copy.</emphasis></para>
        <para>You can see the effect of the shallow copy in the output, where the actions performed on <emphasis role="bold">v2 </emphasis>affect <emphasis role="bold">v</emphasis>:</para>
        <para>v: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</para>
        <para>v: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</para>
        <para> </para>
        <para>Not trying to <emphasis role="bold">clone( ) </emphasis>the objects contained in the <emphasis role="bold">ArrayList </emphasis>is probably a fair assumption because there�s no guarantee that those objects <emphasis role="italic">are</emphasis> cloneable<anchor xreflabel="[80]" xml:id="_ftnref80"/>[80].</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064929"/><anchor xreflabel="Adding
cloneability to a class" xml:id="_Toc375545426"/>Adding cloneability to a class</title>
        <para>Even though the clone method is defined in the base-of-all-classes <emphasis role="bold">Object</emphasis>, cloning is <emphasis role="italic">not </emphasis>automatically available in every class<anchor xreflabel="[81]" xml:id="_ftnref81"/>[81]. This would seem to be counterintuitive to the idea that base-class methods are always available in derived classes. Cloning in Java goes against this idea; if you want it to exist for a class, you must specifically add code to make cloning work.</para>
        <section>
          <title>Using a trick with <emphasis role="bold">protected</emphasis></title>
          <para>To prevent default cloneability in every class you create, the <emphasis role="bold">clone( )</emphasis> method is <emphasis role="bold">protected</emphasis> in the base class <emphasis role="bold">Object</emphasis>. Not only does this mean that it�s not available by default to the client programmer who is simply using the class (not subclassing it), but it also means that you cannot call <emphasis role="bold">clone( )</emphasis> via a reference to the base class. (Although that might seem to be useful in some situations, such as to polymorphically clone a bunch of <emphasis role="bold">Object</emphasis>s.) It is in effect a way to give you, at compile-time, the information that your object is not cloneable�and oddly enough most classes in the standard Java library are not cloneable. Thus, if you say:</para>
          <para>��� Integer x = new Integer(1);</para>
          <para>��� x = x.clone();</para>
          <para> </para>
          <para>You will get, at compile-time, an error message that says <emphasis role="bold">clone( ) </emphasis>is not accessible (since <emphasis role="bold">Integer</emphasis> doesn�t override it and it defaults to the <emphasis role="bold">protected</emphasis> version). </para>
          <para>If, however, you�re in a class derived from <emphasis role="bold">Object </emphasis>(as all classes are), then you have permission to call <emphasis role="bold">Object.clone( ) </emphasis>because it�s <emphasis role="bold">protected </emphasis>and you�re an inheritor. The base class <emphasis role="bold">clone( ) </emphasis>has useful functionality�it performs the actual bitwise duplication <emphasis role="italic">of the derived-class object</emphasis>, thus acting as the common cloning operation. However, you then need to make <emphasis role="italic">your</emphasis> clone operation <emphasis role="bold">public</emphasis> for it to be accessible. So, two key issues when you clone are: </para>
          <para>Virtually always call <emphasis role="bold">super.clone( ) </emphasis></para>
          <para>Make your clone <emphasis role="bold">public</emphasis></para>
          <para>You�ll probably want to override <emphasis role="bold">clone( ) </emphasis>in any further derived classes, otherwise your (now <emphasis role="bold">public</emphasis>) <emphasis role="bold">clone( )</emphasis> will be used, and that might not do the right thing (although, since <emphasis role="bold">Object.clone( )</emphasis> makes a copy of the actual object, it might). The <emphasis role="bold">protected</emphasis> trick works only once�the first time you inherit from a class that has no cloneability and you want to make a class that�s cloneable. In any classes inherited from your class the <emphasis role="bold">clone( ) </emphasis>method is available since it�s not possible in Java to reduce the access of a method during derivation. That is, once a class is cloneable, everything derived from it is cloneable unless you use provided mechanisms (described later) to �turn off� cloning.</para>
        </section>
        <section>
          <title>Implementing the <emphasis role="bold">Cloneable</emphasis> interface</title>
          <para>There�s one more thing you need to do to complete the cloneability of an object: implement the <emphasis role="bold">Cloneable</emphasis><emphasis role="bold">interface</emphasis>. This <emphasis role="bold">interface</emphasis> is a bit strange, because it�s empty!</para>
          <para>interface Cloneable {}</para>
          <para> </para>
          <para>The reason for implementing this empty <emphasis role="bold">interface</emphasis> is obviously not because you are going to upcast to <emphasis role="bold">Cloneable</emphasis> and call one of its methods. The use of <emphasis role="bold">interface</emphasis> here is considered by some to be a �hack� because it�s using a feature for something other than its original intent. Implementing the <emphasis role="bold">Cloneable</emphasis><emphasis role="bold">interface</emphasis> acts as a kind of a flag, wired into the type of the class. </para>
          <para>There are two reasons for the existence of the <emphasis role="bold">Cloneable</emphasis><emphasis role="bold">interface</emphasis>. First, you might have an upcast reference to a base type and not know whether it�s possible to clone that object. In this case, you can use the <emphasis role="bold">instanceof</emphasis> keyword (described in Chapter 12) to find out whether the reference is connected to an object that can be cloned:</para>
          <para>if(myReference instanceof Cloneable) // ...</para>
          <para> </para>
          <para>The second reason is that mixed into this design for cloneability was the thought that maybe you didn�t want all types of objects to be cloneable. So <emphasis role="bold">Object.clone( )</emphasis> verifies that a class implements the <emphasis role="bold">Cloneable</emphasis> interface. If not, it throws a <emphasis role="bold">CloneNotSupportedException</emphasis> exception. So in general, you�re forced to <emphasis role="bold">implement Cloneable</emphasis> as part of support for cloning.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064930"/><anchor xreflabel="Successful " xml:id="_Toc375545427"/>Successful cloning</title>
        <para>Once you understand the details of implementing the <emphasis role="bold">clone( )</emphasis> method, you�re able to create classes that can be easily duplicated to provide a local copy:</para>
        <para>//: appendixa:LocalCopy.java</para>
        <para>// Creating local copies with clone().</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class MyObject implements Cloneable {</para>
        <para>� int i;</para>
        <para>� MyObject(int ii) { i = ii; }</para>
        <para>� public Object clone() {</para>
        <para>��� Object o = null;</para>
        <para>��� try {</para>
        <para>����� o = super.clone();</para>
        <para>��� } catch(CloneNotSupportedException e) {</para>
        <para>����� System.err.println(&quot;MyObject can&apos;t clone&quot;);</para>
        <para>��� }</para>
        <para>��� return o;</para>
        <para>� }</para>
        <para>� public String toString() {</para>
        <para>��� return Integer.toString(i);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class LocalCopy {</para>
        <para>� static MyObject g(MyObject v) {</para>
        <para>��� // Passing a reference, modifies outside object:</para>
        <para>��� v.i++;</para>
        <para>��� return v;</para>
        <para>� }</para>
        <para>� static MyObject f(MyObject v) {</para>
        <para>��� v = (MyObject)v.clone(); // Local copy</para>
        <para>��� v.i++;</para>
        <para>��� return v;</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� MyObject a = new MyObject(11);</para>
        <para>��� MyObject b = g(a);</para>
        <para>��� // Testing reference equivalence,</para>
        <para>��� // not object equivalence:</para>
        <para>��� if(a == b) </para>
        <para>����� System.out.println(&quot;a == b&quot;);</para>
        <para>��� else </para>
        <para>����� System.out.println(&quot;a != b&quot;);</para>
        <para>��� System.out.println(&quot;a = &quot; + a);</para>
        <para>��� System.out.println(&quot;b = &quot; + b);</para>
        <para>��� MyObject c = new MyObject(47);</para>
        <para>��� MyObject d = f(c);</para>
        <para>��� if(c == d) </para>
        <para>����� System.out.println(&quot;c == d&quot;);</para>
        <para>��� else </para>
        <para>����� System.out.println(&quot;c != d&quot;);</para>
        <para>��� System.out.println(&quot;c = &quot; + c);</para>
        <para>��� System.out.println(&quot;d = &quot; + d);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>First of all, <emphasis role="bold">clone( )</emphasis> must be accessible so you must make it <emphasis role="bold">public</emphasis>. Second, for the initial part of your <emphasis role="bold">clone( )</emphasis> operation you should call the base-class version of <emphasis role="bold">clone( )</emphasis>. The <emphasis role="bold">clone( )</emphasis> that�s being called here is the one that�s predefined inside <emphasis role="bold">Object</emphasis>, and you can call it because it�s <emphasis role="bold">protected</emphasis> and thereby accessible in derived classes.</para>
        <para><emphasis role="bold">Object.clone( )</emphasis> figures out how big the object is, creates enough memory for a new one, and copies all the bits from the old to the new. This is called a <emphasis role="italic">bitwise copy,</emphasis> and is typically what you�d expect a <emphasis role="bold">clone( )</emphasis> method to do. But before <emphasis role="bold">Object.clone( )</emphasis> performs its operations, it first checks to see if a class is <emphasis role="bold">Cloneable</emphasis>�that is, whether it implements the <emphasis role="bold">Cloneable</emphasis> interface. If it doesn�t, <emphasis role="bold">Object.clone( )</emphasis> throws a <emphasis role="bold">CloneNotSupportedException</emphasis> to indicate that you can�t clone it. Thus, you�ve got to surround your call to <emphasis role="bold">super.clone( )</emphasis> with a try-catch block, to catch an exception that should never happen (because you�ve implemented the <emphasis role="bold">Cloneable</emphasis> interface).</para>
        <para>In <emphasis role="bold">LocalCopy</emphasis>, the two methods <emphasis role="bold">g( )</emphasis> and <emphasis role="bold">f( )</emphasis> demonstrate the difference between the two approaches for argument passing. <emphasis role="bold">g( )</emphasis> shows passing by reference in which it modifies the outside object and returns a reference to that outside object, while <emphasis role="bold">f( )</emphasis> clones the argument, thereby decoupling it and leaving the original object alone. It can then proceed to do whatever it wants, and even to return a reference to this new object without any ill effects to the original. Notice the somewhat curious-looking statement:</para>
        <para>v = (MyObject)v.clone();</para>
        <para> </para>
        <para>This is where the local copy is created. To prevent confusion by such a statement, remember that this rather strange coding idiom is perfectly feasible in Java because every object identifier is actually a reference. So the reference <emphasis role="bold">v</emphasis> is used to <emphasis role="bold">clone( )</emphasis> a copy of what it refers to, and this returns a reference to the base type <emphasis role="bold">Object</emphasis> (because it�s defined that way in <emphasis role="bold">Object.clone( )</emphasis>) that must then be cast to the proper type.</para>
        <para>In <emphasis role="bold">main( )</emphasis>, the difference between the effects of the two different argument-passing approaches in the two different methods is tested. The output is:</para>
        <para>a == b</para>
        <para>a = 12</para>
        <para>b = 12</para>
        <para>c != d</para>
        <para>c = 47</para>
        <para>d = 48</para>
        <para> </para>
        <para>It�s important to notice that the equivalence tests in Java do not look inside the objects being compared to see if their values are the same. The <emphasis role="bold">==</emphasis> and <emphasis role="bold">!=</emphasis> operators are simply comparing the <emphasis role="italic">references</emphasis>. If the addresses inside the references are the same, the references are pointing to the same object and are therefore �equal.� So what the operators are really testing is whether the references are aliased to the same object!</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064931"/><anchor xreflabel="The
effect of Object.clone( )" xml:id="_Toc375545428"/>The effect of <emphasis role="bold">Object.clone( )</emphasis></title>
        <para>What actually happens when <emphasis role="bold">Object.clone( )</emphasis> is called that makes it so essential to call <emphasis role="bold">super.clone( )</emphasis> when you override <emphasis role="bold">clone( )</emphasis> in your class? The <emphasis role="bold">clone( )</emphasis> method in the root class is responsible for creating the correct amount of storage and making the bitwise copy of the bits from the original object into the new object�s storage. That is, it doesn�t just make storage and copy an <emphasis role="bold">Object</emphasis>�it actually figures out the size of the precise object that�s being copied and duplicates that. Since all this is happening from the code in the <emphasis role="bold">clone( )</emphasis> method defined in the root class (that has no idea what�s being inherited from it), you can guess that the process involves RTTI to determine the actual object that�s being cloned. This way, the <emphasis role="bold">clone( )</emphasis> method can create the proper amount of storage and do the correct bitcopy for that type.</para>
        <para>Whatever you do, the first part of the cloning process should normally be a call to <emphasis role="bold">super.clone( )</emphasis>. This establishes the groundwork for the cloning operation by making an exact duplicate. At this point you can perform other operations necessary to complete the cloning.</para>
        <para>To know for sure what those other operations are, you need to understand exactly what <emphasis role="bold">Object.clone( )</emphasis> buys you. In particular, does it automatically clone the destination of all the references? The following example tests this:</para>
        <para>//: appendixa:Snake.java</para>
        <para>// Tests cloning to see if destination</para>
        <para>// of references are also cloned.</para>
        <para> </para>
        <para>public class Snake implements Cloneable {</para>
        <para>� private Snake next;</para>
        <para>� private char c;</para>
        <para>� // Value of i == number of segments</para>
        <para>� Snake(int i, char x) {</para>
        <para>��� c = x;</para>
        <para>��� if(--i &gt; 0)</para>
        <para>����� next = new Snake(i, (char)(x + 1));</para>
        <para>� }</para>
        <para>� void increment() {</para>
        <para>��� c++;</para>
        <para>��� if(next != null)</para>
        <para>����� next.increment();</para>
        <para>� }</para>
        <para>� public String toString() {</para>
        <para>��� String s = &quot;:&quot; + c;</para>
        <para>��� if(next != null)</para>
        <para>����� s += next.toString();</para>
        <para>��� return s;</para>
        <para>� }</para>
        <para>� public Object clone() {</para>
        <para>��� Object o = null;</para>
        <para>��� try {</para>
        <para>�� ���o = super.clone();</para>
        <para>��� } catch(CloneNotSupportedException e) {</para>
        <para>����� System.err.println(&quot;Snake can&apos;t clone&quot;);</para>
        <para>��� }</para>
        <para>��� return o;</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Snake s = new Snake(5, &apos;a&apos;);</para>
        <para>��� System.out.println(&quot;s = &quot; + s);</para>
        <para>��� Snake s2 = (Snake)s.clone();</para>
        <para>��� System.out.println(&quot;s2 = &quot; + s2);</para>
        <para>��� s.increment();</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;after s.increment, s2 = &quot; + s2);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>A <emphasis role="bold">Snake</emphasis> is made up of a bunch of segments, each of type <emphasis role="bold">Snake</emphasis>. Thus, it�s a singly linked list. The segments are created recursively, decrementing the first constructor argument for each segment until zero is reached. To give each segment a unique tag, the second argument, a <emphasis role="bold">char</emphasis>, is incremented for each recursive constructor call.</para>
        <para>The <emphasis role="bold">increment( )</emphasis> method recursively increments each tag so you can see the change, and the <emphasis role="bold">toString( )</emphasis> recursively prints each tag. The output is:</para>
        <para>s = :a:b:c:d:e</para>
        <para>s2 = :a:b:c:d:e</para>
        <para>after s.increment, s2 = :a:c:d:e:f</para>
        <para> </para>
        <para>This means that only the first segment is duplicated by <emphasis role="bold">Object.clone( )</emphasis>, therefore it does a shallow copy. If you want the whole snake to be duplicated�a deep copy�you must perform the additional operations inside your overridden <emphasis role="bold">clone( )</emphasis>.</para>
        <para>You�ll typically call <emphasis role="bold">super.clone( )</emphasis> in any class derived from a cloneable class to make sure that all of the base-class operations (including <emphasis role="bold">Object.clone( )</emphasis>) take place. This is followed by an explicit call to <emphasis role="bold">clone( ) </emphasis>for every reference in your object; otherwise those references will be aliased to those of the original object. It�s analogous to the way constructors are called�base-class constructor first, then the next-derived constructor, and so on to the most-derived constructor. The difference is that <emphasis role="bold">clone( )</emphasis> is not a constructor, so there�s nothing to make it happen automatically. You must make sure to do it yourself.</para>
      </section>
      <section>
        <title><anchor xreflabel="Cloning a composed object" xml:id="_Toc481064932"/>Cloning a composed object</title>
        <para>There�s a problem you�ll encounter when trying to deep copy a composed object. You must assume that the <emphasis role="bold">clone( )</emphasis> method in the member objects will in turn perform a deep copy on <emphasis role="italic">their</emphasis> references, and so on. This is quite a commitment. It effectively means that for a deep copy to work you must either control all of the code in all of the classes, or at least have enough knowledge about all of the classes involved in the deep copy to know that they are performing their own deep copy correctly.</para>
        <para>This example shows what you must do to accomplish a deep copy when dealing with a composed object:</para>
        <para>//: appendixa:DeepCopy.java</para>
        <para>// Cloning a composed object.</para>
        <para> </para>
        <para>class DepthReading implements Cloneable {</para>
        <para>� private double depth;</para>
        <para>� public DepthReading(double depth) { </para>
        <para>��� this.depth = depth;</para>
        <para>� }</para>
        <para>� public Object clone() {</para>
        <para>��� Object o = null;</para>
        <para>��� try {</para>
        <para>����� o = super.clone();</para>
        <para>��� } catch(CloneNotSupportedException e) {</para>
        <para>����� e.printStackTrace(System.err);</para>
        <para>��� }</para>
        <para>��� return o;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class TemperatureReading implements Cloneable {</para>
        <para>� private long time;</para>
        <para>� private double temperature;</para>
        <para>� public TemperatureReading(double temperature) {</para>
        <para>��� time = System.currentTimeMillis();</para>
        <para>��� this.temperature = temperature;</para>
        <para>� }</para>
        <para>� public Object clone() {</para>
        <para>��� Object o = null;</para>
        <para>��� try {</para>
        <para>����� o = super.clone();</para>
        <para>��� } catch(CloneNotSupportedException e) {</para>
        <para>����� e.printStackTrace(System.err);</para>
        <para>��� }</para>
        <para>��� return o;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class OceanReading implements Cloneable {</para>
        <para>� private DepthReading depth;</para>
        <para>� private TemperatureReading temperature;</para>
        <para>� public OceanReading(double tdata, double ddata){</para>
        <para>��� temperature = new TemperatureReading(tdata);</para>
        <para>�� �depth = new DepthReading(ddata);</para>
        <para>� }</para>
        <para>� public Object clone() {</para>
        <para>��� OceanReading o = null;</para>
        <para>��� try {</para>
        <para>����� o = (OceanReading)super.clone();</para>
        <para>��� } catch(CloneNotSupportedException e) {</para>
        <para>����� e.printStackTrace(System.err);</para>
        <para>��� }</para>
        <para>��� // Must clone references:</para>
        <para>��� o.depth = (DepthReading)o.depth.clone();</para>
        <para>��� o.temperature = </para>
        <para>����� (TemperatureReading)o.temperature.clone();</para>
        <para>��� return o; // Upcasts back to Object</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class DeepCopy {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� OceanReading reading = </para>
        <para>����� new OceanReading(33.9, 100.5);</para>
        <para>��� // Now clone it:</para>
        <para>��� OceanReading r = </para>
        <para>����� (OceanReading)reading.clone();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">DepthReading</emphasis> and <emphasis role="bold">TemperatureReading</emphasis> are quite similar; they both contain only primitives. Therefore, the <emphasis role="bold">clone( )</emphasis> method can be quite simple: it calls <emphasis role="bold">super.clone( )</emphasis> and returns the result. Note that the <emphasis role="bold">clone( )</emphasis> code for both classes is identical.</para>
        <para><emphasis role="bold">OceanReading</emphasis> is composed of <emphasis role="bold">DepthReading</emphasis> and <emphasis role="bold">TemperatureReading</emphasis> objects and so, to produce a deep copy, its <emphasis role="bold">clone( )</emphasis> must clone the references inside <emphasis role="bold">OceanReading</emphasis>. To accomplish this, the result of <emphasis role="bold">super.clone( )</emphasis> must be cast to an <emphasis role="bold">OceanReading</emphasis> object (so you can access the <emphasis role="bold">depth</emphasis> and <emphasis role="bold">temperature</emphasis> references).</para>
      </section>
      <section>
        <title><anchor xreflabel="A deep copy with ArrayList" xml:id="_Toc481064933"/>A deep copy with <emphasis role="bold">ArrayList</emphasis></title>
        <para>Let�s revisit the <emphasis role="bold">ArrayList</emphasis> example from earlier in this appendix. This time the <emphasis role="bold">Int2</emphasis> class is cloneable, so the <emphasis role="bold">ArrayList</emphasis> can be deep copied:</para>
        <para>//: appendixa:AddingClone.java</para>
        <para>// You must go through a few gyrations</para>
        <para>// to add cloning to your own class.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Int2 implements Cloneable {</para>
        <para>� private int i;</para>
        <para>� public Int2(int ii) { i = ii; }</para>
        <para>� public void increment() { i++; }</para>
        <para>� public String toString() {</para>
        <para>��� return Integer.toString(i);</para>
        <para>� }</para>
        <para>� public Object clone() {</para>
        <para>��� Object o = null;</para>
        <para>��� try {</para>
        <para>����� o = super.clone();</para>
        <para>��� } catch(CloneNotSupportedException e) {</para>
        <para>����� System.err.println(&quot;Int2 can&apos;t clone&quot;);</para>
        <para>��� }</para>
        <para>��� return o;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>// Once it&apos;s cloneable, inheritance</para>
        <para>// doesn&apos;t remove cloneability:</para>
        <para>class Int3 extends Int2 {</para>
        <para>� private int j; // Automatically duplicated</para>
        <para>� public Int3(int i) { super(i); }</para>
        <para>}</para>
        <para> </para>
        <para>public class AddingClone {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Int2 x = new Int2(10);</para>
        <para>��� Int2 x2 = (Int2)x.clone();</para>
        <para>��� x2.increment();</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;x = &quot; + x + &quot;, x2 = &quot; + x2);</para>
        <para>��� // Anything inherited is also cloneable:</para>
        <para>��� Int3 x3 = new Int3(7);</para>
        <para>��� x3 = (Int3)x3.clone();</para>
        <para> </para>
        <para>��� ArrayList v = new ArrayList();</para>
        <para>��� for(int i = 0; i &lt; 10; i++ )</para>
        <para>����� v.add(new Int2(i));</para>
        <para>��� System.out.println(&quot;v: &quot; + v);</para>
        <para>��� ArrayList v2 = (ArrayList)v.clone();</para>
        <para>��� // Now clone each element:</para>
        <para>��� for(int i = 0; i &lt; v.size(); i++)</para>
        <para>����� v2.set(i, ((Int2)v2.get(i)).clone());</para>
        <para>��� // Increment all v2&apos;s elements:</para>
        <para>��� for(Iterator e = v2.iterator();</para>
        <para>������� e.hasNext(); )</para>
        <para>����� ((Int2)e.next()).increment();</para>
        <para>��� // See if it changed v&apos;s elements:</para>
        <para>��� System.out.println(&quot;v: &quot; + v);</para>
        <para>��� System.out.println(&quot;v2: &quot; + v2);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">Int3</emphasis> is inherited from <emphasis role="bold">Int2</emphasis> and a new primitive member <emphasis role="bold">int j </emphasis>is added. You might think that you�d need to override <emphasis role="bold">clone( )</emphasis> again to make sure <emphasis role="bold">j</emphasis> is copied, but that�s not the case. When <emphasis role="bold">Int2</emphasis>�s <emphasis role="bold">clone( )</emphasis> is called as <emphasis role="bold">Int3</emphasis>�s <emphasis role="bold">clone( )</emphasis>, it calls <emphasis role="bold">Object.clone( ),</emphasis> which determines that it�s working with an <emphasis role="bold">Int3</emphasis> and duplicates all the bits in the <emphasis role="bold">Int3</emphasis>. As long as you don�t add references that need to be cloned, the one call to <emphasis role="bold">Object.clone( )</emphasis> performs all of the necessary duplication, regardless of how far down in the hierarchy <emphasis role="bold">clone( )</emphasis> is defined.</para>
        <para>You can see what�s necessary in order to do a deep copy of an <emphasis role="bold">ArrayList</emphasis>: after the <emphasis role="bold">ArrayList</emphasis> is cloned, you have to step through and clone each one of the objects pointed to by the <emphasis role="bold">ArrayList</emphasis>. You�d have to do something similar to this to do a deep copy of a <emphasis role="bold">HashMap</emphasis>.</para>
        <para>The remainder of the example shows that the cloning did happen by showing that, once an object is cloned, you can change it and the original object is left untouched.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545429"/><anchor xreflabel="Deep
copy via serialization" xml:id="_Toc481064934"/>Deep copy via serialization</title>
        <para>When you consider Java�s object serialization (introduced in Chapter 11), you might observe that an object that�s serialized and then deserialized is, in effect, cloned.</para>
        <para>So why not use serialization to perform deep copying? Here�s an example that compares the two approaches by timing them:</para>
        <para>//: appendixa:Compete.java</para>
        <para>import java.io.*;</para>
        <para> </para>
        <para>class Thing1 implements Serializable {}</para>
        <para>class Thing2 implements Serializable {</para>
        <para>� Thing1 o1 = new Thing1();</para>
        <para>}</para>
        <para> </para>
        <para>class Thing3 implements Cloneable {</para>
        <para>� public Object clone() {</para>
        <para>�� �Object o = null;</para>
        <para>��� try {</para>
        <para>����� o = super.clone();</para>
        <para>��� } catch(CloneNotSupportedException e) {</para>
        <para>����� System.err.println(&quot;Thing3 can&apos;t clone&quot;);</para>
        <para>��� }</para>
        <para>��� return o;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Thing4 implements Cloneable {</para>
        <para>� Thing3 o3 = new Thing3();</para>
        <para>� public Object clone() {</para>
        <para>��� Thing4 o = null;</para>
        <para>��� try {</para>
        <para>����� o = (Thing4)super.clone();</para>
        <para>��� } catch(CloneNotSupportedException e) {</para>
        <para>����� System.err.println(&quot;Thing4 can&apos;t clone&quot;);</para>
        <para>��� }</para>
        <para>��� // Clone the field, too:</para>
        <para>��� o.o3 = (Thing3)o3.clone();</para>
        <para>��� return o;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Compete {</para>
        <para>� static final int SIZE = 5000;</para>
        <para>� public static void main(String[] args) </para>
        <para>� throws Exception {</para>
        <para>��� Thing2[] a = new Thing2[SIZE];</para>
        <para>��� for(int i = 0; i &lt; a.length; i++)</para>
        <para>����� a[i] = new Thing2();</para>
        <para>��� Thing4[] b = new Thing4[SIZE];</para>
        <para>��� for(int i = 0; i &lt; b.length; i++)</para>
        <para>����� b[i] = new Thing4();</para>
        <para>��� long t1 = System.currentTimeMillis();</para>
        <para>��� ByteArrayOutputStream buf = </para>
        <para>����� new ByteArrayOutputStream();</para>
        <para>��� ObjectOutputStream o =</para>
        <para>����� new ObjectOutputStream(buf);</para>
        <para>��� for(int i = 0; i &lt; a.length; i++)</para>
        <para>����� o.writeObject(a[i]);</para>
        <para>��� // Now get copies:</para>
        <para>��� ObjectInputStream in =</para>
        <para>����� new ObjectInputStream(</para>
        <para>������� new ByteArrayInputStream(</para>
        <para>��������� buf.toByteArray()));</para>
        <para>��� Thing2[] c = new Thing2[SIZE];</para>
        <para>��� for(int i = 0; i &lt; c.length; i++)</para>
        <para>�� ���c[i] = (Thing2)in.readObject();</para>
        <para>��� long t2 = System.currentTimeMillis();</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;Duplication via serialization: &quot; +</para>
        <para>����� (t2 - t1) + &quot; Milliseconds&quot;);</para>
        <para>��� // Now try cloning:</para>
        <para>��� t1 = System.currentTimeMillis();</para>
        <para>��� Thing4[] d = new Thing4[SIZE];</para>
        <para>��� for(int i = 0; i &lt; d.length; i++)</para>
        <para>����� d[i] = (Thing4)b[i].clone();</para>
        <para>��� t2 = System.currentTimeMillis();</para>
        <para>��� System.out.println(</para>
        <para>����� &quot;Duplication via cloning: &quot; +</para>
        <para>����� (t2 - t1) + &quot; Milliseconds&quot;);</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">Thing2</emphasis> and <emphasis role="bold">Thing4</emphasis> contain member objects so that there�s some deep copying going on. It�s interesting to notice that while <emphasis role="bold">Serializable</emphasis> classes are easy to set up, there�s much more work going on to duplicate them. Cloning involves a lot of work to set up the class, but the actual duplication of objects is relatively simple. The results really tell the tale. Here is the output from three different runs:</para>
        <para>Duplication via serialization: 940 Milliseconds</para>
        <para>Duplication via cloning: 50 Milliseconds</para>
        <para> </para>
        <para>Duplication via serialization: 710 Milliseconds</para>
        <para>Duplication via cloning: 60 Milliseconds</para>
        <para> </para>
        <para>Duplication via serialization: 770 Milliseconds</para>
        <para>Duplication via cloning: 50 Milliseconds</para>
        <para> </para>
        <para>Despite the significant time difference between serialization and cloning, you�ll also notice that the serialization technique seems to vary more in its duration, while cloning tends to be more stable.</para>
      </section>
      <section>
        <title><anchor xreflabel="Adding cloneability 
further down a hierarchy" xml:id="_Toc481064935"/>Adding cloneability   further down a hierarchy</title>
        <para>If you create a new class, its base class defaults to <emphasis role="bold">Object</emphasis>, which defaults to noncloneability (as you�ll see in the next section). As long as you don�t explicitly add cloneability, you won�t get it. But you can add it in at any layer and it will then be cloneable from that layer downward, like this:</para>
        <para>//: appendixa:HorrorFlick.java</para>
        <para>// You can insert Cloneability </para>
        <para>// at any level of inheritance.</para>
        <para>import java.util.*;</para>
        <para> </para>
        <para>class Person {}</para>
        <para>class Hero extends Person {}</para>
        <para>class Scientist extends Person </para>
        <para>��� implements Cloneable {</para>
        <para>� public Object clone() {</para>
        <para>��� try {</para>
        <para>�� ���return super.clone();</para>
        <para>��� } catch(CloneNotSupportedException e) {</para>
        <para>����� // this should never happen:</para>
        <para>����� // It&apos;s Cloneable already!</para>
        <para>����� throw new InternalError();</para>
        <para>��� }</para>
        <para>� }</para>
        <para>}</para>
        <para>class MadScientist extends Scientist {}</para>
        <para> </para>
        <para>public class HorrorFlick {</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Person p = new Person();</para>
        <para>��� Hero h = new Hero();</para>
        <para>��� Scientist s = new Scientist();</para>
        <para>��� MadScientist m = new MadScientist();</para>
        <para> </para>
        <para>��� // p = (Person)p.clone(); // Compile error</para>
        <para>��� // h = (Hero)h.clone(); // Compile error</para>
        <para>��� s = (Scientist)s.clone();</para>
        <para>��� m = (MadScientist)m.clone();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>Before cloneability was added, the compiler stopped you from trying to clone things. When cloneability is added in <emphasis role="bold">Scientist</emphasis>, then <emphasis role="bold">Scientist</emphasis> and all its descendants are cloneable.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064936"/><anchor xreflabel="Why
this strange design?" xml:id="_Toc375545430"/>Why this strange design?</title>
        <para>If all this seems to be a strange scheme, that�s because it is. You might wonder why it worked out this way. What is the meaning behind this design?</para>
        <para>Originally, Java was designed as a language to control hardware boxes, and definitely not with the Internet in mind. In a general-purpose language like this, it makes sense that the programmer be able to clone any object. Thus, <emphasis role="bold">clone( )</emphasis> was placed in the root class <emphasis role="bold">Object</emphasis>, <emphasis role="italic">but</emphasis> it was a <emphasis role="bold">public</emphasis> method so you could always clone any object. This seemed to be the most flexible approach, and after all, what could it hurt?</para>
        <para>Well, when Java was seen as the ultimate Internet programming language, things changed. Suddenly, there are security issues, and of course, these issues are dealt with using objects, and you don�t necessarily want anyone to be able to clone your security objects. So what you�re seeing is a lot of patches applied on the original simple and straightforward scheme: <emphasis role="bold">clone( )</emphasis> is now <emphasis role="bold">protected</emphasis> in <emphasis role="bold">Object</emphasis>. You must override it <emphasis role="italic">and</emphasis><emphasis role="bold">implement Cloneable</emphasis><emphasis role="italic">and</emphasis> deal with the exceptions.</para>
        <para>It�s worth noting that you must use the <emphasis role="bold">Cloneable</emphasis> interface <emphasis role="italic">only </emphasis>if you�re going to call <emphasis role="bold">Object</emphasis>�s <emphasis role="bold">clone( )</emphasis>, method, since that method checks at run-time to make sure that your class implements <emphasis role="bold">Cloneable</emphasis>. But for consistency (and since <emphasis role="bold">Cloneable</emphasis> is empty anyway) you should implement it.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064937"/><anchor xreflabel="Controlling
cloneability" xml:id="_Toc375545431"/>Controlling cloneability</title>
      <para>You might suggest that, to remove cloneability, the <emphasis role="bold">clone( )</emphasis> method simply be made <emphasis role="bold">private</emphasis>, but this won�t work since you cannot take a base-class method and make it less accessible in a derived class. So it�s not that simple. And yet, it�s necessary to be able to control whether an object can be cloned. There are actually a number of attitudes you can take to this in a class that you design:</para>
      <para>Indifference. You don�t do anything about cloning, which means that your class can�t be cloned but a class that inherits from you can add cloning if it wants. This works only if the default <emphasis role="bold">Object.clone( )</emphasis> will do something reasonable with all the fields in your class.</para>
      <para>141.   Support <emphasis role="bold">clone( )</emphasis>. Follow the standard practice of implementing <emphasis role="bold">Cloneable</emphasis> and overriding <emphasis role="bold">clone( )</emphasis>. In the overridden <emphasis role="bold">clone( )</emphasis>, you call <emphasis role="bold">super.clone( ) </emphasis>and catch all exceptions (so your overridden <emphasis role="bold">clone( )</emphasis> doesn�t throw any exceptions).</para>
      <para>142.   Support cloning conditionally. If your class holds references to other objects that might or might not be cloneable (a container class, for example), your <emphasis role="bold">clone( )</emphasis> can try to clone all of the objects for which you have references, and if they throw exceptions just pass those exceptions out to the programmer. For example, consider a special sort of <emphasis role="bold">ArrayList</emphasis> that tries to clone all the objects it holds. When you write such an <emphasis role="bold">ArrayList</emphasis>, you don�t know what sort of objects the client programmer might put into your <emphasis role="bold">ArrayList</emphasis>, so you don�t know whether they can be cloned.</para>
      <para>143.   Don�t implement <emphasis role="bold">Cloneable</emphasis> but override <emphasis role="bold">clone( )</emphasis> as <emphasis role="bold">protected</emphasis>, producing the correct copying behavior for any fields. This way, anyone inheriting from this class can override <emphasis role="bold">clone( )</emphasis> and call <emphasis role="bold">super.clone( )</emphasis> to produce the correct copying behavior. Note that your implementation can and should invoke <emphasis role="bold">super.clone( )</emphasis> even though that method expects a <emphasis role="bold">Cloneable</emphasis> object (it will throw an exception otherwise), because no one will directly invoke it on an object of your type. It will get invoked only through a derived class, which, if it is to work successfully, implements <emphasis role="bold">Cloneable</emphasis>.</para>
      <para>144.   Try to prevent cloning by not implementing <emphasis role="bold">Cloneable</emphasis> and overriding <emphasis role="bold">clone( )</emphasis> to throw an exception. This is successful only if any class derived from this calls <emphasis role="bold">super.clone( )</emphasis> in its redefinition of <emphasis role="bold">clone( )</emphasis>. Otherwise, a programmer may be able to get around it.</para>
      <para>145.   Prevent cloning by making your class <emphasis role="bold">final</emphasis>. If <emphasis role="bold">clone( )</emphasis> has not been overridden by any of your ancestor classes, then it can�t be. If it has, then override it again and throw <emphasis role="bold">CloneNotSupportedException</emphasis>. Making the class <emphasis role="bold">final </emphasis>is the only way to guarantee that cloning is prevented. In addition, when dealing with security objects or other situations in which you want to control the number of objects created you should make all constructors <emphasis role="bold">private</emphasis> and provide one or more special methods for creating objects. That way, these methods can restrict the number of objects created and the conditions in which they�re created. (A particular case of this is the <emphasis role="italic">singleton</emphasis> pattern shown in <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis>.)</para>
      <para>Here�s an example that shows the various ways cloning can be implemented and then, later in the hierarchy, �turned off�:</para>
      <para>//: appendixa:CheckCloneable.java</para>
      <para>// Checking to see if a reference can be cloned.</para>
      <para> </para>
      <para>// Can&apos;t clone this because it doesn&apos;t</para>
      <para>// override clone():</para>
      <para>class Ordinary {}</para>
      <para> </para>
      <para>// Overrides clone, but doesn&apos;t implement</para>
      <para>// Cloneable:</para>
      <para>class WrongClone extends Ordinary {</para>
      <para>� public Object clone()</para>
      <para>����� throws CloneNotSupportedException {</para>
      <para>��� return super.clone(); // Throws exception</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>// Does all the right things for cloning:</para>
      <para>class IsCloneable extends Ordinary </para>
      <para>��� implements Cloneable {</para>
      <para>� public Object clone() </para>
      <para>����� throws CloneNotSupportedException {</para>
      <para>��� return super.clone();</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>// Turn off cloning by throwing the exception:</para>
      <para>class NoMore extends IsCloneable {</para>
      <para>� public Object clone() </para>
      <para>����� throws CloneNotSupportedException {</para>
      <para>��� throw new CloneNotSupportedException();</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class TryMore extends NoMore {</para>
      <para>� public Object clone() </para>
      <para>����� throws CloneNotSupportedException {</para>
      <para>��� // Calls NoMore.clone(), throws exception:</para>
      <para>��� return super.clone();</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>class BackOn extends NoMore {</para>
      <para>� private BackOn duplicate(BackOn b) {</para>
      <para>��� // Somehow make a copy of b</para>
      <para>��� // and return that copy. This is a dummy</para>
      <para>��� // copy, just to make the point:</para>
      <para>��� return new BackOn();</para>
      <para>� }</para>
      <para>� public Object clone() {</para>
      <para>� ��// Doesn&apos;t call NoMore.clone():</para>
      <para>��� return duplicate(this);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>// Can&apos;t inherit from this, so can&apos;t override</para>
      <para>// the clone method like in BackOn:</para>
      <para>final class ReallyNoMore extends NoMore {}</para>
      <para> </para>
      <para>public class CheckCloneable {</para>
      <para>� static Ordinary tryToClone(Ordinary ord) {</para>
      <para>��� String id = ord.getClass().getName();</para>
      <para>��� Ordinary x = null;</para>
      <para>��� if(ord instanceof Cloneable) {</para>
      <para>����� try {</para>
      <para>������� System.out.println(&quot;Attempting &quot; + id);</para>
      <para>������� x = (Ordinary)((IsCloneable)ord).clone();</para>
      <para>������� System.out.println(&quot;Cloned &quot; + id);</para>
      <para>����� } catch(CloneNotSupportedException e) {</para>
      <para>������� System.err.println(&quot;Could not clone &quot;+id);</para>
      <para>����� }</para>
      <para>��� }</para>
      <para>��� return x;</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� // Upcasting:</para>
      <para>��� Ordinary[] ord = { </para>
      <para>����� new IsCloneable(),</para>
      <para>���� �new WrongClone(),</para>
      <para>����� new NoMore(),</para>
      <para>����� new TryMore(),</para>
      <para>����� new BackOn(),</para>
      <para>����� new ReallyNoMore(),</para>
      <para>��� };</para>
      <para>��� Ordinary x = new Ordinary();</para>
      <para>��� // This won&apos;t compile, since clone() is</para>
      <para>��� // protected in Object:</para>
      <para>��� //! x = (Ordinary)x.clone();</para>
      <para>��� // tryToClone() checks first to see if</para>
      <para>��� // a class implements Cloneable:</para>
      <para>��� for(int i = 0; i &lt; ord.length; i++)</para>
      <para>����� tryToClone(ord[i]);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The first class, <emphasis role="bold">Ordinary</emphasis>, represents the kinds of classes we�ve seen throughout this book: no support for cloning, but as it turns out, no prevention of cloning either. But if you have a reference to an <emphasis role="bold">Ordinary</emphasis> object that might have been upcast from a more derived class, you can�t tell if it can be cloned or not.</para>
      <para>The class <emphasis role="bold">WrongClone</emphasis> shows an incorrect way to implement cloning. It does override <emphasis role="bold">Object.clone( )</emphasis> and makes that method <emphasis role="bold">public</emphasis>, but it doesn�t implement <emphasis role="bold">Cloneable</emphasis>, so when <emphasis role="bold">super.clone( )</emphasis> is called (which results in a call to <emphasis role="bold">Object.clone( )</emphasis>), <emphasis role="bold">CloneNotSupportedException</emphasis> is thrown so the cloning doesn�t work.</para>
      <para>In <emphasis role="bold">IsCloneable</emphasis> you can see all the right actions performed for cloning: <emphasis role="bold">clone( )</emphasis> is overridden and <emphasis role="bold">Cloneable</emphasis> is implemented. However, this <emphasis role="bold">clone( )</emphasis> method and several others that follow in this example <emphasis role="italic">do not</emphasis> catch <emphasis role="bold">CloneNotSupportedException,</emphasis> but instead pass it through to the caller, who must then put a try-catch block around it. In your own <emphasis role="bold">clone( )</emphasis> methods you will typically catch <emphasis role="bold">CloneNotSupportedException</emphasis><emphasis role="italic">inside</emphasis><emphasis role="bold">clone( )</emphasis> rather than passing it through. As you�ll see, in this example it�s more informative to pass the exceptions through.</para>
      <para>Class <emphasis role="bold">NoMore</emphasis> attempts to �turn off� cloning in the way that the Java designers intended: in the derived class <emphasis role="bold">clone( )</emphasis>, you throw <emphasis role="bold">CloneNotSupportedException</emphasis>. The <emphasis role="bold">clone( ) </emphasis>method in class <emphasis role="bold">TryMore</emphasis> properly calls <emphasis role="bold">super.clone( )</emphasis>, and this resolves to <emphasis role="bold">NoMore.clone( ),</emphasis> which throws an exception and prevents cloning.</para>
      <para>But what if the programmer doesn�t follow the �proper� path of calling <emphasis role="bold">super.clone( )</emphasis> inside the overridden <emphasis role="bold">clone( )</emphasis> method? In <emphasis role="bold">BackOn</emphasis>, you can see how this can happen. This class uses a separate method <emphasis role="bold">duplicate( ) </emphasis>to make a copy of the current object and calls this method inside <emphasis role="bold">clone( )</emphasis><emphasis role="italic">instead</emphasis> of calling <emphasis role="bold">super.clone( )</emphasis>. The exception is never thrown and the new class is cloneable. You can�t rely on throwing an exception to prevent making a cloneable class. The only sure-fire solution is shown in <emphasis role="bold">ReallyNoMore</emphasis>, which is <emphasis role="bold">final</emphasis> and thus cannot be inherited. That means if <emphasis role="bold">clone( )</emphasis> throws an exception in the <emphasis role="bold">final</emphasis> class, it cannot be modified with inheritance and the prevention of cloning is assured. (You cannot explicitly call <emphasis role="bold">Object.clone( ) </emphasis>from a class that has an arbitrary level of inheritance; you are limited to calling <emphasis role="bold">super.clone( ),</emphasis> which has access to only the direct base class.) Thus, if you make any objects that involve security issues, you�ll want to make those classes <emphasis role="bold">final</emphasis>.</para>
      <para>The first method you see in class <emphasis role="bold">CheckCloneable</emphasis> is <emphasis role="bold">tryToClone( )</emphasis>, which takes any <emphasis role="bold">Ordinary</emphasis> object and checks to see whether it�s cloneable with <emphasis role="bold">instanceof</emphasis>. If so, it casts the object to an <emphasis role="bold">IsCloneable</emphasis>, calls <emphasis role="bold">clone( )</emphasis> and casts the result back to <emphasis role="bold">Ordinary</emphasis>, catching any exceptions that are thrown. Notice the use of run-time type identification (see Chapter 12) to print the class name so you can see what�s happening.</para>
      <para>In <emphasis role="bold">main( )</emphasis>, different types of <emphasis role="bold">Ordinary</emphasis> objects are created and upcast to <emphasis role="bold">Ordinary</emphasis> in the array definition. The first two lines of code after that create a plain <emphasis role="bold">Ordinary</emphasis> object and try to clone it. However, this code will not compile because <emphasis role="bold">clone( )</emphasis> is a <emphasis role="bold">protected</emphasis> method in <emphasis role="bold">Object</emphasis>. The remainder of the code steps through the array and tries to clone each object, reporting the success or failure of each. The output is:</para>
      <para>Attempting IsCloneable</para>
      <para>Cloned IsCloneable</para>
      <para>Attempting NoMore</para>
      <para>Could not clone NoMore</para>
      <para>Attempting TryMore</para>
      <para>Could not clone TryMore</para>
      <para>Attempting BackOn</para>
      <para>Cloned BackOn</para>
      <para>Attempting ReallyNoMore</para>
      <para>Could not clone ReallyNoMore</para>
      <para> </para>
      <para>So to summarize, if you want a class to be cloneable:</para>
      <para>Implement the <emphasis role="bold">Cloneable</emphasis> interface.</para>
      <para>146.   Override <emphasis role="bold">clone( )</emphasis>.</para>
      <para>147.   Call <emphasis role="bold">super.clone( )</emphasis> inside your <emphasis role="bold">clone( )</emphasis>.</para>
      <para>148.   Capture exceptions inside your <emphasis role="bold">clone( )</emphasis>.</para>
      <para>This will produce the most convenient effects.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064938"/><anchor xreflabel="The
copy constructor" xml:id="_Toc375545432"/>The copy constructor</title>
        <para>Cloning can seem to be a complicated process to set up. It might seem like there should be an alternative. One approach that might occur to you (especially if you�re a C++ programmer) is to make a special constructor whose job it is to duplicate an object. In C++, this is called the <emphasis role="italic">copy constructor</emphasis>. At first, this seems like the obvious solution, but in fact it doesn�t work. Here�s an example:</para>
        <para>//: appendixa:CopyConstructor.java</para>
        <para>// A constructor for copying an object of the same</para>
        <para>// type, as an attempt to create a local copy.</para>
        <para> </para>
        <para>class FruitQualities {</para>
        <para>� private int weight;</para>
        <para>� private int color;</para>
        <para>� private int firmness;</para>
        <para>� private int ripeness;</para>
        <para>� private int smell;</para>
        <para>� // etc.</para>
        <para>� FruitQualities() { // Default constructor</para>
        <para>��� // do something meaningful...</para>
        <para>� }</para>
        <para>� // Other constructors:</para>
        <para>� // ...</para>
        <para>� // Copy constructor:</para>
        <para>� FruitQualities(FruitQualities f) {</para>
        <para>��� weight = f.weight;</para>
        <para>��� color = f.color;</para>
        <para>��� firmness = f.firmness;</para>
        <para>��� ripeness = f.ripeness;</para>
        <para>��� smell = f.smell;</para>
        <para>��� // etc.</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Seed {</para>
        <para>� // Members...</para>
        <para>� Seed() { /* Default constructor */ }</para>
        <para>� Seed(Seed s) { /* Copy constructor */ }</para>
        <para>}</para>
        <para> </para>
        <para>class Fruit {</para>
        <para>� private FruitQualities fq;</para>
        <para>� private int seeds;</para>
        <para>� private Seed[] s;</para>
        <para>� Fruit(FruitQualities q, int seedCount) { </para>
        <para>��� fq = q;</para>
        <para>��� seeds = seedCount;</para>
        <para>��� s = new Seed[seeds];</para>
        <para>��� for(int i = 0; i &lt; seeds; i++)</para>
        <para>����� s[i] = new Seed();</para>
        <para>� }</para>
        <para>� // Other constructors:</para>
        <para>� // ...</para>
        <para>� // Copy constructor:</para>
        <para>� Fruit(Fruit f) {</para>
        <para>��� fq = new FruitQualities(f.fq);</para>
        <para>��� seeds = f.seeds;</para>
        <para>��� // Call all Seed copy-constructors:</para>
        <para>��� for(int i = 0; i &lt; seeds; i++)</para>
        <para>����� s[i] = new Seed(f.s[i]);</para>
        <para>��� // Other copy-construction activities...</para>
        <para>� }</para>
        <para>� // To allow derived constructors (or other </para>
        <para>� // methods) to put in different qualities:</para>
        <para>� protected void addQualities(FruitQualities q) {</para>
        <para>��� fq = q;</para>
        <para>� }</para>
        <para>� protected FruitQualities getQualities() {</para>
        <para>��� return fq;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class Tomato extends Fruit {</para>
        <para>� Tomato() {</para>
        <para>��� super(new FruitQualities(), 100);</para>
        <para>� }</para>
        <para>� Tomato(Tomato t) { // Copy-constructor</para>
        <para>��� super(t); // Upcast for base copy-constructor</para>
        <para>��� // Other copy-construction activities...</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class ZebraQualities extends FruitQualities {</para>
        <para>� private int stripedness;</para>
        <para>� ZebraQualities() { // Default constructor</para>
        <para>��� // do something meaningful...</para>
        <para>� }</para>
        <para>� ZebraQualities(ZebraQualities z) {</para>
        <para>��� super(z);</para>
        <para>��� stripedness = z.stripedness;</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>class GreenZebra extends Tomato {</para>
        <para>� GreenZebra() {</para>
        <para>��� addQualities(new ZebraQualities());</para>
        <para>� }</para>
        <para>� GreenZebra(GreenZebra g) {</para>
        <para>��� super(g); // Calls Tomato(Tomato)</para>
        <para>��� // Restore the right qualities:</para>
        <para>��� addQualities(new ZebraQualities());</para>
        <para>� }</para>
        <para>� void evaluate() {</para>
        <para>��� ZebraQualities zq = </para>
        <para>����� (ZebraQualities)getQualities();</para>
        <para>��� // Do something with the qualities</para>
        <para>��� // ...</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class CopyConstructor {</para>
        <para>� public static void ripen(Tomato t) {</para>
        <para>��� // Use the &quot;copy constructor&quot;:</para>
        <para>��� t = new Tomato(t); </para>
        <para>��� System.out.println(&quot;In ripen, t is a &quot; +</para>
        <para>����� t.getClass().getName());</para>
        <para>� }</para>
        <para>� public static void slice(Fruit f) {</para>
        <para>��� f = new Fruit(f); // Hmmm... will this work?</para>
        <para>��� System.out.println(&quot;In slice, f is a &quot; +</para>
        <para>����� f.getClass().getName());</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Tomato tomato = new Tomato();</para>
        <para>��� ripen(tomato); // OK</para>
        <para>��� slice(tomato); // OOPS!</para>
        <para>��� GreenZebra g = new GreenZebra();</para>
        <para>��� ripen(g); // OOPS!</para>
        <para>��� slice(g); // OOPS!</para>
        <para>��� g.evaluate();</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>This seems a bit strange at first. Sure, fruit has qualities, but why not just put data members representing those qualities directly into the <emphasis role="bold">Fruit</emphasis> class? There are two potential reasons. The first is that you might want to easily insert or change the qualities. Note that <emphasis role="bold">Fruit</emphasis> has a <emphasis role="bold">protected</emphasis><emphasis role="bold">addQualities( )</emphasis> method to allow derived classes to do this. (You might think the logical thing to do is to have a <emphasis role="bold">protected</emphasis> constructor in <emphasis role="bold">Fruit</emphasis> that takes a <emphasis role="bold">FruitQualities</emphasis> argument, but constructors don�t inherit so it wouldn�t be available in second or greater level classes.) By making the fruit qualities into a separate class, you have greater flexibility, including the ability to change the qualities midway through the lifetime of a particular <emphasis role="bold">Fruit</emphasis> object.</para>
        <para>The second reason for making <emphasis role="bold">FruitQualities</emphasis> a separate object is in case you want to add new qualities or to change the behavior via inheritance and polymorphism. Note that for <emphasis role="bold">GreenZebra</emphasis> (which <emphasis role="italic">really is</emphasis> a type of tomato�I�ve grown them and they�re fabulous), the constructor calls <emphasis role="bold">addQualities( )</emphasis> and passes it a <emphasis role="bold">ZebraQualities</emphasis> object, which is derived from <emphasis role="bold">FruitQualities</emphasis> so it can be attached to the <emphasis role="bold">FruitQualities</emphasis> reference in the base class. Of course, when <emphasis role="bold">GreenZebra</emphasis> uses the <emphasis role="bold">FruitQualities</emphasis> it must downcast it to the correct type (as seen in <emphasis role="bold">evaluate( )</emphasis>), but it always knows that type is <emphasis role="bold">ZebraQualities</emphasis>.</para>
        <para>You�ll also see that there�s a <emphasis role="bold">Seed</emphasis> class, and that <emphasis role="bold">Fruit</emphasis> (which by definition carries its own seeds)<anchor xreflabel="[82]" xml:id="_ftnref82"/>[82] contains an array of <emphasis role="bold">Seed</emphasis>s.</para>
        <para>Finally, notice that each class has a copy constructor, and that each copy constructor must take care to call the copy constructors for the base class and member objects to produce a deep copy. The copy constructor is tested inside the class <emphasis role="bold">CopyConstructor</emphasis>. The method <emphasis role="bold">ripen( )</emphasis> takes a <emphasis role="bold">Tomato </emphasis>argument and performs copy-construction on it in order to duplicate the object:</para>
        <para>t = new Tomato(t);</para>
        <para> </para>
        <para>while <emphasis role="bold">slice( )</emphasis> takes a more generic <emphasis role="bold">Fruit</emphasis> object and also duplicates it:</para>
        <para>f = new Fruit(f);</para>
        <para> </para>
        <para>These are tested with different kinds of <emphasis role="bold">Fruit</emphasis> in <emphasis role="bold">main( )</emphasis>. Here�s the output:</para>
        <para>In ripen, t is a Tomato</para>
        <para>In slice, f is a Fruit</para>
        <para>In ripen, t is a Tomato</para>
        <para>In slice, f is a Fruit</para>
        <para> </para>
        <para>This is where the problem shows up. After the copy-construction that happens to the <emphasis role="bold">Tomato</emphasis> inside <emphasis role="bold">slice( )</emphasis>, the result is no longer a <emphasis role="bold">Tomato</emphasis> object, but just a <emphasis role="bold">Fruit</emphasis>. It has lost all of its tomato-ness. Further, when you take a <emphasis role="bold">GreenZebra</emphasis>, both <emphasis role="bold">ripen( )</emphasis> and <emphasis role="bold">slice( )</emphasis> turn it into a <emphasis role="bold">Tomato</emphasis> and a <emphasis role="bold">Fruit</emphasis>, respectively. Thus, unfortunately, the copy constructor scheme is no good to us in Java when attempting to make a local copy of an object.</para>
        <section>
          <title>Why does it work in C++ and not Java?</title>
          <para>The copy constructor is a fundamental part of C++, since it automatically makes a local copy of an object. Yet the example above proves that it does not work for Java. Why? In Java everything that we manipulate is a reference, while in C++ you can have reference-like entities and you can <emphasis role="italic">also</emphasis> pass around the objects directly. That�s what the C++ copy constructor is for: when you want to take an object and pass it in by value, thus duplicating the object. So it works fine in C++, but you should keep in mind that this scheme fails in Java, so don�t use it.</para>
        </section>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064939"/><anchor xreflabel="Read-only
classes" xml:id="_Toc375545433"/>Read-only classes</title>
      <para>While the local copy produced by <emphasis role="bold">clone( ) </emphasis>gives the desired results in the appropriate cases, it is an example of forcing the programmer (the author of the method) to be responsible for preventing the ill effects of aliasing. What if you�re making a library that�s so general purpose and commonly used that you cannot make the assumption that it will always be cloned in the proper places? Or more likely, what if you <emphasis role="italic">want</emphasis> to allow aliasing for efficiency�to prevent the needless duplication of objects�but you don�t want the negative side effects of aliasing?</para>
      <para>One solution is to create <emphasis role="italic">immutable objects</emphasis> which belong to read-only classes. You can define a class such that no methods in the class cause changes to the internal state of the object. In such a class, aliasing has no impact since you can read only the internal state, so if many pieces of code are reading the same object there�s no problem.</para>
      <para>As a simple example of immutable objects, Java�s standard library contains �wrapper� classes for all the primitive types. You might have already discovered that, if you want to store an <emphasis role="bold">int</emphasis> inside a container such as an <emphasis role="bold">ArrayList</emphasis> (which takes only <emphasis role="bold">Object reference</emphasis>s), you can wrap your <emphasis role="bold">int</emphasis> inside the standard library <emphasis role="bold">Integer</emphasis> class:</para>
      <para>//: appendixa:ImmutableInteger.java</para>
      <para>// The Integer class cannot be changed.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>public class ImmutableInteger {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� ArrayList v = new ArrayList();</para>
      <para>��� for(int i = 0; i &lt; 10; i++) </para>
      <para>����� v.add(new Integer(i));</para>
      <para>��� // But how do you change the int</para>
      <para>��� // inside the Integer?</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The <emphasis role="bold">Integer</emphasis> class (as well as all the primitive �wrapper� classes) implements immutability in a simple fashion: they have no methods that allow you to change the object.</para>
      <para>If you do need an object that holds a primitive type that can be modified, you must create it yourself. Fortunately, this is trivial:</para>
      <para>//: appendixa:MutableInteger.java</para>
      <para>// A changeable wrapper class.</para>
      <para>import java.util.*;</para>
      <para> </para>
      <para>class IntValue { </para>
      <para>� int n;</para>
      <para>� IntValue(int x) { n = x; }</para>
      <para>� public String toString() { </para>
      <para>��� return Integer.toString(n);</para>
      <para>� }</para>
      <para>}</para>
      <para> </para>
      <para>public class MutableInteger {</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� ArrayList v = new ArrayList();</para>
      <para>��� for(int i = 0; i &lt; 10; i++) </para>
      <para>����� v.add(new IntValue(i));</para>
      <para>��� System.out.println(v);</para>
      <para>��� for(int i = 0; i &lt; v.size(); i++)</para>
      <para>����� ((IntValue)v.get(i)).n++;</para>
      <para>��� System.out.println(v);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Note that <emphasis role="bold">n</emphasis> is friendly to simplify coding.</para>
      <para><emphasis role="bold">IntValue</emphasis> can be even simpler if the default initialization to zero is adequate (then you don�t need the constructor) and you don�t care about printing it out (then you don�t need the <emphasis role="bold">toString( )</emphasis>):</para>
      <para>class IntValue { int n; }</para>
      <para> </para>
      <para>Fetching the element out and casting it is a bit awkward, but that�s a feature of <emphasis role="bold">ArrayList,</emphasis> not of <emphasis role="bold">IntValue</emphasis>.</para>
      <section>
        <title><anchor xreflabel="Creating read-only classes" xml:id="_Toc481064940"/>Creating read-only classes</title>
        <para>It�s possible to create your own read-only class. Here�s an example:</para>
        <para>//: appendixa:Immutable1.java</para>
        <para>// Objects that cannot be modified</para>
        <para>// are immune to aliasing.</para>
        <para> </para>
        <para>public class Immutable1 {</para>
        <para>� private int data;</para>
        <para>� public Immutable1(int initVal) {</para>
        <para>��� data = initVal;</para>
        <para>� }</para>
        <para>� public int read() { return data; }</para>
        <para>� public boolean nonzero() { return data != 0; }</para>
        <para>� public Immutable1 quadruple() {</para>
        <para>��� return new Immutable1(data * 4);</para>
        <para>� }</para>
        <para>� static void f(Immutable1 i1) {</para>
        <para>��� Immutable1 quad = i1.quadruple();</para>
        <para>��� System.out.println(&quot;i1 = &quot; + i1.read());</para>
        <para>��� System.out.println(&quot;quad = &quot; + quad.read());</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Immutable1 x = new Immutable1(47);</para>
        <para>��� System.out.println(&quot;x = &quot; + x.read());</para>
        <para>��� f(x);</para>
        <para>��� System.out.println(&quot;x = &quot; + x.read());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>All data is <emphasis role="bold">private</emphasis>, and you�ll see that none of the <emphasis role="bold">public</emphasis> methods modify that data. Indeed, the method that does appear to modify an object is <emphasis role="bold">quadruple( )</emphasis>, but this creates a new <emphasis role="bold">Immutable1</emphasis> object and leaves the original one untouched.</para>
        <para>The method <emphasis role="bold">f( )</emphasis> takes an <emphasis role="bold">Immutable1</emphasis> object and performs various operations on it, and the output of <emphasis role="bold">main( )</emphasis> demonstrates that there is no change to <emphasis role="bold">x</emphasis>. Thus, <emphasis role="bold">x</emphasis>�s object could be aliased many times without harm because the <emphasis role="bold">Immutable1</emphasis> class is designed to guarantee that objects cannot be changed.</para>
      </section>
      <section>
        <title><anchor xreflabel="The drawback to immutability" xml:id="_Toc481064941"/>The drawback to immutability</title>
        <para>Creating an immutable class seems at first to provide an elegant solution. However, whenever you do need a modified object of that new type you must suffer the overhead of a new object creation, as well as potentially causing more frequent garbage collections. For some classes this is not a problem, but for others (such as the <emphasis role="bold">String</emphasis> class) it is prohibitively expensive.</para>
        <para>The solution is to create a companion class that <emphasis role="italic">can</emphasis> be modified. Then, when you�re doing a lot of modifications, you can switch to using the modifiable companion class and switch back to the immutable class when you�re done.</para>
        <para>The example above can be modified to show this:</para>
        <para>//: appendixa:Immutable2.java</para>
        <para>// A companion class for making </para>
        <para>// changes to immutable objects.</para>
        <para> </para>
        <para>class Mutable {</para>
        <para>� private int data;</para>
        <para>� public Mutable(int initVal) {</para>
        <para>��� data = initVal;</para>
        <para>� }</para>
        <para>� public Mutable add(int x) { </para>
        <para>��� data += x;</para>
        <para>��� return this;</para>
        <para>� }</para>
        <para>� public Mutable multiply(int x) {</para>
        <para>��� data *= x;</para>
        <para>��� return this;</para>
        <para>� }</para>
        <para>� public Immutable2 makeImmutable2() {</para>
        <para>��� return new Immutable2(data);</para>
        <para>� }</para>
        <para>}</para>
        <para> </para>
        <para>public class Immutable2 {</para>
        <para>� private int data;</para>
        <para>� public Immutable2(int initVal) {</para>
        <para>��� data = initVal;</para>
        <para>� }</para>
        <para>� public int read() { return data; }</para>
        <para>� public boolean nonzero() { return data != 0; }</para>
        <para>� public Immutable2 add(int x) { </para>
        <para>��� return new Immutable2(data + x);</para>
        <para>� }</para>
        <para>� public Immutable2 multiply(int x) {</para>
        <para>��� return new Immutable2(data * x);</para>
        <para>� }</para>
        <para>� public Mutable makeMutable() {</para>
        <para>��� return new Mutable(data);</para>
        <para>� }</para>
        <para>� public static Immutable2 modify1(Immutable2 y){</para>
        <para>��� Immutable2 val = y.add(12);</para>
        <para>��� val = val.multiply(3);</para>
        <para>��� val = val.add(11);</para>
        <para>��� val = val.multiply(2);</para>
        <para>��� return val;</para>
        <para>� }</para>
        <para>� // This produces the same result:</para>
        <para>� public static Immutable2 modify2(Immutable2 y){</para>
        <para>��� Mutable m = y.makeMutable();</para>
        <para>��� m.add(12).multiply(3).add(11).multiply(2);</para>
        <para>��� return m.makeImmutable2();</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� Immutable2 i2 = new Immutable2(47);</para>
        <para>��� Immutable2 r1 = modify1(i2);</para>
        <para>��� Immutable2 r2 = modify2(i2);</para>
        <para>��� System.out.println(&quot;i2 = &quot; + i2.read());</para>
        <para>��� System.out.println(&quot;r1 = &quot; + r1.read());</para>
        <para>��� System.out.println(&quot;r2 = &quot; + r2.read());</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para><emphasis role="bold">Immutable2 </emphasis>contains methods that, as before, preserve the immutability of the objects by producing new objects whenever a modification is desired. These are the <emphasis role="bold">add( )</emphasis> and <emphasis role="bold">multiply( ) </emphasis>methods. The companion class is called <emphasis role="bold">Mutable</emphasis>, and it also has <emphasis role="bold">add( )</emphasis> and <emphasis role="bold">multiply( )</emphasis> methods, but these modify the <emphasis role="bold">Mutable</emphasis> object rather than making a new one. In addition, <emphasis role="bold">Mutable</emphasis> has a method to use its data to produce an <emphasis role="bold">Immutable2</emphasis> object and vice versa. </para>
        <para>The two static methods <emphasis role="bold">modify1( )</emphasis> and <emphasis role="bold">modify2( )</emphasis> show two different approaches to producing the same result. In <emphasis role="bold">modify1( )</emphasis>, everything is done within the <emphasis role="bold">Immutable2</emphasis> class and you can see that four new <emphasis role="bold">Immutable2</emphasis> objects are created in the process. (And each time <emphasis role="bold">val</emphasis> is reassigned, the previous object becomes garbage.)</para>
        <para>In the method <emphasis role="bold">modify2( )</emphasis>, you can see that the first action is to take the <emphasis role="bold">Immutable2 y</emphasis> and produce a <emphasis role="bold">Mutable</emphasis> from it. (This is just like calling <emphasis role="bold">clone( )</emphasis> as you saw earlier, but this time a different type of object is created.) Then the <emphasis role="bold">Mutable</emphasis> object is used to perform a lot of change operations <emphasis role="italic">without</emphasis> requiring the creation of many new objects. Finally, it�s turned back into an <emphasis role="bold">Immutable2</emphasis>. Here, two new objects are created (the <emphasis role="bold">Mutable</emphasis> and the result <emphasis role="bold">Immutable2</emphasis>) instead of four.</para>
        <para>This approach makes sense, then, when:</para>
        <para>You need immutable objects and</para>
        <para><emphasis role="bold">149.  </emphasis>You often need to make a lot of modifications or</para>
        <para><emphasis role="bold">150.  </emphasis>It�s expensive to create new immutable objects.</para>
      </section>
      <section>
        <title><anchor xreflabel="Immutable Strings" xml:id="_Toc481064942"/>Immutable <emphasis role="bold">String</emphasis>s</title>
        <para>Consider the following code:</para>
        <para>//: appendixa:Stringer.java</para>
        <para> </para>
        <para>public class Stringer {</para>
        <para>� static String upcase(String s) {</para>
        <para>��� return s.toUpperCase();</para>
        <para>� }</para>
        <para>� public static void main(String[] args) {</para>
        <para>��� String q = new String(&quot;howdy&quot;);</para>
        <para>��� System.out.println(q); // howdy</para>
        <para>��� String qq = upcase(q);</para>
        <para>��� System.out.println(qq); // HOWDY</para>
        <para>��� System.out.println(q); // howdy</para>
        <para>� }</para>
        <para>} ///:~</para>
        <para> </para>
        <para>When <emphasis role="bold">q</emphasis> is passed in to <emphasis role="bold">upcase( )</emphasis> it�s actually a copy of the reference to <emphasis role="bold">q</emphasis>. The object this reference is connected to stays put in a single physical location. The references are copied as they are passed around.</para>
        <para>Looking at the definition for <emphasis role="bold">upcase( )</emphasis>, you can see that the reference that�s passed in has the name <emphasis role="bold">s</emphasis>, and it exists for only as long as the body of <emphasis role="bold">upcase( )</emphasis> is being executed. When <emphasis role="bold">upcase( )</emphasis> completes, the local reference <emphasis role="bold">s</emphasis> vanishes. <emphasis role="bold">upcase( )</emphasis> returns the result, which is the original string with all the characters set to uppercase. Of course, it actually returns a reference to the result. But it turns out that the reference that it returns is for a new object, and the original <emphasis role="bold">q</emphasis> is left alone. How does this happen?</para>
        <section>
          <title>Implicit constants</title>
          <para>If you say:</para>
          <para>String s = &quot;asdf&quot;;</para>
          <para>String x = Stringer.upcase(s);</para>
          <para> </para>
          <para>do you really want the <emphasis role="bold">upcase( )</emphasis> method to <emphasis role="italic">change</emphasis> the argument? In general, you don�t, because an argument usually looks to the reader of the code as a piece of information provided to the method, not something to be modified. This is an important guarantee, since it makes code easier to write and understand.</para>
          <para>In C++, the availability of this guarantee was important enough to put in a special keyword, <emphasis role="bold">const</emphasis>, to allow the programmer to ensure that a reference (pointer or reference in C++) could not be used to modify the original object. But then the C++ programmer was required to be diligent and remember to use <emphasis role="bold">const</emphasis> everywhere. It can be confusing and easy to forget.</para>
        </section>
        <section>
          <title><anchor xreflabel="Overloading �+� and the StringBuffer" xml:id="_Toc375545435"/>Overloading �+� and the <emphasis role="bold">StringBuffer</emphasis></title>
          <para>Objects of the <emphasis role="bold">String</emphasis> class are designed to be immutable, using the technique shown previously. If you examine the online documentation<emphasis role="bold"/>for the <emphasis role="bold">String</emphasis> class (which is summarized a little later in this appendix), you�ll see that every method in the class that appears to modify a <emphasis role="bold">String</emphasis> really creates and returns a brand new <emphasis role="bold">String</emphasis> object containing the modification. The original <emphasis role="bold">String</emphasis> is left untouched. Thus, there�s no feature in Java like C++�s <emphasis role="bold">const</emphasis> to make the compiler support the immutability of your objects. If you want it, you have to wire it in yourself, like <emphasis role="bold">String</emphasis> does.</para>
          <para>Since <emphasis role="bold">String </emphasis>objects are immutable, you can alias to a particular <emphasis role="bold">String </emphasis>as many times as you want. Because it�s read-only there�s no possibility that one reference will change something that will affect the other references. So a read-only object solves the aliasing problem nicely.</para>
          <para>It also seems possible to handle all the cases in which you need a modified object by creating a brand new version of the object with the modifications, as <emphasis role="bold">String</emphasis> does. However, for some operations this isn�t efficient. A case in point is the operator <emphasis role="bold">�+</emphasis>� that has been overloaded for <emphasis role="bold">String</emphasis> objects. Overloading means that it has been given an extra meaning when used with a particular class. (The �<emphasis role="bold">+</emphasis>� and �<emphasis role="bold">+=</emphasis>� for <emphasis role="bold">String</emphasis> are the only operators that are overloaded in Java, and Java does not allow the programmer to overload any others)<anchor xreflabel="[83]" xml:id="_ftnref83"/>[83].</para>
          <para>When used with <emphasis role="bold">String</emphasis> objects, the �<emphasis role="bold">+</emphasis>� allows you to concatenate <emphasis role="bold">String</emphasis>s together:</para>
          <para>String s = &quot;abc&quot; + foo + &quot;def&quot; + Integer.toString(47);</para>
          <para> </para>
          <para>You could imagine how this <emphasis role="italic">might</emphasis> work: the <emphasis role="bold">String</emphasis> �abc� could have a method <emphasis role="bold">append( )</emphasis> that creates a new <emphasis role="bold">String</emphasis> object containing �abc� concatenated with the contents of <emphasis role="bold">foo</emphasis>. The new <emphasis role="bold">String</emphasis> object would then create another new <emphasis role="bold">String</emphasis> that added �def,� and so on.</para>
          <para>This would certainly work, but it requires the creation of a lot of <emphasis role="bold">String</emphasis> objects just to put together this new <emphasis role="bold">String</emphasis>, and then you have a bunch of the intermediate <emphasis role="bold">String</emphasis> objects that need to be garbage-collected. I suspect that the Java designers tried this approach first (which is a lesson in software design�you don�t really know anything about a system until you try it out in code and get something working). I also suspect they discovered that it delivered unacceptable performance.</para>
          <para>The solution is a mutable companion class similar to the one shown previously. For <emphasis role="bold">String</emphasis>, this companion class is called <emphasis role="bold">StringBuffer</emphasis>, and the compiler automatically creates a <emphasis role="bold">StringBuffer</emphasis> to evaluate certain expressions, in particular when the overloaded operators <emphasis role="bold">+</emphasis> and <emphasis role="bold">+=</emphasis> are used with <emphasis role="bold">String</emphasis> objects. This example shows what happens:</para>
          <para>//: appendixa:ImmutableStrings.java</para>
          <para>// Demonstrating StringBuffer.</para>
          <para> </para>
          <para>public class ImmutableStrings {</para>
          <para>� public static void main(String[] args) {</para>
          <para>��� String foo = &quot;foo&quot;;</para>
          <para>��� String s = &quot;abc&quot; + foo +</para>
          <para>����� &quot;def&quot; + Integer.toString(47);</para>
          <para>��� System.out.println(s);</para>
          <para>��� // The &quot;equivalent&quot; using StringBuffer:</para>
          <para>��� StringBuffer sb = </para>
          <para>����� new StringBuffer(&quot;abc&quot;); // Creates String!</para>
          <para>��� sb.append(foo);</para>
          <para>��� sb.append(&quot;def&quot;); // Creates String!</para>
          <para>��� sb.append(Integer.toString(47));</para>
          <para>��� System.out.println(sb);</para>
          <para>� }</para>
          <para>} ///:~</para>
          <para> </para>
          <para>In the creation of <emphasis role="bold">String s</emphasis>, the compiler is doing the rough equivalent of the subsequent code that uses <emphasis role="bold">sb</emphasis>: a <emphasis role="bold">StringBuffer</emphasis> is created and <emphasis role="bold">append( )</emphasis> is used to add new characters directly into the <emphasis role="bold">StringBuffer</emphasis> object (rather than making new copies each time). While this is more efficient, it�s worth noting that each time you create a quoted character string such as <emphasis role="bold">�abc�</emphasis> and <emphasis role="bold">�def�</emphasis>, the compiler turns those into <emphasis role="bold">String</emphasis> objects. So there can be more objects created than you expect, despite the efficiency afforded through <emphasis role="bold">StringBuffer</emphasis>.</para>
        </section>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc375545434"/><anchor xreflabel="" xml:id="_Toc375545436"/><anchor xreflabel="" xml:id="_Toc481064943"/><anchor xreflabel="The String
and StringBuffer class" xml:id="_Toc375545438"/>The <emphasis role="bold">String</emphasis> and  <emphasis role="bold">StringBuffer </emphasis>classes</title>
        <para>Here is an overview of the methods available for both <emphasis role="bold">String</emphasis> and <emphasis role="bold">StringBuffer</emphasis> so you can get a feel for the way they interact. These tables don�t contain every single method, but rather the ones that are important to this discussion. Methods that are overloaded are summarized in a single row.</para>
        <para>First, the <emphasis role="bold">String</emphasis> class:</para>
        <informaltable frame="all">
          <tgroup cols="3">
            <colspec colname="c1" colwidth="15*"/>
            <colspec colname="c2" colwidth="16*"/>
            <colspec colname="c3" colwidth="17*"/>
            <thead>
              <row>
                <entry valign="top"><para> Method</para></entry>
                <entry valign="top"><para> Arguments, Overloading</para></entry>
                <entry valign="top"><para> Use</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry valign="top"><para> Constructor</para></entry>
                <entry valign="top"><para> Overloaded: Default, String, StringBuffer, char arrays, byte arrays.</para></entry>
                <entry valign="top"><para> Creating String objects.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> length( )</para></entry>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> Number of characters in the String.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> charAt()</para></entry>
                <entry valign="top"><para> int Index</para></entry>
                <entry valign="top"><para> The char at a location in the String.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> getChars( ), getBytes( )</para></entry>
                <entry valign="top"><para> The beginning and end from which to copy, the array to copy into, an index into the destination array.</para></entry>
                <entry valign="top"><para> Copy chars or bytes into an external array.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> toCharArray( )</para></entry>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> Produces a char[] containing the characters in the String.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> equals( ), equals-IgnoreCase( )</para></entry>
                <entry valign="top"><para> A String to compare with.</para></entry>
                <entry valign="top"><para> An equality check on the contents of the two Strings.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> compareTo( )</para></entry>
                <entry valign="top"><para> A String to compare with.</para></entry>
                <entry valign="top"><para> Result is negative, zero, or positive depending on the lexicographical ordering of the String and the argument. Uppercase and lowercase are not equal!</para></entry>
              </row>
              <row>
                <entry valign="top"><para> regionMatches( )</para></entry>
                <entry valign="top"><para> Offset into this String, the other String and its offset and length to compare. Overload adds �ignore case.�</para></entry>
                <entry valign="top"><para> boolean result indicates whether the region matches.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> startsWith( )</para></entry>
                <entry valign="top"><para> String that it might start with. Overload adds offset into argument.</para></entry>
                <entry valign="top"><para> boolean result indicates whether the String starts with the argument.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> endsWith( )</para></entry>
                <entry valign="top"><para> String that might be a suffix of this String.</para></entry>
                <entry valign="top"><para> boolean result indicates whether the argument is a suffix.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> indexOf( ), lastIndexOf( )</para></entry>
                <entry valign="top"><para> Overloaded: char, char and starting index, String, String, and starting index.</para></entry>
                <entry valign="top"><para> Returns -1 if the argument is not found within this String, otherwise returns the index where the argument starts. lastIndexOf( ) searches backward from end.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> substring( )</para></entry>
                <entry valign="top"><para> Overloaded: Starting index, starting index, and ending index.</para></entry>
                <entry valign="top"><para> Returns a new String object containing the specified character set.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> concat( )</para></entry>
                <entry valign="top"><para> The String to concatenate</para></entry>
                <entry valign="top"><para> Returns a new String object containing the original String�s characters followed by the characters in the argument.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> replace( )</para></entry>
                <entry valign="top"><para> The old character to search for, the new character to replace it with.</para></entry>
                <entry valign="top"><para> Returns a new String object with the replacements made. Uses the old String if no match is found.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> toLowerCase( ) toUpperCase( )</para></entry>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> Returns a new String object with the case of all letters changed. Uses the old String if no changes need to be made.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> trim( )</para></entry>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> Returns a new String object with the white space removed from each end. Uses the old String if no changes need to be made.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> valueOf( )</para></entry>
                <entry valign="top"><para> Overloaded: Object, char[], char[] and offset and count, boolean, char, int, long, float, double.</para></entry>
                <entry valign="top"><para> Returns a String containing a character representation of the argument.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> intern( )</para></entry>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> Produces one and only one String ref per unique character sequence.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para><anchor xreflabel="You can see
that every String method carefully returns a new String object
when it�s necessary to change the contents. Also notice that if the contents
don�t need changing the method will just return a reference to the original String.
This saves storage and overhead." xml:id="_Toc375545437"/>You can see that every <emphasis role="bold">String</emphasis> method carefully returns a new <emphasis role="bold">String</emphasis> object when it�s necessary to change the contents. Also notice that if the contents don�t need changing the method will just return a reference to the original <emphasis role="bold">String</emphasis>. This saves storage and overhead.</para>
        <para>Here�s the <emphasis role="bold">StringBuffer</emphasis> class:</para>
        <informaltable frame="all">
          <tgroup cols="3">
            <colspec colname="c1" colwidth="12*"/>
            <colspec colname="c2" colwidth="20*"/>
            <colspec colname="c3" colwidth="16*"/>
            <thead>
              <row>
                <entry valign="top"><para> Method</para></entry>
                <entry valign="top"><para> Arguments, overloading</para></entry>
                <entry valign="top"><para> Use</para></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry valign="top"><para> Constructor</para></entry>
                <entry valign="top"><para> Overloaded: default, length of buffer to create, String to create from.</para></entry>
                <entry valign="top"><para> Create a new StringBuffer object.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> toString( )</para></entry>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> Creates a String from this StringBuffer.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> length( )</para></entry>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> Number of characters in the StringBuffer.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> capacity( )</para></entry>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> Returns current number of spaces allocated.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> ensure-</para><para> Capacity( )</para></entry>
                <entry valign="top"><para> Integer indicating desired capacity.</para></entry>
                <entry valign="top"><para> Makes the StringBuffer hold at least the desired number of spaces.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> setLength( )</para></entry>
                <entry valign="top"><para> Integer indicating new length of character string in buffer.</para></entry>
                <entry valign="top"><para> Truncates or expands the previous character string. If expanding, pads with nulls.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> charAt( )</para></entry>
                <entry valign="top"><para> Integer indicating the location of the desired element.</para></entry>
                <entry valign="top"><para> Returns the char at that location in the buffer.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> setCharAt( )</para></entry>
                <entry valign="top"><para> Integer indicating the location of the desired element and the new char value for the element.</para></entry>
                <entry valign="top"><para> Modifies the value at that location.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> getChars( )</para></entry>
                <entry valign="top"><para> The beginning and end from which to copy, the array to copy into, an index into the destination array.</para></entry>
                <entry valign="top"><para> Copy chars into an external array. There is no getBytes( ) as in String.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> append( )</para></entry>
                <entry valign="top"><para> Overloaded: Object, String, char[], char[] with offset and length, boolean, char, int, long, float, double.</para></entry>
                <entry valign="top"><para> The argument is converted to a string and appended to the end of the current buffer, increasing the buffer if necessary.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> insert( )</para></entry>
                <entry valign="top"><para> Overloaded, each with a first argument of the offset at which to start inserting: Object, String, char[], boolean, char, int, long, float, double.</para></entry>
                <entry valign="top"><para> The second argument is converted to a string and inserted into the current buffer beginning at the offset. The buffer is increased if necessary.</para></entry>
              </row>
              <row>
                <entry valign="top"><para> reverse( )</para></entry>
                <entry valign="top"><para>  </para></entry>
                <entry valign="top"><para> The order of the characters in the buffer is reversed.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <para>The most commonly used method is <emphasis role="bold">append( )</emphasis>, which is used by the compiler when evaluating <emphasis role="bold">String</emphasis> expressions that contain the �<emphasis role="bold">+</emphasis>� and �<emphasis role="bold">+=</emphasis>� operators. The <emphasis role="bold">insert( )</emphasis> method has a similar form, and both methods perform significant manipulations to the buffer instead of creating new objects.</para>
      </section>
      <section>
        <title><anchor xreflabel="Strings are special" xml:id="_Toc481064944"/><emphasis role="bold">String</emphasis>s are special</title>
        <para>By now you�ve seen that the <emphasis role="bold">String</emphasis> class is not just another class in Java. There are a lot of special cases in <emphasis role="bold">String</emphasis>, not the least of which is that it�s a built-in class and fundamental to Java. Then there�s the fact that a quoted character string is converted to a <emphasis role="bold">String</emphasis> by the compiler and the special overloaded operators <emphasis role="bold">+</emphasis> and <emphasis role="bold">+=</emphasis>. In this appendix you�ve seen the remaining special case: the carefully built immutability using the companion <emphasis role="bold">StringBuffer</emphasis> and some extra magic in the compiler.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064945"/><anchor xreflabel="Summary" xml:id="_Toc375545442"/>Summary</title>
      <para>Because everything is a reference in Java, and because every object is created on the heap and garbage-collected only when it is no longer used, the flavor of object manipulation changes, especially when passing and returning objects. For example, in C or C++, if you wanted to initialize some piece of storage in a method, you�d probably request that the user pass the address of that piece of storage into the method. Otherwise you�d have to worry about who was responsible for destroying that storage. Thus, the interface and understanding of such methods is more complicated. But in Java, you never have to worry about responsibility or whether an object will still exist when it is needed, since that is always taken care of for you. Your can create an object at the point that it is needed, and no sooner, and never worry about the mechanics of passing around responsibility for that object: you simply pass the reference. Sometimes the simplification that this provides is unnoticed, other times it is staggering.</para>
      <para>The downside to all this underlying magic is twofold:</para>
      <para>You always take the efficiency hit for the extra memory management (although this can be quite small), and there�s always a slight amount of uncertainty about the time something can take to run (since the garbage collector can be forced into action whenever you get low on memory). For most applications, the benefits outweigh the drawbacks, and particularly time-critical sections can be written using <emphasis role="bold">native</emphasis> methods (see Appendix B). </para>
      <para>151.   Aliasing: sometimes you can accidentally end up with two references to the same object, which is a problem only if both references are assumed to point to a <emphasis role="italic">distinct</emphasis> object. This is where you need to pay a little closer attention and, when necessary, <emphasis role="bold">clone( )</emphasis> an object to prevent the other reference from being surprised by an unexpected change. Alternatively, you can support aliasing for efficiency by creating immutable objects whose operations can return a new object of the same type or some different type, but never change the original object so that anyone aliased to that object sees no change.</para>
      <para>Some people say that cloning in Java is a botched design, and to heck with it, so they implement their own version of cloning<anchor xreflabel="[84]" xml:id="_ftnref84"/>[84] and never call the <emphasis role="bold">Object.clone( )</emphasis> method, thus eliminating the need to implement <emphasis role="bold">Cloneable</emphasis> and catch the <emphasis role="bold">CloneNotSupportedException</emphasis>. This is certainly a reasonable approach and since <emphasis role="bold">clone( )</emphasis> is supported so rarely within the standard Java library, it is apparently a safe one as well. But as long as you don�t call <emphasis role="bold">Object.clone( )</emphasis> you don�t need to implement <emphasis role="bold">Cloneable</emphasis> or catch the exception, so that would seem acceptable as well.</para>
    </section>
    <section>
      <title><anchor xreflabel="" xml:id="_Toc481064946"/><anchor xreflabel="Exercises" xml:id="_Toc375545443"/>Exercises</title>
      <para>Solutions to selected exercises can be found in the electronic document <emphasis role="italic">The Thinking in Java Annotated Solution Guide</emphasis>, available for a small fee from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>            Demonstrate a second level of aliasing. Create a method that takes a reference to an object but doesn�t modify that reference�s object. However, the method calls a second method, passing it the reference, and this second method does modify the object.</para>
      <para>  259.         Create a class <emphasis role="bold">myString</emphasis> containing a <emphasis role="bold">String</emphasis> object that you initialize in the constructor using the constructor�s argument. Add a <emphasis role="bold">toString( )</emphasis> method and a method <emphasis role="bold">concatenate( )</emphasis> that appends a <emphasis role="bold">String</emphasis> object to your internal string. Implement <emphasis role="bold">clone( )</emphasis> in <emphasis role="bold">myString</emphasis>. Create two <emphasis role="bold">static</emphasis> methods that each take a <emphasis role="bold">myString x</emphasis> reference as an argument and call <emphasis role="bold">x.concatenate(&quot;test&quot;)</emphasis>, but in the second method call <emphasis role="bold">clone( )</emphasis> first. Test the two methods and show the different effects.</para>
      <para>  260.         Create a class called <emphasis role="bold">Battery</emphasis> containing an <emphasis role="bold">int</emphasis> that is a battery number (as a unique identifier). Make it cloneable and give it a <emphasis role="bold">toString( )</emphasis> method. Now create a class called <emphasis role="bold">Toy</emphasis> that contains an array of <emphasis role="bold">Battery</emphasis> and a <emphasis role="bold">toString( )</emphasis> that prints out all the batteries. Write a <emphasis role="bold">clone( )</emphasis> for <emphasis role="bold">Toy</emphasis> that automatically clones all of its <emphasis role="bold">Battery</emphasis> objects. Test this by cloning <emphasis role="bold">Toy</emphasis> and printing the result.</para>
      <para>  261.         Change <emphasis role="bold">CheckCloneable.java</emphasis> so that all of the <emphasis role="bold">clone( )</emphasis> methods catch the <emphasis role="bold">CloneNotSupportedException</emphasis> rather than passing it to the caller.</para>
      <para>  262.         Using the mutable-companion-class technique, make an immutable class containing an <emphasis role="bold">int</emphasis>, a <emphasis role="bold">double</emphasis> and an array of <emphasis role="bold">char</emphasis>.</para>
      <para>  263.         Modify <emphasis role="bold">Compete.java</emphasis> to add more member objects to classes <emphasis role="bold">Thing2</emphasis> and <emphasis role="bold">Thing4</emphasis> and see if you can determine how the timings vary with complexity�whether it�s a simple linear relationship or if it seems more complicated.</para>
      <para>  264.         Starting with <emphasis role="bold">Snake.java</emphasis>, create a deep-copy version of the snake.</para>
      <para>  265.         Inherit an <emphasis role="bold">ArrayList</emphasis> and make its <emphasis role="bold">clone( )</emphasis> perform a deep copy.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064947"/><anchor xreflabel="B: " xml:id="_Toc477690737"/>B: The Java Native Interface (JNI)</title>
    <para><emphasis role="italic">The material in this appendix was contributed by and used with the permission of Andrea Provaglio (www.AndreaProvaglio.com).</emphasis></para>
    <para>The Java language and its standard API are rich enough to write full-fledged applications. But in some cases you must call non-Java code; for example, if you want to access operating-system-specific features, interface with special hardware devices, reuse a preexisting, non-Java code base, or implement time-critical sections of code.</para>
    <para>Interfacing with non-Java code requires dedicated support in the compiler and in the Virtual Machine, and additional tools to map the Java code to the non-Java code. The standard solution for calling non-Java code that is provided by JavaSoft is called the <emphasis role="italic">Java Native Interface</emphasis>, which will be introduced in this appendix. This is not an in-depth treatment, and in some cases you�re assumed to have partial knowledge of the related concepts and techniques.</para>
    <para>JNI is a fairly rich programming interface that allows you to call native methods from a Java application. It was added in Java 1.1, maintaining a certain degree of compatibility with its Java 1.0 equivalent: the native method interface (NMI). NMI has design characteristics that make it unsuitable for adoption across all virtual machines. For this reason, future versions of the language might no longer support NMI, and it will not be covered here.</para>
    <para>Currently, JNI is designed to interface with native methods written only in C or C++. Using JNI, your native methods can:</para>
    <para>�       Create, inspect, and update Java objects (including arrays and <emphasis role="bold">String</emphasis>s)</para>
    <para>�       Call Java methods</para>
    <para>�       Catch and throw exceptions</para>
    <para>�       Load classes and obtain class information</para>
    <para>�       Perform run-time type checking</para>
    <para>Thus, virtually everything you can do with classes and objects in ordinary Java you can also do in native methods. </para>
    <section>
      <title><anchor xreflabel="Calling a native method" xml:id="_Toc481064948"/>Calling a native method</title>
      <para>We�ll start with a simple example: a Java program that calls a native method, which in turn calls the standard C library function <emphasis role="bold">printf( )</emphasis>. </para>
      <para>The first step is to write the Java code declaring a native method and its arguments:</para>
      <para>//: appendixb:ShowMessage.java</para>
      <para>public class ShowMessage {</para>
      <para>� private native void ShowMessage(String msg);</para>
      <para>� static {</para>
      <para>��� System.loadLibrary(&quot;MsgImpl&quot;);</para>
      <para>��� // Linux hack, if you can&apos;t get your library</para>
      <para>��� // path set in your environment:</para>
      <para>��� // System.load(</para>
      <para>��� //� &quot;/home/bruce/tij2/appendixb/MsgImpl.so&quot;);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� ShowMessage app = new ShowMessage();</para>
      <para>��� app.ShowMessage(&quot;Generated with JNI&quot;);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>The native method declaration is followed by a <emphasis role="bold">static</emphasis> block that calls <emphasis role="bold">System.loadLibrary( )</emphasis> (which you could call at any time, but this style is more appropriate). <emphasis role="bold">System.loadLibrary( )</emphasis> loads a DLL in memory and links to it. The DLL must be in your system library path. The file name extension is automatically added by the JVM depending on the platform.</para>
      <para>In the above code you can also see a call to the <emphasis role="bold">System.load( )</emphasis> method, which is commented out. The path specified here is an absolute path, rather than relying on an environment variable. Using an environment variable is naturally the better and more portable solution, but if you can�t figure that out you can comment out the <emphasis role="bold">loadLibrary( )</emphasis> call and uncomment this one, adjusting the path to your own directory.</para>
      <section>
        <title><anchor xreflabel="The header file generator: javah" xml:id="_Toc481064949"/>The header file generator: javah</title>
        <para>Now compile your Java source file and run <emphasis role="bold">javah</emphasis> on the resulting <emphasis role="bold">.class</emphasis> file, specifying the <emphasis role="bold">�jni</emphasis> switch (this is done automatically for you by the makefile in the source code distribution for this book):</para>
        <para>javah �jni ShowMessage</para>
        <para> </para>
        <para><emphasis role="bold">javah</emphasis> reads the Java class file and for each native method declaration it generates a function prototype in a C or C++ header file. Here�s the output: the <emphasis role="bold">ShowMessage.h</emphasis> source file (edited slightly to fit into this book):</para>
        <para>/* DO NOT EDIT THIS FILE </para>
        <para>�� - it is machine generated */</para>
        <para>#include &lt;jni.h&gt;</para>
        <para>/* Header for class ShowMessage */</para>
        <para> </para>
        <para>#ifndef _Included_ShowMessage</para>
        <para>#define _Included_ShowMessage</para>
        <para>#ifdef __cplusplus</para>
        <para>extern &quot;C&quot; {</para>
        <para>#endif</para>
        <para>/*</para>
        <para>�* Class:���� ShowMessage</para>
        <para>�* Method:��� ShowMessage</para>
        <para>�* Signature: (Ljava/lang/String;)V</para>
        <para>�*/</para>
        <para>JNIEXPORT void JNICALL </para>
        <para>Java_ShowMessage_ShowMessage</para>
        <para>� (JNIEnv *, jobject, jstring);</para>
        <para> </para>
        <para>#ifdef __cplusplus</para>
        <para>}</para>
        <para>#endif</para>
        <para>#endif</para>
        <para> </para>
        <para>As you can see by the <emphasis role="bold">#ifdef __cplusplus</emphasis> preprocessor directive, this file can be compiled either by a C or a C++ compiler. The first <emphasis role="bold">#include</emphasis> directive includes <emphasis role="bold">jni.h</emphasis>, a header file that, among other things, defines the types that you can see used in the rest of the file. <emphasis role="bold">JNIEXPORT</emphasis> and <emphasis role="bold">JNICALL</emphasis> are macros that expand to match platform-specific directives. <emphasis role="bold">JNIEnv</emphasis>, <emphasis role="bold">jobject</emphasis> and <emphasis role="bold">jstring</emphasis> are JNI data type definitions, which will be explained shortly.</para>
      </section>
      <section>
        <title><anchor xreflabel="Name mangling and function
signatures" xml:id="_Toc481064950"/>Name mangling and function signatures</title>
        <para>JNI imposes a naming convention (called <emphasis role="italic">name mangling</emphasis>) on native methods. This is important, since it�s part of the mechanism by which the virtual machine links Java calls to native methods. Basically, all native methods start with the word �Java,� followed by the name of the class in which the Java native declaration appears, followed by the name of the Java method. The underscore character is used as a separator. If the Java native method is overloaded, then the function signature is appended to the name as well; you can see the native signature in the comments preceding the prototype. For more information about name mangling and native method signatures, please refer to the JNI documentation.</para>
      </section>
      <section>
        <title><anchor xreflabel="Implementing your DLL" xml:id="_Toc481064951"/>Implementing your DLL</title>
        <para>At this point, all you have to do is write a C or C++ source code file that includes the <emphasis role="bold">javah</emphasis>-generated header file and implements the native method, then compile it and generate a dynamic link library. This part is platform-dependent. The code below is compiled and linked into a file called <emphasis role="bold">MsgImpl.dll</emphasis> for Windows or <emphasis role="bold">MsgImpl.so</emphasis> for Unix/Linux (the makefile packaged with the code listings contains the commands to do this�it is available on the CD ROM bound into this book, or as a free download from <emphasis role="italic">www.BruceEckel.com</emphasis>):</para>
        <para>//: appendixb:MsgImpl.cpp</para>
        <para>//# Tested with VC++ &amp; BC++. Include path must </para>
        <para>//# be adjusted to find the JNI headers. See </para>
        <para>//# the makefile for this chapter (in the </para>
        <para>//# downloadable source code) for an example.</para>
        <para>#include &lt;jni.h&gt;</para>
        <para>#include &lt;stdio.h&gt;</para>
        <para>#include &quot;ShowMessage.h&quot;</para>
        <para> </para>
        <para>extern &quot;C&quot; JNIEXPORT void JNICALL </para>
        <para>Java_ShowMessage_ShowMessage(JNIEnv* env, </para>
        <para>jobject, jstring jMsg) {</para>
        <para>� const char* msg=env-&gt;GetStringUTFChars(jMsg,0);</para>
        <para>� printf(&quot;Thinking in Java, JNI: %s\n&quot;, msg);</para>
        <para>� env-&gt;ReleaseStringUTFChars(jMsg, msg);</para>
        <para>} ///:~</para>
        <para> </para>
        <para>The arguments that are passed into the native method are the gateway back into Java. The first, of type <emphasis role="bold">JNIEnv</emphasis>,<emphasis role="bold"/>contains all the hooks that allow you to call back into the JVM. (We�ll look at this in the next section.) The second argument has a different meaning depending on the type of method. For non-<emphasis role="bold">static</emphasis> methods like the example above, the second argument is the equivalent of the �this� pointer in C++ and similar to <emphasis role="bold">this</emphasis> in Java: it�s a reference to the object that called the native method. For <emphasis role="bold">static</emphasis> methods, it�s a reference to the <emphasis role="bold">Class</emphasis> object where the method is implemented.</para>
        <para>The remaining arguments represent the Java objects passed into the native method call. Primitives are also passed in this way, but they come in by value.</para>
        <para>In the following sections we�ll explain this code by looking at the ways that you access and control the JVM from inside a native method.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Accessing JNI functions: 
the JNIEnv argument" xml:id="_Toc481064952"/>Accessing JNI functions:   the <emphasis role="bold">JNIEnv</emphasis> argument</title>
      <para>JNI functions are those that the programmer uses to interact with the JVM from inside a native method. As you can see in the example above, every JNI native method receives a special argument as its first parameter: the <emphasis role="bold">JNIEnv</emphasis> argument, which is a pointer to a special JNI data structure of type <emphasis role="bold">JNIEnv_</emphasis>. One element of the JNI data structure is a pointer to an array generated by the JVM. Each element of this array is a pointer to a JNI function. The JNI functions can be called from the native method by dereferencing these pointers (it�s simpler than it sounds). Every JVM provides its own implementation of the JNI functions, but their addresses will always be at predefined offsets.</para>
      <para>Through the <emphasis role="bold">JNIEnv</emphasis> argument, the programmer has access to a large set of functions. These functions can be grouped into the following categories:</para>
      <para>�       Obtaining version information</para>
      <para>�       Performing class and object operations</para>
      <para>�       Handling global and local references to Java objects</para>
      <para>�       Accessing instance fields and static fields</para>
      <para>�       Calling instance methods and static methods</para>
      <para>�       Performing string and array operations</para>
      <para>�       Generating and handling Java exceptions</para>
      <para>The number of JNI functions is quite large and won�t be covered here. Instead, I�ll show the rationale behind the use of these functions. For more detailed information, consult your compiler�s JNI documentation.</para>
      <para>If you take a look at the <emphasis role="bold">jni.h</emphasis> header file, you�ll see that inside the <emphasis role="bold">#ifdef __cplusplus</emphasis> preprocessor conditional, the <emphasis role="bold">JNIEnv_</emphasis> structure is defined as a class when compiled by a C++ compiler. This class contains a number of inline functions that let you access the JNI functions with an easy and familiar syntax. For example, the line of C++ code in the preceding example:</para>
      <para>env-&gt;ReleaseStringUTFChars(jMsg, msg);</para>
      <para> </para>
      <para>could also be called from C like this:</para>
      <para>(*env)-&gt;ReleaseStringUTFChars(env, jMsg, msg);</para>
      <para> </para>
      <para>You�ll notice that the C style is (naturally) more complicated�you need a double dereferencing of the <emphasis role="bold">env</emphasis> pointer, and you must also pass the same pointer as the first parameter to the JNI function call. The examples in this appendix use the C++ style.</para>
      <section>
        <title><anchor xreflabel="Accessing Java Strings" xml:id="_Toc481064953"/>Accessing Java Strings</title>
        <para>As an example of accessing a JNI function, consider the code in <emphasis role="bold">MsgImpl.cpp</emphasis>. Here, the <emphasis role="bold">JNIEnv</emphasis> argument <emphasis role="bold">env</emphasis> is used to access a Java <emphasis role="bold">String</emphasis>. Java <emphasis role="bold">String</emphasis>s are in Unicode format, so if you receive one and want to pass it to a non-Unicode function (<emphasis role="bold">printf( )</emphasis>, for example), you must first convert it into ASCII characters with the JNI function <emphasis role="bold">GetStringUTFChars( )</emphasis>. This function takes a Java <emphasis role="bold">String</emphasis> and converts it to UTF-8 characters. (These are 8 bits wide to hold ASCII values or 16 bits wide to hold Unicode. If the content of the original string was composed only of ASCII, the resulting string will be ASCII as well.)</para>
        <para><emphasis role="bold">GetStringUTFChars( )</emphasis> is one of the member functions in <emphasis role="bold">JNIEnv</emphasis>. To access the JNI function, we use the typical C++ syntax for calling a member function though a pointer. You use the form above to access all of the JNI functions.</para>
      </section>
    </section>
    <section>
      <title><anchor xreflabel="Passing and using Java objects" xml:id="_Toc481064954"/>Passing and using Java objects</title>
      <para>In the previous example we passed a <emphasis role="bold">String</emphasis> to the native method. You can also pass Java objects of your own creation to a native method. Inside your native method, you can access the fields and methods of the object that was received.</para>
      <para>To pass objects, use the ordinary Java syntax when declaring the native method. In the example below, <emphasis role="bold">MyJavaClass</emphasis> has one <emphasis role="bold">public</emphasis> field and one <emphasis role="bold">public</emphasis> method. The class <emphasis role="bold">UseObjects </emphasis>declares a native method that takes an object of class <emphasis role="bold">MyJavaClass</emphasis>. To see if the native method manipulates its argument, the <emphasis role="bold">public</emphasis> field of the argument is set, the native method is called, and then the value of the <emphasis role="bold">public</emphasis> field is printed.</para>
      <para>//: appendixb:UseObjects.java</para>
      <para>class MyJavaClass {</para>
      <para>� public int aValue;</para>
      <para>� public void divByTwo() { aValue /= 2; }</para>
      <para>}</para>
      <para> </para>
      <para>public class UseObjects {</para>
      <para>� private native void </para>
      <para>��� changeObject(MyJavaClass obj);</para>
      <para>� static {</para>
      <para>��� System.loadLibrary(&quot;UseObjImpl&quot;);</para>
      <para>��� // Linux hack, if you can&apos;t get your library</para>
      <para>��� // path set in your environment:</para>
      <para>��� // System.load(</para>
      <para>��� //&quot;/home/bruce/tij2/appendixb/UseObjImpl.so&quot;);</para>
      <para>� }</para>
      <para>� public static void main(String[] args) {</para>
      <para>��� UseObjects app = new UseObjects();</para>
      <para>��� MyJavaClass anObj = new MyJavaClass();</para>
      <para>��� anObj.aValue = 2;</para>
      <para>��� app.changeObject(anObj);</para>
      <para>��� System.out.println(&quot;Java: &quot; + anObj.aValue);</para>
      <para>� }</para>
      <para>} ///:~</para>
      <para> </para>
      <para>After compiling the code and running <emphasis role="bold">javah</emphasis>, you can implement the native method. In the example below, once the field and method ID are obtained, they are accessed through JNI functions.</para>
      <para>//: appendixb:UseObjImpl.cpp</para>
      <para>//# Tested with VC++ &amp; BC++. Include path must </para>
      <para>//# be adjusted to find the JNI headers. See </para>
      <para>//# the makefile for this chapter (in the </para>
      <para>//# downloadable source code) for an example.</para>
      <para>#include &lt;jni.h&gt;</para>
      <para>extern &quot;C&quot; JNIEXPORT void JNICALL</para>
      <para>Java_UseObjects_changeObject(</para>
      <para>JNIEnv* env, jobject, jobject obj) {</para>
      <para>� jclass cls = env-&gt;GetObjectClass(obj);</para>
      <para>� jfieldID fid = env-&gt;GetFieldID(</para>
      <para>��� cls, &quot;aValue&quot;, &quot;I&quot;);</para>
      <para>� jmethodID mid = env-&gt;GetMethodID(</para>
      <para>��� cls, &quot;divByTwo&quot;, &quot;()V&quot;);</para>
      <para>� int value = env-&gt;GetIntField(obj, fid);</para>
      <para>� printf(&quot;Native: %d\n&quot;, value);</para>
      <para>� env-&gt;SetIntField(obj, fid, 6);</para>
      <para>� env-&gt;CallVoidMethod(obj, mid);</para>
      <para>� value = env-&gt;GetIntField(obj, fid);</para>
      <para>� printf(&quot;Native: %d\n&quot;, value);</para>
      <para>} ///:~</para>
      <para> </para>
      <para>Ignoring the �this� equivalent, the C++ function receives a <emphasis role="bold">jobject</emphasis>, which is the native side of the Java object reference we pass from the Java code. We simply read <emphasis role="bold">aValue</emphasis>, print it out, change the value, call the object�s <emphasis role="bold">divByTwo( )</emphasis> method, and print the value out again. </para>
      <para>To access a Java field or method, you must first obtain its identifier using <emphasis role="bold">GetFieldID( )</emphasis> for fields and <emphasis role="bold">GetMethodID( )</emphasis> for methods. These functions take the class object, a string containing the element name, and a string that gives type information: the data type of the field, or signature information for a method (details can be found in the JNI documentation). These functions return an identifier that you use to access the element. This approach might seem convoluted, but your native method has no knowledge of the internal layout of the Java object. Instead, it must access fields and methods through indexes returned by the JVM. This allows different JVMs to implement different internal object layouts with no impact on your native methods.</para>
      <para>If you run the Java program, you�ll see that the object that�s passed from the Java side is manipulated by your native method. But what exactly is passed? A pointer or a Java reference? And what is the garbage collector doing during native method calls?</para>
      <para>The garbage collector continues to operate during native method execution, but it�s guaranteed that your objects will not be garbage-collected during a native method call. To ensure this, <emphasis role="italic">local references</emphasis> are created before, and destroyed right after, the native method call. Since their lifetime wraps the call, you know that the objects will be valid throughout the native method call.</para>
      <para>Since these references are created and subsequently destroyed every time the function is called, you cannot make local copies in your native methods, in <emphasis role="bold">static</emphasis> variables. If you want a reference that lasts across function invocations, you need a global reference. Global references are not created by the JVM, but the programmer can make a global reference out of a local one by calling specific JNI functions. When you create a global reference, you become responsible for the lifetime of the referenced object. The global reference (and the object it refers to) will be in memory until the programmer explicitly frees the reference with the appropriate JNI function. It�s similar to <emphasis role="bold">malloc( )</emphasis> and <emphasis role="bold">free( )</emphasis> in C.</para>
    </section>
    <section>
      <title><anchor xreflabel="JNI and Java exceptions" xml:id="_Toc481064955"/>JNI and Java exceptions</title>
      <para>With JNI, Java exceptions can be thrown, caught, printed, and rethrown just as they are inside a Java program. But it�s up to the programmer to call dedicated JNI functions to deal with exceptions. Here are the JNI functions for exception handling:</para>
      <para>�       <emphasis role="bold">Throw( )</emphasis></para>
      <para> Throws an existing exception object. Used in native methods to rethrow an exception.</para>
      <para>�       <emphasis role="bold">ThrowNew( ) </emphasis>Generates a new exception object and throws it.</para>
      <para>�       <emphasis role="bold">ExceptionOccurred( )</emphasis></para>
      <para> Determines if an exception was thrown and not yet cleared.</para>
      <para>�       <emphasis role="bold">ExceptionDescribe( )</emphasis></para>
      <para> Prints an exception and the stack trace.</para>
      <para>�       <emphasis role="bold">ExceptionClear( )</emphasis></para>
      <para> Clears a pending exception.</para>
      <para>�       <emphasis role="bold">FatalError( )</emphasis></para>
      <para> Raises a fatal error. Does not return.</para>
      <para>Among these, you can�t ignore <emphasis role="bold">ExceptionOccurred( )</emphasis> and <emphasis role="bold">ExceptionClear( )</emphasis>. Most JNI functions can generate exceptions, and there is no language feature that you can use in place of a Java try block, so you must call <emphasis role="bold">ExceptionOccurred( ) </emphasis>after each JNI function call to see if an exception was thrown. If you detect an exception, you may choose to handle it (and possibly rethrow it). You must make certain, however, that the exception is eventually cleared. This can be done in your function using <emphasis role="bold">ExceptionClear( )</emphasis> or in some other function if the exception is rethrown, but it must be done.</para>
      <para>You must ensure that the exception is cleared, because otherwise the results will be unpredictable if you call a JNI function while an exception is pending. There are few JNI functions that are safe to call during an exception; among these, of course, are all the exception handling functions.</para>
    </section>
    <section>
      <title><anchor xreflabel="JNI and threading" xml:id="_Toc481064956"/>JNI and threading</title>
      <para>Since Java is a multithreaded language, several threads can call a native method concurrently. (The native method might be suspended in the middle of its operation when a second thread calls it.) It�s entirely up to the programmer to guarantee that the native call is thread-safe; i.e., it does not modify shared data in an unmonitored way. Basically, you have two options: declare the native method as <emphasis role="bold">synchronized</emphasis>, or implement some other strategy within the native method to ensure correct, concurrent data manipulation.</para>
      <para>Also, you should never pass the <emphasis role="bold">JNIEnv</emphasis> pointer across threads, since the internal structure it points to is allocated on a per-thread basis and contains information that makes sense only in that particular thread.</para>
    </section>
    <section>
      <title><anchor xreflabel="Using a preexisting code base" xml:id="_Toc481064957"/>Using a preexisting code base</title>
      <para>The easiest way to implement JNI native methods is to start writing native method prototypes in a Java class, compile that class, and run the <emphasis role="bold">.class</emphasis> file through <emphasis role="bold">javah</emphasis>. But what if you have a large, preexisting code base that you want to call from Java? Renaming all the functions in your DLLs to match the JNI name mangling convention is not a viable solution. The best approach is to write a wrapper DLL �outside� your original code base. The Java code calls functions in this new DLL, which in turn calls your original DLL functions. This solution is not just a work-around; in most cases you must do this anyway because you must call JNI functions on the object references before you can use them.</para>
    </section>
    <section>
      <title><anchor xreflabel="Additional information" xml:id="_Toc481064958"/>Additional information</title>
      <para>You can find further introductory material, including a C (rather than C++) example and discussion of Microsoft issues, in Appendix A of the first edition of this book, which can be found on the CD ROM bound in with this book, or in a free download from <emphasis role="italic">www.BruceEckel.com</emphasis>. More extensive information is available at <emphasis role="italic">java.sun.com</emphasis> (in the search engine, select �training &amp; tutorials� for keywords �native methods�). Chapter 11 of <emphasis role="italic">Core Java 2</emphasis>, <emphasis role="italic">Volume II</emphasis>, by Horstmann &amp; Cornell (Prentice-Hall, 2000) gives excellent coverage of native methods.</para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064959"/><anchor xreflabel="" xml:id="_Toc477690738"/><anchor xreflabel="" xml:id="_Toc375545509"/><anchor xreflabel="" xml:id="Appendix_B"/><anchor xreflabel="" xml:id="Appendix_C"/>C: Java Programming Guidelines</title>
    <para>This appendix contains suggestions to help guide you in performing low-level program design, and in writing code.</para>
    <para>Naturally, these are guidelines and not rules. The idea is to use them as inspirations, and to remember that there are occasional situations where you need to bend or break a rule.</para>
    <section>
      <title><anchor xreflabel="Design" xml:id="_Toc481064960"/>Design</title>
      <para><emphasis role="bold">Elegance always pays off</emphasis>. In the short term it might seem like it takes much longer to come up with a truly graceful solution to a problem, but when it works the first time and easily adapts to new situations instead of requiring hours, days, or months of struggle, you�ll see the rewards (even if no one can measure them). Not only does it give you a program that�s easier to build and debug, but it�s also easier to understand and maintain, and that�s where the financial value lies. This point can take some experience to understand, because it can appear that you�re not being productive while you�re making a piece of code elegant. Resist the urge to hurry; it will only slow you down.</para>
      <para>152.   <emphasis role="bold">First make it work, then make it fast</emphasis>. This is true even if you are certain that a piece of code is really important and that it will be a principal bottleneck in your system. Don�t do it. Get the system going first with as simple a design as possible. Then if it isn�t going fast enough, profile it. You�ll almost always discover that �your� bottleneck isn�t the problem. Save your time for the really important stuff.</para>
      <para>153.   <emphasis role="bold">Remember the �divide and conquer� principle</emphasis>. If the problem you�re looking at is too confusing, try to imagine what the basic operation of the program would be, given the existence of a magic �piece� that handles the hard parts. That �piece� is an object�write the code that uses the object, then look at the object and encapsulate <emphasis role="italic">its</emphasis> hard parts into other objects, etc.</para>
      <para>154.   <emphasis role="bold">Separate the class creator from the class user (<emphasis role="italic">client programmer</emphasis>)</emphasis>. The class user is the �customer� and doesn�t need or want to know what�s going on behind the scenes of the class. The class creator must be the expert in class design and write the class so that it can be used by the most novice programmer possible, yet still work robustly in the application. Library use will be easy only if it�s transparent.</para>
      <para>155.   <emphasis role="bold">When you create a class, attempt to make your names so clear that comments are unnecessary</emphasis>. Your goal should be to make the client programmer�s interface conceptually simple. To this end, use method overloading when appropriate to create an intuitive, easy-to-use interface.</para>
      <para>156.   <emphasis role="bold">Your analysis and design must produce, at minimum, the classes in your system, their public interfaces, and their relationships to other classes, especially base classes</emphasis>. If your design methodology produces more than that, ask yourself if all the pieces produced by that methodology have value over the lifetime of the program. If they do not, maintaining them will cost you. Members of development teams tend not to maintain anything that does not contribute to their productivity; this is a fact of life that many design methods don�t account for.</para>
      <para>157.   <emphasis role="bold">Automate everything</emphasis>.<emphasis role="bold"/>Write the test code first (before you write the class), and keep it with the class. Automate the running of your tests through a makefile or similar tool. This way, any changes can be automatically verified by running the test code, and you�ll immediately discover errors. Because you know that you have the safety net of your test framework, you will be bolder about making sweeping changes when you discover the need. Remember that the greatest improvements in languages come from the built-in testing provided by type checking, exception handling, etc., but those features take you only so far. You must go the rest of the way in creating a robust system by filling in the tests that verify features that are specific to your class or program.</para>
      <para>158.   <emphasis role="bold">Write the test code first (before you write the class) in order to verify that your class design is complete</emphasis>. If you can�t write test code, you don�t know what your class looks like. In addition, the act of writing the test code will often flush out additional features or constraints that you need in the class�these features or constraints don�t always appear during analysis and design. Tests also provide example code showing how your class can be used.</para>
      <para>159.   <emphasis role="bold">All software design problems can be simplified by introducing an extra level of conceptual indirection</emphasis><emphasis role="italic">.</emphasis> This fundamental rule of software engineering<anchor xreflabel="[85]" xml:id="_ftnref85"/>[85] is the basis of abstraction, the primary feature of object-oriented programming.</para>
      <para>160.   <emphasis role="bold">An indirection should have a meaning </emphasis>(in concert with guideline 9). This meaning can be something as simple as �putting commonly used code in a single method.� If you add levels of indirection (abstraction, encapsulation, etc.) that don�t have meaning, it can be as bad as not having adequate indirection.</para>
      <para>161.   <emphasis role="bold">Make classes as atomic as possible</emphasis>. Give each class a single, clear purpose. If your classes or your system design grows too complicated, break complex classes into simpler ones. The most obvious indicator of this is sheer size: if a class is big, chances are it�s doing too much and should be broken up.</para>
      <para> Clues to suggest redesign of a class are:</para>
      <para> 1) A complicated switch statement: consider using polymorphism. </para>
      <para> 2) A large number of methods that cover broadly different types of operations: consider using several classes.</para>
      <para> 3) A large number of member variables that concern broadly different characteristics: consider using several classes.</para>
      <para>162.   <emphasis role="bold">Watch for long argument lists</emphasis>. Method calls then become difficult to write, read, and maintain. Instead, try to move the method to a class where it is (more) appropriate, and/or pass objects in as arguments.</para>
      <para>163.   <emphasis role="bold">Don�t repeat yourself</emphasis>. If a piece of code is recurring in many methods in derived classes, put that code into a single method in the base class and call it from the derived-class methods. Not only do you save code space, you provide for easy propagation of changes. Sometimes the discovery of this common code will add valuable functionality to your interface.</para>
      <para>164.   <emphasis role="bold">Watch for <emphasis role="italic">switch</emphasis> statements or chained <emphasis role="italic">if-else</emphasis> clauses</emphasis>. This is typically an indicator of <emphasis role="italic">type-check coding</emphasis>, which means you are choosing what code to execute based on some kind of type information (the exact type may not be obvious at first). You can usually replace this kind of code with inheritance and polymorphism; a polymorphic method call will perform the type checking for you, and allow for more reliable and easier extensibility.</para>
      <para>165.   <emphasis role="bold">From a design standpoint, look for and separate things that change from things that stay the same</emphasis>. That is, search for the elements in a system that you might want to change without forcing a redesign, then encapsulate those elements in classes. You can learn significantly more about this concept in <emphasis role="italic">Thinking in Patterns with Java</emphasis>, downloadable at <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
      <para>166.   <emphasis role="bold">Don�t extend fundamental functionality by subclassing</emphasis>. If an interface element is essential to a class it should be in the base class, not added during derivation. If you�re adding methods by inheriting, perhaps you should rethink the design.</para>
      <para>167.   <emphasis role="bold">Less is more</emphasis>. Start with a minimal interface to a class, as small and simple as you need to solve the problem at hand, but don�t try to anticipate all the ways that your class <emphasis role="italic">might</emphasis> be used. As the class is used, you�ll discover ways you must expand the interface. However, once a class is in use you cannot shrink the interface without disturbing client code. If you need to add more methods, that�s fine; it won�t disturb code, other than forcing recompiles. But even if new methods replace the functionality of old ones, leave the existing interface alone (you can combine the functionality in the underlying implementation if you want). If you need to expand the interface of an existing method by adding more arguments, create an overloaded method with the new arguments; this way you won�t disturb any existing calls to the existing method.</para>
      <para>168.   <emphasis role="bold">Read your classes aloud to make sure they�re logical</emphasis>. Refer to the relationship between a base class and derived class as �is-a� and member objects as �has-a.�</para>
      <para>169.   <emphasis role="bold">When deciding between inheritance and composition, ask if you need to upcast to the base type</emphasis>. If not, prefer composition (member objects) to inheritance. This can eliminate the perceived need for multiple base types. If you inherit, users will think they are supposed to upcast.</para>
      <para>170.   <emphasis role="bold">Use data members for variation in value and method overriding for variation in behavior</emphasis>. That is, if you find a class that uses state variables along with methods that switch behavior based on those variables, you should probably redesign it to express the differences in behavior within subclasses and overridden methods.</para>
      <para>171.   <emphasis role="bold">Watch for overloading</emphasis>. A method should not conditionally execute code based on the value of an argument. In this case, you should create two or more overloaded methods instead.</para>
      <para>172.   <emphasis role="bold">Use exception hierarchies</emphasis>�preferably derived from specific appropriate classes in the standard Java exception hierarchy. The person catching the exceptions can then catch the specific types of exceptions, followed by the base type. If you add new derived exceptions, existing client code will still catch the exception through the base type.</para>
      <para>173.   <emphasis role="bold">Sometimes simple aggregation does the job</emphasis>. A �passenger comfort system� on an airline consists of disconnected elements: seat, air conditioning, video, etc., and yet you need to create many of these in a plane. Do you make private members and build a whole new interface? No�in this case, the components are also part of the public interface, so you should create public member objects. Those objects have their own private implementations, which are still safe. Be aware that simple aggregation is not a solution to be used often, but it does happen.</para>
      <para>174.   <emphasis role="bold">Consider the perspective of the client programmer and the person maintaining the code</emphasis>. Design your class to be as obvious as possible to use. Anticipate the kind of changes that will be made, and design your class so that those changes will be easy.</para>
      <para>175.   <emphasis role="bold">Watch out for �giant object syndrome.�</emphasis> This is often an affliction of procedural programmers who are new to OOP and who end up writing a procedural program and sticking it inside one or two giant objects. With the exception of application frameworks, objects represent concepts in your application, not the application.</para>
      <para>176.   <emphasis role="bold">If you must do something ugly, at least localize the ugliness inside a class</emphasis>.</para>
      <para>177.   <emphasis role="bold">If you must do something nonportable, make an abstraction for that service and localize it within a class</emphasis>. This extra level of indirection prevents the nonportability from being distributed throughout your program. (This idiom is embodied in the <emphasis role="italic">Bridge </emphasis>Pattern).</para>
      <para>178.   <emphasis role="bold">Objects should not simply hold some data</emphasis>. They should also have well-defined behaviors. (Occasionally, �data objects� are appropriate, but only when used expressly to package and transport a group of items when a generalized container is innappropriate.)</para>
      <para>179.   <emphasis role="bold">Choose composition first when creating new classes from existing classes</emphasis>. You should only used inheritance if it is required by your design. If you use inheritance where composition will work, your designs will become needlessly complicated.</para>
      <para>180.   <emphasis role="bold">Use inheritance and method overriding to express differences in behavior, and fields to express variations in state</emphasis>. An extreme example of what not to do is inheriting different classes to represent colors instead of using a �color� field.</para>
      <para>181.   <emphasis role="bold">Watch out for <emphasis role="italic">variance</emphasis></emphasis>. Two semantically different objects may have identical actions, or responsibilities, and there is a natural temptation to try to make one a subclass of the other just to benefit from inheritance. This is called variance, but there�s no real justification to force a superclass/subclass relationship where it doesn�t exist. A better solution is to create a general base class that produces an interface for both as derived classes�it requires a bit more space, but you still benefit from inheritance, and will probably make an important discovery about the design.</para>
      <para>182.   <emphasis role="bold">Watch out for <emphasis role="italic">limitation</emphasis> during inheritance</emphasis>. The clearest designs add new capabilities to inherited ones. A suspicious design removes old capabilities during inheritance without adding new ones. But rules are made to be broken, and if you are working from an old class library, it may be more efficient to restrict an existing class in its subclass than it would be to restructure the hierarchy so your new class fits in where it should, above the old class.</para>
      <para>183.   <emphasis role="bold">Use design patterns to eliminate �naked functionality.�</emphasis> That is, if only one object of your class should be created, don�t bolt ahead to the application and write a comment �Make only one of these.� Wrap it in a singleton. If you have a lot of messy code in your main program that creates your objects, look for a creational pattern like a factory method in which you can encapsulate that creation. Eliminating �naked functionality� will not only make your code much easier to understand and maintain, it will also make it more bulletproof against the well-intentioned maintainers that come after you.</para>
      <para>184.   <emphasis role="bold">Watch out for �analysis paralysis.�</emphasis> Remember that you must usually move forward in a project before you know everything, and that often the best and fastest way to learn about some of your unknown factors is to go to the next step rather than trying to figure it out in your head. You can�t know the solution until you <emphasis role="italic">have</emphasis> the solution. Java has built-in firewalls; let them work for you. Your mistakes in a class or set of classes won�t destroy the integrity of the whole system.</para>
      <para>185.   <emphasis role="bold">When you think you�ve got a good analysis, design, or implementation, do a walkthrough</emphasis>. Bring someone in from outside your group�this doesn�t have to be a consultant, but can be someone from another group within your company. Reviewing your work with a fresh pair of eyes can reveal problems at a stage when it�s much easier to fix them, and more than pays for the time and money �lost� to the walkthrough process.</para>
    </section>
    <section>
      <title><anchor xreflabel="Implementation" xml:id="_Toc481064961"/>Implementation</title>
      <para>186.   <emphasis role="bold">In general, follow the Sun coding conventions</emphasis>. These are available at</para>
      <para><emphasis role="italic">java.sun.com/docs/codeconv/index.html</emphasis> (the code in this book follows these conventions as much as I was able). These are used for what constitutes arguably the largest body of code that the largest number of Java programmers will be exposed to. If you doggedly stick to the coding style you�ve always used, you will make it harder for your reader. Whatever coding conventions you decide on, ensure they are consistent throughout the project. There is a free tool to automatically reformat Java code at: <emphasis role="italic">home.wtal.de/software-solutions/jindent.</emphasis></para>
      <para>187.   <emphasis role="bold">Whatever coding style you use, it really does make a difference if your team (and even better, your company) standardizes on it</emphasis>. This means to the point that everyone considers it fair game to fix someone else�s coding style if it doesn�t conform. The value of standardization is that it takes less brain cycles to parse the code, so that you can focus more on what the code means.</para>
      <para>188.   <emphasis role="bold">Follow standard capitalization rules</emphasis>. Capitalize the first letter of class names. The first letter of fields, methods, and objects (references) should be lowercase. All identifiers should run their words together, and capitalize the first letter of all intermediate words. For example:</para>
      <para><emphasis role="bold">ThisIsAClassName  thisIsAMethodOrFieldName</emphasis></para>
      <para> Capitalize <emphasis role="italic">all</emphasis> the letters of <emphasis role="bold">static</emphasis><emphasis role="bold">final</emphasis> primitive identifiers that have constant initializers in their definitions. This indicates they are compile-time constants.</para>
      <para><emphasis role="bold">Packages are a special case</emphasis>�they are all lowercase letters, even for intermediate words. The domain extension (com, org, net, edu, etc.) should also be lowercase. (This was a change between Java 1.1 and Java 2.)</para>
      <para>189.   <emphasis role="bold">Don�t create your own �decorated� private data member names</emphasis>. This is usually seen in the form of prepended underscores and characters. Hungarian notation is the worst example of this, where you attach extra characters that indicate data type, use, location, etc., as if you were writing assembly language and the compiler provided no extra assistance at all. These notations are confusing, difficult to read, and unpleasant to enforce and maintain. Let classes and packages do the name scoping for you.</para>
      <para>190.   <emphasis role="bold">Follow a �canonical form� </emphasis>when creating a class for general-purpose use. Include definitions for <emphasis role="bold">equals( )</emphasis>, <emphasis role="bold">hashCode( )</emphasis>, <emphasis role="bold">toString( )</emphasis>, <emphasis role="bold">clone( )</emphasis> (implement <emphasis role="bold">Cloneable</emphasis>), and implement <emphasis role="bold">Comparable </emphasis>and <emphasis role="bold">Serializable</emphasis>. </para>
      <para>191.   <emphasis role="bold">Use the JavaBeans �get,� �set,� and �is� naming conventions</emphasis> for methods that read and change <emphasis role="bold">private</emphasis> fields, even if you don�t think you�re making a JavaBean at the time. Not only does it make it easy to use your class as a Bean, but it�s a standard way to name these kinds of methods and so will be more easily understood by the reader.</para>
      <para>192.   <emphasis role="bold">For each class you create, consider including a <emphasis role="italic">static public test( )</emphasis> that contains code to test that class</emphasis>. You don�t need to remove the test code to use the class in a project, and if you make any changes you can easily rerun the tests. This code also provides examples of how to use your class.</para>
      <para>193.   <emphasis role="bold">Sometimes you need to inherit in order to access <emphasis role="italic">protected</emphasis> members of the base class</emphasis>. This can lead to a perceived need for multiple base types. If you don�t need to upcast, first derive a new class to perform the protected access. Then make that new class a member object inside any class that needs to use it, rather than inheriting.</para>
      <para>194.   <emphasis role="bold">Avoid the use of <emphasis role="italic">final</emphasis> methods for efficiency purposes</emphasis>. Use <emphasis role="bold">final </emphasis>only when the program is running, but not fast enough, and your profiler has shown you that a method invocation is the bottleneck.</para>
      <para>195.   <emphasis role="bold">If two classes are associated with each other in some functional way (such as containers and iterators), try to make one an inner class of the other</emphasis>. This not only emphasizes the association between the classes, but it allows the class name to be reused within a single package by nesting it within another class. The Java containers library does this by defining an inner <emphasis role="bold">Iterator</emphasis> class inside each container class, thereby providing the containers with a common interface. The other reason you�ll want to use an inner class is as part of the <emphasis role="bold">private </emphasis>implementation. Here, the inner class beneficial for implementation hiding rather than the class association and prevention of namespace pollution noted above.</para>
      <para>196.   <emphasis role="bold">Anytime you notice classes that appear to have high coupling with each other, consider the coding and maintenance improvements you might get by using inner classes</emphasis>. The use of inner classes will not uncouple the classes, but rather make the coupling explicit and more convenient.</para>
      <para>197.   <emphasis role="bold">Don�t fall prey to premature optimization</emphasis>. This way lies madness. In particular, don�t worry about writing (or avoiding) native methods, making some methods <emphasis role="bold">final</emphasis>, or tweaking code to be efficient when you are first constructing the system. Your primary goal should be to prove the design, unless the design requires a certain efficiency.</para>
      <para>198.   <emphasis role="bold">Keep scopes as small as possible so the visibility and lifetime of your objects are as small as possible</emphasis>. This reduces the chance of using an object in the wrong context and hiding a difficult-to-find bug. For example, suppose you have a container and a piece of code that iterates through it. If you copy that code to use with a new container, you may accidentally end up using the size of the old container as the upper bound of the new one. If, however, the old container is out of scope, the error will be caught at compile-time.</para>
      <para>199.   <emphasis role="bold">Use the containers in the standard Java library</emphasis>. Become proficient with their use and you�ll greatly increase your productivity. Prefer <emphasis role="bold">ArrayList</emphasis> for sequences, <emphasis role="bold">HashSet</emphasis> for sets, <emphasis role="bold">HashMap</emphasis> for associative arrays, and <emphasis role="bold">LinkedList</emphasis> for stacks (rather than <emphasis role="bold">Stack</emphasis>) and queues.</para>
      <para>200.   <emphasis role="bold">For a program to be robust, each component must be robust</emphasis>. Use all the tools provided by Java: access control, exceptions, type checking, and so on, in each class you create. That way you can safely move to the next level of abstraction when building your system.</para>
      <para>201.   <emphasis role="bold">Prefer compile-time errors to run-time errors</emphasis>. Try to handle an error as close to the point of its occurrence as possible. Prefer dealing with the error at that point to throwing an exception. Catch any exceptions in the nearest handler that has enough information to deal with them. Do what you can with the exception at the current level; if that doesn�t solve the problem, rethrow the exception.</para>
      <para>202.   <emphasis role="bold">Watch for long method definitions</emphasis>. Methods should be brief, functional units that describe and implement a discrete part of a class interface. A method that is long and complicated is difficult and expensive to maintain, and is probably trying to do too much all by itself. If you see such a method, it indicates that, at the least, it should be broken up into multiple methods. It may also suggest the creation of a new class. Small methods will also foster reuse within your class. (Sometimes methods must be large, but they should still do just one thing.)</para>
      <para>203.   <emphasis role="bold">Keep things as �<emphasis role="italic">private</emphasis> as possible.�</emphasis> Once you publicize an aspect of your library (a method, a class, a field), you can never take it out. If you do, you�ll wreck somebody�s existing code, forcing them to rewrite and redesign. If you publicize only what you must, you can change everything else with impunity, and since designs tend to evolve this is an important freedom. In this way, implementation changes will have minimal impact on derived classes. Privacy is especially important when dealing with multithreading�only <emphasis role="bold">private</emphasis> fields can be protected against un-<emphasis role="bold">synchronized</emphasis> use.</para>
      <para>204.   <emphasis role="bold">Use comments liberally, and use the <emphasis role="italic">javadoc</emphasis> comment-documentation syntax to produce your program documentation</emphasis>. However, the comments should add geniune meaning to the code; comments that only reiterate what the code is clearly expressing are annoying. Note that the typical verbose detail of Java class and method names reduce the need for as many comments.</para>
      <para>205.   <emphasis role="bold">Avoid using �magic numbers�</emphasis>�which are numbers hard-wired into code. These are a nightmare if you need to change them, since you never know if �100� means �the array size� or �something else entirely.� Instead, create a constant with a descriptive name and use the constant identifier throughout your program. This makes the program easier to understand and much easier to maintain.</para>
      <para>206.   <emphasis role="bold">When creating constructors, consider exceptions</emphasis>. In the best case, the constructor won�t do anything that throws an exception. In the next-best scenario, the class will be composed and inherited from robust classes only, so they will need no cleanup if an exception is thrown. Otherwise, you must clean up composed classes inside a <emphasis role="bold">finally</emphasis> clause. If a constructor must fail, the appropriate action is to throw an exception, so the caller doesn�t continue blindly, thinking that the object was created correctly.</para>
      <para>207.   <emphasis role="bold">If your class requires any cleanup when the client programmer is finished with the object, place the cleanup code in a single, well-defined method</emphasis>�with a name like <emphasis role="bold">cleanup( )</emphasis> that clearly suggests its purpose. In addition, place a <emphasis role="bold">boolean</emphasis> flag in the class to indicate whether the object has been cleaned up so that <emphasis role="bold">finalize( )</emphasis> can check for �the death condition� (see Chapter 4).</para>
      <para>208.   <emphasis role="bold">The responsibility of <emphasis role="italic">finalize( )</emphasis> can only be to verify �the death condition� of an object for debugging.</emphasis> (See Chapter 4.) In special cases, it might be needed to release memory that would not otherwise be released by the garbage collector. Since the garbage collector might not get called for your object, you cannot use <emphasis role="bold">finalize( ) </emphasis>to perform necessary cleanup. For that you must create your own �cleanup� method. In the <emphasis role="bold">finalize( )</emphasis> method for the class, check to make sure that the object has been cleaned up and throw a class derived from <emphasis role="bold">RuntimeException</emphasis> if it hasn�t, to indicate a programming error. Before relying on such a scheme, ensure that <emphasis role="bold">finalize( ) </emphasis>works on your system. (You might need to call <emphasis role="bold">System.gc( )</emphasis> to ensure this behavior.)</para>
      <para>209.   <emphasis role="bold">If an object must be cleaned up (other than by garbage collection) within a particular scope, use the following approach:</emphasis> Initialize the object and, if successful, immediately enter a <emphasis role="bold">try</emphasis> block with a <emphasis role="bold">finally</emphasis> clause that performs the cleanup.</para>
      <para>210.   <emphasis role="bold">When overriding <emphasis role="italic">finalize( )</emphasis> during inheritance, remember to call <emphasis role="italic">super.finalize( )</emphasis></emphasis><emphasis role="bold">.</emphasis> (This is not necessary if <emphasis role="bold">Object</emphasis> is your immediate superclass.) You should call <emphasis role="bold">super.finalize( )</emphasis> as the <emphasis role="italic">final</emphasis> act of your overridden <emphasis role="bold">finalize( )</emphasis> rather than the first, to ensure that base-class components are still valid if you need them.</para>
      <para>211.   <emphasis role="bold">When you are creating a fixed-size container of objects, transfer them to an array</emphasis>�especially if you�re returning this container from a method. This way you get the benefit of the array�s compile-time type checking, and the recipient of the array might not need to cast the objects in the array in order to use them. Note that the base-class of the containers library, <emphasis role="bold">java.util.Collection</emphasis>, has two <emphasis role="bold">toArray( )</emphasis> methods to accomplish this.</para>
      <para>212.   <emphasis role="bold">Choose <emphasis role="italic">interfaces</emphasis> over <emphasis role="italic">abstract</emphasis> classes</emphasis>. If you know something is going to be a base class, your first choice should be to make it an <emphasis role="bold">interface</emphasis>, and only if you�re forced to have method definitions or member variables should you change it to an <emphasis role="bold">abstract</emphasis> class. An <emphasis role="bold">interface </emphasis>talks about what the client wants to do, while a class tends to focus on (or allow) implementation details.</para>
      <para>213.   <emphasis role="bold">Inside constructors, do only what is necessary to set the object into the proper state</emphasis>. Actively avoid calling other methods (except for <emphasis role="bold">final</emphasis> methods) since those methods can be overridden by someone else to produce unexpected results during construction. (See Chapter 7 for details.) Smaller, simpler constructors are less likely to throw exceptions or cause problems.</para>
      <para>214.   <emphasis role="bold">To avoid a highly frustrating experience, make sure that there is only one unpackaged class of each name anywhere in your classpath</emphasis>. Otherwise, the compiler can find the identically-named other class first, and report error messages that make no sense. If you suspect that you are having a classpath problem, try looking for <emphasis role="bold">.class</emphasis> files with the same names at each of the starting points in your classpath. Ideally, put all your classes within packages.</para>
      <para>215.   <emphasis role="bold">Watch out for accidental overloading</emphasis>. If you attempt to override a base-class method and you don�t quite get the spelling right, you�ll end up adding a new method rather than overriding an existing method. However, this is perfectly legal, so you won�t get any error message from the compiler or run-time system�your code simply won�t work correctly.</para>
      <para>216.   <emphasis role="bold">Watch out for premature optimization</emphasis>. First make it work, then make it fast�but only if you must, and only if it�s proven that there is a performance bottleneck in a particular section of your code. Unless you have used a profiler to discover a bottleneck, you will probably be wasting your time. The hidden cost of performance tweaks is that your code becomes less understandable and maintainable. </para>
      <para>217.   <emphasis role="bold">Remember that code is read much more than it is written</emphasis>. Clean designs make for easy-to-understand programs, but comments, detailed explanations, and examples are invaluable. They will help both you and everyone who comes after you. If nothing else, the frustration of trying to ferret out useful information from the online Java documentation should convince you.</para>
      <para> </para>
     </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064962"/><anchor xreflabel="" xml:id="_Toc477690739"/><anchor xreflabel="" xml:id="Appendix_D"/>D: Resources</title>
    <section>
      <title><anchor xreflabel="Software" xml:id="_Toc481064963"/>Software</title>
      <para><emphasis role="bold">The JDK </emphasis>from <emphasis role="italic">java.sun.com</emphasis>. Even if you choose to use a third-party development environment, it�s always a good idea to have the JDK on hand in case you come up against what might be a compiler error. The JDK is the touchstone, and if there is a bug in it, chances are it will be well-known.</para>
      <para><emphasis role="bold">The HTML Java documentation</emphasis> from <emphasis role="italic">java.sun.com</emphasis>. I have never found a reference book on the standard Java libraries that wasn�t out of date or missing information. Although the HTML documentation from Sun is shot-through with small bugs and is sometimes unusably terse, all the classes and methods are at least <emphasis role="italic">there</emphasis>. People are sometimes uncomfortable at first using an online resource rather than a printed book, but it�s worth your while to get over this and open the HTML docs first, so you can at least get the big picture. If you can�t figure it out at that point, then reach for the printed books.</para>
    </section>
    <section>
      <title><anchor xreflabel="Books" xml:id="_Toc481064964"/>Books</title>
      <para><emphasis role="bold"><emphasis role="italic">Thinking in Java, 1<superscript>st</superscript> Edition</emphasis></emphasis>. Available as fully-indexed, color-syntax-highlighted HTML on the CD ROM bound in with this book, or as a free download from <emphasis role="italic">www.BruceEckel.com</emphasis>. Includes older material and material that was not considered interesting enough to carry through to the 2<superscript>nd</superscript> edition.</para>
      <para><emphasis role="bold"><emphasis role="italic">Core Java 2</emphasis></emphasis>, by Horstmann &amp; Cornell, Volume I�Fundamentals (Prentice-Hall, 1999). Volume II�Advanced Features, 2000. Huge, comprehensive, and the first place I go when I�m hunting for answers. The book I recommend when you�ve completed <emphasis role="italic">Thinking in Java</emphasis> and need to cast a bigger net.</para>
      <para><emphasis role="bold"><emphasis role="italic">Java in a Nutshell: A Desktop Quick Reference, 2nd Edition</emphasis></emphasis>,<emphasis role="bold"/>by David Flanagan (O�Reilly, 1997). A compact summary of the online Java documentation. Personally, I prefer to browse the docs from <emphasis role="italic">java.sun.com</emphasis> online, especially since they change so often. However, many folks still like printed documentation and this fits the bill; it also provides more discussion than the online documents.</para>
      <para><emphasis role="bold"><emphasis role="italic">The Java Class Libraries: An Annotated Reference</emphasis></emphasis>,<emphasis role="bold"/>by Patrick Chan and Rosanna Lee (Addison-Wesley, 1997). What the online reference <emphasis role="italic">should</emphasis> have been: enough description to make it usable. One of the technical reviewers for <emphasis role="italic">Thinking in Java</emphasis> said, �If I had only one Java book, this would be it (well, in addition to yours, of course).� I�m not as thrilled with it as he is. It�s big, it�s expensive, and the quality of the examples doesn�t satisfy me. <emphasis role="italic">But</emphasis> it�s a place to look when you�re stuck and it seems to have more depth (and sheer size) than <emphasis role="italic">Java in a Nutshell</emphasis>.</para>
      <para><emphasis role="bold"><emphasis role="italic">Java Network Programming</emphasis></emphasis>, by Elliotte Rusty Harold (O�Reilly, 1997). I didn�t begin to understand Java networking until I found this book. I also find his Web site, Caf� au Lait, to be a stimulating, opinionated, and up-to-date perspective on Java developments, unencumbered by allegiances to any vendors. His regular updates keep up with fast-changing news about Java. See <emphasis role="italic">metalab.unc.edu/javafaq/</emphasis>.</para>
      <para><emphasis role="bold"><emphasis role="italic">JDBC Database Access with Java</emphasis></emphasis>, by Hamilton, Cattell &amp; Fisher (Addison-Wesley, 1997). If you know nothing about SQL and databases, this is a nice, gentle introduction. It also contains some of the details as well as an �annotated reference� to the API (again, what the online reference should have been). The drawback, as with all books in <emphasis role="italic">The Java Series </emphasis>(�The ONLY Books Authorized by JavaSoft�) is that it�s been whitewashed so that it says only wonderful things about Java�you won�t find out about any dark corners in this series.</para>
      <para><emphasis role="bold"><emphasis role="italic">Java Programming with CORBA</emphasis></emphasis>, by Andreas Vogel &amp; Keith Duddy (John Wiley &amp; Sons, 1997). A serious treatment of the subject with code examples for three Java ORBs (Visibroker, Orbix, Joe). </para>
      <para><emphasis role="bold"><emphasis role="italic">Design Patterns</emphasis></emphasis>, by Gamma, Helm, Johnson &amp; Vlissides (Addison-Wesley, 1995). The seminal book that started the patterns movement in programming.</para>
      <para><emphasis role="bold"><emphasis role="italic">Practical Algorithms for Programmers</emphasis></emphasis>, by Binstock &amp; Rex (Addison-Wesley, 1995). The algorithms are in C, so they�re fairly easy to translate into Java. Each algorithm is thoroughly explained.</para>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc481064965"/><anchor xreflabel="Analysis
&amp; design" xml:id="_Toc472655073"/>Analysis &amp; design</title>
        <para><emphasis role="italic"><emphasis role="bold">Extreme Programming Explained</emphasis></emphasis>,<emphasis role="bold"/>by Kent Beck (Addison-Wesley, 2000). I <emphasis role="italic">love</emphasis> this book. Yes, I tend to take a radical approach to things but I&apos;ve always felt that there could be a much different, much better program development process, and I think XP comes pretty darn close. The only book that has had a similar impact on me was <emphasis role="italic">PeopleWare </emphasis>(described below), which talks primarily about the environment and dealing with corporate culture. <emphasis role="italic">Extreme Programming Explained</emphasis> talks about programming, and turns most things, even recent �findings,� on their ear. They even go so far as to say that pictures are OK as long as you don�t spend too much time on them and are willing to throw them away. (You�ll notice that this book does <emphasis role="italic">not </emphasis>have the �UML stamp of approval� on its cover.) I could see deciding whether to work for a company based solely on whether they used XP. Small book, small chapters, effortless to read, exciting to think about. You start imagining yourself working in such an atmosphere and it brings visions of a whole new world.</para>
        <para><emphasis role="italic"><emphasis role="bold">UML Distilled, 2<superscript>nd</superscript> Edition</emphasis></emphasis>, by Martin Fowler (Addison-Wesley, 2000). When you first encounter UML, it is daunting because there are so many diagrams and details. According to Fowler, most of this stuff is unnecessary so he cuts through to the essentials. For most projects, you only need to know a few diagramming tools, and Fowler�s goal is to come up with a good design rather than worry about all the artifacts of getting there. A nice, thin, readable book; the first one you should get if you need to understand UML.</para>
        <para><emphasis role="bold"><emphasis role="italic">UML Toolkit</emphasis></emphasis>, by Hans-Erik Eriksson &amp; Magnus Penker, (John Wiley &amp; Sons, 1997). Explains UML and how to use it, and has a case study in Java. An accompanying CD ROM contains the Java code and a cut-down version of Rational Rose. An excellent introduction to UML and how to use it to build a real system.</para>
        <para><emphasis role="bold"><emphasis role="italic">The Unified Software Development Process</emphasis></emphasis>, by Ivar Jacobsen, Grady Booch, and James Rumbaugh (Addison-Wesley, 1999). I went in fully prepared to dislike this book. It seemed to have all the makings of a boring college text. I was pleasantly surprised�only pockets of the book contain explanations that seem as if those concepts aren�t clear to the authors. The bulk of the book is not only clear, but enjoyable. And best of all, the process makes a lot of practical sense. It�s not Extreme Programming (and does not have their clarity about testing) but it�s also part of the UML juggernaut�even if you can�t get XP adopted, most people have climbed aboard the �UML is good� bandwagon (regardless of their <emphasis role="italic">actual</emphasis> level of experience with it) and so you can probably get it adopted. I think this book should be the flagship of UML, and the one you can read after Fowler�s <emphasis role="italic">UML Distilled</emphasis> when you want more detail.</para>
        <para>Before you choose any method, it�s helpful to gain perspective from those who are not trying to sell one. It�s easy to adopt a method without really understanding what you want out of it or what it will do for you. Others are using it, which seems a compelling reason. However, humans have a strange little psychological quirk: If they want to believe something will solve their problems, they�ll try it. (This is experimentation, which is good.) But if it doesn�t solve their problems, they may redouble their efforts and begin to announce loudly what a great thing they�ve discovered. (This is denial, which is not good.) The assumption here may be that if you can get other people in the same boat, you won�t be lonely, even if it�s going nowhere (or sinking).</para>
        <para>This is not to suggest that all methodologies go nowhere, but that you should be armed to the teeth with mental tools that help you stay in experimentation mode (�It�s not working; let�s try something else�) and out of denial mode (�No, that�s not really a problem. Everything�s wonderful, we don�t need to change�). I think the following books, read <emphasis role="italic">before</emphasis> you choose a method, will provide you with these tools.</para>
        <para><emphasis role="bold"><emphasis role="italic">Software Creativity</emphasis></emphasis>, by Robert Glass (Prentice-Hall, 1995). This is the best book I�ve seen that discusses <emphasis role="italic">perspective</emphasis> on the whole methodology issue. It�s a collection of short essays and papers that Glass has written and sometimes acquired (P.J. Plauger is one contributor), reflecting his many years of thinking and study on the subject. They�re entertaining and only long enough to say what�s necessary; he doesn�t ramble and bore you. He�s not just blowing smoke, either; there are hundreds of references to other papers and studies. All programmers and managers should read this book before wading into the methodology mire.</para>
        <para><emphasis role="bold"><emphasis role="italic">Software Runaways: Monumental Software Disasters</emphasis></emphasis>, by Robert Glass (Prentice-Hall, 1997). The great thing about this book is that it brings to the forefront what we don�t talk about: how many projects not only fail, but fail spectacularly. I find that most of us still think �That can�t happen to me� (or �That can�t happen <emphasis role="italic">again</emphasis>�), and I think this puts us at a disadvantage. By keeping in mind that things can always go wrong, you�re in a much better position to make them go right.</para>
        <para><emphasis role="bold"><emphasis role="italic">Peopleware</emphasis></emphasis><emphasis role="italic">, <emphasis role="bold">2<superscript>nd</superscript> Edition</emphasis></emphasis>,<emphasis role="bold"/>by Tom Demarco and Timothy Lister (Dorset House, 1999). Although they have backgrounds in software development, this book is about projects and teams in general. But the focus is on the <emphasis role="italic">people</emphasis> and their needs, rather than the technology and its needs. They talk about creating an environment where people will be happy and productive, rather than deciding what rules those people should follow to be adequate components of a machine. This latter attitude, I think, is the biggest contributor to programmers smiling and nodding when XYZ method is adopted and then quietly doing whatever they�ve always done.</para>
        <para><emphasis role="bold"><emphasis role="italic">Complexity</emphasis></emphasis>, by M. Mitchell Waldrop (Simon &amp; Schuster, 1992). This chronicles the coming together of a group of scientists from different disciplines in Santa Fe, New Mexico, to discuss real problems that their individual disciplines couldn�t solve (the stock market in economics, the initial formation of life in biology, why people do what they do in sociology, etc.). By crossing physics, economics, chemistry, math, computer science, sociology, and others, a multidisciplinary approach to these problems is developing. But more important, a different way of <emphasis role="italic">thinking</emphasis> about these ultra-complex problems is emerging: Away from mathematical determinism and the illusion that you can write an equation that predicts all behavior, and toward first <emphasis role="italic">observing </emphasis>and looking for a pattern and trying to emulate that pattern by any means possible. (The book chronicles, for example, the emergence of genetic algorithms.) This kind of thinking, I believe, is useful as we observe ways to manage more and more complex software projects.</para>
      </section>
      <section>
        <title><anchor xreflabel="" xml:id="_Toc472655071"/><anchor xreflabel="Python" xml:id="_Toc481064966"/>Python</title>
        <para><emphasis role="bold"><emphasis role="italic">Learning Python</emphasis></emphasis>, by Mark Lutz and David Ascher (O�Reilly, 1999). A nice programmer�s introduction to what is rapidly becoming my favorite language, an excellent companion to Java. The book includes an introduction to JPython, which allows you to combine Java and Python in a single program (the JPython interpreter is compiled to pure Java bytecodes, so there is nothing special you need to add to accomplish this). This language union promises great possibilities.</para>
      </section>
      <section>
        <title><anchor xreflabel="My own list of books" xml:id="_Toc481064967"/>My own list of books</title>
        <para>Listed in order of publication. Not all of these are currently available.</para>
        <para><emphasis role="bold"><emphasis role="italic">Computer Interfacing with Pascal &amp; C</emphasis></emphasis>,<emphasis role="bold"/>(Self-published via the Eisys imprint, 1988. Only available via <emphasis role="italic">www.BruceEckel.com</emphasis>). An introduction to electronics from back when CP/M was still king and DOS was an upstart. I used high-level languages and often the parallel port of the computer to drive various electronic projects. Adapted from my columns in the first and best magazine I wrote for, <emphasis role="italic">Micro Cornucopia. </emphasis>(To paraphrase Larry O�Brien, long-time editor of <emphasis role="italic">Software Development Magazine</emphasis>: the best computer magazine ever published�they even had plans for building a robot in a flower pot!) Alas, Micro C became lost long before the Internet appeared. Creating this book was an extremely satisfying publishing experience.</para>
        <para><emphasis role="bold"><emphasis role="italic">Using C++</emphasis></emphasis>,<emphasis role="bold"/>(Osborne/McGraw-Hill, 1989). One of the first books out on C++. This is out of print and replaced by its second edition, the renamed <emphasis role="italic">C++ Inside &amp; Out</emphasis>.</para>
        <para><emphasis role="bold"><emphasis role="italic">C++ Inside &amp; Out</emphasis></emphasis>,<emphasis role="bold"/>(Osborne/McGraw-Hill, 1993). As noted, actually the 2<superscript>nd</superscript> edition of <emphasis role="bold">Using C++</emphasis>. The C++ in this book is reasonably accurate, but it&apos;s circa 1992 and <emphasis role="italic">Thinking in C++</emphasis> is intended to replace it. You can find out more about this book and download the source code at <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
        <para><emphasis role="bold"><emphasis role="italic">Thinking in C++, 1<superscript>st</superscript> Edition</emphasis></emphasis>, (Prentice-Hall, 1995). </para>
        <para><emphasis role="bold"><emphasis role="italic">Thinking in C++, 2<superscript>nd</superscript> Edition, Volume 1</emphasis></emphasis>, (Prentice-Hall, 2000). Downloadable from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
        <para><emphasis role="bold"><emphasis role="italic">Black Belt C++, the Master�s Collection</emphasis></emphasis>, Bruce Eckel, editor (M&amp;T Books, 1994). Out of print. A collection of chapters by various C++ luminaries based on their presentations in the C++ track at the Software Development Conference, which I chaired. The cover on this book stimulated me to gain control over all future cover designs.</para>
        <para><emphasis role="bold"><emphasis role="italic">Thinking in Java, 1<superscript>st</superscript> Edition</emphasis></emphasis>, (Prentice-Hall, 1998). The first edition of this book won the <emphasis role="italic">Software Development Magazine </emphasis>Productivity Award, the <emphasis role="italic">Java Developer�s Journal </emphasis>Editor�s Choice Award, and the <emphasis role="italic">JavaWorld Reader�s Choice Award for best book</emphasis>. Downloadable from <emphasis role="italic">www.BruceEckel.com</emphasis>.</para>
        <para> </para>
        </section>
    </section>
  </section>
  <section>
    <title><anchor xreflabel="" xml:id="_Toc481064968"/><anchor xreflabel="Index" xml:id="_Toc477690740"/>Index</title>
    <para>Please note that some names will be duplicated in capitalized form. Following Java style, the capitalized names refer to Java classes, while lowercase names refer to a general concept.</para>
     <para>- � 139</para>
    <para>! � 143</para>
    <para>!= � 141; operator � 1025</para>
    <para>&amp; � 146</para>
    <para>&amp;&amp; � 143</para>
    <para>&amp;= � 147</para>
    <para>@deprecated � 128</para>
    <para>�[ ]: indexing operator [ ] � 231</para>
    <para>^ � 146</para>
    <para>^= � 147</para>
    <para>| � 146</para>
    <para>|| � 143</para>
    <para>|= � 147</para>
    <para>��+�: operator + for String � 1054</para>
    <para>+ � 139</para>
    <para>&lt; � 141</para>
    <para>&lt;&lt; � 147</para>
    <para>&lt;&lt;= � 147</para>
    <para>&lt;= � 141</para>
    <para>== � 141; operator � 1025; vs. equals( ) � 645</para>
    <para>&gt; � 141</para>
    <para>&gt;= � 141</para>
    <para>&gt;&gt; � 147</para>
    <para>&gt;&gt;= � 147</para>
    <para>A</para>
    <para>abstract: class � 326; inheriting from an abstract class � 326; vs. interface � 356</para>
    <para>abstract keyword � 327</para>
    <para>Abstract Window Toolkit (AWT) � 689</para>
    <para>AbstractButton � 734</para>
    <para>abstraction � 30</para>
    <para>AbstractSequentialList � 502</para>
    <para>AbstractSet � 461</para>
    <para>accept( ) � 909</para>
    <para>access: class � 263; control � 243, 267; inner classes &amp; access rights � 376; package access and friendly � 255; specifiers � 36, 243, 255; within a directory, via the default package � 257</para>
    <para>action command � 765</para>
    <para>ActionEvent � 766, 814</para>
    <para>ActionListener � 712</para>
    <para>actor, in use cases � 77</para>
    <para>adapters: listener adapters � 729</para>
    <para>add( ), ArrayList � 450</para>
    <para>addActionListener( ) � 811, 857</para>
    <para>addChangeListener � 771</para>
    <para>addition � 137</para>
    <para>addListener � 722</para>
    <para>addXXXListener( ) � 723</para>
    <para>Adler32 � 608</para>
    <para>aggregate array initialization � 231</para>
    <para>aggregation � 37</para>
    <para>aliasing � 136; and String � 1054; during a method call � 1014</para>
    <para>align � 697</para>
    <para>alphabetic vs. lexicographic sorting � 436</para>
    <para>AlreadyBoundException � 978</para>
    <para>analysis: and design, object-oriented � 71; paralysis � 72; requirements analysis � 75</para>
    <para>AND: bitwise � 154; logical (&amp;&amp;) � 143</para>
    <para>anonymous inner class � 370, 576, 709, 875; and constructors � 375</para>
    <para>anonymous inner class, and table-driven code � 502</para>
    <para>applet � 692; advantages for client/server systems � 693; align � 697; and packages � 699; archive tag, for HTML and JAR files � 793; classpath � 699; codebase � 697; combined applets and applications � 700; displaying a Web page from within an applet � 923; name � 697; packaging applets in a JAR file to optimize loading � 793; parameter � 697; placing inside a Web page � 695; restrictions � 692</para>
    <para>Applet: combined with application � 839; initialization parameters � 839</para>
    <para>appletviewer � 698</para>
    <para>application: application builder � 800; application framework � 394; combined applets and applications � 700; combined with Applet � 839; windowed applications � 700</para>
    <para>application framework, and applets � 694</para>
    <para>archive tag, for HTML and JAR files � 793</para>
    <para>argument: constructor � 193; final � 298, 577; passing a reference into a method � 1014; variable argument lists (unknown quantity and type of arguments) � 235</para>
    <para>array � 407; associative array � 477; associative array, Map � 442; bounds checking � 232; comparing arrays � 431; copying an array � 429; dynamic aggregate initialization syntax � 412; element comparisons � 431; first-class objects � 409; initialization � 231; length � 232, 409; multidimensional � 236; of objects � 409; of primitives � 409; return an array � 413</para>
    <para>ArrayList � 456, 463, 467, 500, 505; add( ) � 450; and deep copying � 1030; get( ) � 450, 456; size( ) � 451; type-conscious ArrayList � 454; used with HashMap � 652</para>
    <para>Arrays class, container utility � 415</para>
    <para>Arrays.asList( ) � 519</para>
    <para>Arrays.binarySearch( ) � 437</para>
    <para>Arrays.fill( ) � 428</para>
    <para>assigning objects � 134</para>
    <para>assignment � 134</para>
    <para>associative array � 439, 477</para>
    <para>associative arrays (Maps) � 442</para>
    <para>auto-decrement operator � 139</para>
    <para>auto-increment operator � 139</para>
    <para>automatic type conversion � 273</para>
    <para>available( ) � 598</para>
    <para>B</para>
    <para>bag � 440</para>
    <para>base: types � 39</para>
    <para>base 16 � 156</para>
    <para>base 8 � 156</para>
    <para>base class � 260, 275, 315; abstract base class � 326; base-class interface � 320; constructor � 332; constructors and exceptions � 281; initialization � 278</para>
    <para>Basic: Microsoft Visual Basic � 800</para>
    <para>basic concepts of object-oriented programming (OOP) � 29</para>
    <para>BASIC language � 92</para>
    <para>BasicArrowButton � 735</para>
    <para>beanbox Bean testing tool � 817</para>
    <para>BeanInfo: custom BeanInfo � 818</para>
    <para>Beans: and Borland�s Delphi � 800; and Microsoft�s Visual Basic � 800; and multithreading � 854; application builder � 800; beanbox Bean testing tool � 817; bound properties � 818; component � 801; constrained properties � 818; custom BeanInfo � 818; custom property editor � 818; custom property sheet � 818; events � 801; EventSetDescriptors � 808; FeatureDescriptor � 818; getBeanInfo( ) � 805; getEventSetDescriptors( ) � 808; getMethodDescriptors( ) � 808; getName( ) � 808; getPropertyDescriptors( ) � 808; getPropertyType( ) � 808; getReadMethod( ) � 808; getWriteMethod( ) � 808; indexed property � 818; Introspector � 805; JAR files for packaging � 816; manifest file � 816; Method � 808; MethodDescriptors � 808; naming convention � 802; properties � 801; PropertyChangeEvent � 818; PropertyDescriptors � 808; ProptertyVetoException � 818; reflection � 801, 804; Serializable � 814; visual programming � 800</para>
    <para>Beck, Kent � 1093</para>
    <para>Bill Joy � 141</para>
    <para>binary: numbers � 156; operators � 146</para>
    <para>binary numbers, printing � 150</para>
    <para>binarySearch( ) � 437</para>
    <para>bind( ) � 976</para>
    <para>binding: dynamic binding � 316; dynamic, late, or run-time binding � 311; early � 45; late � 45; late binding � 316; method call binding � 315; run-time binding � 316</para>
    <para>BitSet � 522</para>
    <para>bitwise: AND � 154; AND operator (&amp;) � 146; EXCLUSIVE OR XOR (^) � 146; NOT ~ � 146; operators � 146; OR � 154; OR operator (|) � 146</para>
    <para>bitwise copy � 1024</para>
    <para>blank final � 297</para>
    <para>blocking: and available( ) � 598; and threads � 859; on I/O � 869</para>
    <para>Booch, Grady � 1093</para>
    <para>book: errors, reporting � 23; updates of the book � 22</para>
    <para>boolean: operators that won�t work with boolean � 141</para>
    <para>Boolean � 169; algebra � 146; and casting � 155; vs. C and C++ � 144</para>
    <para>BorderLayout � 713</para>
    <para>Borland � 820; Delphi � 800</para>
    <para>bound properties � 818</para>
    <para>bounds checking, array � 232</para>
    <para>Box, for BoxLayout � 718</para>
    <para>BoxLayout � 717</para>
    <para>break keyword � 175</para>
    <para>browser: class browser � 263</para>
    <para>BufferedInputStream � 586</para>
    <para>BufferedOutputStream � 588</para>
    <para>BufferedReader � 563, 591, 597</para>
    <para>BufferedWriter � 591, 599</para>
    <para>business objects/logic � 796</para>
    <para>button: creating your own � 730; radio button � 750</para>
    <para>button, Swing � 706</para>
    <para>ButtonGroup � 736, 750</para>
    <para>buttons � 734</para>
    <para>ByteArrayInputStream � 582</para>
    <para>ByteArrayOutputStream � 583</para>
    <para>C</para>
    <para>C/C++, interfacing with � 1065</para>
    <para>C++ � 141; copy constructor � 1042; Standard Container Library aka STL � 440; strategies for transition to � 93; templates � 455; vector class, vs. array and ArrayList � 408; why it succeeds � 91</para>
    <para>callback � 432, 575, 708</para>
    <para>callbacks: and inner classes � 391</para>
    <para>capacity, of a HashMap or HashSet � 491</para>
    <para>capitalization: Java capitalization style source-code checking tool � 645; of package names � 116</para>
    <para>case statement � 183</para>
    <para>cast � 47, 201, 661; and containers � 450; and primitive types � 170; from float or double to integral, truncation � 186; operators � 154</para>
    <para>catch: catching an exception � 534; catching any exception � 543; keyword � 535</para>
    <para>CD ROM for book � 20</para>
    <para>CGI: Common-Gateway Interface � 948</para>
    <para>change: vector of change � 397</para>
    <para>CharArrayReader � 590</para>
    <para>CharArrayWriter � 590</para>
    <para>check box � 748</para>
    <para>CheckedInputStream � 606</para>
    <para>CheckedOutputStream � 606</para>
    <para>Checksum � 608</para>
    <para>class � 32, 262; abstract class � 326; access � 263; anonymous inner � 709; anonymous inner class � 370, 576, 875; anonymous inner class and constructors � 375; base class � 260, 275, 315; browser � 263; class hierarchies and exception handling � 567; class literal � 664, 669; creators � 35; defining the interface � 88; derived class � 315; equivalence, and instanceof/isInstance( ) � 672; final classes � 301; inheritance diagrams � 293; inheriting from an abstract class � 326; inheriting from inner classes � 384; initialization &amp; class loading � 304; initialization of data members � 220; initializing members at point of definition � 221; initializing the base class � 278; inner class � 365; inner class nesting within any arbitrary scope � 372; inner classes � 799; inner classes &amp; access rights � 376; inner classes and overriding � 385; inner classes and super � 385; inner classes and Swing � 722; inner classes and upcasting � 368; inner classes in methods &amp; scopes � 370; inner classes, identifiers and .class files � 387; instance of � 31; intializing the derived class � 278; keyword � 38; loading � 305; member initialization � 273; multiply-nested � 383; order of initialization � 223; private inner classes � 397; public class, and compilation units � 245; read-only classes � 1047; referring to the outer class object in an inner class � 381; static inner classes � 379; style of creating classes � 262; subobject � 278</para>
    <para>Class � 737; Class object � 633, 662, 848; forName( ) � 664, 727; getClass( ) � 544; getConstructors( ) � 681; getInterfaces( ) � 676; getMethods( ) � 681; getName( ) � 677; getSuperclass( ) � 676; isInstance � 671; isInterface( ) � 677; newInstance( ) � 676; printInfo( ) � 677; RTTI using the Class object � 674</para>
    <para>Class object � 227</para>
    <para>ClassCastException � 345, 666</para>
    <para>classpath � 248, 699; and rmic � 979</para>
    <para>class-responsibility-collaboration (CRC) cards � 79</para>
    <para>cleanup: and garbage collector � 283; performing � 209; with finally � 554</para>
    <para>cleanup, guaranteeing with finalize( ) � 214</para>
    <para>client programmer � 35; vs. library creator � 243</para>
    <para>client, network � 907</para>
    <para>clipboard: system clipboard � 790</para>
    <para>clone( ) � 1021; and composition � 1027; and inheritance � 1034; Object.clone( ) � 1025; removing/turning off cloneability � 1036; super.clone( ) � 1025, 1041; supporting cloning in derived classes � 1036</para>
    <para>Cloneable interface � 1022</para>
    <para>CloneNotSupportedException � 1024</para>
    <para>close( ) � 597</para>
    <para>closure, and inner classes � 391</para>
    <para>code: calling non-Java code � 1065; coding standards � 22, 1077; organization � 255; re-use � 271</para>
    <para>codebase � 697</para>
    <para>Collection � 440</para>
    <para>collection class � 407</para>
    <para>Collections � 511</para>
    <para>Collections.enumeration( ) � 520</para>
    <para>Collections.fill( ) � 443</para>
    <para>Collections.reverseOrder() � 434</para>
    <para>collision: name � 250</para>
    <para>collisions, during hashing � 488</para>
    <para>com.bruceeckel.swing � 703</para>
    <para>combo box � 751</para>
    <para>comma operator � 152, 175</para>
    <para>Command Pattern � 575</para>
    <para>comments: and embedded documentation � 122</para>
    <para>common interface � 325</para>
    <para>common pitfalls when using operators � 153</para>
    <para>Common-Gateway Interface (CGI) � 948</para>
    <para>Comparable � 432, 475</para>
    <para>Comparator � 434, 475</para>
    <para>compareTo( ), in java.lang.Comparable � 432</para>
    <para>comparing arrays � 431</para>
    <para>compilation unit � 245</para>
    <para>compile-time constant � 294</para>
    <para>compiling a Java program � 121</para>
    <para>component, and JavaBeans � 801</para>
    <para>composition � 37, 271; and cloning � 1027; and design � 340; and dynamic behavior change � 341; choosing composition vs. inheritance � 288; combining composition &amp; inheritance � 281; vs. inheritance � 294, 642</para>
    <para>compression: compression library � 606</para>
    <para>concept, high � 75</para>
    <para>ConcurrentModificationException � 515</para>
    <para>conditional operator � 151</para>
    <para>conference, Software Development Conference � 10</para>
    <para>Console: Swing display framework in com.bruceeckel.swing � 702</para>
    <para>console input � 597</para>
    <para>const, in C++ � 1053</para>
    <para>constant: compile-time constant � 294; folding � 294; groups of constant values � 359; implicit constants, and String � 1053</para>
    <para>constrained properties � 818</para>
    <para>constructor � 191; and anonymous inner classes � 370; and exception handling � 562; and exceptions � 561; and finally � 562; and overloading � 194; and polymorphism � 330; arguments � 193; base-class constructor � 332; base-class constructors and exceptions � 281; behavior of polymorphic methods inside constructors � 337; C++ copy constructor � 1042; calling base-class constructors with arguments � 280; calling from other constructors � 205; default � 202; default constructors � 196; initialization during inheritance and composition � 281; name � 192; no-arg constructors � 196; order of constructor calls with inheritance � 330; return value � 193; static construction clause � 228; synthesized default constructor access � 681</para>
    <para>Constructor: for reflection � 678</para>
    <para>consulting &amp; mentoring provided by Bruce Eckel � 23</para>
    <para>container: class � 407, 439; of primitives � 412</para>
    <para>container classes, utilities for � 444</para>
    <para>continue keyword � 175</para>
    <para>control: access � 36</para>
    <para>control framework, and inner classes � 394</para>
    <para>controlling access � 267</para>
    <para>conversion: automatic � 273; narrowing conversion � 155, 201; widening conversion � 155</para>
    <para>cookies: and JSP � 971</para>
    <para>cookies, and servlets � 955</para>
    <para>copy: deep copy � 1020; shallow copy � 1019</para>
    <para>copying an array � 429</para>
    <para>CORBA � 980</para>
    <para>costs, startup � 95</para>
    <para>coupling � 537</para>
    <para>CRC, class-responsibility-collaboration cards � 79</para>
    <para>CRC32 � 608</para>
    <para>createStatement( ) � 930</para>
    <para>critical section, and synchronized block � 852</para>
    <para>D</para>
    <para>daemon threads � 840</para>
    <para>data: final � 294; primitive data types and use with operators � 159; static initialization � 225</para>
    <para>data type: equivalence to class � 33</para>
    <para>database: flat-file database � 932; Java DataBase Connectivity (JDBC) � 927; relational database � 933; URL � 928</para>
    <para>DatabaseMetaData � 938</para>
    <para>DataFlavor � 792</para>
    <para>Datagram � 923; User Datagram Protocol (UDP) � 923</para>
    <para>DataInput � 593</para>
    <para>DataInputStream � 586, 591, 597, 599</para>
    <para>DataOutput � 593</para>
    <para>DataOutputStream � 588, 592, 599</para>
    <para>dead, Thread � 859</para>
    <para>deadlock, multithreading � 865, 872</para>
    <para>death condition, and finalize( ) � 214</para>
    <para>decorator design pattern � 585</para>
    <para>decoupling: via polymorphism � 46</para>
    <para>decoupling through polymorphism � 311</para>
    <para>decrement operator � 139</para>
    <para>deep copy � 1020, 1027; and ArrayList � 1030; using serialization to perform deep copying � 1032</para>
    <para>default constructor � 196, 202; synthesizing a default constructor � 279</para>
    <para>default constructor, access the same as the class � 681</para>
    <para>default keyword, in a switch statement � 183</para>
    <para>default package � 257</para>
    <para>DefaultMutableTreeNode � 784</para>
    <para>defaultReadObject( ) � 629</para>
    <para>DefaultTreeModel � 784</para>
    <para>defaultWriteObject( ) � 629</para>
    <para>DeflaterOutputStream � 606</para>
    <para>Delphi, from Borland � 800</para>
    <para>Demarco, Tom � 1095</para>
    <para>dequeue � 440</para>
    <para>derived: derived class � 315; derived class, initializing � 278; types � 39</para>
    <para>design � 342; adding more methods to a design � 268; analysis and design, object-oriented � 71; and composition � 340; and inheritance � 339; and mistakes � 268; five stages of object design � 82; library design � 243; of object hierarchies � 307; patterns � 86, 94</para>
    <para>design patterns � 266; decorator � 585; singleton � 266</para>
    <para>destroy( ) � 877</para>
    <para>destructor � 208, 209, 554; Java doesn�t have one � 283</para>
    <para>development, incremental � 291</para>
    <para>diagram: inheritance � 47; use case � 77</para>
    <para>diagram, class inheritance diagrams � 293</para>
    <para>dialog box � 771</para>
    <para>dialog, file � 776</para>
    <para>dialog, tabbed � 755</para>
    <para>dictionary � 477</para>
    <para>digital signing � 692</para>
    <para>directory: and packages � 254; creating directories and paths � 578; lister � 574</para>
    <para>display framework, for Swing � 702</para>
    <para>dispose( ) � 772</para>
    <para>division � 137</para>
    <para>documentation: comments &amp; embedded documentation � 122</para>
    <para>Domain Name System (DNS) � 905</para>
    <para>dotted quad � 905</para>
    <para>double, literal value marker (D) � 156</para>
    <para>do-while � 173</para>
    <para>downcast � 293, 343, 666; type-safe downcast in run-time type identification � 665</para>
    <para>Drawing lines in Swing � 768</para>
    <para>drop-down list � 751</para>
    <para>dynamic: behavior change with composition � 341; binding � 311, 316</para>
    <para>dynamic aggregate initialization syntax for arrays � 412</para>
    <para>E</para>
    <para>early binding � 45, 315</para>
    <para>East, BorderLayout � 713</para>
    <para>editor, creating one using the Swing JTextPane � 747</para>
    <para>efficiency: and arrays � 408; and final � 302; and threads � 828; when using the synchronized keyword � 853</para>
    <para>EJB � 990</para>
    <para>elegance, in programming � 87</para>
    <para>else keyword � 171</para>
    <para>encapsulation � 261</para>
    <para>Enterprise JavaBeans (EJB) � 990</para>
    <para>enum, groups of constant values in C &amp; C++ � 359</para>
    <para>Enumeration � 520</para>
    <para>equals( ) � 142, 475; and hashed data structures � 485; overriding for HashMap � 484; vs. == � 645</para>
    <para>equivalence: == � 141; object equivalence � 141</para>
    <para>error: handling with exceptions � 531; recovery � 568; reporting errors in book � 23; standard error stream � 538</para>
    <para>event: event-driven system � 394; JavaBeans � 801; multicast � 796; multicast event and JavaBeans � 854; responding to a Swing event � 707; Swing event model � 794; unicast � 796</para>
    <para>event listener � 722; order of execution � 796</para>
    <para>event model, Swing � 722</para>
    <para>event-driven programming � 707</para>
    <para>events and listeners � 723</para>
    <para>EventSetDescriptors � 808</para>
    <para>evolution, in program development � 85</para>
    <para>exception: and base-class constructors � 281; and constructors � 561; and inheritance � 558, 566; catching an exception � 534; catching any exception � 543; changing the point of origin of the exception � 547; class hierarchies � 567; constructors � 562; creating your own � 537; design issues � 565; Error class � 549; Exception class � 549; <emphasis role="italic">exception handler</emphasis> � 535; exception handling � 531; exception matching � 566; FileNotFoundException � 565; fillInStackTrace( ) � 545; finally � 552; guarded region � 535; handler � 532; handling � 283; losing an exception, pitfall � 557; NullPointerException � 550; printStackTrace( ) � 545; restrictions � 558; re-throwing an exception � 545; RuntimeException � 550; specification � 542; termination vs. resumption � 536; Throwable � 543; throwing an exception � 533; try � 554; try block � 535; typical uses of exceptions � 568</para>
    <para>exceptional condition � 532</para>
    <para>exceptions: and JNI � 1074</para>
    <para>executeQuery( ) � 930</para>
    <para>Exponential notation � 156</para>
    <para>extending a class during inheritance � 41</para>
    <para>extends � 260, 277, 342; and interface � 359; keyword � 275</para>
    <para>extensible: program � 320</para>
    <para>extension: pure inheritance vs. extension � 341</para>
    <para>extension, sign � 147</para>
    <para>extension, zero � 147</para>
    <para>Externalizable � 620; alternative approach to using � 626</para>
    <para>Extreme Programming (XP) � 88, 1093</para>
    <para>F</para>
    <para>fail fast containers � 515</para>
    <para>false � 143</para>
    <para>FeatureDescriptor � 818</para>
    <para>Field, for reflection � 678</para>
    <para>fields, initializing fields in interfaces � 361</para>
    <para>FIFO � 472</para>
    <para>file: characteristics of files � 578; File.list( ) � 574; incomplete output files, errors and flushing � 599; JAR file � 245</para>
    <para>File � 582, 592, 655; class � 574</para>
    <para>file dialogs � 776</para>
    <para>File Transfer Protocol (FTP) � 699</para>
    <para>FileDescriptor � 582</para>
    <para>FileInputReader � 597</para>
    <para>FileInputStream � 582</para>
    <para>FilenameFilter � 574, 653</para>
    <para>FileNotFoundException � 565</para>
    <para>FileOutputStream � 583</para>
    <para>FileReader � 563, 590</para>
    <para>FileWriter � 590, 599</para>
    <para>fillInStackTrace( ) � 545</para>
    <para>FilterInputStream � 582</para>
    <para>FilterOutputStream � 583</para>
    <para>FilterReader � 591</para>
    <para>FilterWriter � 591</para>
    <para>final � 350; and efficiency � 302; and private � 299; and static � 294; argument � 298, 577; blank finals � 297; classes � 301; data � 294; keyword � 294; method � 316; methods � 299, 339; static primitives � 296; with object references � 295</para>
    <para>finalize( ) � 207, 566; and inheritance � 333; and super � 335; calling directly � 210; order of finalization of objects � 336</para>
    <para>finally � 283, 286; and constructors � 562; keyword � 552; pitfall � 557</para>
    <para>finding .class files during loading � 247</para>
    <para>flat-file database � 932</para>
    <para>flavor, clipboard � 790</para>
    <para>float, literal value marker(F) � 156</para>
    <para>floating point: true and false � 144</para>
    <para>FlowLayout � 714</para>
    <para>flushing output files � 599</para>
    <para>focus traversal � 691</para>
    <para>folding, constant � 294</para>
    <para>for keyword � 173</para>
    <para>forName( ) � 664, 727</para>
    <para>FORTRAN � 156</para>
    <para>forward referencing � 222</para>
    <para>Fowler, Martin � 72, 85, 1093</para>
    <para>framework: application framework and applets � 694; control framework and inner classes � 394</para>
    <para>friendly � 243, 368; and interface � 350; and protected � 290; less accessible than protected � 335</para>
    <para>FTP: File Transfer Protocol (FTP) � 699</para>
    <para>function: member function � 35; overriding � 42</para>
    <para>functor � 575</para>
    <para>G</para>
    <para>garbage collection � 207, 210, 333; and cleanup � 283; and native method execution � 1073; forcing finalization � 286; how the collector works � 215; order of object reclamation � 286; reachable objects � 495; setting references to null to allow cleanup � 397</para>
    <para>generator � 443</para>
    <para>generator object, to fill arrays and containers � 416</para>
    <para>get( ), ArrayList � 450, 456</para>
    <para>get( ), HashMap � 481</para>
    <para>getBeanInfo( ) � 805</para>
    <para>getBytes( ) � 598</para>
    <para>getClass( ) � 544, 674</para>
    <para>getConstructor( ) � 737</para>
    <para>getConstructors( ) � 681</para>
    <para>getContentPane( ) � 695</para>
    <para>getContents( ) � 792</para>
    <para>getEventSetDescriptors( ) � 808</para>
    <para>getFloat( ) � 930</para>
    <para>getInputStream( ) � 909</para>
    <para>getInt( ) � 930</para>
    <para>getInterfaces( ) � 676</para>
    <para>getMethodDescriptors( ) � 808</para>
    <para>getMethods( ) � 681</para>
    <para>getModel( ) � 784</para>
    <para>getName( ) � 677, 808</para>
    <para>getOutputStream( ) � 909</para>
    <para>getPriority( ) � 878</para>
    <para>getPropertyDescriptors( ) � 808</para>
    <para>getPropertyType( ) � 808</para>
    <para>getReadMethod( ) � 808</para>
    <para>getSelectedValues( ) � 753</para>
    <para>getState( ) � 765</para>
    <para>getString( ) � 930</para>
    <para>getSuperclass( ) � 676</para>
    <para>getTransferData( ) � 792</para>
    <para>getTransferDataFlavors( ) � 792</para>
    <para>getWriteMethod( ) � 808</para>
    <para>Glass, Robert � 1094</para>
    <para>glue, in BoxLayout � 717</para>
    <para>goto: lack of goto in Java � 177</para>
    <para>graphical user interface (GUI) � 394, 689</para>
    <para>graphics � 776</para>
    <para>Graphics � 768</para>
    <para>greater than (&gt;) � 141</para>
    <para>greater than or equal to (&gt;=) � 141</para>
    <para>GridBagLayout � 716</para>
    <para>GridLayout � 715, 894</para>
    <para>guarded region, in exception handling � 535</para>
    <para>GUI: graphical user interface � 394, 689</para>
    <para>GUI builders � 690</para>
    <para>guidelines: object development � 83</para>
    <para>guidelines, coding standards � 1077</para>
    <para>GZIPInputStream � 606</para>
    <para>GZIPOutputStream � 606</para>
    <para>H</para>
    <para><emphasis role="italic">handler, exception</emphasis> � 535</para>
    <para>hardware devices, interfacing with � 1065</para>
    <para>has-a � 37</para>
    <para>has-a relationship, composition � 289</para>
    <para>hash code � 477, 488</para>
    <para>hash function � 488</para>
    <para>hashCode( ) � 473, 477; and hashed data structures � 485; issues when writing � 492; overriding for HashMap � 484</para>
    <para>hashing � 485; external chaining � 488; perfect hashing function � 488</para>
    <para>HashMap � 476, 500, 733; used with ArrayList � 652</para>
    <para>HashSet � 473, 506</para>
    <para>Hashtable � 510, 521</para>
    <para>hasNext( ), Iterator � 457</para>
    <para>Hexadecimal � 156</para>
    <para>hiding: implementation � 35</para>
    <para>hiding, implementation � 261</para>
    <para>high concept � 75</para>
    <para>HTML � 948; name � 839; param � 839; value � 839</para>
    <para>HTML on Swing components � 779</para>
    <para>I</para>
    <para>I/O: and threads, blocking � 860; available( ) � 598; blocking on I/O � 869; blocking, and available( ) � 598; BufferedInputStream � 586; BufferedOutputStream � 588; BufferedReader � 563, 591, 597; BufferedWriter � 591, 599; ByteArrayInputStream � 582; ByteArrayOutputStream � 583; characteristics of files � 578; CharArrayReader � 590; CharArrayWriter � 590; CheckedInputStream � 606; CheckedOutputStream � 606; close( ) � 597; compression library � 606; console input � 597; controlling the process of serialization � 619; DataInput � 593; DataInputStream � 586, 591, 597, 599; DataOutput � 593; DataOutputStream � 588, 592, 599; DeflaterOutputStream � 606; directory lister � 574; directory, creating directories and paths � 578; Externalizable � 620; File � 582, 592, 655; File class � 574; File.list( ) � 574; FileDescriptor � 582; FileInputReader � 597; FileInputStream � 582; FilenameFilter � 574, 653; FileOutputStream � 583; FileReader � 563, 590; FileWriter � 590, 599; FilterInputStream � 582; FilterOutputStream � 583; FilterReader � 591; FilterWriter � 591; from standard input � 602; GZIPInputStream � 606; GZIPOutputStream � 606; InflaterInputStream � 606; input � 581; InputStream � 581, 913; InputStreamReader � 589, 590, 913; internationalization � 590; library � 573; lightweight persistence � 613; LineNumberInputStream � 586; LineNumberReader � 591; mark( ) � 593; mkdirs( ) � 580; nextToken( ) � 654; ObjectOutputStream � 614; output � 581; OutputStream � 581, 583, 913; OutputStreamWriter � 589, 590, 913; pipe � 581; piped stream � 869; piped streams � 602; PipedInputStream � 582; PipedOutputStream � 582, 583; PipedReader � 590; PipedWriter � 590; PrintStream � 588; PrintWriter � 591, 599, 913; pushBack( ) � 654; PushbackInputStream � 586; PushBackReader � 591; RandomAccessFile � 592, 593, 599; read( ) � 581; readChar( ) � 600; readDouble( ) � 600; Reader � 581, 589, 590, 913; readExternal( ) � 620; readLine( ) � 565, 591, 599, 600, 603; readObject( ) � 614; redirecting standard I/O � 604; renameTo( ) � 580; reset( ) � 593; seek( ) � 593, 601; SequenceInputStream � 582, 592; Serializable � 620; setErr(PrintStream) � 604; setIn(InputStream) � 604; setOut(PrintStream) � 604; StreamTokenizer � 591, 639, 653, 682; StringBuffer � 582; StringBufferInputStream � 582; StringReader � 590, 597; StringWriter � 590; System.err � 602; System.in � 597, 602; System.out � 602; transient � 624; typical I/O configurations � 594; Unicode � 590; write( ) � 581; writeBytes( ) � 600; writeChars( ) � 600; writeDouble( ) � 600; writeExternal( ) � 620; writeObject( ) � 614; Writer � 581, 589, 590, 913; ZipEntry � 610; ZipInputStream � 606; ZipOutputStream � 606</para>
    <para>Icon � 738</para>
    <para>IDL � 982</para>
    <para>idltojava � 984</para>
    <para>if-else statement � 151, 171</para>
    <para>IllegalMonitorStateException � 866</para>
    <para>ImageIcon � 738</para>
    <para>immutable objects � 1047</para>
    <para>implementation � 34; and interface � 288, 350; and interface, separating � 36; and interface, separation � 262; hiding � 35, 261, 368; separation of interface and implementation � 722</para>
    <para>implements keyword � 350</para>
    <para>import keyword � 244</para>
    <para>increment operator � 139</para>
    <para>incremental development � 291</para>
    <para>indexed property � 818</para>
    <para>indexing operator [ ] � 231</para>
    <para>indexOf( ): String � 576, 681</para>
    <para>InflaterInputStream � 606</para>
    <para>inheritance � 38, 260, 271, 275, 311; and cloning � 1034; and final � 302; and finalize( ) � 333; and synchronized � 858; choosing composition vs. inheritance � 288; class inheritance diagrams � 293; combining composition &amp; inheritance � 281; designing with inheritance � 339; diagram � 47; extending a class during � 41; extending interfaces with inheritance � 358; from an abstract class � 326; from inner classes � 384; inheritance and method overloading vs. overriding � 286; initialization with inheritance � 304; multiple inheritance in C++ and Java � 354; pure inheritance vs. extension � 341; specialization � 289; vs composition � 642; vs. composition � 294</para>
    <para>initial capacity, of a HashMap or HashSet � 491</para>
    <para>initialization: and class loading � 304; array initialization � 231; base class � 278; class member � 273; constructor initialization during inheritance and composition � 281; initializing class members at point of definition � 221; initializing with the constructor � 191; instance initialization � 229, 375; member initializers � 332; non-static instance initialization � 229; of class data members � 220; of method variables � 220; order of initialization � 223, 338; static � 306; with inheritance � 304</para>
    <para>inizialization: lazy � 273</para>
    <para>inline method calls � 299</para>
    <para>inner class � 365, 799; access rights � 376; and super � 385; and overriding � 385; and control frameworks � 394; and Swing � 722; and upcasting � 368; anonymous � 709; anonymous inner class � 576, 875; anonymous inner class and constructors � 375; anonymous, and table-driven code � 502; callback � 391; closure � 391; hidden reference to the object of the enclosing class � 378; identifiers and .class files � 387; in methods &amp; scopes � 370; inheriting from inner classes � 384; nesting within any arbitrary scope � 372; private � 833; private inner classes � 397; referring to the outer class object � 381; static inner classes � 379</para>
    <para>input: console input � 597</para>
    <para>InputStream � 581, 913</para>
    <para>InputStreamReader � 589, 590, 913</para>
    <para>insertNodeInto( ) � 784</para>
    <para>instance: instance initialization � 375; non-static instance initialization � 229</para>
    <para>instance of a class � 31</para>
    <para>instanceof: dynamic instanceof � 671; keyword � 666</para>
    <para>Integer: parseInt( ) � 776</para>
    <para>Integer wrapper class � 233</para>
    <para>interface: and implementation, separation � 262; and inheritance � 358; base-class interface � 320; Cloneable interface used as a flag � 1022; common interface � 325; defining the class � 88; for an object � 32; graphical user interface (GUI) � 394, 689; implementation, separation of � 36; initializing fields in interfaces � 361; keyword � 349; nesting interfaces within classes and other interfaces � 362; private, as nested interfaces � 364; Runnable � 836; separation of interface and implementation � 722; upcasting to an interface � 353; user � 78; vs. abstract � 356; vs. implemenation � 288</para>
    <para>Interface Definition Language (IDL) � 982</para>
    <para>interfaces: name collisions when combining interfaces � 356</para>
    <para>interfacing with hardware devices � 1065</para>
    <para>internationalization, in I/O library � 590</para>
    <para>Internet: Internet Protocol � 905; Internet Service Provider (ISP) � 699</para>
    <para>interrupt( ) � 873</para>
    <para>InterruptedException � 827</para>
    <para>intranet � 693; and applets � 693</para>
    <para>Introspector � 805</para>
    <para>IP (Internet Protocol) � 905</para>
    <para>is-a � 341; relationship, inheritance � 289; relationship, inheritance &amp; upcasting � 292; vs. is-like-a relationships � 42</para>
    <para>isDaemon( ) � 840</para>
    <para>isDataFlavorSupported( ) � 792</para>
    <para>isInstance � 671</para>
    <para>isInterface( ) � 677</para>
    <para>is-like-a � 342</para>
    <para>ISP (Internet Service Provider) � 699</para>
    <para>iteration, in program development � 84</para>
    <para>iterator � 456</para>
    <para>Iterator � 456, 463, 500; hasNext( ) � 457; next( ) � 457</para>
    <para>iterator( ) � 463</para>
    <para>J</para>
    <para>Jacobsen, Ivar � 1093</para>
    <para>JApplet � 713; menus � 759</para>
    <para>JAR � 816; archive tag, for HTML and JAR files � 793; file � 245; jar files and classpath � 249; packaging applets to optimize loading � 793</para>
    <para>JAR utility � 611</para>
    <para>Java � 99; and pointers � 1013; and set-top boxes � 146; capitalization style source-code checking tool � 645; compiling and running a program � 121; containers library � 440; public Java seminars � 11; versions � 22</para>
    <para>Java 1.1: I/O streams � 589</para>
    <para>Java AWT � 689</para>
    <para>Java Foundation Classes (JFC/Swing) � 689</para>
    <para>Java operators � 133</para>
    <para>Java programs, running from the Windows Explorer � 705</para>
    <para>Java Server Pages (JSP) � 960</para>
    <para>Java Virtual Machine � 662</para>
    <para>JavaBeans: see Beans � 800</para>
    <para>javac � 121</para>
    <para>javah � 1067</para>
    <para>JButton � 738</para>
    <para>JButton, Swing � 706</para>
    <para>JCheckBox � 738, 748</para>
    <para>JCheckboxMenuItem � 765</para>
    <para>JCheckBoxMenuItem � 760</para>
    <para>JComboBox � 751</para>
    <para>JComponent � 740, 768</para>
    <para>JDBC: createStatement( ) � 930; database URL � 928; DatabaseMetaData � 938; executeQuery( ) � 930; flat-file database � 932; getFloat( ) � 930; getInt( ) � 930; getString( ) � 930; Java DataBase Connectivity � 927; join � 932; relational database � 933; ResultSet � 930; SQL stored procedures � 935; Statement � 930; Structured Query Language (SQL) � 927</para>
    <para>JDialog � 771; menus � 759</para>
    <para>JDK: downloading and installing � 121</para>
    <para>JFC: Java Foundation Classes (JFC/Swing) � 689</para>
    <para>JFileChooser � 776</para>
    <para>JFrame � 704, 713; menus � 759</para>
    <para>Jini � 1003</para>
    <para>JIT: Just-In Time compilers � 98</para>
    <para>JLabel � 695, 743</para>
    <para>JList � 753</para>
    <para>JMenu � 759, 765</para>
    <para>JMenuBar � 759, 766</para>
    <para>JMenuItem � 738, 759, 765, 766, 768</para>
    <para>JNI functions � 1069</para>
    <para>JNICALL � 1068</para>
    <para>JNIEnv � 1069</para>
    <para>JNIEXPORT � 1068</para>
    <para>join � 932</para>
    <para>JOptionPane � 756</para>
    <para>JPanel � 713, 736, 768, 894</para>
    <para>JPopupMenu � 766</para>
    <para>JProgressBar � 781</para>
    <para>JRadioButton � 738, 750</para>
    <para>JScrollPane � 712, 744, 755, 784</para>
    <para>JSlider � 781</para>
    <para>JSP � 960</para>
    <para>JTabbedPane � 755</para>
    <para>JTable � 784</para>
    <para>JTextArea � 711, 790</para>
    <para>JTextField � 708, 740</para>
    <para>JTextPane � 747</para>
    <para>JToggleButton � 736</para>
    <para>JTree � 781</para>
    <para>JVM (Java Virtual Machine) � 662</para>
    <para>K</para>
    <para>keyboard navigation, and Swing � 691</para>
    <para>keyboard shortcuts � 765</para>
    <para>keySet( ) � 511</para>
    <para>keywords: class � 32, 38</para>
    <para>Koenig, Andrew � 1079</para>
    <para>L</para>
    <para>label � 178</para>
    <para>labeled break � 178</para>
    <para>labeled continue � 178</para>
    <para>late binding � 45, 311, 316</para>
    <para>layout: controlling layout with layout managers � 712</para>
    <para>lazy inizialization � 273</para>
    <para>left-shift operator (&lt;&lt;) � 147</para>
    <para>length, array member � 232</para>
    <para>length, for arrays � 409</para>
    <para>less than (&lt;) � 141</para>
    <para>less than or equal to (&lt;=) � 141</para>
    <para>lexicographic vs. alphabetic sorting � 436</para>
    <para>library: creator, vs. client programmer � 243; design � 243; use � 244</para>
    <para>LIFO � 471</para>
    <para>lightweight: Swing components � 691</para>
    <para>lightweight persistence � 613</para>
    <para>LineNumberInputStream � 586</para>
    <para>LineNumberReader � 591</para>
    <para>linked list � 440</para>
    <para>LinkedList � 467, 472, 505</para>
    <para>list: drop-down list � 751</para>
    <para>List � 408, 439, 440, 467, 753; sorting and searching � 511</para>
    <para>list boxes � 753</para>
    <para>listener adapters � 729</para>
    <para>listener classes � 799</para>
    <para>listener interfaces � 728</para>
    <para>listeners and events � 723</para>
    <para>Lister, Timothy � 1095</para>
    <para>ListIterator � 467</para>
    <para>literal: class literal � 664, 669; double � 156; float � 156; long � 156; values � 155</para>
    <para>load factor, of a HashMap or HashSet � 491</para>
    <para>loading: .class files � 247; initialization &amp; class loading � 304; loding a class � 305</para>
    <para>local loopback IP address � 907</para>
    <para>localhost � 907; and RMI � 977</para>
    <para>lock, for multithreading � 848</para>
    <para>logarithms: natural logarithms � 156</para>
    <para>logical: AND � 154; operator and short-circuiting � 144; operators � 143; OR � 154</para>
    <para>long, literal value marker (L) � 156</para>
    <para>Look &amp; Feel: Pluggable � 787</para>
    <para>lvalue � 134</para>
    <para>M</para>
    <para>main( ) � 277</para>
    <para>maintenance, program � 85</para>
    <para>management obstacles � 95</para>
    <para>manifest file, for JAR files � 611, 816</para>
    <para>map � 477</para>
    <para>Map � 408, 439, 440, 476, 508</para>
    <para>Map.Entry � 486</para>
    <para>mark( ) � 593</para>
    <para>Math.random( ) � 480; values produced by � 186</para>
    <para>mathematical operators � 137</para>
    <para>max( ) � 512</para>
    <para>member: member function � 35; object � 37</para>
    <para>member initializers � 332</para>
    <para>memory exhaustion, solution via References � 495</para>
    <para>mentoring: and training � 95, 96</para>
    <para>menu: JPopupMenu � 766</para>
    <para>menus: JDialog, JApplet, JFrame � 759</para>
    <para>message box, in Swing � 756</para>
    <para>message,� sending � 33</para>
    <para>meta-class � 662</para>
    <para>method: adding more methods to a design � 268; aliasing during a method call � 1014; aliasing during method calls � 136; behavior of polymorphic methods inside constructors � 337; distinguishing overloaded methods � 196; final � 316, 339; final methods � 299; initialization of method variables � 220; inline method calls � 299; inner classes in methods &amp; scopes � 370; lookup tool � 724; method call binding � 315; overloading � 194; passing a reference into a method � 1014; polymorphic method call � 311; private � 339; protected methods � 290; recursive � 459; static � 206; synchronized method and blocking � 860</para>
    <para>Method � 808; for reflection � 678</para>
    <para>MethodDescriptors � 808</para>
    <para>methodology, analysis and design � 71</para>
    <para>Meyers, Scott � 35</para>
    <para>Microsoft � 820; Visual Basic � 800</para>
    <para>min( ) � 512</para>
    <para>mission statement � 75</para>
    <para>mistakes, and design � 268</para>
    <para>mkdirs( ) � 580</para>
    <para>mnemonics (keyboard shortcuts) � 765</para>
    <para>modulus � 137</para>
    <para>monitor, for multithreading � 848</para>
    <para>multicast � 814; event, and JavaBeans � 854; multicast events � 796</para>
    <para>multidimensional arrays � 236</para>
    <para>Multimedia CD ROM for book � 20</para>
    <para>multiparadigm programming � 31</para>
    <para>multiple inheritance, in C++ and Java � 354</para>
    <para>multiplication � 137</para>
    <para>multiply-nested class � 383</para>
    <para>MultiStringMap � 652</para>
    <para>multitasking � 825</para>
    <para>multithreading � 825, 917; and containers � 514; and JavaBeans � 854; blocking � 859; deadlock � 865; deciding what methods to synchronize � 858; drawbacks � 899; Runnable � 891; servlets � 954; when to use it � 899</para>
    <para>multi-tiered systems � 796</para>
    <para>N</para>
    <para>name � 697; clash � 244; collisions � 250; creating unique package names � 247; spaces � 244</para>
    <para>name collisions when combining interfaces � 356</para>
    <para>name, HTML keyword � 839</para>
    <para>Naming: bind( ) � 976; rebind( ) � 978; unbind( ) � 978</para>
    <para>narrowing conversion � 155, 170, 201</para>
    <para>native method interface (NMI) in Java 1.0 � 1065</para>
    <para>natural logarithms � 156</para>
    <para>nesting interfaces � 362</para>
    <para>network programming � 904; accept( ) � 909; client � 907; Common-Gateway Interface (CGI) � 948; datagrams � 923; dedicated connection � 917; displaying a Web page from within an applet � 923; DNS (Domain Name System) � 905; dotted quad � 905; getInputStream( ) � 909; getOutputStream( ) � 909; HTML � 948; identifying machines � 905; Internet Protocol (IP) � 905; Java DataBase Connectivity (JDBC) � 927; local loopback IP address � 907; localhost � 907; multithreading � 917; port � 908; reliable protocol � 923; server � 907; serving multiple clients � 917; showDocument( ) � 924; Socket � 915; stream-based sockets � 923; testing programs without a network � 907; Transmission Control Protocol (TCP) � 923; unreliable protocol � 923; URL � 925; User Datagram Protocol (UDP) � 923</para>
    <para>new operator � 207; and primitives, array � 233</para>
    <para>newInstance( ) � 737; reflection � 676</para>
    <para>next( ), Iterator � 457</para>
    <para>nextToken( ) � 654</para>
    <para>NMI: Java 1.0 native method interface � 1065</para>
    <para>no-arg: constructors � 196</para>
    <para>non-Java code, calling � 1065</para>
    <para>North, BorderLayout � 713</para>
    <para>NOT: logical (!) � 143</para>
    <para>not equivalent (!=) � 141</para>
    <para>notify( ) � 860</para>
    <para>notifyAll( ) � 860</para>
    <para>notifyListeners( ) � 858</para>
    <para>null � 107, 411; garbage collection, allowing cleanup � 397</para>
    <para>NullPointerException � 550</para>
    <para>numbers, binary � 156</para>
    <para>O</para>
    <para>object � 31; aliasing � 136; arrays are first-class objects � 409; assigning objects by copying references � 134; assignment and reference copying � 134; business object/logic � 796; Class object � 633, 662, 848; creation � 192; equals( ) method � 142; equivalence � 141; equivalence vs reference equivalence � 142; final � 295; five stages of object design � 82; guidelines for object development � 83; immutable objects � 1047; interface to � 32; lock, for multithreading � 848; member � 37; object-oriented programming � 660; order of finalization of objects � 336; process of creation � 227; reference equivalence vs. object equivalence � 1025; serialization � 613; web of objects � 614, 1020</para>
    <para>Object � 408; clone( ) � 1021, 1025; getClass( ) � 674; hashCode( ) � 477; standard root class, default inheritance from � 275; wait( ) and notify( ) methods � 866</para>
    <para>object-oriented: analysis and design � 71; basic concepts of object-oriented programming (OOP) � 29</para>
    <para>ObjectOutputStream � 614</para>
    <para>obstacles, management � 95</para>
    <para>Octal � 156</para>
    <para>ODBC � 928</para>
    <para>OMG � 981</para>
    <para>ones complement operator � 146</para>
    <para>OOP � 262; analysis and design � 71; basic characteristics � 31; basic concepts of object-oriented programming � 29; protocol � 350; Simula programming language � 32; substitutability � 31</para>
    <para>operator � 133; + and += overloading for String � 277; +, for String � 1054; == and != � 1025; binary � 146; bitwise � 146; casting � 154; comma � 152; comma operator � 175; common pitfalls � 153; indexing operator [ ] � 231; logical � 143; logical operators and short-circuiting � 144; ones-complement � 146; operator overloading for String � 1054; overloading � 153; precedence � 134; precedence mnemonic � 158; relational � 141; shift � 147; ternary � 151; unary � 139, 146</para>
    <para>optional methods, in the Java 2 containers � 516</para>
    <para>OR � 154; (||) � 143</para>
    <para>order: of constructor calls with inheritance � 330; of finalization of objects � 336; of initialization � 223, 304, 338</para>
    <para>organization, code � 255</para>
    <para>OutputStream � 581, 583, 913</para>
    <para>OutputStreamWriter � 589, 590, 913</para>
    <para>overflow: and primitive types � 169</para>
    <para>overloading: and constructors � 194; distinguishing overloaded methods � 196; lack of name hiding during inheritance � 286; method overloading � 194; on return values � 202; operator + and += overloading for String � 277; operator overloading � 153; operator overloading for String � 1054; overloading vs. overriding � 286; vs. overriding � 324</para>
    <para>overriding: and inner classes � 385; function � 42; overloading vs. overriding � 286; vs. overloading � 324</para>
    <para>P</para>
    <para>package � 244; access, and friendly � 255; and applets � 699; and directory structure � 254; creating unique package names � 247; default package � 257; names, capitalization � 116; visibility, friendly � 368</para>
    <para>paintComponent( ) � 768, 776</para>
    <para>Painting on a JPanel in Swing � 768</para>
    <para>pair programming � 90</para>
    <para>paralysis, analysis � 72</para>
    <para>param, HTML keyword � 839</para>
    <para>parameter, applet � 697</para>
    <para>parameterized type � 455</para>
    <para>parseInt( ) � 776</para>
    <para>pass: pass by value � 1018; passing a reference into a method � 1014</para>
    <para>Pattern: Command Pattern � 575</para>
    <para>patterns, design � 86, 94</para>
    <para>patterns, design patterns � 266</para>
    <para>perfect hashing function � 488</para>
    <para>performance: and final � 302</para>
    <para>performance issues � 96</para>
    <para>Perl programming language � 705</para>
    <para>persistence � 630; lightweight persistence � 613</para>
    <para>PhantomReference � 495</para>
    <para>pipe � 581</para>
    <para>piped stream � 869</para>
    <para>piped streams � 602</para>
    <para>PipedInputStream � 582</para>
    <para>PipedOutputStream � 582, 583</para>
    <para>PipedReader � 590</para>
    <para>PipedWriter � 590</para>
    <para>planning, software development � 74</para>
    <para>Plauger, P.J. � 1094</para>
    <para>Pluggable Look &amp; Feel � 787</para>
    <para>pointer: Java exclusion of pointers � 391</para>
    <para>pointers, and Java � 1013</para>
    <para>polymorphism � 44, 311, 346, 660, 685; and constructors � 330; behavior of polymorphic methods inside constructors � 337</para>
    <para>port � 908</para>
    <para>portability in C, C++ and Java � 158</para>
    <para>position, absolute, when laying out Swing components � 716</para>
    <para>precedence: operator precedence mnemonic � 158</para>
    <para>prerequisites, for this book � 29</para>
    <para>primitive: comparison � 142; containers of primitives � 412; data types, and use with operators � 159; dealing with the immutability of primitive wrapper classes � 1047; final � 294; final static primitives � 296; initialization of class data members � 220; wrappers � 481</para>
    <para>primitive types � 105</para>
    <para>printInfo( ) � 677</para>
    <para>printing arrays � 417</para>
    <para>println( ) � 458</para>
    <para>printStackTrace( ) � 543, 545</para>
    <para>PrintStream � 588</para>
    <para>PrintWriter � 591, 599, 913</para>
    <para>priority: default priority for a Thread group � 882; thread � 877</para>
    <para>private � 36, 243, 255, 258, 290, 848; illusion of overriding private methods � 299; inner class � 833; inner classes � 397; interfaces, when nested � 364; methods � 339</para>
    <para>problem space � 30, 291</para>
    <para>process, and threading � 825</para>
    <para>program: maintenance � 85</para>
    <para>programmer, client � 35</para>
    <para>programming: basic concepts of object-oriented programming (OOP) � 29; coding standards � 1077; event-driven programming � 707; Extreme Programming (XP) � 88, 1093; in the large � 92; multiparadigm � 31; object-oriented � 660; pair � 90</para>
    <para>progress bar � 780</para>
    <para>promotion: of primitive types � 169; type promotion � 157</para>
    <para>Properties � 652</para>
    <para>property � 801; bound properties � 818; constrained properties � 818; custom property editor � 818; custom property sheet � 818; indexed property � 818</para>
    <para>PropertyChangeEvent � 818</para>
    <para>PropertyDescriptors � 808</para>
    <para>ProptertyVetoException � 818</para>
    <para>protected � 36, 243, 255, 260, 290; and friendly � 290; is also friendly � 261; more accessible than friendly � 335; use in clone( ) � 1021</para>
    <para>protocol � 350; unreliable protocol � 923</para>
    <para>prototyping: rapid � 86</para>
    <para>public � 36, 243, 255, 256; and interface � 350; class, and compilation units � 245</para>
    <para>pure: substitution � 42</para>
    <para>pure inheritance, vs. extension � 341</para>
    <para>pure substitution � 342</para>
    <para>pushBack( ) � 654</para>
    <para>PushbackInputStream � 586</para>
    <para>PushBackReader � 591</para>
    <para>put( ), HashMap � 481</para>
    <para>Python � 81, 99</para>
    <para>Q</para>
    <para>queue � 440, 472</para>
    <para>R</para>
    <para>RAD (Rapid Application Development) � 678</para>
    <para>radio button � 750</para>
    <para>random number generator, values produced by � 186</para>
    <para>random( ) � 480</para>
    <para>RandomAccessFile � 592, 593, 599</para>
    <para>rapid prototyping � 86</para>
    <para>reachable objects and garbage collection � 495</para>
    <para>read( ) � 581</para>
    <para>readChar( ) � 600</para>
    <para>readDouble( ) � 600</para>
    <para>Reader � 581, 589, 590, 869, 913</para>
    <para>readExternal( ) � 620</para>
    <para>reading from standard input � 602</para>
    <para>readLine( ) � 565, 591, 599, 600, 603</para>
    <para>readObject( ) � 614; with Serializable � 627</para>
    <para>rebind( ) � 978</para>
    <para>recursion, unintended via toString() � 459</para>
    <para>redirecting standard I/O � 604</para>
    <para>refactoring � 85</para>
    <para>reference: assigning objects by copying references � 134; equivalence vs object equivalence � 142; final � 295; finding exact type of a base reference � 662; null � 107; reference equivalence vs. object equivalence � 1025</para>
    <para>Reference, from java.lang.ref � 495</para>
    <para>referencing, forward referencing � 222</para>
    <para>reflection � 677, 678, 724, 804; and Beans � 801; difference between RTTI and reflection � 679</para>
    <para>reflection example � 736</para>
    <para>registry: remote object registry � 976</para>
    <para>relational: database � 933; operators � 141</para>
    <para>reliable protocol � 923</para>
    <para>Remote Method Invocation (RMI) � 973</para>
    <para>RemoteException � 980</para>
    <para>removeActionListener( ) � 812, 857</para>
    <para>removeXXXListener( ) � 723</para>
    <para>renameTo( ) � 580</para>
    <para>reporting errors in book � 23</para>
    <para>request, in OOP � 33</para>
    <para>requirements analysis � 75</para>
    <para>reset( ) � 593</para>
    <para>ResultSet � 930</para>
    <para>resume( ) � 860, 864; and deadlocks � 873; deprecation in Java 2 � 875</para>
    <para>resumption, termination vs. resumption, exception handling � 536</para>
    <para>re-throwing an exception � 545</para>
    <para>return: an array � 413; constructor return value � 193; overloading on return value � 202</para>
    <para>reusability � 37</para>
    <para>reuse � 83; code reuse � 271; existing class libraries � 94; reusable code � 800</para>
    <para>right-shift operator (&gt;&gt;) � 147</para>
    <para>RMI: AlreadyBoundException � 978; and CORBA � 989; bind( ) � 976; localhost � 977; rebind( ) � 978; Remote � 974; remote interface � 974; Remote Method Invocation � 973; remote object registry � 976; RemoteException � 974, 980; rmic � 979; rmic and classpath � 979; rmiregistry � 976; RMISecurityManager � 976; Serializable arguments � 978; skeleton � 978; stub � 978; TCP/IP � 977; unbind( ) � 978; UnicastRemoteObject � 974</para>
    <para>rmic � 979</para>
    <para>rmiregistry � 976</para>
    <para>RMISecurityManager � 976</para>
    <para>rollover � 740</para>
    <para>RTTI: and cloning � 1025; cast � 661; Class � 737; Class object � 662; ClassCastException � 666; Constructor � 678; difference between RTTI and reflection � 679; downcast � 666; Field � 678; getConstructor( ) � 737; instanceof keyword � 666; isInstance � 671; meta-class � 662; Method � 678; newInstance( ) � 737; reflection � 677; run-time type identification (RTTI) � 344; type-safe downcast � 665; using the Class object � 674</para>
    <para>Rumbaugh, James � 1093</para>
    <para>runFinalizersOnExit( ) � 335</para>
    <para>Runnable � 891; interface � 836; Thread � 859</para>
    <para>running a Java program � 121</para>
    <para>run-time binding � 316; polymorphism � 311</para>
    <para>run-time type identification: (RTTI) � 344; misuse � 685; shape example � 659; when to use it � 685</para>
    <para>RuntimeException � 408, 550</para>
    <para>rvalue � 134</para>
    <para>S</para>
    <para>safety, and applet restrictions � 692</para>
    <para>scenario � 77</para>
    <para>scheduling � 79</para>
    <para>scope: inner class nesting within any arbitrary scope � 372; inner classes in methods &amp; scopes � 370; use case � 84</para>
    <para>scrolling in Swing � 712</para>
    <para>searching: sorting and searching Lists � 511</para>
    <para>searching an array � 437</para>
    <para>section, critical section and synchronized block � 852</para>
    <para>seek( ) � 593, 601</para>
    <para>seminars: public Java seminars � 11; training, provided by Bruce Eckel � 23</para>
    <para>sending a message � 33</para>
    <para>separating business logic from UI logic � 796</para>
    <para>separation of interface and implementation � 36, 262, 722</para>
    <para>SequenceInputStream � 582, 592</para>
    <para>Serializable � 613, 620, 625, 637, 814; readObject( ) � 627; writeObject( ) � 627</para>
    <para>serialization: and object storage � 630; and transient � 624; controlling the process of serialization � 619; defaultReadObject( ) � 629; defaultWriteObject( ) � 629; RMI arguments � 978; to perform deep copying � 1032; Versioning � 630</para>
    <para>server � 907</para>
    <para>servlet � 948; multithreading � 954; running servlets with Tomcat � 960; session tracking � 955</para>
    <para>session: and JSP � 969</para>
    <para>session tracking, with servlets � 955</para>
    <para>Set � 408, 439, 440, 473, 506</para>
    <para>setActionCommand( ) � 765</para>
    <para>setBorder( ) � 743</para>
    <para>setContents( ) � 792</para>
    <para>setDaemon( ) � 840</para>
    <para>setDefaultCloseOperation( ) � 704</para>
    <para>setErr(PrintStream) � 604</para>
    <para>setIcon( ) � 740</para>
    <para>setIn(InputStream) � 604</para>
    <para>setLayout( ) � 713</para>
    <para>setMnemonic( ) � 765</para>
    <para>setOut(PrintStream) � 604</para>
    <para>setPriority( ) � 878</para>
    <para>setToolTipText( ) � 740</para>
    <para>shallow copy � 1019, 1027</para>
    <para>shape: example � 39, 316; example, and run-time type identification � 659</para>
    <para>shift operators � 147</para>
    <para>short-circuit, and logical operators � 144</para>
    <para>shortcut, keyboard � 765</para>
    <para>show( ) � 773</para>
    <para>showDocument( ) � 924</para>
    <para>shuffle( ) � 512</para>
    <para>side effect � 133, 141, 202, 1016</para>
    <para>sign extension � 147</para>
    <para>signed two�s complement � 151</para>
    <para>Simula programming language � 32</para>
    <para>Simula-67 � 262</para>
    <para>sine wave � 768</para>
    <para>singleton: design pattern � 266</para>
    <para>size( ), ArrayList � 451</para>
    <para>Size, of a HashMap or HashSet � 491</para>
    <para>sizeof( ): lack of in Java � 158</para>
    <para>skeleton, RMI � 978</para>
    <para>sleep( ) � 827, 846, 860, 862</para>
    <para>slider � 780</para>
    <para>Smalltalk � 31, 207</para>
    <para>Socket � 915</para>
    <para>sockets, stream-based � 923</para>
    <para>SoftReference � 495</para>
    <para>software: development methodology � 72</para>
    <para>Software Development Conference � 10</para>
    <para>solution space � 30</para>
    <para>sorting � 431; and searching Lists � 511</para>
    <para>source code copyright notice � 20</para>
    <para>South, BorderLayout � 713</para>
    <para>space: problem � 30; solution � 30</para>
    <para>specialization � 289</para>
    <para>specification: system specification � 75</para>
    <para>specification, exception � 542</para>
    <para>specifier: access specifiers � 36, 243, 255</para>
    <para>SQL: stored procedures � 935; Structured Query Language � 927</para>
    <para>Stack � 471, 521</para>
    <para>standard input: Reading from standard input � 602</para>
    <para>standards: coding standards � 22, 1077</para>
    <para>startup costs � 95</para>
    <para>stateChanged( ) � 771</para>
    <para>statement: mission � 75</para>
    <para>Statement � 930</para>
    <para>static � 350; and final � 294; block � 228; clause � 664; construction clause � 228; data initialization � 225; final static primitives � 296; initialization � 306; inner classes � 379; keyword � 206; method � 206; synchronized static � 848</para>
    <para>STL: C++ � 440</para>
    <para>stop( ): and deadlocks � 873; deprecation in Java 2 � 873</para>
    <para>stored procedures in SQL � 935</para>
    <para>stream, I/O � 581</para>
    <para>stream-based sockets � 923</para>
    <para>StreamTokenizer � 591, 639, 653, 682</para>
    <para>String: automatic type conversion � 454; class methods � 1052; concatenation with operator + � 153; immutability � 1052; indexOf( ) � 576, 681; lexicographic vs. alphabetic sorting � 436; methods � 1056; operator + � 454; Operator + � 153; operator + and += overloading � 277; toString( ) � 272, 452</para>
    <para>StringBuffer � 582; methods � 1058</para>
    <para>StringBufferInputStream � 582</para>
    <para>StringReader � 590, 597</para>
    <para>StringSelection � 792</para>
    <para>StringTokenizer � 642</para>
    <para>StringWriter � 590</para>
    <para>struts, in BoxLayout � 717</para>
    <para>stub, RMI � 978</para>
    <para>style of creating classes � 262</para>
    <para>subobject � 278, 288</para>
    <para>substitutability, in OOP � 31</para>
    <para>substitution: principle � 42</para>
    <para>subtraction � 137</para>
    <para>super � 280; and finalize( ) � 335; and inner classes � 385</para>
    <para>super keyword � 278</para>
    <para>super.clone( ) � 1021, 1025, 1041</para>
    <para>superclass � 278</para>
    <para>suspend( ) � 860, 864; and deadlocks � 873; deprecation in Java 2 � 875</para>
    <para>Swing � 689</para>
    <para>Swing component examples � 734</para>
    <para>Swing components, using HTML with � 779</para>
    <para>Swing event model � 722, 794</para>
    <para>switch keyword � 183</para>
    <para>synchronized � 59, 848; and inheritance � 858; and wait( ) &amp; notify( ) � 866; containers � 514; deciding what methods to synchronize � 858; efficiency � 853; method, and blocking � 860; static � 848; synchronized block � 852</para>
    <para>system clipboard � 790</para>
    <para>system specification � 75</para>
    <para>System.arraycopy( ) � 429</para>
    <para>System.err � 538, 602</para>
    <para>System.gc( ) � 213</para>
    <para>System.in � 597, 602</para>
    <para>System.out � 602</para>
    <para>System.out.println( ) � 458</para>
    <para>System.runFinalization( ) � 213</para>
    <para>T</para>
    <para>tabbed dialog � 755</para>
    <para>table � 784</para>
    <para>table-driven code, and anonymous inner classes � 502</para>
    <para>TCP, Transmission Control Protocol � 923</para>
    <para>TCP/IP, and RMI � 977</para>
    <para>template: in C++ � 455</para>
    <para>termination vs. resumption, exception handling � 536</para>
    <para>ternary operator � 151</para>
    <para>testing: automated � 89; Extreme Programming (XP) � 88; unit testing � 277</para>
    <para>testing techniques � 381</para>
    <para>this keyword � 203</para>
    <para>Thread � 825, 827; and JavaBeans � 854; and Runnable � 891; blocked � 859; combined with main class � 834; daemon threads � 840; dead � 859; deadlock � 872; deciding what methods to synchronize � 858; destroy( ) � 877; drawbacks � 899; getPriority( ) � 878; I/O and threads, blocking � 860; interrupt( ) � 873; isDaemon( ) � 840; new Thread � 859; notify( ) � 860; notifyAll( ) � 860; order of execution of threads � 831; priority � 877; properly suspending &amp; resuming � 874; resume( ) � 860, 864; resume( ) , deprecation in Java 2 � 875; resume( ), and deadlocks � 873; run( ) � 829; Runnable � 859; Runnable interface � 836; setDaemon( ) � 840; setPriority( ) � 878; sharing limited resources � 842; sleep( ) � 846, 860, 862; start( ) � 830; states � 859; stop( ) , deprecation in Java 2 � 873; stop( ), and deadlocks � 873; stopping � 873; suspend( ) � 860, 864; suspend( ) , deprecation in Java 2 � 875; suspend( ), and deadlocks � 873; synchronized method and blocking � 860; thread group � 882; thread group, default priority � 882; threads and efficiency � 828; wait( ) � 860, 866; when they can be suspended � 847; when to use threads � 899; yield( ) � 860</para>
    <para>throw keyword � 534</para>
    <para>Throwable � 547; base class for Exception � 543</para>
    <para>throwing an exception � 533</para>
    <para>time-critical code sections � 1065</para>
    <para>toArray( ) � 511</para>
    <para>token � 639</para>
    <para>Tokenizing � 639</para>
    <para>Tomcat, standard servlet container � 960</para>
    <para>tool tips � 740</para>
    <para>TooManyListenersException � 796, 814</para>
    <para>toString( ) � 272, 452, 458, 500</para>
    <para>training � 93; and mentoring � 95, 96</para>
    <para>training seminars provided by Bruce Eckel � 23</para>
    <para>Transferable � 792</para>
    <para>transient keyword � 624</para>
    <para>translation unit � 245</para>
    <para>Transmission Control Protocol (TCP) � 923</para>
    <para>tree � 781</para>
    <para>TreeMap � 476, 510, 642</para>
    <para>TreeSet � 473, 506</para>
    <para>true � 143</para>
    <para>try � 286, 554; try block in exceptions � 535</para>
    <para>two�s complement, signed � 151</para>
    <para>type: base � 39; data type equivalence to class � 33; derived � 39; finding exact type of a base reference � 662; parameterized type � 455; primitive � 105; primitive data types and use with operators � 159; type checking and arrays � 408; type safety in Java � 154; type-safe downcast in run-time type identification � 665; weak typing � 45</para>
    <para>TYPE field, for primitive class literals � 665</para>
    <para>type safe sets of constants � 361</para>
    <para>type-conscious ArrayList � 454</para>
    <para>U</para>
    <para>UDP, User Datagram Protocol � 923</para>
    <para>UML � 81; indicating composition � 37; Unified Modeling Language � 35, 1093</para>
    <para>unary: minus (-) � 139; operator � 146; operators � 139; plus (+) � 139</para>
    <para>unbind( ) � 978</para>
    <para>unicast � 814; unicast events � 796</para>
    <para>UnicastRemoteObject � 974</para>
    <para>Unicode � 590</para>
    <para>Unified Modeling Language (UML) � 35, 1093</para>
    <para>unit testing � 277</para>
    <para>unmodifiable, making a Collection or Map unmodifiable � 513</para>
    <para>unsupported methods, in the Java 2 containers � 516</para>
    <para>UnsupportedOperationException � 516</para>
    <para>upcasting � 47, 291, 312, 660; and interface � 353; inner classes and upcasting � 368</para>
    <para>updates of the book � 22</para>
    <para>URL � 925</para>
    <para>use case � 76; iteration � 84; scope � 84</para>
    <para>User Datagram Protocol (UDP) � 923</para>
    <para>user interface � 78; and threads, for responsiveness � 831; responsive, with threading � 826</para>
    <para>V</para>
    <para>value: preventing change at run-time � 294</para>
    <para>value, HTML keyword � 839</para>
    <para>variable: defining a variable � 174; initialization of method variables � 220; variable argument lists (unknown quantity and type of arguments) � 235</para>
    <para>vector: of change � 86</para>
    <para>Vector � 505, 519, 521</para>
    <para>vector of change � 397</para>
    <para>versioning, serialization � 630</para>
    <para>versions of Java � 22</para>
    <para>visibility, package visibility, (friendly) � 368</para>
    <para>visual: programming � 800</para>
    <para>Visual Basic, Microsoft � 800</para>
    <para>visual programming environments � 690</para>
    <para>W</para>
    <para>wait( ) � 860, 866</para>
    <para>Waldrop, M. Mitchell � 1095</para>
    <para>weak: weakly typed language � 45</para>
    <para>WeakHashMap � 498</para>
    <para>WeakReference � 495</para>
    <para>Web: displaying a Web page from within an applet � 923; placing an applet inside a Web page � 695; safety, and applet restrictions � 692</para>
    <para>web of objects � 614, 1020</para>
    <para>West, BorderLayout � 713</para>
    <para>while � 172</para>
    <para>widening conversion � 155</para>
    <para>wild-card � 73</para>
    <para>WindowAdapter � 704</para>
    <para>windowClosing( ) � 704, 771</para>
    <para>windowed applications � 700</para>
    <para>Windows Explorer, running Java programs from � 705</para>
    <para>wrapper, dealing with the immutability of primitive wrapper classes � 1047</para>
    <para>write( ) � 581</para>
    <para>writeBytes( ) � 600</para>
    <para>writeChars( ) � 600</para>
    <para>writeDouble( ) � 600</para>
    <para>writeExternal( ) � 620</para>
    <para>writeObject( ) � 614; with Serializable � 627</para>
    <para>Writer � 581, 589, 590, 869, 913</para>
    <para>X</para>
    <para>XOR � 146</para>
    <para>XP, Extreme Programming � 88</para>
    <para>Y</para>
    <para>yield( ) � 860</para>
    <para>Z</para>
    <para>zero extension � 147</para>
    <para>ZipEntry � 610</para>
    <para>ZipInputStream � 606</para>
    <para>ZipOutputStream � 606</para>
     <para> </para>
     <para><inlinemediaobject><imageobject role="html">
          <imagedata contentdepth="1" contentwidth="517" fileref="./TIJ2_files/image033.jpg" format="JPG" scalefit="1"/>
        </imageobject>
<imageobject role="fo">
          <imagedata contentdepth="100%" fileref="./TIJ2_files/image033.jpg" format="JPG" scalefit="1" width="100%"/>
        </imageobject>
</inlinemediaobject></para>
    <informaltable frame="none">
      <tgroup cols="2">
        <colspec colname="c1" colwidth="13*"/>
        <colspec colname="c2" colwidth="87*"/>
        <tbody>
          <row>
            <entry><para/></entry>
          </row>
          <row>
            <entry><para/></entry>
            <entry><para><inlinemediaobject><imageobject role="html">
                    <imagedata contentdepth="4" contentwidth="548" fileref="./TIJ2_files/image034.png" format="PNG" scalefit="1"/>
                  </imageobject>
<imageobject role="fo">
                    <imagedata contentdepth="100%" fileref="./TIJ2_files/image034.png" format="PNG" scalefit="1" width="100%"/>
                  </imageobject>
</inlinemediaobject></para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
      <informaltable frame="none">
      <tgroup cols="2">
        <colspec colname="c1" colwidth="6"/>
        <colspec colname="c2" colwidth="100*"/>
        <tbody>
          <row>
            <entry><para/></entry>
          </row>
          <row>
            <entry><para/></entry>
            <entry><para><inlinemediaobject><imageobject role="html">
                    <imagedata contentdepth="4" contentwidth="728" fileref="./TIJ2_files/image035.png" format="PNG" scalefit="1"/>
                  </imageobject>
<imageobject role="fo">
                    <imagedata contentdepth="100%" fileref="./TIJ2_files/image035.png" format="PNG" scalefit="1" width="100%"/>
                  </imageobject>
</inlinemediaobject></para></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
     <para>End-User License Agreement for Microsoft Software</para>
    <para> </para>
    <para>IMPORTANT-READ CAREFULLY: This Microsoft End-User License Agreement (&quot;EULA&quot;) is a legal agreement between you (either an individual or a single entity) and Microsoft Corporation for the Microsoft software product included in this package, which includes computer software and may include associated media, printed materials, and &quot;online&quot; or electronic documentation (&quot;SOFTWARE PRODUCT&quot;). The SOFTWARE PRODUCT also includes any updates and supplements to the original SOFTWARE PRODUCT provided to you by Microsoft. By installing, copying, downloading, accessing or otherwise using the SOFTWARE PRODUCT, you agree to be bound by the terms of this EULA. If you do not agree to the terms of this EULA, do not install, copy, or otherwise use the SOFTWARE PRODUCT.</para>
    <para> </para>
    <para>SOFTWARE PRODUCT LICENSE</para>
    <para> </para>
    <para>The SOFTWARE PRODUCT is protected by copyright laws and international copyright treaties, as well as other intellectual property laws and treaties. The SOFTWARE PRODUCT is licensed, not sold. </para>
    <para>1. GRANT OF LICENSE. This EULA grants you the following rights:</para>
    <para>1.1 License Grant. Microsoft grants to you as an individual, a personal nonexclusive license to make and use copies of the SOFTWARE PRODUCT for the sole purposes of evaluating and learning how to use the SOFTWARE PRODUCT, as may be instructed in accompanying publications or documentation. You may install the software on an unlimited number of computers provided that you are the only individual using the SOFTWARE PRODUCT. </para>
    <para>1.2 Academic Use. You must be a &quot;Qualified Educational User&quot; to use the SOFTWARE PRODUCT in the manner described in this section. To determine whether you are a Qualified Educational User, please contact the Microsoft Sales Information Center/One Microsoft Way/Redmond, WA 98052-6399 or the Microsoft subsidiary serving your country. If you are a Qualified Educational User, you may either:</para>
    <para>(i) exercise the rights granted in Section 1.1, OR </para>
    <para>(ii) if you intend to use the SOFTWARE PRODUCT solely for instructional purposes in connection with a class or other educational program, this EULA grants you the following alternative license models: </para>
    <para>(A) Per Computer Model. For every valid license you have acquired for the SOFTWARE PRODUCT, you may install a single copy of the SOFTWARE PRODUCT on a single computer for access and use by an unlimited number of student end users at your educational institution, provided that all such end users comply with all other terms of this EULA, OR </para>
    <para>(B) Per License Model. If you have multiple licenses for the SOFTWARE PRODUCT, then at any time you may have as many copies of the SOFTWARE PRODUCT in use as you have licenses, provided that such use is limited to student or faculty end users at your educational institution and provided that all such end users comply with all other terms of this EULA. For purposes of this subsection, the SOFTWARE PRODUCT is &quot;in use&quot; on a computer when it is loaded into the temporary memory (i.e., RAM) or installed into the permanent memory (e.g., hard disk, CD ROM, or other storage device) of that computer, except that a copy installed on a network server for the sole purpose of distribution to other computers is not &quot;in use&quot;. If the anticipated number of users of the SOFTWARE PRODUCT will exceed the number of applicable licenses, then you must have a reasonable mechanism or process in place to ensure that the number of persons using the SOFTWARE PRODUCT concurrently does not exceed the number of licenses.</para>
    <para>2. DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS. </para>
    <para>� Limitations on Reverse Engineering, Decompilation, and Disassembly. You may not reverse engineer, decompile, or disassemble the SOFTWARE PRODUCT, except and only to the extent that such activity is expressly permitted by applicable law notwithstanding this limitation.</para>
    <para>� Separation of Components. The SOFTWARE PRODUCT is licensed as a single product. Its component parts may not be separated for use on more than one computer.</para>
    <para>� Rental. You may not rent, lease or lend the SOFTWARE PRODUCT.</para>
    <para>� Trademarks. This EULA does not grant you any rights in connection with any trademarks or service marks of Microsoft.</para>
    <para>� Software Transfer. The initial user of the SOFTWARE PRODUCT may make a one-time permanent transfer of this EULA and SOFTWARE PRODUCT only directly to an end user. This transfer must include all of the SOFTWARE PRODUCT (including all component parts, the media and printed materials, any upgrades, this EULA, and, if applicable, the Certificate of Authenticity). Such transfer may not be by way of consignment or any other indirect transfer. The transferee of such one-time transfer must agree to comply with the terms of this EULA, including the obligation not to further transfer this EULA and SOFTWARE PRODUCT.</para>
    <para>� No Support. Microsoft shall have no obligation to provide any product support for the SOFTWARE PRODUCT.</para>
    <para>� Termination. Without prejudice to any other rights, Microsoft may terminate this EULA if you fail to comply with the terms and conditions of this EULA. In such event, you must destroy all copies of the SOFTWARE PRODUCT and all of its component parts.</para>
    <para>3. COPYRIGHT. All title and intellectual property rights in and to the SOFTWARE PRODUCT (including but not limited to any images, photographs, animations, video, audio, music, text, and &quot;applets&quot; incorporated into the SOFTWARE PRODUCT), the accompanying printed materials, and any copies of the SOFTWARE PRODUCT are owned by Microsoft or its suppliers. All title and intellectual property rights in and to the content which may be accessed through use of the SOFTWARE PRODUCT is the property of the respective content owner and may be protected by applicable copyright or other intellectual property laws and treaties. This EULA grants you no rights to use such content. All rights not expressly granted are reserved by Microsoft.</para>
    <para>4. BACKUP COPY. After installation of one copy of the SOFTWARE PRODUCT pursuant to this EULA, you may keep the original media on which the SOFTWARE PRODUCT was provided by Microsoft solely for backup or archival purposes. If the original media is required to use the SOFTWARE PRODUCT on the COMPUTER, you may make one copy of the SOFTWARE PRODUCT solely for backup or archival purposes. Except as expressly provided in this EULA, you may not otherwise make copies of the SOFTWARE PRODUCT or the printed materials accompanying the SOFTWARE PRODUCT.</para>
    <para>5. U.S. GOVERNMENT RESTRICTED RIGHTS. The SOFTWARE PRODUCT and documentation are provided with RESTRICTED RIGHTS. Use, duplication, or disclosure by the Government is subject to restrictions as set forth in subparagraph (c)(1)(ii) of the Rights in Technical Data and Computer Software clause at DFARS 252.227-7013 or subparagraphs (c)(1) and (2) of the Commercial Computer Software-Restricted Rights at 48 CFR 52.227-19, as applicable. Manufacturer is Microsoft Corporation/One Microsoft Way/Redmond, WA 98052-6399.</para>
    <para>6. EXPORT RESTRICTIONS. You agree that you will not export or re-export the SOFTWARE PRODUCT, any part thereof, or any process or service that is the direct product of the SOFTWARE PRODUCT (the foregoing collectively referred to as the &quot;Restricted Components&quot;), to any country, person, entity or end user subject to U.S. export restrictions. You specifically agree not to export or re-export any of the Restricted Components (i) to any country to which the U.S. has embargoed or restricted the export of goods or services, which currently include, but are not necessarily limited to Cuba, Iran, Iraq, Libya, North Korea, Sudan and Syria, or to any national of any such country, wherever located, who intends to transmit or transport the Restricted Components back to such country; (ii) to any end-user who you know or have reason to know will utilize the Restricted Components in the design, development or production of nuclear, chemical or biological weapons; or (iii) to any end-user who has been prohibited from participating in U.S. export transactions by any federal agency of the U.S. government. You warrant and represent that neither the BXA nor any other U.S. federal agency has suspended, revoked, or denied your export privileges.</para>
    <para>7. NOTE ON JAVA SUPPORT. THE SOFTWARE PRODUCT MAY CONTAIN SUPPORT FOR PROGRAMS WRITTEN IN JAVA. JAVA TECHNOLOGY IS NOT FAULT TOLERANT AND IS NOT DESIGNED, MANUFACTURED, OR INTENDED FOR USE OR RESALE AS ON-LINE CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF JAVA TECHNOLOGY COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE.</para>
    <para> </para>
    <para>MISCELLANEOUS</para>
    <para> </para>
    <para>If you acquired this product in the United States, this EULA is governed by the laws of the State of Washington. </para>
    <para>If you acquired this product in Canada, this EULA is governed by the laws of the Province of Ontario, Canada. Each of the parties hereto irrevocably attorns to the jurisdiction of the courts of the Province of Ontario and further agrees to commence any litigation which may arise hereunder in the courts located in the Judicial District of York, Province of Ontario. </para>
    <para>If this product was acquired outside the United States, then local law may apply.</para>
    <para>Should you have any questions concerning this EULA, or if you desire to contact Microsoft for any reason, please contact </para>
    <para>Microsoft, or write: Microsoft Sales Information Center/One Microsoft Way/Redmond, WA 98052-6399. </para>
    <para> </para>
    <para>LIMITED WARRANTY</para>
    <para> </para>
    <para>LIMITED WARRANTY. Microsoft warrants that (a) the SOFTWARE PRODUCT will perform substantially in accordance with the accompanying written materials for a period of ninety (90) days from the date of receipt, and (b) any Support Services provided by Microsoft shall be substantially as described in applicable written materials provided to you by Microsoft, and Microsoft support engineers will make commercially reasonable efforts to solve any problem. To the extent allowed by applicable law, implied warranties on the SOFTWARE PRODUCT, if any, are limited to ninety (90) days. Some states/jurisdictions do not allow limitations on duration of an implied warranty, so the above limitation may not apply to you.</para>
    <para>CUSTOMER REMEDIES. Microsoft&apos;s and its suppliers&apos; entire liability and your exclusive remedy shall be, at Microsoft&apos;s option, either (a) return of the price paid, if any, or (b) repair or replacement of the SOFTWARE PRODUCT that does not meet Microsoft&apos;s Limited Warranty and that is returned to Microsoft with a copy of your receipt. This Limited Warranty is void if failure of the SOFTWARE PRODUCT has resulted from accident, abuse, or misapplication. Any replacement SOFTWARE PRODUCT will be warranted for the remainder of the original warranty period or thirty (30) days, whichever is longer. Outside the United States, neither these remedies nor any product support services offered by Microsoft are available without proof of purchase from an authorized international source.</para>
    <para>NO OTHER WARRANTIES. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, MICROSOFT AND ITS SUPPLIERS DISCLAIM ALL OTHER WARRANTIES AND CONDITIONS, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OR CONDITIONS OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT, WITH REGARD TO THE SOFTWARE PRODUCT, AND THE PROVISION OF OR FAILURE TO PROVIDE SUPPORT SERVICES. THIS LIMITED WARRANTY GIVES YOU SPECIFIC LEGAL RIGHTS. YOU MAY HAVE OTHERS, WHICH VARY FROM STATE/JURISDICTION TO STATE/JURISDICTION.</para>
    <para>LIMITATION OF LIABILITY. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL MICROSOFT OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THE SOFTWARE PRODUCT OR THE FAILURE TO PROVIDE SUPPORT SERVICES, EVEN IF MICROSOFT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY CASE, MICROSOFT&apos;S ENTIRE LIABILITY UNDER ANY PROVISION OF THIS EULA SHALL BE LIMITED TO THE GREATER OF THE AMOUNT ACTUALLY PAID BY YOU FOR THE SOFTWARE PRODUCT OR U.S.$5.00; PROVIDED, HOWEVER, IF YOU HAVE ENTERED INTO A MICROSOFT SUPPORT SERVICES AGREEMENT, MICROSOFT&apos;S ENTIRE LIABILITY REGARDING SUPPORT SERVICES SHALL BE GOVERNED BY THE TERMS OF THAT AGREEMENT. BECAUSE SOME STATES/JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF LIABILITY, THE ABOVE LIMITATION MAY NOT APPLY TO YOU.</para>
    <para>0495 Part No. 64358</para>
     <para>LICENSE AGREEMENT FOR MindView, Inc.&apos;s</para>
    <para> Thinking in C: Foundations for Java &amp; C++ CD ROM</para>
    <para> by Chuck Allison</para>
    <para>This CD is provided together with the book &quot;Thinking in Java, 2<superscript>nd</superscript> edition.&quot;</para>
    <para> READ THIS AGREEMENT BEFORE USING THIS &quot;Thinking in C: Foundations for C++ &amp; Java&quot; (Hereafter called &quot;CD&quot;). BY USING THE CD YOU AGREE TO BE BOUND BY THE TERMS AND CONDITIONS OF THIS AGREEMENT. IF YOU DO NOT AGREE TO THE TERMS AND CONDITIONS OF THIS AGREEMENT, IMMEDIATELY RETURN THE UNUSED CD FOR A FULL REFUND OF MONIES PAID, IF ANY.</para>
    <para> �2000 MindView, Inc. All rights reserved. Printed in the U.S.</para>
    <para> SOFTWARE REQUIREMENTS</para>
    <para> The purpose of this CD is to provide the Content, not the associated software necessary to view the Content. The Content of this CD is in HTML for viewing with Microsoft Internet Explorer 4 or newer, and uses Microsoft Sound Codecs available in Microsoft&apos;s Windows Media Player for Windows. It is your responsibility to correctly install the appropriate Microsoft software for your system. </para>
    <para> The text, images, and other media included on this CD (&quot;Content&quot;) and their compilation are licensed to you subject to the terms and conditions of this Agreement by MindView, Inc., having a place of business at 5343 Valle Vista, La Mesa, CA 91941. Your rights to use other programs and materials included on the CD are also governed by separate agreements distributed with those programs and materials on the CD (the &quot;Other Agreements&quot;). In the event of any inconsistency between this Agreement and the Other Agreements, this Agreement shall govern. By using this CD, you agree to be bound by the terms and conditions of this Agreement. MindView, Inc. owns title to the Content and to all intellectual property rights therein, except insofar as it contains materials that are proprietary to third-party suppliers. All rights in the Content except those expressly granted to you in this Agreement are reserved to MindView, Inc. and such suppliers as their respective interests may appear.</para>
    <para> 1. LIMITED LICENSE</para>
    <para> MindView, Inc. grants you a limited, nonexclusive, nontransferable license to use the Content on a single dedicated computer (excluding network servers). This Agreement and your rights hereunder shall automatically terminate if you fail to comply with any provisions of this Agreement or any of the Other Agreements. Upon such termination, you agree to destroy the CD and all copies of the CD, whether lawful or not, that are in your possession or under your control. </para>
    <para> 2. ADDITIONAL RESTRICTIONS</para>
    <para> a. You shall not (and shall not permit other persons or entities to) directly or indirectly, by electronic or other means, reproduce (except for archival purposes as permitted by law), publish, distribute, rent, lease, sell, sublicense, assign, or otherwise transfer the Content or any part thereof.</para>
    <para> b. You shall not (and shall not permit other persons or entities to) use the Content or any part thereof for any commercial purpose or merge, modify, create derivative works of, or translate the Content.</para>
    <para> c. You shall not (and shall not permit other persons or entities to) obscure MindView&apos;s or its suppliers copyright, trademark, or other proprietary notices or legends from any portion of the Content or any related materials.</para>
    <para> 3. PERMISSIONS</para>
    <para>a. Except as noted in the Contents of the CD, you must treat this software just like a book. However, you may copy it onto a computer to be used and you may make archival copies of the software for the sole purpose of backing up the software and protecting your investment from loss. By saying, &quot;just like a book,&quot; MindView, Inc. means, for example, that this software may be used by any number of people and may be freely moved from one computer location to another, so long as there is no possibility of its being used at one location or on one computer while it is being used at another. Just as a book cannot be read by two different people in two different places at the same time, neither can the software be used by two different people in two different places at the same time.</para>
    <para>b. You may show or demonstrate the un-modified Content in a live presentation, live seminar, or live performance as long as you attribute all material of the Content to MindView, Inc.</para>
    <para>c. Other permissions and grants of rights for use of the CD must be obtained directly from MindView, Inc. at http://www.MindView.net. (Bulk copies of the CD may also be purchased at this site.) </para>
    <para>DISCLAIMER OF WARRANTY</para>
    <para> The Content and CD are provided &quot;AS IS&quot; without warranty of any kind, either express or implied, including, without limitation, any warranty of merchantability and fitness for a particular purpose. The entire risk as to the results and performance of the CD and Content is assumed by you. MindView, Inc. and its suppliers assume no responsibility for defects in the CD, the accuracy of the Content, or omissions in the CD or the Content. MindView, Inc. and its suppliers do not warrant, guarantee, or make any representations regarding the use, or the results of the use, of the product in terms of correctness, accuracy, reliability, currentness, or otherwise, or that the Content will meet your needs, or that operation of the CD will be uninterrupted or error-free, or that any defects in the CD or Content will be corrected. MindView, Inc. and its suppliers shall not be liable for any loss, damages, or costs arising from the use of the CD or the interpretation of the Content. Some states do not allow exclusion or limitation of implied warranties or limitation of liability for incidental or consequential damages, so all of the above limitations or exclusions may not apply to you.</para>
    <para> In no event shall MindView, Inc. or its suppliers&apos; total liability to you for all damages, losses, and causes of action (whether in contract, tort, or otherwise) exceed the amount paid by you for the CD.</para>
    <para>MindView, Inc., and Prentice-Hall, Inc. specifically disclaim the implied warrantees of merchantability and fitness for a particular purpose. No oral or written information or advice given by MindView, Inc., Prentice-Hall, Inc., their dealers, distributors, agents or employees shall create a warrantee. You may have other rights, which vary from state to state.</para>
    <para>Neither MindView, Inc., Bruce Eckel, Chuck Allison, Prentice-Hall, nor anyone else who has been involved in the creation, production or delivery of the product shall be liable for any direct, indirect, consequential, or incidental damages (including damages for loss of business profits, business interruption, loss of business information, and the like) arising out of the use of or inability to use the product even if MindView, Inc., has been advised of the possibility of such damages. Because some states do not allow the exclusion or limitation of liability for consequential or incidental damages, the above limitation may not apply to you.</para>
    <para>This CD is provided as a supplement to the book &quot;Thinking in Java 2nd� edition.&quot; The sole responsibility of Prentice-Hall will be to provide a replacement CD in the event that the one that came with the book is defective. This replacement warrantee shall be in effect for a period of sixty days from the purchase date. MindView, Inc. does not bear any additional responsibility for the CD.</para>
    <para>NO TECHNICAL SUPPORT IS PROVIDED WITH THIS CD ROM</para>
    <para>The following are trademarks of their respective companies in the U.S. and may be protected as trademarks in other countries: Sun and the Sun Logo, Sun Microsystems, Java, all Java-based names and logos and the Java Coffee Cup are trademarks of Sun Microsystems; Internet Explorer, the Windows Media Player, DOS, Windows 95, and Windows NT are trademarks of Microsoft.</para>
     <para><emphasis role="bold">Thinking in C: Foundations for Java &amp; C++</emphasis></para>
    <para>Multimedia Seminar-on-CD ROM </para>
    <para>�2000 MindView, Inc. All rights reserved. </para>
    <para><emphasis role="bold">WARNING: BEFORE OPENING THE DISC PACKAGE, CAREFULLY READ THE TERMS AND CONDITIONS OF THE LICENSE AGREEMENT &amp; WARANTEE LIMITATION ON THE PREVIOUS PAGES.</emphasis></para>
    <para>The CD ROM packaged with this book is a multimedia seminar consisting of synchronized slides and audio lectures. The goal of this seminar is to introduce you to the aspects of C that are necessary for you to move on to C++ or Java, leaving out the unpleasant parts that C programmers must deal with on a day-to-day basis but that the C++ and Java languages steer you away from. The CD also contains this book in HTML form along with the source code for the book.</para>
    <para>This CD ROM will work with Windows (with a sound system). However, you must: </para>
    <para>Install the most recent version of Microsoft�s Internet Explorer. Because of the features provided on the CD, it will NOT work with Netscape Navigator. <emphasis role="bold">The Internet Explorer software for Windows 9X/NT is included on the CD.</emphasis></para>
    <para>Install Microsoft�s <emphasis role="italic">Windows Media Player</emphasis>. <emphasis role="bold">The Media Player software for Windows 9X/NT is included on the CD. </emphasis>You can also go to <emphasis role="bold">http://www.microsoft.com/windows/mediaplayer</emphasis> and follow the instructions or links there to download and install the Media Player for your particular platform. </para>
    <para>At this point you should be able to play the lectures on the CD. Using the Internet Explorer Web browser, open the file <emphasis role="bold">Install.html</emphasis> that you�ll find on the CD. This will introduce you to the CD and provide further instructions about the use of the CD.</para>
    <para> </para>
    <para> </para>
     <anchor xml:id="ftn1"/>    <para><anchor xreflabel="[1]" xml:id="_ftn1"/>[1] I take this back on the 2<superscript>nd</superscript> edition: I believe that the Python language comes closest to doing exactly that. See www.Python.org.</para>
    <anchor xml:id="ftn2"/>    <para><anchor xreflabel="[2]" xml:id="_ftn2"/>[2] See <emphasis role="italic">Multiparadigm Programming in Leda</emphasis> by Timothy Budd (Addison-Wesley 1995).</para>
    <anchor xml:id="ftn3"/>    <para><anchor xreflabel="[3]" xml:id="_ftn3"/>[3] Some people make a distinction, stating that type determines the interface while class is a particular implementation of that interface.</para>
    <anchor xml:id="ftn4"/>    <para><anchor xreflabel="[4]" xml:id="_ftn4"/>[4] I�m indebted to my friend Scott Meyers for this term.</para>
    <anchor xml:id="ftn5"/>    <para><anchor xreflabel="[5]" xml:id="_ftn5"/>[5] This is usually enough detail for most diagrams, and you don�t need to get specific about whether you�re using aggregation or composition.</para>
    <anchor xml:id="ftn6"/>    <para><anchor xreflabel="[6]" xml:id="_ftn6"/>[6] My term.</para>
    <anchor xml:id="ftn7"/>    <para><anchor xreflabel="[7]" xml:id="_ftn7"/>[7] Primitive types, which you�ll learn about later, are a special case.</para>
    <anchor xml:id="ftn8"/>    <para><anchor xreflabel="[8]" xml:id="_ftn8"/>[8] An excellent example of this is <emphasis role="italic">UML Distilled</emphasis>, 2<superscript>nd</superscript> edition, by Martin Fowler (Addison-Wesley 2000), which reduces the sometimes-overwhelming UML process to a manageable subset.</para>
    <anchor xml:id="ftn9"/>    <para><anchor xreflabel="[9]" xml:id="_ftn9"/>[9] My rule of thumb for estimating such projects: If there�s more than one wild card, don�t even try to plan how long it�s going to take or how much it will cost until you�ve created a working prototype. There are too many degrees of freedom.</para>
    <anchor xml:id="ftn10"/>    <para><anchor xreflabel="[10]" xml:id="_ftn10"/>[10] Thanks for help from James H Jarrett.</para>
    <anchor xml:id="ftn11"/>    <para><anchor xreflabel="[11]" xml:id="_ftn11"/>[11] More information on use cases can be found in <emphasis role="italic">Applying Use Cases</emphasis> by Schneider &amp; Winters (Addison-Wesley 1998) and <emphasis role="italic">Use Case Driven Object Modeling with UML</emphasis> by Rosenberg (Addison-Wesley 1999).</para>
    <anchor xml:id="ftn12"/>    <para><anchor xreflabel="[12]" xml:id="_ftn12"/>[12] My personal take on this has changed lately. Doubling and adding 10 percent will give you a reasonably accurate estimate (assuming there are not too many wild-card factors), but you still have to work quite diligently to finish in that time. If you want time to really make it elegant and to enjoy yourself in the process, the correct multiplier is more like three or four times, I believe.</para>
    <anchor xml:id="ftn13"/>    <para><anchor xreflabel="[13]" xml:id="_ftn13"/>[13] For starters, I recommend the aforementioned <emphasis role="italic">UML Distilled</emphasis>, 2<superscript>nd</superscript> edition.</para>
    <anchor xml:id="ftn14"/>    <para><anchor xreflabel="[14]" xml:id="_ftn14"/>[14]Python (www.Python.org) is often used as �executable pseudocode.�</para>
    <anchor xml:id="ftn15"/>    <para><anchor xreflabel="[15]" xml:id="_ftn15"/>[15] At least one aspect of evolution is covered in Martin Fowler�s book <emphasis role="italic">Refactoring: improving the design of existing code</emphasis> (Addison-Wesley 1999), which uses Java examples exclusively.</para>
    <anchor xml:id="ftn16"/>    <para><anchor xreflabel="[16]" xml:id="_ftn16"/>[16] This is something like �rapid prototyping,� where you were supposed to build a quick-and-dirty version so that you could learn about the system, and then throw away your prototype and build it right. The trouble with rapid prototyping is that people didn�t throw away the prototype, but instead built upon it. Combined with the lack of structure in procedural programming, this often leads to messy systems that are expensive to maintain.</para>
    <anchor xml:id="ftn17"/>    <para><anchor xreflabel="[17]" xml:id="_ftn17"/>[17] Although this may be a more American perspective, the stories of Hollywood reach everywhere.</para>
    <anchor xml:id="ftn18"/>    <para><anchor xreflabel="[18]" xml:id="_ftn18"/>[18] Including (especially) the PA system. I once worked in a company that insisted on broadcasting every phone call that arrived for every executive, and it constantly interrupted our productivity (but the managers couldn�t begin to conceive of stifling such an important service as the PA). Finally, when no one was looking I started snipping speaker wires.</para>
    <anchor xml:id="ftn19"/>    <para><anchor xreflabel="[19]" xml:id="_ftn19"/>[19] In particular, I recommend looking at Python (http://www.Python.org).</para>
    <anchor xml:id="ftn20"/>    <para><anchor xreflabel="[20]" xml:id="_ftn20"/>[20] This can be a flashpoint. There are those who say �clearly, it�s a pointer,� but this presumes an underlying implementation. Also, Java references are much more akin to C++ references than pointers in their syntax. In the first edition of this book, I chose to invent a new term, �handle,� because C++ references and Java references have some important differences. I was coming out of C++ and did not want to confuse the C++ programmers whom I assumed would be the largest audience for Java. In the 2<superscript>nd</superscript> edition, I decided that �reference� was the more commonly used term, and that anyone changing from C++ would have a lot more to cope with than the terminology of references, so they might as well jump in with both feet. However, there are people who disagree even with the term �reference.� I read in one book where it was �completely wrong to say that Java supports pass by reference,� because Java object identifiers (according to that author) are <emphasis role="italic">actually</emphasis> �object references.� And (he goes on) everything is <emphasis role="italic">actually</emphasis> pass by value. So you�re not passing by reference, you�re �passing an object reference by value.� One could argue for the precision of such convoluted explanations, but I think my approach simplifies the understanding of the concept without hurting anything (well, the language lawyers may claim that I�m lying to you, but I�ll say that I�m providing an appropriate abstraction.)</para>
    <anchor xml:id="ftn21"/>    <para><anchor xreflabel="[21]" xml:id="_ftn21"/>[21]<emphasis role="bold">static</emphasis> methods, which you�ll learn about soon, can be called <emphasis role="italic">for the class</emphasis>, without an object.</para>
    <anchor xml:id="ftn22"/>    <para><anchor xreflabel="[22]" xml:id="_ftn22"/>[22] With the usual exception of the aforementioned �special� data types <emphasis role="bold">boolean, char</emphasis>, <emphasis role="bold">byte</emphasis>, <emphasis role="bold">short</emphasis>, <emphasis role="bold">int</emphasis>, <emphasis role="bold">long</emphasis>,<emphasis role="bold"> float,</emphasis> and <emphasis role="bold">double</emphasis>. In general, though, you pass objects, which really means you pass references to objects.</para>
    <anchor xml:id="ftn23"/>    <para><anchor xreflabel="[23]" xml:id="_ftn23"/>[23] Some programming environments will flash programs up on the screen and close them before you&apos;ve had a chance to see the results. You can put in the following bit of code at the end of <emphasis role="bold">main( )</emphasis> to pause the output:</para>
    <para>��� try {</para>
    <para>����� System.in.read();</para>
    <para>��� } catch(Exception e) {}</para>
    <para> </para>
    <para>This will pause the output until you press �Enter� (or any other key). This code involves concepts that will not be introduced until much later in the book, so you won�t understand it until then, but it will do the trick.</para>
    <anchor xml:id="ftn24"/>    <para><anchor xreflabel="[24]" xml:id="_ftn24"/>[24] A tool that I created using Python (see www.Python.org) uses this information to extract the code files, put them in appropriate subdirectories, and create makefiles.</para>
    <anchor xml:id="ftn25"/>    <para><anchor xreflabel="[25]" xml:id="_ftn25"/>[25] John Kirkham writes, �I started computing in 1962 using FORTRAN II on an IBM 1620. At that time, and throughout the 1960s and into the 1970s, FORTRAN was an all uppercase language. This probably started because many of the early input devices were old teletype units that used 5 bit Baudot code, which had no lowercase capability. The �E� in the exponential notation was also always upper case and was never confused with the natural logarithm base �e�, which is always lowercase. The �E� simply stood for exponential, which was for the base of the number system used�usually 10. At the time octal was also widely used by programmers. Although I never saw it used, if I had seen an octal number in exponential notation I would have considered it to be base 8. The first time I remember seeing an exponential using a lowercase �e� was in the late 1970s and I also found it confusing. The problem arose as lowercase crept into FORTRAN, not at its beginning. We actually had functions to use if you really wanted to use the natural logarithm base, but they were all uppercase.�</para>
    <anchor xml:id="ftn26"/>    <para><anchor xreflabel="[26]" xml:id="_ftn26"/>[26] Chuck Allison writes: The total number of numbers in a floating-point number system is</para>
    <para><emphasis role="bold">2(M-m+1)b^(p-1) + 1</emphasis></para>
    <para> where <emphasis role="bold">b</emphasis> is the base (usually 2), <emphasis role="bold">p</emphasis> is the precision (digits in the mantissa), <emphasis role="bold">M</emphasis> is the largest exponent, and <emphasis role="bold">m</emphasis> is the smallest exponent. IEEE 754 uses:</para>
    <para><emphasis role="bold">M = 1023, m = -1022, p = 53, b = 2</emphasis></para>
    <para> so the total number of numbers is</para>
    <para><emphasis role="bold">2(1023+1022+1)2^52  = 2((2^10-1) + (2^10-1))2^52  = (2^10-1)2^54  = 2^64 - 2^54</emphasis></para>
    <para> Half of these numbers (corresponding to exponents in the range [-1022, 0]) are less than 1 in magnitude (both positive and negative), so 1/4 of that expression, or 2^62 - 2^52� + 1 (approximately 2^62)� is in the range [0,1). See my paper at http://www.freshsources.com/1995006a.htm (last of text).</para>
    <anchor xml:id="ftn27"/>    <para><anchor xreflabel="[27]" xml:id="_ftn27"/>[27] In some of the Java literature from Sun they instead refer to these with the clumsy but descriptive name �no-arg constructors.� The term �default constructor� has been in use for many years and so I will use that.</para>
    <anchor xml:id="ftn28"/>    <para><anchor xreflabel="[28]" xml:id="_ftn28"/>[28] The one case in which this is possible occurs if you pass a reference to an object into the <emphasis role="bold">static</emphasis> method. Then, via the reference (which is now effectively <emphasis role="bold">this</emphasis>), you can call non-<emphasis role="bold">static</emphasis> methods and access non-<emphasis role="bold">static</emphasis> fields. But typically if you want to do something like this you�ll just make an ordinary, non-<emphasis role="bold">static</emphasis> method.</para>
    <anchor xml:id="ftn29"/>    <para><anchor xreflabel="[29]" xml:id="_ftn29"/>[29] A term coined by Bill Venners (www.artima.com) during a seminar that he and I were giving together.</para>
    <anchor xml:id="ftn30"/>    <para><anchor xreflabel="[30]" xml:id="_ftn30"/>[30] In contrast, C++ has the <emphasis role="italic">constructor initializer list</emphasis> that causes initialization to occur before entering the constructor body, and is enforced for objects. See <emphasis role="italic">Thinking in C++, 2<superscript>nd</superscript> edition</emphasis> (available on this book�s CD ROM and at <emphasis role="italic">www.BruceEckel.com</emphasis>).</para>
    <anchor xml:id="ftn31"/>    <para><anchor xreflabel="[31]" xml:id="_ftn31"/>[31] See <emphasis role="italic">Thinking in C++, 2<superscript>nd</superscript> edition</emphasis>� for a complete description of C++ aggregate initialization.</para>
    <anchor xml:id="ftn32"/>    <para><anchor xreflabel="[32]" xml:id="_ftn32"/>[32] There�s nothing in Java that forces the use of an interpreter. There exist native-code Java compilers that generate a single executable file.</para>
    <anchor xml:id="ftn33"/>    <para><anchor xreflabel="[33]" xml:id="_ftn33"/>[33] There�s another effect in this case: Since the default constructor is the only one defined, and it�s <emphasis role="bold">private</emphasis>, it will prevent inheritance of this class. (A subject that will be introduced in Chapter 6.)</para>
    <anchor xml:id="ftn34"/>    <para><anchor xreflabel="[34]" xml:id="_ftn34"/>[34] However, people often refer to implementation hiding alone as encapsulation.</para>
    <anchor xml:id="ftn35"/>    <para><anchor xreflabel="[35]" xml:id="_ftn35"/>[35] Actually, an <emphasis role="italic">inner class</emphasis> can be private or protected, but that�s a special case. These will be introduced in Chapter 7.</para>
    <anchor xml:id="ftn36"/>    <para><anchor xreflabel="[36]" xml:id="_ftn36"/>[36] You can also do it by inheriting (Chapter 6) from that class.</para>
    <anchor xml:id="ftn37"/>    <para><anchor xreflabel="[37]" xml:id="_ftn37"/>[37] For C++ programmers, this is the analogue of C++�s <emphasis role="italic">pure virtual function</emphasis>.</para>
    <anchor xml:id="ftn38"/>    <para><anchor xreflabel="[38]" xml:id="_ftn38"/>[38] This approach was inspired by an e-mail from Rich Hoffarth.</para>
    <anchor xml:id="ftn39"/>    <para><anchor xreflabel="[39]" xml:id="_ftn39"/>[39] Thanks to Martin Danner for asking this question during a seminar.</para>
    <anchor xml:id="ftn40"/>    <para><anchor xreflabel="[40]" xml:id="_ftn40"/>[40] This is very different from the design of <emphasis role="italic">nested classes</emphasis> in C++, which is simply a name-hiding mechanism. There is no link to an enclosing object and no implied permissions in C++.</para>
    <anchor xml:id="ftn41"/>    <para><anchor xreflabel="[41]" xml:id="_ftn41"/>[41] Thanks again to Martin Danner.</para>
    <anchor xml:id="ftn42"/>    <para><anchor xreflabel="[42]" xml:id="_ftn42"/>[42] On the other hand, �$� is a meta-character to the Unix shell and so you�ll sometimes have trouble when listing the <emphasis role="bold">.class</emphasis> files. This is a bit strange coming from Sun, a Unix-based company. My guess is that they weren�t considering this issue, but instead thought you�d naturally focus on the source-code files.</para>
    <anchor xml:id="ftn43"/>    <para><anchor xreflabel="[43]" xml:id="_ftn43"/>[43] For some reason this has always been a pleasing problem for me to solve; it came from my earlier book <emphasis role="italic">C++ Inside &amp; Out</emphasis>, but Java allows a much more elegant solution.</para>
    <anchor xml:id="ftn44"/>    <para><anchor xreflabel="[44]" xml:id="_ftn44"/>[44] It�s possible, however, to ask how big the <emphasis role="bold">vector</emphasis> is, and the <emphasis role="bold">at( )</emphasis> method <emphasis role="italic">does</emphasis> perform bounds checking.</para>
    <anchor xml:id="ftn45"/>    <para><anchor xreflabel="[45]" xml:id="_ftn45"/>[45] This is one of the places where C++ is distinctly superior to Java, since C++ supports <emphasis role="italic">parameterized types</emphasis> with the <emphasis role="bold">template</emphasis> keyword.</para>
    <anchor xml:id="ftn46"/>    <para><anchor xreflabel="[46]" xml:id="_ftn46"/>[46] The C++ programmer will note how much the code could be collapsed with the use of default arguments and templates. The Python programmer will note that this entire library would be largely unnecessary in that language.</para>
    <anchor xml:id="ftn47"/>    <para><anchor xreflabel="[47]" xml:id="_ftn47"/>[47] By Joshua Bloch at Sun.</para>
    <anchor xml:id="ftn48"/>    <para><anchor xreflabel="[48]" xml:id="_ftn48"/>[48] This data was found on the Internet, then processed by creating a Python program (see <emphasis role="italic">www.Python.org</emphasis>).</para>
    <anchor xml:id="ftn49"/>    <para><anchor xreflabel="[49]" xml:id="_ftn49"/>[49] This is a place where operator overloading would be nice.</para>
    <anchor xml:id="ftn50"/>    <para><anchor xreflabel="[50]" xml:id="_ftn50"/>[50] If these speedups still don�t meet your performance needs, you can further accelerate table lookup by writing your own <emphasis role="bold">Map</emphasis> and customizing it to your particular types to avoid delays due to casting to and from <emphasis role="bold">Object</emphasis>s. To reach even higher levels of performance, speed enthusiasts can use Donald Knuth�s <emphasis role="italic">The Art of Computer Programming, Volume 3: Sorting and Searching, Second Edition</emphasis> to replace overflow bucket lists with arrays that have two additional benefits: they can be optimized for disk storage characteristics and they can save most of the time of creating and garbage collecting individual records.</para>
    <anchor xml:id="ftn51"/>    <para><anchor xreflabel="[51]" xml:id="_ftn51"/>[51] The C programmer can look up the return value of <emphasis role="bold">printf( )</emphasis> for an example of this.</para>
    <anchor xml:id="ftn52"/>    <para><anchor xreflabel="[52]" xml:id="_ftn52"/>[52] This is a significant improvement over C++ exception handling, which doesn�t catch violations of exception specifications until run time, when it�s not very useful.</para>
    <anchor xml:id="ftn53"/>    <para><anchor xreflabel="[53]" xml:id="_ftn53"/>[53] C++ exception handling does not have the <emphasis role="bold">finally</emphasis> clause because it relies on destructors to accomplish this sort of cleanup.</para>
    <anchor xml:id="ftn54"/>    <para><anchor xreflabel="[54]" xml:id="_ftn54"/>[54] A destructor is a function that�s always called when an object becomes unused. You always know exactly where and when the destructor gets called. C++ has automatic destructor calls, but Delphi�s Object Pascal versions 1 and 2 do not (which changes the meaning and use of the concept of a destructor for that language).</para>
    <anchor xml:id="ftn55"/>    <para><anchor xreflabel="[55]" xml:id="_ftn55"/>[55] ISO C++ added similar constraints that require derived-method exceptions to be the same as, or derived from, the exceptions thrown by the base-class method. This is one case in which C++ is actually able to check exception specifications at compile-time.</para>
    <anchor xml:id="ftn56"/>    <para><anchor xreflabel="[56]" xml:id="_ftn56"/>[56] In C++, a <emphasis role="italic">destructor</emphasis> would handle this for you.</para>
    <anchor xml:id="ftn57"/>    <para><anchor xreflabel="[57]" xml:id="_ftn57"/>[57]<emphasis role="italic">Design Patterns</emphasis>, Erich Gamma <emphasis role="italic">et al.</emphasis>, Addison-Wesley 1995.</para>
    <anchor xml:id="ftn58"/>    <para><anchor xreflabel="[58]" xml:id="_ftn58"/>[58] XML is another way to solve the problem of moving data across different computing platforms, and does not depend on having Java on all platforms. However, Java tools exist that support XML.</para>
    <anchor xml:id="ftn59"/>    <para><anchor xreflabel="[59]" xml:id="_ftn59"/>[59] Chapter 13 shows an even more convenient solution for this: a GUI program with a scrolling text area.</para>
    <anchor xml:id="ftn60"/>    <para><anchor xreflabel="[60]" xml:id="_ftn60"/>[60] Especially in the past. However, Sun has greatly improved its HTML Java documentation so that it�s easier to see base-class methods.</para>
    <anchor xml:id="ftn61"/>    <para><anchor xreflabel="[61]" xml:id="_ftn61"/>[61] A variation on this is called �the principle of least astonishment,� which essentially says: �don�t surprise the user.�</para>
    <anchor xml:id="ftn62"/>    <para><anchor xreflabel="[62]" xml:id="_ftn62"/>[62] This is an example of the design pattern called the <emphasis role="italic">template method</emphasis>.</para>
    <anchor xml:id="ftn63"/>    <para><anchor xreflabel="[63]" xml:id="_ftn63"/>[63] It is assumed that the reader is familiar with the basics of HTML. It�s not too hard to figure out, and there are lots of books and resources.</para>
    <anchor xml:id="ftn64"/>    <para><anchor xreflabel="[64]" xml:id="_ftn64"/>[64] This page�in particular, the �clsid� portion�seemed to work fine with both JDK1.2.2 and JDK1.3 rc-1. However, you may find that you have to change the tag sometime in the future. Details can be found at <emphasis role="italic">java.sun.com</emphasis>.</para>
    <anchor xml:id="ftn65"/>    <para><anchor xreflabel="[65]" xml:id="_ftn65"/>[65] In my opinion. And after you learn about Swing, you won�t want to waste your time on the earlier stuff.</para>
    <anchor xml:id="ftn66"/>    <para><anchor xreflabel="[66]" xml:id="_ftn66"/>[66] As described earlier, �Frame� was already taken by the AWT, so Swing uses JFrame.</para>
    <anchor xml:id="ftn67"/>    <para><anchor xreflabel="[67]" xml:id="_ftn67"/>[67] This will make sense after you�ve read further in this chapter. First, make the reference <emphasis role="bold">J</emphasis><emphasis role="bold">Applet</emphasis> a <emphasis role="bold">static</emphasis> member of the class (instead of a local variable of <emphasis role="bold">main( )</emphasis>), and then call <emphasis role="bold">applet.stop( )</emphasis> and <emphasis role="bold">applet.destroy( )</emphasis> inside <emphasis role="bold">WindowAdapter.windowClosing( )</emphasis> before you call <emphasis role="bold">System.exit( )</emphasis>.</para>
    <anchor xml:id="ftn68"/>    <para><anchor xreflabel="[68]" xml:id="_ftn68"/>[68] There is no <emphasis role="bold">MouseMotionEvent</emphasis> even though it seems like there ought to be. Clicking and motion is combined into <emphasis role="bold">MouseEvent</emphasis>, so this second appearance of <emphasis role="bold">MouseEvent</emphasis> in the table is not an error.</para>
    <anchor xml:id="ftn69"/>    <para><anchor xreflabel="[69]" xml:id="_ftn69"/>[69] In Java 1.0/1.1 you could <emphasis role="italic">not</emphasis> usefully inherit from the button object. This was only one of numerous fundamental design flaws.</para>
    <anchor xml:id="ftn70"/>    <para><anchor xreflabel="[70]" xml:id="_ftn70"/>[70]<emphasis role="bold">Runnable</emphasis> was in Java 1.0, while inner classes were not introduced until Java 1.1, which may partially account for the existence of <emphasis role="bold">Runnable</emphasis>. Also, traditional multithreading architectures focused on a function to be run rather than an object. My preference is always to inherit from <emphasis role="bold">Thread</emphasis> if I can; it seems cleaner and more flexible to me.</para>
    <anchor xml:id="ftn71"/>    <para><anchor xreflabel="[71]" xml:id="_ftn71"/>[71]<emphasis role="italic">The Java Programming Language</emphasis>, by Ken Arnold and James Gosling, Addison-Wesley 1996 pp 179.</para>
    <anchor xml:id="ftn72"/>    <para><anchor xreflabel="[72]" xml:id="_ftn72"/>[72] This means a maximum of just over four billion numbers, which is rapidly running out. The new standard for IP addresses will use a 128-bit number, which should produce enough unique IP addresses for the foreseeable future.</para>
    <anchor xml:id="ftn73"/>    <para><anchor xreflabel="[73]" xml:id="_ftn73"/>[73] Created by Dave Bartlett.</para>
    <anchor xml:id="ftn74"/>    <para><anchor xreflabel="[74]" xml:id="_ftn74"/>[74] Dave Bartlett was instrumental in the development of this material, and also the JSP section.</para>
    <anchor xml:id="ftn75"/>    <para><anchor xreflabel="[75]" xml:id="_ftn75"/>[75] A primary tenet of Extreme Programming (XP). See <emphasis role="italic">www.xprogramming.com</emphasis>.</para>
    <anchor xml:id="ftn76"/>    <para><anchor xreflabel="[76]" xml:id="_ftn76"/>[76] Many brain cells died in agony to discover this information.</para>
    <anchor xml:id="ftn77"/>    <para><anchor xreflabel="[77]" xml:id="_ftn77"/>[77] This section was contributed by Robert Castaneda, with help from Dave Bartlett.</para>
    <anchor xml:id="ftn78"/>    <para><anchor xreflabel="[78]" xml:id="_ftn78"/>[78] This section was contributed by Bill Venners (www.artima.com).</para>
    <anchor xml:id="ftn79"/>    <para><anchor xreflabel="[79]" xml:id="_ftn79"/>[79] In C, which generally handles small bits of data, the default is pass-by-value. C++ had to follow this form, but with objects pass-by-value isn�t usually the most efficient way. In addition, coding classes to support pass-by-value in C++ is a big headache.</para>
    <anchor xml:id="ftn80"/>    <para><anchor xreflabel="[80]" xml:id="_ftn80"/>[80] This is not the dictionary spelling of the word, but it�s what is used in the Java library, so I�ve used it here, too, in some hopes of reducing confusion.</para>
    <anchor xml:id="ftn81"/>    <para><anchor xreflabel="[81]" xml:id="_ftn81"/>[81] You can apparently create a simple counter-example to this statement, like this:</para>
    <para>public class Cloneit implements Cloneable {</para>
    <para>� public static void main (String[] args) </para>
    <para>� throws CloneNotSupportedException {</para>
    <para>��� Cloneit a = new Cloneit();</para>
    <para>��� Cloneit b = (Cloneit)a.clone();</para>
    <para>� }</para>
    <para>}</para>
    <para>However, this only works because <emphasis role="bold">main( )</emphasis> is a method of <emphasis role="bold">Cloneit</emphasis> and thus has permission to call the <emphasis role="bold">protected</emphasis> base-class method <emphasis role="bold">clone( )</emphasis>. If you call it from a different class, it won�t compile.</para>
    <anchor xml:id="ftn82"/>    <para><anchor xreflabel="[82]" xml:id="_ftn82"/>[82] Except for the poor avocado, which has been reclassified to simply �fat.�</para>
    <anchor xml:id="ftn83"/>    <para><anchor xreflabel="[83]" xml:id="_ftn83"/>[83] C++ allows the programmer to overload operators at will. Because this can often be a complicated process (see Chapter 10 of <emphasis role="italic">Thinking in C++, 2<superscript>nd</superscript> edition,</emphasis> Prentice-Hall, 2000), the Java designers deemed it a �bad� feature that shouldn�t be included in Java. It wasn�t so bad that they didn�t end up doing it themselves, and ironically enough, operator overloading would be much easier to use in Java than in C++. This can be seen in Python (see www.Python.org) which has garbage collection and straightforward operator overloading.</para>
    <anchor xml:id="ftn84"/>    <para><anchor xreflabel="[84]" xml:id="_ftn84"/>[84] Doug Lea, who was helpful in resolving this issue, suggested this to me, saying that he simply creates a function called <emphasis role="bold">duplicate( )</emphasis> for each class.</para>
    <anchor xml:id="ftn85"/>    <para><anchor xreflabel="[85]" xml:id="_ftn85"/>[85] Explained to me by Andrew Koenig.</para>
  </section>
  <index/>
</article>
